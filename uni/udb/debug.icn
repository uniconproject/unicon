
#
#  debug.icn
#  Handles the main Runtime Monitor 
#

$include "evdefs.icn"
link evinit
link image
link ximage
link getpaths
link evnames
link icode
link srcfile

$include "defaults.icn"

#
# Evaltree uses the following record to keep track of the procedures.
# Node   : contains procedure, function or other data
# Parent : is the parent of the current Node
# Child  : is a list which contains the childern of the current node.
# Level  : is used for the next command to keep track of the procedure stack.
# Ecode  : is the s_code given by each event.
# fname  : is the current source file name
# linnum : is the current line number in the current source file
#
record activation_record(node, parent, children, level, ecode, fname, linenum)

#
# This global will contain a table. For every file that has a break point
# we will create a new set to store each breakpoint in.
#
record breakPt(file_name, line_num, code)

#
# This record will be used by the udb_evalTree
#
record __evaltree_node(node,parent,children)

#
# This new record is used by the traceList
# level: is the level of the procedure in the evaltree
# fname: is the source file name that has the procedure 
# line : is the line in the source file that starts on
# proc : is the procdure name
# param: is a string with the parameters and their values
#
record traceProcRec(level, fname, line, proc, param)

#
# This record is used by checkTraceFail()
# fname: file name
# line : line number
# code : the source code of the line where the fail is.
#
record traceRec(fname, line, code)

#
# This record is used by checkTraceVar()
# fname: is the file name
# line : is the line number
# var  : is the variable name
# value: is an image of the variable value 
#
record traceVarRec(fname, line, var, value) 

#
# Contains the core of the udb debugging facilities 
#
class Debug(
   TP,            # TargetProgram and its arguments
   icode,         # an instance of the Icode class
   srcFile,       # an instance of the SourceFile class

   State,         # Debugging state such RUN, PUSE, etc
   RunCode,       # It is one of the RUNNING States (RUN|CONTINUE|SPEP|NEXT)

   eventMask,     # the mask that we are building the evaltree based on
   breakMask,     # a set of the E_Line Event-values that we like to break on
   watchMask,     # a set of the E_Assign Event-values that we like to watch for   
   valueMask,     # table used for break points and watch points set of masks
   breakPoints,   # A table maps files to their a its list of break point 
   
   treeFlag,      # by default is null:no tree is included 
   treeRoot,      # the evaltree head
   cur_Frame,     # points at the last investigated frame, using up,down,frame n
   step_count,    # the cmdStep optional counter, initial value 0, default 1
   next_count,    # the cmdNext optional counter, initial value 0, default 1
   nex_level,     # used with the next command to skip over a call

   #new stuff
   #guiFlag,       # &null vs. not &null: not &null means we are debugging GUI
   #guiMask,       # s set of the E_Pcall Event-value "util__Connectable_fire"

   #new trace stuff
   traceState,    # a cset of &eventcode(s) of wanted traced fetures
   traceTable,    # an eventcode maped to a list of traceRec
   traceVarMask,  # a set just like watchMask, has the traced variables and is
                  # used by the valueMask along with watchMask 
   traceVarTable, # a table with keys from traceVarMask to a list of var values

   #evalTree codes
   CallCodes,     # function and procedure calls
   SuspendCodes,  # suspend a coroutine
   ResumeCodes,   # resume a coroutine
   ReturnCodes,   # return from a procedure with return st
   FailCodes,     # fail in a procedure 
   RemoveCodes,   # remove
   
   global_vars,   # a set contains all of the global variable names
   Message        # a string formated with the current message
   )

#
# prints a message out into a console, message box, and so
#
method Write(Msg)
   if /Msg then
      Msg := Message
   write(Msg)
   Message := ""
end

#
# This was in the evaltree.icn unicon library, we had to modify 
# it some how for the need of the udb debugging facilities. 
#
#method udb_evalTree(mask, activation_record) #Old
method udb_evalTree(activation_record)
   local c, current, p, child

   # when there is no evalTree involved
   if /treeFlag then{
      while EvGet(eventMask,valueMask) do {
         #write("-->",evnames(&eventcode), ": ", image(&eventvalue))
         debug_CallBack(current, current)
         if State = PAUSE then{ suspend }
         if State = END then  { return  }
         }
      }   
   else{# it is not used until the cmdTree() is used with "tree=on"
     /activation_record := __evaltree_node
     CallCodes    := string(eventMask ** 
                             cset(E_Pcall || E_Fcall || E_Ocall || E_Snew))
     SuspendCodes := string(eventMask ** 
                            cset(E_Psusp || E_Fsusp || E_Osusp || E_Ssusp))
     ResumeCodes  := string(eventMask ** 
                            cset(E_Presum || E_Fresum || E_Oresum || E_Sresum))
     ReturnCodes  := string(eventMask ** 
                            cset(E_Pret || E_Fret || E_Oret))
     FailCodes    := string(eventMask ** 
                            cset(E_Pfail || E_Ffail || E_Ofail || E_Sfail))
     RemoveCodes  := string(eventMask **  
                            cset(E_Prem || E_Frem || E_Orem || E_Srem))
 
     current := activation_record()
     current.parent := activation_record()
     current.children := []
     current.parent.children := []

      #every write(evnames(kk := key(valueMask))," :  ", !(valueMask[kk]))
     while EvGet(eventMask,valueMask) do {
      case &eventcode of {
       !CallCodes: {
          c := activation_record()
          c.node := &eventvalue
          c.parent := current
          c.children := []
          put(current.children, c)
          current := c
          #top_Frame := cur_Frame := current
          debug_CallBack(current, current.parent)
          }
       !ReturnCodes | !FailCodes: {
          p := pull(current.parent.children)
          current := current.parent
          #top_Frame := cur_Frame := current
          debug_CallBack(current, p)
          }
       !SuspendCodes: {
          current := current.parent
          #top_Frame := cur_Frame := current
          debug_CallBack(current, current.children[-1])
          }
       !ResumeCodes: {
          current := current.children[-1]
          #top_Frame := cur_Frame := current
          debug_CallBack(current, current.parent)
          }
       !RemoveCodes: {
          if child := pull(current.children) then {
             while put(current.children, pop(child.children))
             #top_Frame := cur_Frame := current
             debug_CallBack(current, child)
          }
          else{
             if current === current.parent.children[-1] then {
             p := pull(current.parent.children)
             current := current.parent
             #top_Frame := cur_Frame := current
             debug_CallBack(current, p)
             next
             }
             else
                 stop("evaltree: unknown removal")
             }
          }
       default: {
          debug_CallBack(current, current)
          }
      }# end case
      if State = PAUSE then{ suspend }
      if State = END then  { return  }
     }# end do
    return
   }
end

#
# Add a new node when ecode==(E_Pcall | E_Fcall | E_Ocall | E_Snew)
#
method add_Node(new, old)
   local x, i, p

   if /new.parent.node then{
      # New Tree Root
      new.level := 1
      treeRoot  := new
      }
   else
      new.level := new.parent.level+1

   new.ecode   := &eventcode
   new.fname   := keyword("file", Monitored)
   new.linenum := keyword("line", Monitored)
end

#
# Try to build the Behavior Procedure Tracer
# traceProcRec(level, fname, line, proc, param)
# traceCode is something from the ProcMask
#
method checkTraceProc(traceCode)
   local i, x, R, level, procName, p:=""
   local cur_file:="", cur_line:="" 

   # level at that point of the execution time
   level := keyword("level", Monitored)

   every x := paramnames(Monitored,0) do{
      i := variable(x, Monitored,0)
      p ||:= x ||"="||image(i)||", "
      }
   p := p[1:-2]

   procName := image(&eventvalue)
   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)
   #write("--Treace:",level,"(",cur_file,")(",cur_line,")",procName,p)
   R:= traceProcRec(level,cur_file,cur_line,procName,p)

   if member(traceTable, traceCode) then
      put(traceTable[traceCode],R)
   else
      traceTable[traceCode] := [R]
end 

#
# Check for a behavior trace other than procedures
# record traceRec(fname, line, code)
#
method checkTraceOther(traceCode)
   local cur_file, cur_line, R, srcCode, OperCode

   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)
   srcCode  := srcFile.getSrcLine(cur_line, cur_file)
   R := traceRec(cur_file, cur_line, srcCode)

   if member(traceTable, traceCode) then
      put(traceTable[traceCode],R)
   else
      traceTable[traceCode]:=[R]
end

#
# check trace dispatcher 
#
method checkTrace()
   local ecode := &eventcode

   if member(traceState, ecode) then{
      if member(ProcMask, ecode) then  checkTraceProc(ecode)
      else                             checkTraceOther(ecode)
      }
#   else
#      Write(Message := "\n\t No trace on this event!!!")   
end

#
# Check the Monitored file for a break point
#
method checkBreakPoint()
   static breakPt_list
   local  cur_file, cur_line, skip
   local  i := 1, temp

   cur_file := keyword("file", Monitored)
   cur_line := keyword("line", Monitored)
   if member(breakPoints, cur_file) then{
      breakPt_list := breakPoints[cur_file]
      skip := 0
      }
   else{
      skip := 1
      }

   if skip = 0 then{
      while i <= *breakPt_list do{
         temp := breakPt_list[i]
         if cur_line = temp.line_num then{
            State := PAUSE
            # this delete will help "next" and "step" operate well
            # jut remove the the breakMask set from the valueMask 
            # table temporarly until the continue command comes on
            delete(valueMask,E_Line) 
            Message :="\n\t Break point in "||cur_file||"("|| cur_line ||")"|| 
                      "\n\t Code:" || srcFile.getSrcLine(cur_line, cur_file) 
            Write(Message)
            return
            }
         i +:= 1
         }
      }
end

#
# Check the Monitored file for a watch point
#
method checkWatchPoint()
   local cur_file, cur_line, var

   var := &eventvalue
   if member(watchMask, var) then{
      State := PAUSE
      RunCode := WATCH
      cur_file := keyword("file", Monitored)
      cur_line := keyword("line", Monitored)
      Message:="\n\t Watching for \""|| var ||"\" in "|| cur_file ||
               "("||cur_line||")\n\t Code: "|| srcFile.getSrcLine(cur_line) 
      Write(Message)
      return
   }
end

#
# Check the Monitored file for a variable trace point
# record traceVarRec(fname, line, var, value) 
#
method checkTraceVar()
   local cur_file, cur_line, var, varinfo
   static varName

   var := &eventvalue
   if member(traceVarMask, var) then{
      #State := RUN
      RunCode := TRACE
      varName := var
      eventMask ++:=cset(E_Value)
      }
   else if RunCode = TRACE then{
      cur_file := keyword("file", Monitored)
      cur_line := keyword("line", Monitored)
      varinfo := traceVarRec(cur_file,cur_line,varName,image(var))
      if member(traceVarTable,varName) then
         put(traceVarTable[varName],varinfo)
      else
         traceVarTable[varName]:=[varinfo]
      RunCode := RUN
      write("------traceVar : ",image(var))
      eventMask --:=cset(E_Value)
      }
end

#
# while next_count > 0, keep next until it is 0,
# then stop there and change the state to step
#
method checkNext()
   local cur_line, cur_file, level

   level := keyword("level", Monitored)
   if level = nex_level then{
      if next_count > 1 then{
         next_count -:= 1
         }
      else if next_count = 1 then{
         next_count := 0
         step_count := 1
         State := PAUSE
         RunCode := STEP
         }
      }
end

#
# while step_count > 0, keep step until it is 0,
# then stop there and make State := STEP
#
method checkStep()
   local cur_line, cur_file

   if step_count > 1 then{
      step_count -:= 1
      State := RUN
      RunCode := NEXT
   }else
   if step_count = 1 then{
      step_count -:= 1

      cur_file := keyword("file", Monitored)
      cur_line := keyword("line", Monitored)

      Message := "\n\t Stepping in "||cur_file||"("||cur_line||")"||
                 "\n\t code : "|| srcFile.getSrcLine(cur_line, cur_file)
      Write(Message)

      State := PAUSE
      RunCode := STEP
   }
end

#
# This is where most of the UDB checking goes on.
#
method debug_CallBack(new, old)
   local ecode := &eventcode

   if State = RUN then {
      #write("-->",evnames(ecode), ": ", image(&eventvalue))
      case ecode of{
        E_Line:{
           # ????           
           checkBreakPoint()
           if RunCode = NEXT then{ checkNext() }
           if RunCode = STEP then{ checkStep() }
           }
        E_Assign | E_Value :{
           # check for (Watch|Trace) point on var
           checkWatchPoint()
           checkTraceVar()
           }
        E_Exit:{
           State := END
           }
        E_Error:{
           State := PAUSE
           RunCode := ERROR
           Message := "\n\t Run-time error" ||
                      "\n\t File: "|| keyword("file", Monitored) ||
                      ", Line: " || keyword("line", Monitored)  ||
                      ", Proc: " || image(proc(Monitored, 0 ))
           }
      } # end of case ecode
      checkTrace()
   }else
      Write("The State is Not a RUN State !!!")
end

#
# Here where the udb Session starts on
#
method start_Debugging()
   local x, t

   #-- it may need to be in EvInit() for the sake of re-run
   &eventsource := &null

   EvInit(TP) | stop("cant start evinit on " || TP[1])

   #global_vars := set()
   every x := globalnames(Monitored) do{
     t := image(variable(x, Monitored, 0))
     # note, do not use ~ in such cases, use not
     if not find("procedure"|"function",t) then {
        insert(global_vars, x)
     }
   }

   if State = RUN  then {
      # a generator that ends when TP is over and no more events out of it.
      #every udb_evalTree(eventMask, activation_record) do{
      every udb_evalTree(activation_record) do{
         if State = PAUSE then{
            # suspends the loop and go back to udb_Console() for a new cmd.
            suspend
         }
         if State = END then{
            break
         }
      }#end every 
   }

  #EvQuit()
  #EvTerm()
  #cofail(Monitored)
  State := END
  Message := "\n\t End of Program!!!"
  Write(Message)
  return
end

#
# Initialize the UDB Session
#
method init_Debugging(tp)
   local x, src

   # This is only when the TP is apssed when starting the udb, ex ./udb test
   # in either case th ErrorCode will be initialized
   State := NONE
   if tp[1] then{
      TP := tp
      # check if the TP is loadable and accessable.
      if stat(TP[1]) then{
         if src := icode.getSrcFileNames(TP[1]) then{
            srcFile.loadSourceFiles(TP[1], src)
            State := LOAD
            Message := "\n\t "|| srcFile.exeName ||" : is a "||
                       icode.icodeVersion || "\n\t Found source files: "||
                       srcFile.getSourceFiles()
            Message ||:= "\n\t Type \"help\" for assistance."
            }
         else{
            Message := "\n\t can not get the Source File Names_
                        \n\t Type \"help\" for assistance."
            }
      }
      else{
         State := ERROR
         Message := "\n\t Could not access \"" || TP[1] ||"\""||
                    "\n\t Type \"help\" for assistance."
         RunCode := NONE
      }
   }
   else{
      State := ERROR
      Message := "\n\t A program must be pre-loaded_
                  \n\t Type \"help\" for assistance"
      RunCode := NONE
   }
   Write(Message)
end

initially()

   ####self.SourceFile.initially()
   
   TP      := []
   icode   := Icode()
   srcFile := SourceFile()

   breakPoints := table(0)

   State      := NONE
   RunCode    := NONE
   step_count := 0
   next_count := 0
   treeFlag   := &null
   treeRoot   := &null
   cur_Frame  := 0 # the current active frame is the last one
   nex_level  := &null
   global_vars:= set()

   # tracing stuff
   traceState    := cset('')
   traceTable    := table(0)
   traceVarMask  := set()
   traceVarTable := table(0)
   #guiFlag    := &null
   #guiMask    := set("util__Connectable_fire")

#   # in case of treeFlag is not null 
#   CallCodes   := SuspendCodes := ResumeCodes := ""
#   ReturnCodes := FailCodes    := RemoveCodes := ""

   breakMask  := set(-1)
   watchMask  := set()
   valueMask  := table()
   #valueMask[E_Pcall] := guiMask
   valueMask[E_Line]  := breakMask
   #valueMask[E_Assign]:= watchMask
   #eventmask(Monitored, , valueMask)

   #For the sake of redusing the context switch between the TP and Monitor:
   #Initilly, eventMask does not contain the E_Line & E_Assigne events
   #If there is a break point, E_Line will be added to the eventMask,
   #and the break point linenum will be inserted in valueMask[E_Line] set
   #Also, initially the eventMask will not contain the E_Assign event
   #If there is a watch point then the E_Assign will be added and the 
   #variable will be added to the watchMask set.
   #note for every thing to behave correctly, procMask must be in eventMask

   eventMask   := cset(E_Error || E_Exit || E_Line || E_Assign) #++ ProcMask
#  eventMask ++:= ProcMask # monitoring the user defined procedures   
#  eventMask ++:= FncMask  # monitoring the built-in functions
#  eventMask ++:= OperMask # monitoring the operation
#  eventMask ++:= ScanMask # monitoring the string scanning operations

   Message  := "\t "
end

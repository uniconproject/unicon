#
# json.icn - JSON support library
#
# Authors: Gigi Young, Clinton Jeffery
#
# This library is intended to support conversion of Unicon values
# to and from JSON format, suitable for storage or transmission.
#

#
# Error handling object
#
class ErrorHandler(filename, 
                   lineno, 
                   error,
                   errout,
                   tag
                  )
   method init(filename)
      self.filename := filename
      self.lineno := 1
      self.error := &null
      return
   end

   method incr_line()
      lineno +:= 1
      return
   end

   method constr_msg(s)
      if \filename then 
         return tag || " " || filename || ":" || lineno || ": " || s
      else
         return tag || " " ||  s
   end

   #
   # Sets (error) using constr_msg()
   #
   method set_err(s)
      if /(error) then {
         error := constr_msg(s)
         }
   end

   #
   # Writes error (s) to file descriptor specified by errout.
   #
   method write_err(s)
      write(errout,tag||" "||s)
   end

   #
   # Write out (error), if it exists, to (errout)
   #
   method get_err() 
       if \error then {
          write(errout, error)
          }
   end
initially(errout)
   self.errout := \errout | &errout
   self.lineno := 1
   self.tag := "[json]"
end



#
# For standalone testing
#
$ifdef MAIN
procedure main(argv)
   local input
   if *argv=0 then {
      write("Enter the name of a JSON file:")
      x := jtou(input := read())
      write(utoj(x))
      }
   else every i := 1 to *argv do {
      write(argv[i])
      x := jtou(argv[i])
      write(utoj(x))
      }
end
$endif

#
# For scanner speed testing
#
$ifdef SCAN 
procedure main(argv)
   local input
   if *argv=0 then {
      write("Enter the name of a JSON file:")
      file := open(input := read())
      text := ""
      while text ||:= read(file) || "\n"
      scanner := create json_scanner(text)
      while write(@scanner)
      }
   else every i := 1 to *argv do {
      file := open(argv[i])
      text := ""
      while text ||:= read(file) || "\n"
      scanner := create json_scanner(text)

      while write(@scanner)
      }

end
$endif

#
# Takes a string s that will be interpreted as JSON data.
# If the conversion fails, jtou() attempts to use s as a
# filename. If it fails, then the function fails.
#
# The optional second parameter, mode, can be specified to
# force file conversion ("f") or string conversion ("s").
#
# This procedure is a generator. It will return the 
# corresponding unicon objects, one-by-one, until the
# conversion is complete.
#
# An optional third parameter, error, as a file handle will specify 
# where to print an error message in the event of a error
#
procedure jtou(s,mode,error)
   local file, j, u, tok_gen, jerror, errout
   j := ""
   jerror := ErrorHandler(error)

   # default semantics
   if /mode then {
      # run as string
      tok_gen := create json_scanner(s,jerror)
      if u := json_parser(tok_gen,jerror) then {
         suspend u
	 while u := json_parser(tok_gen,jerror) do suspend u
	 fail
	 }
      # string conversion failed, run as file
      else {
         if not (file := open(s)) then {
            return jerror.write_err("Unable to open file "||image(s))
            }
         while j ||:= read(file) || "\n"
         close(file)
         jerror.init(s)
         }
      }
   # mode specified
   else {
      case mode of {
         # file mode
         "f" : {
            if not (file := open(s)) then {
               return jerror.write_err("Unable to open file "||image(s))
               }
            while j ||:= read(file) || "\n"
            close(file)
            jerror.init(s)
            }
         # string mode
         "s" : j := s 
         default: return jerror.write_err("Invalid mode "||image(mode)) 
         }
      }
   # parse
   tok_gen := create json_scanner(j,jerror)
   while u := json_parser(tok_gen,jerror) do {
      suspend u
      }
   jerror.get_err()
end

#<p>
# Simple interface to convert a JSON string into a unicon entity.
# <i>Note: Unlike jtou(), this assumes the JSON string contains a single
# unicon entity.</i>
# <[param s JSON-encoded string]>
# <[param error - file for error messages (defaults to <tt>&errout</tt>)]>
# <[return unicon entity encoded in JSON string]>
#</p>
procedure jtous(s,error)
   local tok_gen, u, jerror

   jerror := ErrorHandler(error) # ErrorHandler() defaults error to &errout
   tok_gen := create json_scanner(s, jerror)
   while u := json_parser(tok_gen, jerror) do suspend u
   jerror.get_err()
end

#<p>
# Simple interface to convert a JSON file into a unicon entity.
# <[param s - JSON filename]>
# <[param error - file for error messages (defaults to <tt>&errout</tt>)]>
# <[return unicon entity encoded in JSON string]>
#</p>
procedure jtouf(s,error)
   local tok_gen, u, jerror

   jerror := ErrorHandler(error) # ErrorHandler() defaults error to &errout
   if not (file := open(s)) then {
      return jerror.write_err("Unable to open file "||image(s))
      }
   while j ||:= read(file) || "\n"
   close(file)
   jerror.init(s)
   tok_gen := create json_scanner(j, jerror)
   while u := json_parser(tok_gen, jerror) do suspend u
   jerror.get_err()
end

#
# It is insane to propose a single function as the primary API for the
# entire library, so here it is.
#
# Given a Unicon structure, produce a JSON equivalent if possible.
#
# An optional second parameter, error, as a file handle will specify 
# where to print an error message in the event of a error
#
procedure utoj(x,error)
   local j;
   jerror := ErrorHandler(error)
    
   if j := _utoj(x,jerror) then
      return j

   jerror.get_err()
end

#
# Given a Unicon structure, produce a JSON equivalent if possible.
#
# TODO: Check for fails that need error messages
#
procedure _utoj(u,jerror)
   local s, tmp
   case type(u) of {
      "null": return type(u)
      "string": {
         return      if u == "__true__" then "true"
                else if u == "__false__" then "false"
	        else jsonify_string(u,jerror)
         }
      "integer" | "real": return image(u)
      "list": {
         s := "["
         if *u > 0 then s ||:= _utoj(u[1],jerror)
         every i := 2 to *u do {
	    s ||:= ("," || _utoj(u[i],jerror)) | fail
            }
         s ||:= "]"
         return s
         }
      "set": {
         s := "["; i := 1

         every x := !u do {
            if i>1 then s ||:= ","
	    s ||:= _utoj(x,jerror) | fail
            i +:= 1
            }
         s ||:= "]"
         return s
         }
 
      "table": {
         s := "{"
         every k := key(u) do {
	    if s[-1] ~== "{" then s ||:= ","
            if type(k) == "string" then 
               s ||:= jsonify_string(k)|| ":" || _utoj(u[k],jerror) | fail
            else
               s ||:= "\""||image(k)||"\""||":"||_utoj(u[k],jerror) | fail
            }
         s ||:= "}"
         return s
         }

      "cset": { # Encode a cset as a special JSON object: {"__unicset":"abc..."}
         return "{\"__unicset\":"||jsonify_string(string(u))||"}"
         }

      default: {
         # Class - Do we care about method names? Currently we don't
         if match("object ", tmp := image(u)) then {
            s := "{\"class\":\""||tmp[8:upto("_",tmp)\1|0]||"\""
            every k := key(u) do {
               if k == ("__s" | "__m") then next
               if type(k) ~== "string" then fail
	       s ||:= ","||jsonify_string(k)|| ":" || _utoj(u[k],jerror) | fail
               }
            s ||:= "}"
            return s
            }
         # Record
         else if match("record ", tmp := image(u)) then {
            s := "{\"record\":\""||tmp[8:upto("_",tmp)\1|0]||"\""
            every k := key(u) do {
               if type(k) ~== "string" then fail
	       s ||:= ","||jsonify_string(k)|| ":" || _utoj(u[k],jerror) | fail
               }
            s ||:= "}"
            return s
            }
         else {
            return jerror.set_err(type(u) || " has no JSON equivalent")
            }
         }
      }
end

#
# Procedure for converting Unicon escapes and escape sequences to valid 
# JSON escape sequences.
#
procedure jsonify_string(s,jerror)
   static hex, oct, T_Esc
   local ns := "", tmp, i

   initial {
      hex := '0123456789abcdefABCDEF'
      oct := '01234567'
      T_Esc := table()

      every i := 0 to 31 do 
         T_Esc[char(i)] := "\\u"||right(_dectohex(i),4,"0")
      T_Esc[char(8)] := "\\b"
      T_Esc[char(10)] := "\\n"
      T_Esc[char(11)] := "\\t"
      T_Esc[char(12)] := "\\f"
      T_Esc[char(13)] := "\\r"
      }

   s ? {
      while c := move(1) do {
         if c == '\"' then return jerror.set_err("Unicon string \""||s||
            "\" contains an illegal double quote for JSON strings")

         if c == "\\" then {
            case (c := move(1)) | 
                  return jerror.set_err("Incomplete escape sequence") of {
               # JSON escapes
               "\\": ns ||:= "\\\\"
               "/": ns ||:= "\\/"
               "\"": ns ||:= "\\\""
               "u": { # unicode - restrict to 16-bit unicode
                  tmp := tab(many(hex)) | ""
                  if (i := *tmp) > 4 then {
                     tmp := tmp[1:5]
                     move(*tmp - i)
                     }
                  ns ||:= "\\u"||right(tmp,4,"0")
                  }
               # Unicon escapes
               "b": ns ||:= "\\b"
               "d": ns ||:= "\\u007F"
               "e": ns ||:= "\\u001B"
               "f": ns ||:= "\\f"
               "l": ns ||:= "\\u000A"
               "n": ns ||:= "\\n"
               "r": ns ||:= "\\r"
               "t": ns ||:= "\\t"
               "v": ns ||:= "\\u000B"
               "x": { # hexadecimal, \xXX
                  # Taken from hexcode() in escape.icn
                  tmp := tab(many(hex)) | ""
                  if (i := *tmp) > 2 then {
                     tmp := tmp[1:3]
                     move(*tmp - i)
                     }
                  ns ||:= "\\u00"||tmp
                  }
               !oct: { # octal 
                  # Taken from octcode() in escape.icn
                  tmp := c || tab(many(oct)) | ""
                  if (i := *tmp) > 3 then { # back off if too large
                     tmp := tmp[1:4]
                     move(*tmp - i)
                     }
                  ns ||:= "\\u"||right(_octtohex(tmp),4,"0")
                  }
               "^": { # control sequence
                  c := move(1) 
                  write("Control character: "||c)
                  ns ||:= \(T_Esc[char(ord(c)%32)]) | ""
                  }
               default: { # Use unicon conventions for escape sequences
                  write("default: "||c)
                  ns ||:= c
                  }
               } # end case
            } # end if
         else ns ||:= \(T_Esc[c]) | c
         } # end while
      } 
   return "\""||ns||"\"" 
end

#
# Given an octal string, returns a hexadecimal string. Uses Unicon octal
# specifications
#
procedure _octtohex(s) 
   local val := 0, len := *s, i := len
   while i > 0 do {
      val +:= integer(s[i]) * 8^(len-i)
      i -:= 1
      }
   return _dectohex(val % 256)
end

#
# Given an integer value, return a hexidecimal string
#
procedure _dectohex(val)
   local ns := "", rem 

   while val > 0 do {
      rem := val % 16
      val := integer(val/16)

      if rem < 10 then ns := string(rem) || ns 
      else case rem of {
         10: ns := "A" || ns
         11: ns := "B" || ns
         12: ns := "C" || ns
         13: ns := "D" || ns
         14: ns := "E" || ns
         15: ns := "F" || ns
         }
      }
   return ns         
end

#####################
# SCANNER FUNCTIONS #
#####################

#
# A string-scanning generator - takes a JSON-formatted string 
# and returns single JSON tokens until scanning is complete
#
procedure json_scanner(s,jerror)
   local token
   local ws, operator, number
   local end_pos := *s + 1 

   ws := ' \t'
   operator := '{}[]:,'
   number := '-0123456789'

   s ? {
      repeat {
         # skip whitespace
         tab(many(ws))
         c := move(1) | fail

         # operators
         if any(operator, c) then token := c
         # numbers
         else if any(number, c) then token := scan_number(c,jerror) | fail
         # strings
         else if c == "\"" then token := scan_string(jerror) | fail
         # true
         else if c == "t" then token := scan_true(jerror) | fail
         # false
         else if c == "f" then token := scan_false(jerror) | fail
         # null
         else if c == "n" then token := scan_null(jerror) | fail
         # line counter
         else if c == "\n" then { jerror.incr_line(); next }
         else {
            return jerror.set_err("Unrecognized JSON token: " ||
                   c || tab(upto(ws++operator)\1))
            }
         suspend token
         }
      }
end


#
# String scanning helper function to retrieve JSON value 'true'
#
procedure scan_true(jerror)
   if move(3) == "rue" then return "true"
   else 
      return jerror.set_err("Expected JSON true: " || 
             "t"||tab(upto(' \t\n{}[]:,')\1))
end

#
# String scanning helper function to retrieve JSON value 'false'
#
procedure scan_false(jerror)
   if move(4) == "alse" then return "false"
   else 
      return jerror.set_err("Expected JSON false: " || 
             "f"||tab(upto(' \t\n{}[]:,')\1))
end

#
# String scanning helper function to retrieve JSON value 'null'
#
procedure scan_null(jerror)
   if move(3) == "ull" then return "null" 
   else 
      return jerror.set_err("Expected JSON null: " || 
             "n"||tab(upto(' \t\n{}[]:,')\1))
end

#
# String scanning helper function that finds a valid JSON escape sequence
# and returns a valid Unicon escape or escape sequence if possible.
#
procedure scan_ctrl_char(jerror)
   static hex := '0123456789abcdefABCDEF'
   local i, ns

   #
   # This code is modified from escape() from IPL file escape.icn
   #
   case (c := move(1)) | 
        return jerror.set_err("Incomplete JSON escape sequence") of {
      "b":  return "\b"
      "f":  return "\f"
      "n":  return "\n"
      "r":  return "\r"
      "t":  return "\t"
      "\\":  return "\\"
      "/":  return "/"
      "\"":  return "\""
      "u":  {
         # 
         # Code taken from hexcode() in escape.icn and modified to handle
         # unicode escape sequence conversion. JSON supports unicode from
         # 0020-10FFFF, but this code restricts unicode to 16-bits to remove
         # ambiguity from Unicon and JSON escape conversion.
         # 
         # If the unicode is extended ASCII, then return a Unicon hex escape.
         # Otherwise try to return a unicode escape
         # 
         ns := tab(many(hex)) | ""
         if (i := *ns) > 4 then {
            ns := ns[1:5]
            move(*ns - i)
            }
         ns := ns[many('0',ns):0]
         if *ns > 2 then return "\\u"||right(ns,4,"0")
         else return char("16r"||ns)
         }
      default: {
         return jerror.set_err("JSON string has invalid escape sequence: " ||
            c || tab(upto(' \t\n\"{}[]:,')\1))
         }
      }
end

#
# String scanning helper function that identifies a JSON string and 
# returns a Unicon string
#
procedure scan_string(jerror)
   local str, ctrl, c
   static j_char := ~'\"'
   str := ""

   while any(~'\"', c := move(1)) do {
      if c ~== "\\" then str ||:= c
      else { 
         if ctrl := scan_ctrl_char(jerror) then str ||:= ctrl
         else fail
         }
      }
   if move(1) == "\"" then return "\""||str||"\""
   else return jerror.set_err(
               "JSON string missing terminating double-quotes: " || str) 
end

#
# String scanning helper function that returns a JSON number as a string
#
procedure scan_number(c,jerror)
   local num_str
   num_str := ""
 
   # if negative
   if c == "-" then {
      num_str ||:= c
      c := move(1)
      }

   # integer 
   if any(&digits,c) then {

      # append
      num_str ||:= c

      # c is 0
      if c == "0" then {
         # number starting with 0 is either 0, frac, or exp
         if any(&digits,move(1)) then 
            return jerror.set_err("JSON int cannot have leading zero: " || 
                   num_str)

         } 

      # c is 1-9, get all sequential digits
      else num_str ||:= tab(many(&digits)) 
      }
   
   # fraction 
   if (c := move(1)) == "." then {

      # append .
      num_str ||:= c
        
      # get any/all sequential digits
      if not (num_str ||:= tab(many(&digits))) then 
         return jerror.set_err("Expected digits after '.' in JSON frac: " || 
                num_str)
      }

   # exponent
   if any('eE',c := move(1)) then { 
        
      # append e|E
      num_str ||:= c

      # check for -|+
      if (c := move(1)) == "-" then num_str ||:= c
      else if (c := move(1)) == "+" then {}

      # check for sequential digits
      if not (num_str ||:= tab(many(&digits))) then 
         return jerror.set_err("Expected digits after 'e' in JSON exp: " ||
                num_str)
      } 
   return num_str
end


#########################
# END SCANNER FUNCTIONS #
#########################



####################
# PARSER FUNCTIONS #
####################

#
# Takes a co-expression to generate JSON tokens.
# Returns a Unicon equivalent JSON structure.
#
procedure json_parser(token_gen,jerror)
   local unicon_struct, struct, token
   static parse_funcs

   initial {
      parse_funcs := table()

      parse_funcs["{"] := parse_object 
      parse_funcs["["] := parse_array 
      parse_funcs["\""] := parse_string 
      parse_funcs["-"] := parse_number
      parse_funcs["0"] := parse_number
      parse_funcs["1"] := parse_number
      parse_funcs["2"] := parse_number
      parse_funcs["3"] := parse_number
      parse_funcs["4"] := parse_number
      parse_funcs["5"] := parse_number
      parse_funcs["6"] := parse_number
      parse_funcs["7"] := parse_number
      parse_funcs["8"] := parse_number
      parse_funcs["9"] := parse_number
      parse_funcs["t"] := parse_true
      parse_funcs["f"] := parse_false
      parse_funcs["n"] := parse_null
      }

   while token := @token_gen do {
      if \(func := parse_funcs[token[1]]) then {
         if struct := func(token, token_gen, parse_funcs,jerror) then
            suspend struct
         else fail
         }
      else fail
      }
end


#
# Helper parsing functions that return the equivalent Unicon data structure
#

#
# Returns a string to represent a boolean true
#
procedure parse_true(token, token_gen, parse_funcs, jerror)
   return "__true__"
end

#
# Returns a string to represent a boolean false
#
procedure parse_false(token, token_gen, parse_funcs, jerror)
   return "__false__"
end

#
# Returns the null value
#
procedure parse_null(token, token_gen, parse_funcs, jerror)
   return &null
end

#
# Returns the numeric() of the token
#
procedure parse_number(token, token_gen, parse_funcs, jerror)
   return numeric(token)
end

#
# Removes the delimiting double-quotes from the token (type string) 
#
procedure parse_string(token, token_gen, parse_funcs, jerror)
   return token[2:-1]
end

#
# Helper parsing function that recognizes the production rules for a
# JSON object. Returns a Unicon table if proper syntax (success).
#
procedure parse_object(token, token_gen, parse_funcs, jerror)
   local json_object, json_key, json_value, prev_token, tok
   prev_token := token
   json_object := table()

   while tok := @token_gen do {

      # end of object, return
      if tok == "}"  then {
         # allow for trailing comma, e.g. {... ,}
         #if prev_token ~== "," then return json_object
         #else return jerror.set_err("Unexpected comma before: }")
         return json_object
         }

      # commas are valid only if the preceeding token is a value (not { or ,)
      else if tok == "," then {
         if not (prev_token == ("{"|",")) then prev_token := tok
         else return jerror.set_err("Unexpected comma in JSON object after: "||
                     tok)
         }

      # parse pairs: a key is always a string
      else if tok[1] == "\"" then {
         if prev_token == ("{"|",") then {
            # string
            prev_token := tok
            json_key := parse_funcs["\""](tok, token_gen, parse_funcs, jerror)

            # check for colon
            if (tok := @token_gen) == ":" then prev_token := tok 
            else return jerror.set_err(
                        "Expected colon in JSON pair before: " || tok)
            # value 
            if tok := @token_gen then {
               if \(func := parse_funcs[tok[1]]) then {
                  json_value := func(tok, token_gen, parse_funcs, jerror)
                  #prev_token := json_value 
                  prev_token := "value"

                  # Special case: key-value pair is a cset - this needs testing
                  #if json_key == "__unicset" & type(json_value) == "string" then
                  if json_key == "__unicset" & *json_object = 0 then
                     json_object := cset(json_value) | return jerror.set_err("Expected JSON string for Unicon cset, got: "||tok)
                  else 
                     json_object[json_key] := json_value
                  }
               else 
                  return jerror.set_err("Expected JSON value in JSON pair" ||                        ", got: " || tok)
               }
            else 
               return jerror.set_err("JSON pair missing JSON value")
            }
         else return jerror.set_err(
                     "Expected comma in JSON object before: " || tok)
         }

      # Invalid object syntax
      else {
         if prev_token == (","|"{") then 
            return jerror.set_err("Expected JSON pair, got: " || tok)
         else
            return jerror.set_err("Token violated JSON object syntax: " ||
                   tok)
         }
      }
   return jerror.set_err("Expected terminating } for JSON object")
end

#
# Helper parsing function recognizes the production rules for a JSON array.
# Returns a Unicon list if the syntax is proper (success).
#
procedure parse_array(token, token_gen, parse_funcs, jerror)
   local json_array, json_value, prev_token, tok
   prev_token := token
   json_array := []

   while tok := @token_gen do {

      # end of array, return
      if tok == "]" then {
         # allow for a trailing comma, e.g. [... ,]
         #if prev_token ~== "," then return json_array
         #else return jerror.set_err("Unexpected comma at end of JSON array")
         return json_array
         }

      # comma can only come after a value (not [ or ,)
      else if tok == "," then {
         if not any('[,', prev_token) then prev_token := tok
         else return jerror.set_err("Unexpected comma in JSON array")
         }

      # value
      else if \(func := parse_funcs[tok[1]]) then {
         if prev_token == ("["|",") then { 
            json_value := func(tok, token_gen, parse_funcs, jerror)
            prev_token := "value"
            put(json_array, json_value) 
            }
         else return jerror.set_err("Expected comma in JSON array before: " ||
              tok)
         }
        
      # invalid array syntax
      else { 
         if prev_token == ("["|",") then
            return jerror.set_err("Expected JSON value, got: " || tok)
         else
            return jerror.set_err("Token violated JSON array syntax: " || 
                tok) 
         }
      }
   return jerror.set_err("Expected terminating ] for JSON array")
end

########################
# END PARSER FUNCTIONS #
########################

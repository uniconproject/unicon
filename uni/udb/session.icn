#
# session.icn
# Handles the main debugging session properties such as initialization
# Author : Ziad Al-Sharif
# Date   : Feb 24, 2008 
#


$include "evdefs.icn"
$include "defaults.icn"

#
# This class is used to handle the current debugging state 
#
class Session(
   DState,       # an object of the class State()
   Message,      # the formatted output message
   Debug         # An object of the class Evaluator() 
   )

#
# Here where the udb Session starts on
#
method startSession()
   local arg

   #-- it may need to be in EvInit() for the sake of re-run
   &eventsource := &null

   EvInit(DState.TP) | stop("cant start evinit on " || DState.TP[1])
   Message :="   Starting program: "
   every arg := !DState.TP do Message ||:=" "||arg
   Message ||:="\n"
   DState.Write(Message)
   #DState.srcCode.analyzeGlobalNames()

   if DState.State = RUN  then {
      # a generator that ends when TP is over and no more events out of it.
      # every udb_evalTree(eventMask, activation_record) do{
      every Debug.startEvaluator() do{
         if DState.State = PAUSE then{
            if DState.RunCode = SIGNAL then{
               Message := "\n   "||DState.TP[1]||" program received a signal "||
                          &eventvalue ||"."
               DState.Write(Message)
               } 
            # suspends the loop and go back to udb_Console() for a new cmd.
            suspend
            }
         if DState.State = END then{
            # The program exit normally
            break
            }
      }#end every 
   }

  DState.State := END
  Message := "\n   "||DState.TP[1]||" program exited normally."
  DState.Write(Message)
  return
end

#
# Parse a command
#
method parse_Command(cmd)

   case cmd[1] of{
     #-The start of the standard debugging commands
     "load"   :{  cmdLoad(cmd)                      }
     "r"      |
     "run"    :{  cmdRun(cmd)                       }
     "q"      |
     "quit"   :{  cmdQuit()                         }
     "p"      |
     "print"  :{  cmdPrint(cmd)                     }
     "b"      |
     "break"  :{  Debug.Break.cmdBreak(cmd)         }
     "watch"  |
     "awatch" |
     "twatch" |
     "vwatch" |
     "rwatch" |
     "swatch" :{  Debug.Watch.cmdWatch(cmd)         }
     "s"      |
     "step"   :{  Debug.Step.cmdStep(cmd)           }
     "n"      |
     "next"   :{  Debug.Step.cmdNext(cmd)           }
     "ret"    |
     "return" |
     "finish" :{  Debug.Step.cmdReturn(cmd)         }
     "f"      |
     "frame"  :{  Debug.Frame.cmdFrame(cmd)         }
     "up"     :{  Debug.Frame.cmdUp()               }
     "down"   :{  Debug.Frame.cmdDown()             }
     "?"      |
     "h"      |
     "help"   :{  cmdHelp(cmd)                      }
     "c"      |
     "cont"   :{  Debug.Step.cmdContinue()          }
     "w"      |
     "where"  |
     "backtrace"|
     "bt"     :{  Debug.Frame.cmdBacktrace(cmd)     }
     "l"      |
     "list"   :{  Debug.Print.cmdList(cmd)          }
     "clear"  :{  cmdClear(cmd)                     }
     "delete" :{  cmdDelete(cmd)                    }
     "enable" :{  cmdEnable(cmd)                    }
     "disable":{  cmdDisable(cmd)                   }
     #-cmds that are not in GDB
     "source" |
     "src"    :{  Debug.Print.cmdSource(cmd)        }
     "trace"  :{  Debug.Trace.cmdTrace(cmd)         }
     "info"   :{  cmdInfo(cmd)                      }
     "analyze":{  Debug.Internal.cmdAnalyzeInfo(cmd[3]) }
     #- the shell commands
     "ls"|"ll":{ ls()  }
     "pwd"    :{ pwd() }
     #-new set of commands for the UDB config script 
     "loadscript" :{ }
     "runscript"  :{ }
     default  :{
        # anything else
        DState.State := ERROR
        Message := "\n   Undefined Command: \""||DState.cmdHistory[1]||"\""||
                   "\n   Try \"help\" for assistance."
        DState.Write(Message)
        }
     }
end

#
# Loads a file after running the UDB Session 
# or loads an external monitor: load -external name
#
method cmdLoad(cmd)
   
   if cmd[2][1] == "-" then{
      #load -agent name
      if find("agent", cmd[2]) & \cmd[3] then{
         if Debug.External.cmdLoad(cmd[3:0]) then{
            Message := "\n   External Agent: \""|| cmd[3] ||"\" _
                        is loaded successfully."
            DState.Write(Message)
            }
         else{
            DState.State := ERROR
            Message := "\n   Can not fined agent: \""|| cmd[3] ||"\" !!!."
            DState.Write(Message)
            }
         } 
      #load -semi-internal name 
      else if find("semi-internal", cmd[2]) & \cmd[3] then
         Debug.SemiInternal.cmdLoad(cmd[3])
      else{
         DState.State := ERROR
         Message := "\n   Undefined Command: \""|| cmd[1] ||" "||cmd[2]||"\""||
                    "\n   Try \"help\" for assistance."
         DState.Write(Message)
         }
      }
   else
      DState.initializeState(cmd[2:0])
end

#
# Runs the pre-loaded file, it can be used to re-run the program again
#
method cmdRun(cmd)
   local i, ans, args
     
   if DState.State = (LOAD | END | PAUSE) then{
      args := [DState.TP[1]]
      if *cmd >= 2 then
          every i:=2 to *cmd do
             put(args, cmd[i])
      DState.TP := args
 
      if DState.State = PAUSE then{
         Message  :="\n   The program being debugged has been started already."
         Message||:="\n   Start it from the beginning? (Y/n)?: "
         DState.Writes(Message)
         if *(ans:=read())=0 | not(ans[1] == ("n"|"N")) then{
            Debug.Watch.resetWatchInfo()
            Debug.Trace.resetTraceInfo()
            DState.Update(RERUN)
            } 
         else{
            DState.State := SKIP
            return
            }
         } 
      else{
         DState.Update(RUN)
         if DState.RunCount >= 1 then{
            Debug.Watch.resetWatchInfo()
            Debug.Trace.resetTraceInfo()
            }             
         }
      }
   else{
      DState.State := ERROR
      Message   := "\n   No program to RUN, load program first_
                    \n   Type \"help\" for assistance"
      DState.Write(Message)
   }
end

#
# Allows you to quit the program.
#
method cmdQuit()
   local ans

   # check whether a program is running or not, Paused, etc??????
   # do not exit directlly if the program is in the running state
   if DState.State = (RUN | PAUSE) then{
      DState.Writes("\n   The program "|| 
                          DState.srcFile.exeName ||
                          " is running.  Exit anyway (Y/n)?: ")
      if *(ans:=read())=0 | ans == ("y"|"Y"|"yes"|"YES") then
         DState.State := QUIT
      else
         DState.State := SKIP
      }
   else
      DState.State := QUIT
end

#
# Enables some debugging commands
#
method cmdPrint(cmd)

   if \cmd[2] & cmd[2] == "-internal" then
      Debug.Internal.cmdPrintInfo(cmd[3])
   else if \cmd[2] & cmd[2] == "-trace" then
      Debug.Watch.cmdPrintTrace(cmd)
   else
      Debug.Print.cmdPrint(cmd)
end

#
# clears breakpoints, watchpoints, and tracepoints 
#
method cmdClear(cmd)

if *cmd = 1 then
   Debug.Break.cmdClear(cmd)
else{
   case cmd[2] of  {
      "b"          |
      "break"      |
      "breakpoint" |
      "breakpoints":{ Debug.Break.cmdClear(cmd)     }
      "awatch"     |
      "rwatch"     |
      "twatch"     |
      "vwatch"     |
      "swatch"     |
      "watch"      |
      "watchpoint" |
      "watchpoints":{ Debug.Watch.cmdClear(cmd)     }
      "ptrace"     |
      "otrace"     |
      "ftrace"     |
      "trace"      |
      "watchpoint" |
      "tracepoints":{ Debug.Trace.cmdClear(cmd)     }
      "internal"   :{                               }
      "external"   :{                               }
      default:{
         DState.State := ERROR
         Message:="\n   Undefined Command: \""||DState.cmdHistory[1]||"\""||
                  "\n   Try \"help\" for assistance."
         DState.Write(Message)
         }
      }
   }
end

#
# deletes breakpoints, watchpoints, and tracepoints 
#
method cmdDelete(cmd)

if *cmd = 1 then
   Debug.Break.cmdDelete(cmd)
else{
   case cmd[2] of  {
      "b"          |
      "break"      |
      "breakpoint" |
      "breakpoints":{ Debug.Break.cmdDelete(cmd)    }
      "awatch"     |
      "rwatch"     |
      "twatch"     |
      "vwatch"     |
      "swatch"     |
      "watch"      |
      "watchpoint" |
      "watchpoints":{ Debug.Watch.cmdDelete(cmd)    }
      "ptrace"     |
      "otrace"     |
      "ftrace"     |
      "trace"      |
      "tracepoint" |
      "tracepoints":{ Debug.Trace.cmdDelete(cmd)    }
      "internal"   :{                               }
      "external"   :{                               }
      default:{
         DState.State := ERROR
         Message:="\n   Undefined Command: \""||DState.cmdHistory[1]||"\""||
                  "\n   Try \"help\" for assistance."
         DState.Write(Message)
         }
      }
   }
end

#
# Enables some debugging commands
#
method cmdEnable(cmd)

if *cmd = 1 then
   Debug.Break.cmdEnable(cmd)
else{
   case cmd[2] of  {
      "b"          |
      "break"      |
      "breakpoint" |
      "breakpoints":{ Debug.Break.cmdEnable(cmd)    }
      "awatch"     |
      "rwatch"     |
      "twatch"     |
      "vwatch"     |
      "swatch"     |
      "watch"      |
      "watchpoint" |
      "watchpoints":{ Debug.Watch.cmdEnable(cmd)    }
      "ptrace"     |
      "otrace"     |
      "ftrace"     |
      "trace"      |
      "watchpoint" |
      "tracepoints":{ Debug.Trace.cmdEnable(cmd)    }
      "internal"   :{                               }
      "external"   :{                               }
      default:{
         DState.State := ERROR
         Message:="\n   Undefined Command: \""||DState.cmdHistory[1]||"\""||
                  "\n   Try \"help\" for assistance."
         DState.Write(Message)
         }
      }
   }
end

#
# Disables some debugging commands
#
method cmdDisable(cmd)

if *cmd = 1 then
   Debug.Break.cmdDisable(cmd)
else{
   case cmd[2] of  {
      "b"          |
      "break"      |
      "breakpoint" |
      "breakpoints":{ Debug.Break.cmdDisable(cmd)    }
      "awatch"     |
      "rwatch"     |
      "twatch"     |
      "vwatch"     |
      "swatch"     |
      "watch"      |
      "watchpoint" |
      "watchpoints":{ Debug.Watch.cmdDisable(cmd)    }
      "ptrace"     |
      "otrace"     |
      "ftrace"     |
      "trace"      |
      "watchpoint" |
      "tracepoints":{ Debug.Trace.cmdDisable(cmd)    }
      "internal"   :{                                }
      "external"   :{                                }
      default:{
          DState.State := ERROR
          Message:="\n   Undefined Command: \""||DState.cmdHistory[1]||"\""||
                   "\n   Try \"help\" for assistance."
          DState.Write(Message)
          }
       }
   }
end

#
# Finds out information about some of the debugging commands
#
method cmdInfo(cmd)

   case cmd[2] of  {
      "b"          |
      "break"      |
      "breakpoint" |
      "breakpoints":{ Debug.Break.printBreakInfo(cmd)        }
      "awatch"     |
      "rwatch"     |
      "twatch"     |
      "vwatch"     |
      "watch"      |
      "watchpoint" |
      "watchpoints":{ Debug.Watch.printWatchInfo(cmd)        }
      "ptrace"     |
      "otrace"     |
      "ftrace"     |
      "trace"      |
      "watchpoint" |
      "tracepoints":{ Debug.Trace.printTraceInfo(cmd)        }
      "global"     :{ Debug.Print.cmdPrint(["p","-g"])       }
      "local"      :{ Debug.Print.cmdPrint(["p","-l"])       }
      "static"     :{ Debug.Print.cmdPrint(["p","-s"])       }
      "param"      |
      "parameter"  :{ Debug.Print.cmdPrint(["p","-p"])       }
      "source"     :{ Debug.Print.cmdSource(["src"])         }
      "file"       :{ Debug.Print.cmdSource(["src","-file"]) }
      "found"      :{ Debug.Print.cmdSource(["src","-f"])    }
      "missing"    :{ Debug.Print.cmdSource(["src","-m"])    }
      "user"       :{ Debug.Print.cmdSource(["src","-u"])    }
      "lib"        :{ Debug.Print.cmdSource(["src","-l"])    }
      "package"    :{ Debug.Print.cmdSource(["src","-pkg"])  }
      "class"      :{ Debug.Print.cmdSource(["src","-cls"])  }
      "record"     :{ Debug.Print.cmdSource(["src","-rec"])  }
      "procedure"  :{ Debug.Print.cmdSource(["src","-proc"]) }
      "function"   :{ Debug.Print.cmdSource(["src","-func"]) }
      "icode"      :{ Debug.Print.cmdSource(["src","-icode"])}      
      "internal"   :{ Debug.Internal.cmdInfo(cmd[3])         }
      "external"   :{ Debug.External.cmdInfo(cmd[3])         }
      default:{
          DState.State := ERROR
          Message := "\n   Undefined Command: \""||DState.cmdHistory[1]||"\""||
                     "\n   Try \"help\" for assistance."
          DState.Write(Message)
          }
      }
end

#
# the shell ls command
#
method ls()
   system(DState.cmdHistory[1])
end

#
# the shell pwd command
#
method pwd()
   system(DState.cmdHistory[1])
end

#         
# General Help Command
#
method cmdHelp(cmd)

   #write("This is command " || cmd[1])
   if *cmd = 1 then {
   case DState.State of {
    NONE | LOAD | END:{
      Message:="_
      \n   Applicable Commands are:_
      \n   load  : loads a new program into udb_
      \n   run   : runs the pre-loaded program under udb_
      \n   break : sets a breakpoint in the source code_
      \n   clear : deletes an existing breakpoint_
      \n   trace : to trace some of the program behaviors_
      \n   list  : prints out lines of the source code_
      \n   src   : prints out a list of the source files_
      \n   quit  : quits the current UDB Session_
      \n   help cmd : shows more info about a specific command"
      }
    PAUSE:{
      Message:="_
      \n   Applicable Commands are:_
      \n   cont  : continue on a full speed execution after a PAUSE_
      \n   step  : stepping one or more lines in the source code_
      \n   next  : same as step command except treating a_
      \n           procedure call as one command or one line of code_
      \n   load  : loads a new program into udb_
      \n   run   : restarts the execution from the begining_
      \n   where : shows the current location info_
      \n   frame : shows the current stack frame info_
      \n   up    : moves up one or more stack frame_
      \n   down  : moves down one or more stack frame_
      \n   print : prints out the value of a var in current frame_
      \n   bt    : prints out the back trace_
      \n   break : sets a breakpoint in the source code_
      \n   clear : deletes an existing breakpoint_
      \n   trace : to trace some of the program behaviors_
      \n   list  : to print out lines of the source code_
      \n   src   : prints out a list of the source files_
      \n   quit  : quits the current UDB Session_
      \n   help cmd : shows more info about a specific command"
      }
    ERROR:{
      Message:="_
      \n   Applicable Commands are:_
      \n   where : shows the current location info_
      \n   bt    : prints out the back trace_
      \n   print : prints out the value of a var in current frame_
      \n   load  : loads a new program into udb_
      \n   run   : restarts the execution from the begining_
      \n   break : sets a breakpoint in the source code_
      \n   clear : deletes an existing breakpoint_
      \n   trace : to trace some of the program behaviors_
      \n   list  : to print out lines of the source code_
      \n   src   : prints out a list of the source files_
      \n   quit  : quits the current UDB Session_
      \n   help cmd : shows more info about a specific command"
      }
   }# end of case   
   }
   else{
   case cmd[2] of {
    "load":{
      Message:="_
      \n   Loads a program into UDB. Use: \"load program\"_
      \n   load p     : loads program (p)_
      \n   load p arg : loads program (p) with argument (arg)"
      }
    "step":{
      Message:="_
      \n   Steps into the next line in the source code_
      \n   step   : steps one line_
      \n   step n : steps (n) lines"
      }
    "run":{
      Message:="_
      \n   Starts (or restarts) program execution_
      \n   run      : runs current loaded program_
      \n   run args : args list passed to program"
      }
    "next":{
      Message:="_
      \n   next steps to next line even on function calls_
      \n   treats function call as only one operation_
      \n   next   : steps one line_
      \n   next n : steps (n) lines"
      }
    "frame":{
      Message:="_
      \n   Prints out the Stack Frame info_
      \n   frame   : prints current stack frame info_
      \n   frame n : prints info about stack frame number (n)_
      \n             n=0 current frame, oldest frame has the bigest number_
      \n   look for \"help up\" and \"help down"
      }
    "up":{
      Message:="_
      \n   Moves current frame pointer up in the execution stack_
      \n   up   : moves current frame pointer one frame up_
      \n   up n : moves current frame pointer (n) frames up_
      \n   look for \"help down\" and \"help frame\""
      }
    "down":{
      Message:="_
      \n   Moves current frame pointer down in the stack_
      \n   down   : moves current frame pointer one frame down_
      \n   down n : moves current frame pointer (n) frames down_
      \n   look for \"help up\" and \"help frame\""
      }
    "quit":{
      Message:="\n   quit: Exits UDB. Use: \"quit\""
      }
    "help":{
      Message:="\n   help: for more help. Try \"help command\""
      }
    "print":{
      Message:="_
      \n   Prints variable information:_
      \n   print       : prints globals and locals of current frame_
      \n   print var   : prints the var value from current frame_
      \n   print var i : prints tha var value from frame number i_
      \n   print -G    : prints all global vars_
      \n   print -L    : prints all local vars in current frame_
      \n   print -P    : prints all Formal Parameters"
      }
    "where":{
      Message:="_
      \n   Prints the current position in the Source Code_
      \n   where      : shows 10 stack frames from the top_
      \n                another where will show the next 10 frames_
      \n   where i    : shows 10 stack frames starting at frame i_
      \n   where -i   : shows 10 stack frames starting at frame i from the end_
      \n   look for \"help break\""
      }
    "cont":{
      Message:="_
      \n   Continue to run at full speed after a breakpoint_
      \n   continue_
      \n   look for \"help cont\""
      }
    "break":{
      Message:="_
      \n   Sets a breakpoint_
      \n   break        : prints all of the pre-set breakpoints_
      \n   break num    : Sets a break at line number (num)_
      \n   break f num  : Sets a break in file f at line number num_
      \n   break Proc   : Sets a break at procedure named \"Proc\"_
      \n   break f Proc : Sets a break in file f at procedure \"Proc\""
      }
    "clear":{
      Message:="_
      \n   Clears a breakpoint_
      \n   clear        : Clears all of the pre-set breakpoints_
      \n   clear num    : Clears break at line num in the current file_
      \n   clear f num  : Clears break in file f at line num_
      \n   clear Proc   : Clears break at procedure Proc in the current file_
      \n   clear f Proc : Clears break in file f at procedure Proc"
      }
    "watch":{
      Message:="_
      \n   Sets a watchpoint on some var_
      \n   watch          : prints a list of all pre-set watch vars_
      \n   watch var      : break at every line the var can change,_
      \n                    if the program is running, it watche for_ 
      \n                    var in the local scope, otherwize it_
      \n                    assumes that var is a global variable_
      \n   watch var proc : watch for local var in procedure proc"
      }
    "list":{
      Message:="_
      \n   Prints out some source code lines_
      \n   list      : if program is not running yet, current line is the_
      \n               line of procedure main(). Otherwise, current line is_
      \n               where the execution paused_ 
      \n   list +    : prints 10 lines from the current file centered_
      \n               around the current line, another list cmd will_
      \n               print the next 10 lines and so on._
      \n   list -    : prints the previous 10 lines from the current print_
      \n   list num  : prints 10 lines centered around the line num_
      \n   list Proc : prints 10 lines centered around the precedure Proc_
      \n   list f    : prints 10 lines from the begining of file f_
      \n   list f n  : prints 10 lines centered around the line n of file f"
      }
    "src":{
      Message:="_
      \n   Prints out a sorted list of related source code info_
      \n   src       : prints a detailed summery of all used file names_
      \n   src -f    : prints all loaded file names_
      \n   src -m    : prints all unloaded source file names_
      \n   src -u    : prints all loaded user files_
      \n   src -l    : prints all loaded library files_
      \n   src -pkg  : prints all used package names_
      \n   src -cls  : prints all used class names-does not belong to packages_
      \n   src -proc : prints all used procedure names_
      \n   src -fun  : prints all used function names_
      \n   src -g    : prints all used global variables_
      \n   src -r    : prints all used record names_
      \n   src -a    : prints a summery of used source files"
      }
    "trace":{
      Message:="_
      \n   Sets a tracer on any variable or execution behavior of the program:_
      \n   trace var | var=[on|off]_
      \n      -proc | -proc=[on | off] |_
      \n      -proc [ call | fail | suspend | resume ]=[on | off]_
      \n      -func | -func=[on | off] |_
      \n      -func [ call | fail | suspend | resume ]=[on | off]_
      \n      -oper | -oper=[on | off] |_
      \n      -oper [ call | fail | suspend | resume ]=[on | off]_
      \n      -scan | -scan=[on | off] |_
      \n      -scan [ new  | fail | suspend | resume ]=[on | off]_
      \n   \"on\" and \"off\" are used to turn the tracer on and off_
      \n   when there is no on/off then the action is printing info_
      \n   ----------------------_
      \n   trace var             : prints the traced var info_
      \n                           if the program is running, it assumes the_ 
      \n                           var is in the local scope, otherwise it_
      \n                           assumes that var is a global variable_
      \n   trace var p           : prints traced var info that is local to p_
      \n   trace var=[on|off]    : traces every value the var can have,_
      \n   trace var=[on|off] p  : traces a local var in procedure p_
      \n   --In oreder to set any of the following behavior tracers ON,_
      \n     it must be set before the program is running/rerunning_
      \n   trace -proc           : prints all the traced procedure info_
      \n   trace -proc=[on|off]  : Sets the procdure tracer on/off _
      \n   trace -proc call      : prints the traced procedure calls_
      \n   trace -proc call=on   : Sets a tracer ON on every procedure call_
      \n   trace -proc call=off  : Sets a tracer OFF on every procedure call_
      \n   and the rest ar going in the same fashion"
      }
    default:{
      Message:="\n   Command not found. Type \"help\" for assistance"
      } 
   }#end of case
   }# end of else
   #make udb console takes no actions 
   DState.State := SKIP
   DState.Write(Message)
end

#
# Initialization
#
initially()

   Debug  := Evaluator()

   DState := Debug.DState           := 
             Debug.Break.DState     := 
             Debug.Watch.DState     := 
             Debug.Step.DState      := 
             Debug.Frame.DState     := 
             Debug.Print.DState     := 
             Debug.Trace.DState     :=
             Debug.Internal.DState  := 
             Debug.External.DState  := State()

# Test : To test the inter-program event forwarding
#        DState.external := debug.external
end

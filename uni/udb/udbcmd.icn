#
# commands.icn
# March 16, 2007
#

$include "defaults.icn"
$include "evdefs.icn"

class Commands : Debug()

#
# Parse a command
#
method parse_Command(cmd)

   case cmd[1] of{
     "load"  :{  cmdLoad(cmd)      }
     "r"     |
     "run"   :{  cmdRun(cmd)       }
     "q"     |
     "quit"  :{  cmdQuit()         }
     "p"     |
     "print" :{  cmdPrint(cmd)     }
     "w"     |
     "where" :{  cmdWhere()        }
     "b"     |
     "break" :{  cmdBreak(cmd)     }
     "watch" :{  cmdWatch(cmd)     }
     "s"     |
     "step"  :{  cmdStep(cmd)      }
     "n"     |
     "next"  :{  cmdNext(cmd)      }
     "f"     |
     "frame" :{  cmdFrame(cmd)     }
     "up"    :{  cmdUp()           }
     "down"  :{  cmdDown()         }
     "?"     |
     "h"     |
     "help"  :{  cmdHelp(cmd)      }
     "c"     |
     "cont"  :{  cmdContinue()     }
     "bt"    :{  cmdBacktrace()    }
     "l"     |
     "list"  :{  cmdList(cmd)      }
     "clear" :{  cmdClear(cmd)     }
      #-cmds that are not in gdb
     "src"   :{  cmdSource(cmd)    }
     "tree"  :{  cmdTree(cmd)      }
     "ihdr"  :{  cmdIcodeHeader()  }
     "trace" :{  cmdTrace(cmd)     }
     "gui"   :{  cmdGUI(cmd)       }
     default :{   
        # anything else
        State := ERROR
        Message   := "\n\t Undefined Command: \""|| cmd[1] ||"\"" ||
                     "\n\t Try \"help\" for assistance."
        Write(Message)
     }
   }
end


#
# Loads a file after running the UDB Session 
#
method cmdLoad(cmd)

   init_Debugging(cmd[2:0])
end

#
# Runs the pre-loaded file, it can be used to re-run the program again
#
method cmdRun(cmd)
   local i, ans, args:=[]

   if *cmd >= 2 then{
      if State = (LOAD | PAUSE | END) then{
         put(args, TP[1])
         every i:=2 to *cmd do
            put(args, cmd[i])
         TP := args
         }
      }

   if State = (LOAD | END | PAUSE) then{ 
      if State = PAUSE then{
         Write("\t A Program is currently running")
         writes("\t Are you sure you want to re-run?, (Y/N )? :")
         ans := read()
         if ans[1] == ("y"|"Y") then
            State := RERUN
         else{
            State := SKIP
            return
            }
         } 
      else  
         State := RUN

      if not member(valueMask, E_Line) & *breakMask > 0 then{
         valueMask[E_Line] := breakMask
         eventMask ++:= cset(E_Line) 
         write("------E_Line added")
         }
      if not member(valueMask, E_Assign) & (*watchMask | *traceVarMask) >0 then{
         valueMask[E_Assign] := watchMask ++ traceVarMask
         eventMask ++:= cset(E_Assign)
         write("------E_Assign added")
         }
      }
   else{
      State := ERROR
      Message   := "\n\t No program to RUN, load program first_
                    \n\t Type \"help\" for assistance"
      Write(Message)
   }
end

#
# Allows you to quit the program.
#
method cmdQuit()
   local ans

   # check whether a program is running or not, Paused, etc??????
   # do not exit directlly if the program is in the running state
   if State = (RUN | PAUSE) then
      Write("\t A Program is currently running")

   # always ask the user if he realy wants to quit!!!
   writes("\t Are you sure you want to Quit?, (Y/N )? :")
   ans := read()
   if ans[1] == ("y"|"Y") then
      State := QUIT
   else{
      #make udb console takes no actions 
      State := SKIP
   }
end


#
# prints out all of the Global Variables state in some level
#
method printGlobals(level)
   local x, i
        
   if /level then  level := cur_Frame # 0 if no up/down involved
   
   Message := ""
   every x := !global_vars do{
      i := variable(x, Monitored, level)
      Message ||:= "\n\t "||x||" = "||image(i)||" : "|| type(i)
   }
   Write(Message)
end

#
# prints out all of the Local Variables for some Level  
#
method printLocals(level)
   local x, i

   if /level then level := cur_Frame # 0 if no up/down involved

   Message := ""
   every x := localnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n\t "||x||" = "||image(i)||" : "|| type(i)
   }
   Write(Message)
end

#
# prints out all of the Formal Parameters for some Level  
#
method printParams(level)
   local x, i

   if /level then level := cur_Frame # 0 if no up/down involved

   Message := ""
   every x := paramnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n\t "||x||" = "||image(i)||" : "|| type(i)
   }
   Write(Message)
end

#
# Prints out a variable and it's current value. Variables from previous
# procedures that are still in the stack can also be viewed.
#
method cmdPrint(cmd)
   local x,    # is the dummy variable that we are looking for
         i,j,  # is the index when x is a table or list
         var,  # is the actual variable that we got from variable()
         level,# stack frame level, 0: current level, biger level means older
         i1,i2,temp,
         action

   if State = PAUSE then{ 
      if x := temp := cmd[2] then{
         if temp == ("-g" |"-G" | "-globals") then{
            printGlobals()
            return
	    }
	 else if temp == ("-l" | "-L" | "-locals") then{
            printLocals()
            return
	    }
	 else if temp == ("-p" | "-P" | "-params") then{
            printParams()
            return
	    }

         if j:=find("&", temp) then{
            Message := "\n\t "|| temp
            x := temp := temp[j+1:0]
            Message ||:=" = "||keyword(x,Monitored) 
            Write(Message)
            return
            }

         if j:=find("*",temp) then{
            action := "*"
            x := temp := temp[j+1:0]
            } 

         #--To be able to print things like T[1], T["a"], L[10], etc.
         if (i1:= find("[",temp)) & (i2:= find("]", temp)) then{
            x := temp[1:i1]
            i := temp[i1+1:i2]
            if *i > 0 then
               if find("\"",i) then  i := string(i[2:*i])
               else                  i := integer(i)
            else
               i := &null             
            }

         if cmd[3] then  level := integer(cmd[3]) | 0  #(level | current level) 
         else            level := cur_Frame # which is 0 if no up/down involved
         
         if var := variable(x, Monitored, level) then{
            if type(var) == ("table" | "list" | "string" ) then{
               if \i  then{
                  if \action then Message := "\n\t *"||x||" = "||*var[i]
                  else            Message := "\n\t "||x||" = "||ximage(var[i])
                  }
               else{
                  if \action then Message := "\n\t *"||x||" = "||*var
                  else            Message := "\n\t "||x||" = "||ximage(var)
                  } 
               }# if type(var)...
            else{
               if type(var) == "null" then
                  Message := "\n\t "||x||" = "||image(var)
               else
                  Message := "\n\t "||x||" = "||var
               } 
	    }
	 else
            Message := "\n\t "||x||" : Is not in the current frame !!"
	 }
      else {
         level := cur_Frame # which is 0 if no up/down involved
         printFrame(level)
	 }
      }
   else{
      State := ERROR
      Message := "\n\t No program is running !!!_
                  \n\t Try \"run\", or Type \"help\" for assistance"
      }
   Write(Message)
end

#
# writes down the current frame information, 
# used by cmdPrint, cmdFrame, cmdUp, cmdDown
#
method printFrame(frame)
   local x, i, level, p:="("
   
   level := keyword("level", Monitored) -1
   if 0 <= frame <= level then{
      Message   := "\t #"|| frame
      Message ||:= ": "|| image(proc(Monitored, frame))
      every x := paramnames(Monitored,frame) do{
         i := variable(x, Monitored,frame)
         p ||:= x||"="||image(i)||", "
         }
      p:= p[1:-2]
      Message ||:= p ||")"
      }
   else
      Message := " The \""||frame ||"\" is not a valid frame number"||
                 " valid frames are (0 <= frame_num <= "||level||")"  
   Write(Message)
end

#
# Moves one frame up on the execution stack
#
method cmdUp()
   local level

   level := keyword("level",Monitored) - 1 
   if State = PAUSE then {
      if cur_Frame = level then
         Write("\t No more Frames up !!!")
      else {
         cur_Frame +:= 1
         printFrame(cur_Frame)
	 }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Moves one frame down on the execution stack
#
method cmdDown()

   if State = PAUSE then {
      if cur_Frame = 0 then
         Write("\t No more Frames Down !!!")
      else {
         cur_Frame -:= 1
         printFrame(cur_Frame)
	 }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Prints out the current stack frame info,
# It can be used to jump into a specific frame, [f n]
#
method cmdFrame(cmd)
   local frame, level 

   if State = PAUSE then{ 
      if *cmd = 1 then {
         printFrame(cur_Frame)
	 }
      else{
         if frame := integer(cmd[2]) then
            printFrame(frame)
         else
            Write("cmdFrame, What ???")
         }
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Prints out where you are in the code, what file, and what line.
#
method cmdWhere()
   local i, x, cur_file, cur_line, p, param

   if State = PAUSE then{
      cur_file := keyword("file", Monitored)
      cur_line := keyword("line", Monitored)
      p        := image(proc(Monitored,0))
      param:="("
      every x := paramnames(Monitored,0) do{
         i := variable(x, Monitored,0)
         param ||:= x||"="||image(i)||", "
         }
      param:= param[1:-2] ||")"
     
      Message := "\n\t "||cur_file||"("||cur_line||")"||": "|| p||param ||
                 "\n\t Code: "|| srcFile.getSrcLine(cur_line, cur_file)  
      }
   else {
      State := ERROR
      Message := "\n\t No program is running !!!_
                  \n\t Try \"run\", or Type \"help\" for assistance"
      }
   Write(Message)
end

#
# To back trace the executin in the stack
# [bt]
#
method cmdBacktrace()
   local level, frame

   level := keyword("level", Monitored) - 1
   if State = PAUSE then
      every frame := 0 to level do
         printFrame(frame) 
   else{
      State := ERROR
      Message := "\n\t Execution Stack is empty\n\t Try \"run\" first"
      Write(Message)
      }
end

#
# Continue the full speed execution after a PAUSE
# [cont]
#
method cmdContinue()

   if State = PAUSE & RunCode ~= ERROR then {
      State := CONTINUE
      
      if not member(valueMask, E_Assign) & *watchMask > 0 then{
         valueMask[E_Assign] := watchMask
         eventMask ++:= cset(E_Assign)
         }
      else if *watchMask = 0 then  eventMask --:= cset(E_Assign)

      if not member(valueMask, E_Line) & *breakMask > 0 then{
         valueMask[E_Line] := breakMask
         eventMask ++:= cset(E_Line)
         }
      else if *breakMask = 0 then  eventMask --:= cset(E_Line)
      }
   else{
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Steps only on line of execution
# [step], [step n]; n's default value is one
#
method cmdStep(cmd)
   local count

   if State = PAUSE & RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
         step_count := count
      else
         step_count := 1
      State := STEP

      if *breakMask > 0 then  delete(valueMask, E_Line)
      if *watchMask > 0 then  eventMask ++:= cset(E_Line)
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# Steps only one line of execution, treats procedure call as one operation
# [next], [next n]; n's default value is one  
#
method cmdNext(cmd)
   local count

   if State = PAUSE & RunCode ~= ERROR then {
      if count := integer(cmd[2]) then
	 next_count := count
      else
	 next_count := 1

      State := NEXT
      nex_level := keyword("level", Monitored)

      if *breakMask > 0 then  delete(valueMask, E_Line)
      if *watchMask > 0 then  eventMask ++:= cset(E_Line)
      }
   else {
      State := ERROR
      Message   := "\n\t No program is running !!!_
                    \n\t Try \"run\", or Type \"help\" for assistance"
      Write(Message)
      }
end

#
# watches for a variable
#
method cmdWatch(cmd)
   local x, var, procName, i, old_State := State

   if not (State = (LOAD | PAUSE)) then {
      State := ERROR
      Message   := "\n\t No Program is Loaded_
                    \n\t Type \"help\" for assistance"
      Write(Message)
      return
      }
   State := SKIP
   
   # if cmd is only "watch"; will print all of the pre-set watch points info
   if *cmd = 1 then{
      Message :="\n\t " || cmd[1]
      every x := !watchMask do
         Message ||:= "\n\t Watch for : " || x

      Write(Message)
      return
      }

   var := cmd[2]
   if member(watchMask, var) then {
      Message := "\n\t There is already an existing watch point on: " || var
      Write(Message)
      return
      }
   
   # Note: we have to be smart about the scope of the watched variable
   if cmd[3] then {
      var ||:= "-" || cmd[3] # cmd[3] is the procedure name
      }
   else if old_State = LOAD then {
      # we would assume that the watched variable is a global one  
      var ||:="+"  # + is the global scope character
      }
   else if old_State = PAUSE then {
      # assume? that the watched variable is local to where it is paused
      procName := image(proc(Monitored, 0))
      i := find(" ",procName)
      var ||:= "-" || procName[i+1:0]
      }
   insert(watchMask, var)
   Message := "\n\t Watchkpoint successfully set for: "||var
   Write(Message)
end

#
# prints out a list of the existing break points used by cmdBreak
#
method printBreakPoints(cmd)
   local x, L, bp

   Message := "\n\t " || cmd[1]
   every x := key(breakPoints) do {
      L := breakPoints[x]
      every bp := !L do
         Message ||:= "\n\t " || bp.file_name ||
                      "(" || bp.line_num ||")"|| ": " || bp.code
      }
      Write(Message)
end

#
# check to see whether a break point is pre-exist or not
#
method isBreakExist(fname, line)
   local L, bp

   if member(breakPoints, fname) then {
      L := breakPoints[fname]
      every bp := !L do
         if bp.line_num = line then
            return
      }
   fail
end

#
# used to add a new break point into the 
# breakPoints table and the breakMask set
#
method addBreakPoint(fname, bp)
   local L
   
   if member(breakPoints,fname) then
      put(breakPoints[fname], bp)
   else {
      L := []
      put(L, bp)
      breakPoints[fname] := L
      }
   insert(breakMask,bp.line_num)
end

#
# used it clear break points, is used by cmdClear()
#
method deleteBreakPoint(fname, line)
   local L, x, i
   
   L := breakPoints[fname]
   every i := 1 to *L do{
      x := L[i]
      if x.line_num = line then
         delete(L,i)
      } 
   if *L = 0 then
      delete(breakPoints, fname)
   delete(breakMask,line)
end

#
# Used by cmdBreak
#
method addExtension(fname)
   local temp1, temp2

   fname ? {
      temp1 := tab(many(CHARACTER ++ '_-'))
      repeat {
	 if (temp2 := move(1)) then {
	    temp1 ||:= temp2
            }
	 else {
	    temp1 ||:= ".icn"
            return temp1
            }
	 temp2 := tab(many(CHARACTER))
         if temp2 == "icn" then {
	    return fname
            }
         }
      }
end

#
# Sets Break points on line numbers or procedure names
# [b linenum], [b ProcName], [b file linenum]
#
method cmdBreak(cmd)
   local code, line, fname, arg, break_point

   if not (State = (LOAD | PAUSE)) then {
      State := ERROR
      Message   := "\n\t No Program is Loaded_
                    \n\t Type \"help\" for assistance"
      Write(Message)
      return
      }
   State := SKIP

   # if cmd is only "break"; will print all of the preset breakpoints info
   if *cmd = 1 then{
      printBreakPoints(cmd)
      return
      } 
 
   if *cmd = 2 then {
      fname := srcFile.exeName
      arg   := cmd[2]
      }
   else if *cmd > 2 then {
      fname := cmd[2]
      arg   := cmd[3]
      }

   fname := addExtension(fname)

   if srcFile.isLoaded(fname) then{
      if line := integer(arg) then{
         if srcFile.isInFile(fname, line) then{
            if code := srcFile.searchFileLines(fname, line) then
               break_point := breakPt(fname, line, code)
            else{
               Message   := "\n\t Line number was not found,_
                             \n\t Please try a different line number"
               Write(Message)
               return
               }
            }
         else{
            Message := "\n\t Line number is not within the \""||fname||"\""
            Write(Message)
            return
            }
         }
      else{
         if line := srcFile.searchFileProcs(fname, arg) then
            break_point := breakPt(fname,line,srcFile.getSrcLine(line, fname))
         else{
            Message   := "\n\t Procedure not found_
                          \n\t Make sure the method name is correct!"
            Write(Message)
            return
            }
         } 
      }      
   else{
      Message := "\n\t Source File \""||fname||"\" is not loaded !!!"
      if line := integer(arg) then
         break_point := breakPt(fname , line, "?")
      #Write(Message)???
      }
      
   # record breakPt(file_name, line_num, code)
   line := break_point.line_num
   if isBreakExist(fname, line) then
      Message ||:= "\n\t The break point is already exist,_
                    \n\t Type \"break\" to see all breakpoints"
   else{
      addBreakPoint(fname, break_point)
      Message ||:= "\n\t Breakpoint set successfully in:\n\t "||
                   fname ||"("||line||"): "
      Message ||:= srcFile.getSrcLine(line, fname) 
      } 
   Write(Message)
end

#
# it clears pre-set break points
#
method cmdClear(cmd)
   local line, x, fname, arg

   # clears all of the preset break points
   if *cmd = 1 then{
      breakMask := set(-1)
      every x := key(breakPoints) do
          delete(breakPoints, x)
      Message := "\n\t All break points are cleared!!!"
      Write(Message)
      return
      }

   if *cmd = 2 then{
      fname := srcFile.exeName
      arg   := cmd[2]
      }
   else if *cmd > 2 then{
      fname := cmd[2]
      arg   := cmd[3]
      }

   fname := addExtension(fname)
   if line := integer(arg) then{
      if isBreakExist(fname, line) then{
         deleteBreakPoint(fname, line)
         Message := "\n\t The break point is cleared at :\n\t "||fname||
                    "("||line ||"): "||srcFile.getSrcLine(line, fname)
         }
      else
         Message := "\n\t There is no break point at : \n\t "||fname||
                    "("||line ||"): "||srcFile.getSrcLine(line)
      }
   else{ 
      if line := srcFile.searchFileProcs(fname, arg) then{
         if isBreakExist(fname, line) then{
            deleteBreakPoint(fname,line)
            Message := "\n\t The break point is cleared at :\n\t "||fname||
                       "("||line ||"): "||srcFile.getSrcLine(line, fname)
            }
         else
            Message := "\n\t There is no break point at : \n\t "||fname||
                       "("||line ||"): "||srcFile.getSrcLine(line)
         }
      else
         Message   := "\n\t Procedure not found_
                       \n\t Make sure the method name is correct!"
      }
   Write(Message)
end

#
# used by cmdList to print a a bunch of src lines
#
method printSrcLines(cur_line, cur_file, num)
   local i, line := cur_line - 5

   if /num then num := 10

   if line < 0 then line := 0

   Message :="" 
   every i:= 1 to num do{
      line +:= 1
      if line = cur_line then
         Message ||:="\n    --> "||line ||":"||
                     srcFile.getSrcLine(line, cur_file)
      else
         Message ||:="\n\t"||line ||":"||
                     srcFile.getSrcLine(line, cur_file)
      }
   Write(Message)
end

#
# The list command from gdb, as in gdb defaults are 10 lines from
# the current file are printed centered around the curent line 
#
method cmdList(cmd)
   local cur_line, cur_file, fnc, line
   static last_line := -1
   
   if RunCode ~= LIST then{
      last_line := -1
      RunCode := LIST
      }

   if State = LOAD then{
      cur_file := srcFile.exeName ||".icn"
      cur_line := 5
      } 
   else if State = PAUSE then{
      cur_file := keyword("file", Monitored)
      cur_line := keyword("line", Monitored)
      }
   else{
      State := ERROR
      Message := "\n\t No Program is Loaded nor Running_
                  \n\t Type \"help\" for assistance"
      Write(Message)
      return
      }

   if *cmd = 1 then{
      if last_line = -1 then
         last_line := cur_line
      else
         last_line +:= 10
      }
   else{
       if line := integer(cmd[2]) then
          last_line := line
       else{
          if cmd[2] == "-" then
             last_line -:= 10
          else{
             fnc := cmd[2]
             if line := srcFile.searchFileProcs(cur_file, fnc) then
                last_line := line
             else if member(srcFile.foundFiles, fnc||".icn") then{#????
                cur_file:= fnc||".icn"
                last_line := 5
                } 
             else{
                Message := "\n\t Procedure not found_
                            \n\t Make sure the method name is correct!"
                Write(Message)
                return
                }
             }
          }
       }

   if srcFile.isLoaded(cur_file) then{
      if srcFile.isInFile(cur_file, last_line) then
         printSrcLines(last_line, cur_file)
      else{
         Message := "\n\t line #("||last_line||") is out of the file limits"
         last_line := -1
         Write(Message)
         }
      }
   else{
      Message := "\n\t Source File \""||cur_file||"\" is NOT loaded !!!"
      last_line := -1
      Write(Message)
      }
end

#------ Commands that are not in gdb,thay need Dr.J's approval

#
# a method to print the Icode Header
#
method cmdIcodeHeader()

   icode.printIcodeHeader()

end

#
# it is to print the found/missing source files
#
method cmdSource(cmd)
   local op, files

   if cmd[3] then{
      Message := srcFile.getSourceCode(cmd[3])
      Write(Message)
      return
      }

   op := cmd[2] | ""
   case op of{
      "-f" | "-found":{
           if files := srcFile.getFoundFiles() then{
              Message := "\n    Found Source Files are:\n"
              Message ||:= files
              }
           else
              Message := "\n\t No file(s) found !!"
           }
      "-m" | "-missing":{
           if files := srcFile.getMissingFiles() then{
              Message   := "\n    Missing Source Files are:\n"
              Message ||:= files
              }
           else
              Message := "\n\t No file(s) missing !!"
           }
      "-a" | "-all":{
           if files := srcFile.getSourceFiles() then{
              Message   := "\n    All Source Files are:\n"
              Message ||:= files
              }
           else
              Message := "\n\t No file(s) loaded !!"
           }
      default:{
           if files := srcFile.getFoundFiles() then{
              Message   := "\n    Found Source Files are:\n"
              Message ||:= files
              }
           if files := srcFile.getMissingFiles() then{
              Message ||:= "\n    Missing Source Files are:\n"
              Message ||:= files
              }
           } 
      } 
   Write(Message)
end

#
# Used by the cmdTree method, leaf initial value is "treeRoot".  
#
method printT(leaf)
   local t, i

   Message ||:= "\n\t num of leaf:" || *leaf.children ||
                "\n\t Proc  : " || image(leaf.node)   ||
                "\n\t Level : " || leaf.level
   Write(Message)

   t := leaf.children
   if *t < 1 then  return
   every printT(!t)
end

#
# Prints out the current execution tree, very simelar to bt cmd
#
method cmdTree(cmd)
   # evalTree can not be printed unless the TP ran for a while.
   if State = ( LOAD | END) then{
      if *cmd = 1 then
         printT(treeRoot)
      else{
         if cmd[2] == "on" then{
            # it is on by default until it is set to be off
            treeFlag := 1
            Write(Message:="\n\t the evaltree is ON.")
            }
         else if cmd[2] == "off" then {
            treeFlag := &null
            Write(Message:="\n\t the evaltree is Off.")
            }
         }
      }
   else{
      State := ERROR
      Message := "\n\t EvalTree must be turned on befor running the program!"
      Write(Message)
      }
end

#
# set a trace on a variable
#
method traceVar(cmd)
   local L, var, r, procName, i, old_State := State
   
   # Note: we have to be smart about the scope of the traced variable
   # find the real var first, then find the action
   var := cmd[2]
   if not cmd[3] then{
      if old_State = LOAD then {
         # we would assume that the watched variable is a global one  
         var ||:="+"  # + is the global scope character
         }
      else if old_State = PAUSE then {
         # assume? that the watched variable is local to where it is paused
         procName := image(proc(Monitored,0))
         i := find(" ",procName)
         var ||:= "-" || procName[i+1:0]
         }
      else{
         Message:= "\n\t unknown action_
                    \n\t Try \"help trace\" for assistance"
         Write(Message)
         return
         }
      }
   else if not (cmd[3] == ("on"|"off")) then{
      var ||:= "-" || cmd[3] # cmd[3] is the procedure name
      }
   else if cmd[3] == ("on"|"off") then{
      if cmd[4] then {
         var ||:= "-" || cmd[4] # cmd[4] is the procedure name
         }
      else if old_State = LOAD then {
         # we would assume that the watched variable is a global one  
         var ||:="+"  # + is the global scope character
         }
      else if old_State = PAUSE then {
         # assume? that the watched variable is local to where it is paused
         #procName := image(top_Frame.node)
         procName := image(proc(Monitored,0))
         i := find(" ",procName)
         var ||:= "-" || procName[i+1:0]
         }
      }

   # write("------var= ",var)
   if member(traceVarMask, var) then{
      if cmd[3] == "on" then
         Message := "\n\t Trace for \""||var||"\" is already ON"
      else if cmd[3] == "off" then{
         Message := "\n\t Trace for \""||var||"\" is set to be OFF"
         delete(traceVarMask, var)
         }
      else{ #$trace var proc, or $trace var, are used to print the var info 
         if member(traceVarTable, var) then{
            L := traceVarTable[var]
            if *L > 0 then{
               Message := "\n\t--The tracing info for \""||var||"\""
               every r := !L do
                  Message ||:="\n\t  " || r.fname || ", " || r.line ||
                              ": "|| r.var||" = "||r.value
               }# end if *L > 0
            else
               Message:= "\n\t var: "||var||" has no trace info yet!"
            }
         else
            Message:= "\n\t Var: "||var||" has no trace info yet!"
         }# end else
      }
   else{# if not member(traceVarMask, var)
      if cmd[3] == "on" then{
         insert(traceVarMask, var)
         Message := "\n\t Trace for \""||var||"\" is set to be ON"
         }
      else if cmd[3] == "off" then
         Message := "\n\t Trace for \""||var||"\" is not ON to set it OFF"
      else
         Message:= "\n\t unknown action_
                    \n\t Try \"help trace\" for assistance"
      }
   Write(Message)
end

#
# prints the execution behavior tracer info
# it is used by traceBehavior()
#
method printTraceBehavior(ecodeSet)
   local x, L, e, traced

   every e := !ecodeSet do{
      if member(traceState, e) then{
         Message := "\n\t--The tracing info for \""||evnames(e)||"\":"
         L := traceTable[e]
         if type(L) ~== "list" then next
         if member(ProcMask, e) then
            every x := !L do
               Message ||:= "\n\t  "||x.level ||", "||x.fname||", "||x.line||
                            ": "||x.proc  ||"("||x.param||")."
         else
            every x := !L do
               Message ||:= "\n\t -"||x.fname||", "||x.line||": "||x.code
         }
      else
         Message:="\n\t No trace is ON for \""||evnames(e)||"\" to print._
                   \n\t Try \"help trace\" for assistance"
      Write(Message)
      }
end

#
# get what action to do for the trace command
# it is used by the traceBehavior()
#
method traceBehaviorAction(cmd)
   local action
 
   if *cmd = 2 then{
      action := "print"
      }
   else if *cmd >=3 then{
      case cmd[3] of{
        "call"         :{ action   := "print" }
        "fail"         :{ action   := "print" }
        "suspend"      :{ action   := "ptint" }
        "resume"       :{ action   := "print" }
        "on"|"enable"  :{ action   := "on"    }
        "off"|"disable":{ action   := "off"   }
         }
      if *cmd = 4 then{
         if cmd[4] == ("on"|"enable") then
            action := "on"
         else if cmd[4] == ("off"|"disable") then
                 action := "off"
         }
      }
   return action
end

#
# Process the trace behavior command
# it isused by cmdTrace()
#
method traceBehavior(cmd)
   local e, ecodeSet, action, ename

   case cmd[2] of{
   "-proc" :{
       ecodeSet := ProcMask
       case cmd[3] of{
         "call"   :{ ecodeSet := cset(E_Pcall)  }
         "fail"   :{ ecodeSet := cset(E_Pfail)  }
         "suspend":{ ecodeSet := cset(E_Psusp)  }
         "resume" :{ ecodeSet := cset(E_Presum) }
       }} 
   "-func" :{
       ecodeSet := FncMask
       case cmd[3] of{
         "call"   :{ ecodeSet := cset(E_Fcall)  }
         "fail"   :{ ecodeSet := cset(E_Ffail)  }
         "suspend":{ ecodeSet := cset(E_Fsusp)  }
         "resume" :{ ecodeSet := cset(E_Fresum) }
       }}
   "-oper" :{
       ecodeSet := OperMask
       case cmd[3] of{
         "call"   :{ ecodeSet := cset(E_Ocall)  }
         "fail"   :{ ecodeSet := cset(E_Ofail)  }
         "suspend":{ ecodeSet := cset(E_Osusp)  }
         "resume" :{ ecodeSet := cset(E_Oresum) }
       }}
   "-scan" :{
       ecodeSet := ScanMask
       case cmd[3] of{
         "new"    :{ ecodeSet := cset(E_Snew)   }
         "fail"   :{ ecodeSet := cset(E_Sfail)  }
         "suspend":{ ecodeSet := cset(E_Ssusp)  }
         "resume" :{ ecodeSet := cset(E_Sresum) }
       }}
   default:{ action := "error" }
   }# end case
   
   #if action ~== "error" then
   action := traceBehaviorAction(cmd)
   
   ename := ""
   every e := !ecodeSet do
     ename ||:= evnames(e)||", "
   ename := ename[1:-2]
   
   case action of{
     "print" :{ printTraceBehavior(ecodeSet) }
     "on"    :{ traceState ++:= ecodeSet
                eventMask ++:= ecodeSet ## ???     
                Message := "\n\t The traceState has a new trace code: "||ename
                Write(Message)
              }
     "off"   :{ traceState --:= ecodeSet    
                Message := "\n\t The traceState lost a trace code: "||ename
                Write(Message)
              }
     default :{ Message := "\n\t unknown trace action_
                            \n\t Try \"help trace\" for assistance"
                Write(Message)
              }
     }# end case
end

#
# build Variable(s) and/or Behavior(s) tracer  
#
method cmdTrace(cmd)
   local ecodeSet, traced, action

   if not (State = (LOAD | PAUSE | END)) then {
      State := ERROR
      Message   := "\n\t No Program is Loaded_
                    \n\t Type \"help trace\" for assistance"
      Write(Message)
      return
      }

   if *cmd >= 2 then{
      if find("-",cmd[2]) then traceBehavior(cmd)
      else                     traceVar(cmd)
      }
   else{
      Message := "\n\t unknown trace action !!?_
                  \n\t try \"help trace\" for assistance"
      Write(Message)
      }
   State := SKIP
end

#
# to skip the infinite loop that goes in the gui stuff waitting for an event
#
method cmdGUI(cmd)
   if cmd[2]=="on" then{
#      guiFlag:=1
      Write(Message := "\n\t The guiFlag is set to be on") 
   }
   else if cmd[2]=="off" then{
#      guiFlag := &null
      Write(Message := "\n\t The guiFlag is set to be off") 
   }
   else
      Write(Message := "\n\t cmdGUI: No Action specified")
end

#---------- end commands that are not in gdb

#         
# General Help Command
#
method cmdHelp(cmd)

   #write("\t This is command " || cmd[1])
   if *cmd = 1 then {
   case State of {
    NONE | LOAD | END:{
      Message:="_
      \n\t Applicable Commands are:_
      \n\t load  : loads a new program into udb_
      \n\t run   : runs the pre-loaded program under udb_
      \n\t break : sets a break point in the source code_
      \n\t clear : deletes an existing break point_
      \n\t trace : to trace some of the program behaviors_
      \n\t list  : prints out lines of the source code_
      \n\t src   : prints out a list of the source files_
      \n\t quit  : quits the current UDB Session_
      \n\t help cmd : shows more info about a specific command"
      }
    PAUSE:{
      Message:="_
      \n\t Applicable Commands are:_
      \n\t cont  : continue on a ful speed execution after a PAUSE_
      \n\t step  : stepping one or more lines in the source code_
      \n\t next  : same as step command except treating a \n\t\t_
      \n\t         procedure call as one command or one line of code_
      \n\t load  : loads a new program into udb_
      \n\t run   : restarts the execution from the begining_
      \n\t where : shows the current location info_
      \n\t frame : shows the current stack frame info_
      \n\t up    : moves up one ore more stack frame_
      \n\t down  : moves down one or more stack frame_
      \n\t print : prints out the value of a var in current frame_
      \n\t bt    : prints out the back trace_
      \n\t break : sets a break point in the source code_
      \n\t clear : deletes an existing break point_
      \n\t trace : to trace some of the program behaviors_
      \n\t list  : to print out lines of the source code_
      \n\t src   : prints out a list of the source files_
      \n\t quit  : quits the current UDB Session_
      \n\t help cmd : shows more info about a specific command"
      }
    ERROR:{
      Message:="_
      \n\t Applicable Commands are:_
      \n\t where : shows the current location info_
      \n\t bt    : prints out the back trace_
      \n\t print : prints out the value of a var in current frame_
      \n\t load  : loads a new program into udb_
      \n\t run   : restarts the execution from the begining_
      \n\t break : sets a break point in the source code_
      \n\t clear : deletes an existing break point_
      \n\t trace : to trace some of the program behaviors_
      \n\t list  : to print out lines of the source code_
      \n\t src   : prints out a list of the source files_
      \n\t quit  : quits the current UDB Session_
      \n\t help cmd : shows more info about a specific command"
      }
   }# end of case   
   }
   else{
   case cmd[2] of {
    "load":{
      Message:="_
      \n\t Loads a program into UDB. Use: \"load program\"_
      \n\t load p     : loads program (p)_
      \n\t load p arg : loads program (p) with argument (arg)"
      }
    "step":{
      Message:="_
      \n\t Steps into the next line in the source code_
      \n\t step   : steps one line_
      \n\t step n : steps (n) lines"
      }
    "run":{
      Message:="_
      \n\t Starts (or restarts) program execution_
      \n\t run      : runs current loaded program_
      \n\t run args : args list passed to program"
      }
    "next":{
      Message:="_
      \n\t next steps to next line even on function calls_
      \n\t treats function call as only one operation_
      \n\t next   : steps one line_
      \n\t next n : steps (n) lines"
      }
    "frame":{
      Message:="_
      \n\t Prints out the Stack Frame info_
      \n\t frame   : prints current stack frame info_
      \n\t frame n : prints info about stack frame number (n)_
      \n\t n=0: current frame, oldest frame has the bigest number_
      \n\t look for \"help up\" and \"help down"
      }
    "up":{
      Message:="_
      \n\t Moves current frame pointer up in the execution stack_
      \n\t up   : moves current frame pointer one frame up_
      \n\t up n : moves current frame pointer (n) frames up_
      \n\t look for \"help down\" and \"help frame\""
      }
    "down":{
      Message:="_
      \n\t Moves current frame pointer down in the stack_
      \n\t down   : moves current frame pointer one frame down_
      \n\t down n : moves current frame pointer (n) frames down_
      \n\t look for \"help up\" and \"help frame\""
      }
    "quit":{
      Message:="\n\t quit: Exits UDB. Use: \"quit\""
      }
    "help":{
      Message:="\n\t help: for more help. Try \"help command\""
      }
    "print":{
      Message:="_
      \n\t Prints variable information:_
      \n\t print       : prints globals and locals of current frame_
      \n\t print var   : prints the var value from current frame_
      \n\t print var i : prints tha var value from frame number i_
      \n\t print -G    : prints all global vars_
      \n\t print -L    : prints all local vars in current frame_
      \n\t print -P    : prints all Formal Parameters"
      }
    "where":{
      Message:="_
      \n\t Prints the current position in the Source Code_
      \n\t where_
      \n\t look for \"help break\""
      }
    "cont":{
      Message:="_
      \n\t Continue to run at full speed after a break point_
      \n\t continue_
      \n\t look for \"help cont\""
      }
    "break":{
      Message:="_
      \n\t Sets a break point_
      \n\t break        : prints all of the pre-set break points_
      \n\t break num    : Sets a break at line number (num)_
      \n\t break f num  : Sets a break in file f at line number num_
      \n\t break Proc   : Sets a break at procedure named \"Proc\"_
      \n\t break f Proc : Sets a break in file f at procedure \"Proc\""
      }
    "clear":{
      Message:="_
      \n\t Clears a break point_
      \n\t clear        : Clears all of the pre-set break points_
      \n\t clear num    : Clears break at line num in the current file_
      \n\t clear f num  : Clears break in file f at line num_
      \n\t clear Proc   : Clears break at procedure Proc in the current file_
      \n\t clear f Proc : Clears break in file f at procedure Proc"
      }
    "watch":{
      Message:="_
      \n\t Sets a watch point on some var_
      \n\t watch          : prints a list of all pre-set watch vars_
      \n\t watch var      : break at every line the var can change,_
      \n\t                  if the program is running, it watche for_ 
      \n\t                  var in the local scope, otherwize it_
      \n\t                  assumes that var is a global variable_
      \n\t watch var proc : watch for local var in procedure proc"
      }
    "list":{
      Message:="_
      \n\t Prints out some source code lines_
      \n\t list      : prints 10 lines from the current file centered_
      \n\t             around the current line, another list cmd will_
      \n\t             print the next 10 lines and so on_ 
      \n\t list -    : prints the previous 10 lines from the current print_
      \n\t list num  : prints 10 lines centered around the line num_
      \n\t list Proc : prints 10 lines centered around the precedure Proc"
      }
    "src":{
      Message:="_
      \n\t Prints out a list of the source file names_
      \n\t src    : prints all of the found & missing source file names_
      \n\t src -f : prints only the loaded source file names_
      \n\t src -m : prints only the unloaded source file names_
      \n\t src -a : prints all of the source file names along with their path"
      }
    "trace":{
      Message:="_
      \n\t Sets a tracer on any variable or execution behavior of the program:_
      \n\t trace var | var=[on|off]_
      \n\t       -proc | -proc=[on | off] |_
      \n\t       -proc [ call | fail | suspend | resume ]=[on | off]_
      \n\t       -func | -func=[on | off] |_
      \n\t       -func [ call | fail | suspend | resume ]=[on | off]_
      \n\t       -oper | -oper=[on | off] |_
      \n\t       -oper [ call | fail | suspend | resume ]=[on | off]_
      \n\t       -scan | -scan=[on | off] |_
      \n\t       -scan [ new  | fail | suspend | resume ]=[on | off]_
      \n\t \"on\" and \"off\" are used to turn the tracer on and off_
      \n\t when there is no on/off then the action is printing info_
      \n\t ----------------------_
      \n\t trace var             : prints the traced var info_
      \n\t                         if the program is running, it assumes the_ 
      \n\t                         var is in the local scope, otherwise it_
      \n\t                         assumes that var is a global variable_
      \n\t trace var p           : prints traced var info that is local to p_
      \n\t trace var=[on|off]    : traces every value the var can have,_
      \n\t trace var=[on|off] p  : traces a local var in procedure p_
      \n\t --In oreder to set any of the following behavior tracers ON,_
      \n\t   it must be set before the program is running/rerunning_
      \n\t trace -proc           : prints all the traced procedure info_
      \n\t trace -proc=[on|off]  : Sets the procdure tracer on/off _
      \n\t trace -proc call      : prints the traced procedure calls_
      \n\t trace -proc call=on   : Sets a tracer ON on every procedure call_
      \n\t trace -proc call=off  : Sets a tracer OFF on every procedure call_
      \n\t and the rest ar going in the same fashion"
      }
    default:{
      Message:="\n\t Command not found. Type \"help\" for assistance"
      } 
   }#end of case
   }# end of else
   #make udb console takes no actions 
   State := SKIP
   Write(Message)
end

# Just make sure that the base class is initialized
initially()
   self.Debug.initially()
end

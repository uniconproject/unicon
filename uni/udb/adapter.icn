link ximage
link strings
link findre
import json
global seq, lastUdbCmd, waitingForTerminal, requestQueue, cmdQueue, currStructuredVars

class Adapter(
   port,
   sock,
   dapcomSock,
   filePath,
   shellProcessId,
   clientDetails,
   currentRequestBody,
   showResult,
   udbError,
   tpArgs,
   bpSuccess,
   numBreakpoints,
   breakpointList,
   wpSuccess,
   numWatchpoints,
   watchpointList,
   numScopes,
   scopesList
   )

   # Process a result from udb in table or list form.
   method processResult(res)
   local response
      write("udb -> udap: "||ximage(res["type"]))
      # write("udb -> udap:\n"|| ximage(res))
      \res | fail

      if type(res) == "table" then
         process_udb_output_table(res)
      else if type(res) == "list" then
         every resTable := !res do
            if type(resTable) == "table" then
               process_udb_output_table(res)
   end

   # Get the next command in cmdQueue.
   method getNextCommand()
      local request_body, request_seq, request_command, request_arguments, cmdElement, cmd, req

      repeat {
         if *cmdQueue ~= 0 then {
            cmdElement := pop(cmdQueue)
            write(ximage(cmdElement))
            currentRequestBody := cmdElement["request"]
            showResult := cmdElement["showResult"]
            cmd := cmdElement["command"]
            write("udb command: "||cmd||"\n")
            return cmd
         }
         every request_body := get_request(sock) do {
            write("command: "||jtou(request_body)["command"]||"\n")
            if \waitingForTerminal then {
                  if jtou(request_body)["command"] ~== "runInTerminal" then {
                     write("put "||jtou(request_body)["command"])
                     put(requestQueue, request_body)
                     write(ximage(requestQueue))
                     next
                  }
                  else {
                     waitingForTerminal := &null
                     process_request(request_body)
                     load_cmds()

                     while req := \pop(requestQueue) do {
                        process_request(req)
                     }
                  }
            }
            else {
               process_request(request_body)
            }
         }
      }
   end

   method put_cmdQueue(cmd, requestBody, hideResult)
   local cmdElement := table(), showResult
      cmdElement["command"] := cmd
      cmdElement["request"] := \requestBody
      if /hideResult then cmdElement["showResult"] := "__true__"
      put(cmdQueue, cmdElement)
   end

   method push_cmdQueue(cmd, requestBody, hideResult)
   local cmdElement := table(), showResult
      cmdElement["command"] := cmd
      cmdElement["request"] := \requestBody
      if /hideResult then cmdElement["showResult"] := "__true__"
      push(cmdQueue, cmdElement)
   end

   # Put commands necessary for loading target program into cmdQueue.
   method load_cmds()
      local dir, procs, cmd

      filePath ? {
         if dir := tab(findre("\/[^\/]+$")) then
            put_cmdQueue("dir args " || dir)
      }

      if procs := pathfind("udb") then {
         procs ? procs := tab(findre("unicon") + 6)
         procs ||:= "/ipl/procs"
         put_cmdQueue("dir args " || procs)
      }

      if \tpArgs then
         put_cmdQueue("load " || filePath || " " || tpArgs)
      else
         put_cmdQueue("load " || filePath)

    end

   # Given a DAP client request body, process that request.
   method process_request(request_json)
      local request_body, request_seq, request_command, request_arguments, response_body

      request_body := jtou(request_json)

      request_seq := request_body["seq"]
      request_command := request_body["command"]
      request_arguments := request_body["arguments"]
      response_body := request_body["body"]

      write("client -> udap: " || request_json||"\n")

      case request_command of {
         "initialize": { initialize(request_seq, request_command, request_arguments) }
         "launch" : { launch(request_seq, request_command, request_arguments) }
         "setBreakpoints" : { set_breakpoints(request_body, request_seq, request_command, request_arguments) }
         "setDataBreakpoints" : { set_watchpoints(request_body, request_seq, request_command, request_arguments) }
         "dataBreakpointInfo" : { watchpoint_info(request_body, request_seq, request_command, request_arguments)}
         "configurationDone" : { put_cmdQueue("run", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "threads" : { threads(request_seq, request_command, 1) }
         "continue" : { put_cmdQueue("cont", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "next" : { put_cmdQueue("next", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "stepIn" : { put_cmdQueue("step", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "stepOut" : { put_cmdQueue("return", request_body); if /udbError then acknowledge(request_seq, request_command) }
         "stackTrace" : { put_cmdQueue("bt", request_body, 1)}
         "scopes" : { put_cmdQueue("frame "||request_arguments["frameId"], request_body, 1);
                     every put_cmdQueue(![: "print -"||!"glsp" :], request_body, 1) }
         "variables" : { variables(request_body, request_seq, request_command, request_arguments) }
         "disconnect" : { acknowledge(request_seq, request_command); disconnect() }
         "runInTerminal" : { if member(response_body, "shellProcessId") then shellProcessId := response_body["shellProcessId"] }
         "evaluate" : { evaluate(request_body, request_seq, request_command, request_arguments) }
         default: { write("Don't know what to do with: ", request_command) }
      }
   end

   # Attempt to read messages from client given a socket and returns each message as a generator.
   method get_request(sock)
      local request_body, msg, len

      while /request_body | request_body == "" do {

         select(sock)

         msg := ready(sock)

         # Handling socket reading anomoly: header alone or header + request_body
         while msg ~== "" do {
            msg ? {
               tab(find("Content-Length:") + 16)
               len := integer(tab(many(&digits)))
               tab(upto("\r\n\r\n") + 4)
               if pos(0) then {
                  request_body := ready(sock, len)
               }
               else {
                  request_body := move(len)
                  msg := tab(0)
               }
            }
            suspend request_body
         }
      }
   end

   # Create and return a response for client in json format.
   method build_response(request_seq, success, request_command, body, message)
      local responseTable, responseBody, responseHeader

      responseTable := [
         "seq": seq;
         "type": "response";
         "request_seq": request_seq;
         "success": success;
         "command": request_command
      ]
      responseTable["message"] := \message
      responseTable["body"] := \body

      responseBody := tojson(responseTable) | tojson([
         "seq": seq;
         "type": "response";
         "request_seq": request_seq;
         "success": "__false__";
         "command": request_command;
         "message": "Failed to convert response to json."
         ])

      responseHeader := "Content-Length:" || *responseBody || "\r\n\r\n"

      write(ximage(responseTable))

      write("udap -> client: " || responseBody)

      seq +:= 1

      return responseHeader || responseBody
   end

   # Create and return a request for client in json format.
   method build_request(command, arguments)
      local requestTable, requestBody, requestHeader

      requestTable := [
         "seq": seq;
         "type": "request";
         "command": command
      ]
      requestTable["arguments"] := \arguments

      requestBody := tojson(requestTable)
      requestHeader := "Content-Length:" || *requestBody || "\r\n\r\n"

      write("udap -> client: " || requestBody)

      seq +:= 1

      return requestHeader || requestBody
   end

   # Create and return an event for client in json format.
   method build_event(event, body)
      local eventTable, eventBody, eventHeader

      eventTable := [
         "seq": seq;
         "type": "event";
         "event": event
      ]
      eventTable["body"] := \body

      eventBody := tojson(eventTable) | tojson([
         "seq": seq;
         "type": "event";
         "event": event
         ])
      eventHeader := "Content-Length:" || *eventBody || "\r\n\r\n"

      write("udap -> client: " || eventBody)

      seq +:= 1

      return eventHeader || eventBody
   end

   # Handles all the things required from a client "initialize" request.
   method initialize(request_seq, request_command, request_arguments)
      local capabilitiesTable, res, udbPort, startRes, event, req

      clientDetails := \request_arguments

      capabilitiesTable := [
         "supportsConfigurationDoneRequest": "__true__";
         # "supportsFunctionBreakpoints": "__true__";
         "supportsDataBreakpoints" : "__true__"
      ]

      res := build_response(request_seq, "__true__", request_command, capabilitiesTable)
      writes(sock, res)

      event := build_event("initialized")
      writes(sock, event)
   end

   # Handles all the things required from a client "launch" request.
   method launch(request_seq, request_command, request_arguments)
      local res, pth, event, dapPort

      pth := request_arguments["program"]
      pth ? {
         tab(match("^\"\\"))
         pth := tab(find(".icn"))
      }
      filePath := \pth | request_arguments["program"]

      if member(request_arguments, "args") then {
         tpArgs := request_arguments["args"]
      }

      dapPort := integer(port) + 10

      event := build_request("runInTerminal", [
         "kind": "integrated";
         "cwd": "";
         "title": "udbTerminal";
         "args": ["dapcom " || dapPort];
         "argsCanBeInterpretedByShell": "__true__"])
      writes(sock, event)
      waitingForTerminal := 1

      dapcomSock := open_sock(dapPort)

      if /dapcomSock then {
         res := build_response(request_seq, "__false__", request_command, &null, "udap failed to open dapcomSock: " || dapPort)
         writes(sock, res)
         return
      }

      res := build_response(request_seq, "__true__", request_command)
      writes(sock, res)
   end

   # Handles all the things required from a client "setBreakpoints" request.
   method set_breakpoints(request_body, request_seq, request_command, request_arguments)
      local pth, filename

      if member(request_arguments["source"], "path") then
         pth := request_arguments["source"]["path"]
      else {
         res := build_response(request_seq, "__false__", request_command, &null, "SetBreakpoints source.path not given.")
         writes(sock, res)
         return
      }

      pth ? {
         tab(findre("\/[^\/]+$"))
         move()
         filename := tab(0)
      }

      put_cmdQueue("clear break " || filename || " all", request_body, 1)
      numBreakpoints +:= 1

      if member(request_arguments, "breakpoints") then {
         every bp := !request_arguments["breakpoints"] do {
            put_cmdQueue("b " || filename || ":" || bp["line"], request_body)
            numBreakpoints +:= 1
         }
      }
      else if member(request_arguments, "lines") then {
         every line := !request_arguments["lines"] do {
            put_cmdQueue("b " || filename || ":" || line, request_body)
            numBreakpoints +:= 1
         }
      }
      else {
         res := build_response(request_seq, "__false__", request_command, &null, "SetBreakpoints breakpoints not specified")
         writes(sock, res)
         return
      }
   end

   method set_watchpoints(request_body, request_seq, request_command, request_arguments)
      watchpoints := request_arguments["breakpoints"]

      put_cmdQueue("clear watch", request_body, 1)
      numWatchpoints +:= 1

      every wp := !watchpoints do {
         if \wp["frameId"] then put_cmdQueue("frame "||wp["frameId"], 1)
         put_cmdQueue("vwatch "||wp["dataId"])
         numWatchpoints +:= 1
      }

   end

   method watchpoint_info(request_body, request_seq, request_command, request_arguments)
   local res, body
      write(ximage(request_body))

      body := [
         "dataId": request_arguments["name"]; # should be id that udb uses, not sure how that should be retrieved
         "description": "description here"
      ]

      res := build_response(request_seq, "__true__", request_command, body)
      writes(sock, res)
   end

   # Handles all the things required from a client "threads" request.
   method threads(request_seq, request_command)
      local res, threadsTable

      threadsTable := [
         "threads": [[
            "id": 1;
            "name": "main"
         ]]
      ]

      res := build_response(request_seq, "__true__", request_command, threadsTable)
      writes(sock, res)
   end

   method variables(request_body, request_seq, request_command, request_arguments)
   local ref
      ref := request_arguments["variablesReference"]
      write("ref requested:")
      write(ref)
      write(ximage(currStructuredVars))
      if ref < 5 then
         put_cmdQueue("print -" || "glsp"[request_arguments["variablesReference"]], request_body, 1)
      else {
         #put_cmdQueue("print "||currStructuredVars[ref]["name"], request_body, 1)
         # any ref passed by vscode has already been stored in currStructuredVars, so just process what's stored in there
         struct := currStructuredVars[ref]["value"]
         vars := []
         if type(struct) == ("list" | "table" )| match("record"|"object", image(struct)) then {
            every k := key(struct) do {
               val := struct[k]
               if type(val) == ("list" | "table" ) | match("record"|"object", image(struct)) then {
                  put(currStructuredVars, [
                     "name": image(val)
                     "value": val
                  ])
                  varRef := *currStructuredVars
               }
               else {
                  varRef := 0
               }
               put(vars, [
                  "name": replace("["||image(k)||"]", "\"", "\\\"")
                  "value": replace(image(val), "\"", "\\\"")
                  "type": type(val)
                  "variablesReference": varRef
               ])
            }
         }

         response := build_response(request_seq, "__true__", request_command, table("variables", vars))
         writes(sock, response)
      }
   end


   # Default response for request that only requires an acknowledgement.
   method acknowledge(request_seq, request_command)
      local res

      res := build_response(request_seq, "__true__", request_command)
      writes(sock, res)
   end

   # Given a udb output table as 'outputTable', process that table.
   # EVERYTHING that udb outputs should go through this method.
   method process_udb_output_table(outputTable)
      local udbRes := "", event, curCmd, body

      curCmd := (\currentRequestBody)["command"] | "none"

      udbRes := outputTable["consoleMsg"]

      /outputTable["type"] := "console"
      if not (outputTable["type"] == ("exited" | "stderr" | "crash" )) then {
         if outputTable["type"] == "breakpoint" then {
            event := build_event("stopped", [
               "reason": "breakpoint";
               "description": udbRes;
               "hitBreakpointIds": [outputTable["id"]];
               "threadId": 1])
            writes(sock, event)
         }
         else if outputTable["type"] == "step" then {
            event := build_event("stopped", [
               "reason": "step";
               "threadId": 1])
            writes(sock, event)
         }
         else if outputTable["type"] == "watchpoint" then {
            event := build_event("stopped", [
               "reason": "data breakpoint";
               "threadId": 1])
            writes(sock, event)
         }
         if \showResult & outputTable["type"] ~== "assignVar" then {
            body := [
               "category": "console";
               "output": udbRes]
            event := build_event("output", body)
            writes(sock, event)
         }
         case curCmd of {
            "setBreakpoints": processBreakpointResult(outputTable)
            "setDataBreakpoints": processWatchpointResult(outputTable)
            "stackTrace": processStackTraceResult(outputTable)
            "scopes": processScopesResult(outputTable)
            "variables": processVariablesResult(outputTable)
            "evaluate": processEvaluateResult(outputTable)
         }
      }
      else if outputTable["type"] == "stderr" then {
         event := build_event("output", [
            "category": "stderr";
            "output": udbRes])
         writes(sock, event)
         event := build_event("stopped", [
            "reason": "exception";
            "description": udbRes;
            "text": udbRes;
            "threadId": 1])
         writes(sock, event)
         cmdQueue := []
         # If error happened before execution even started, abort immediately
         if member(outputTable, "state") then {
            if outputTable["state"] = 0 then {
               event := build_event("terminated")
               writes(sock, event)
            }
         }
      }
      else if outputTable["type"] == "exited" then {
         event := build_event("exited", [
            "exitCode",
            outputTable["exitCode"]])
         writes(sock, event)
      }
      else if outputTable["type"] == "crash" then {
         handle_error(outputTable)
         return
      }
      if \outputTable["requireResponse"] then {
         event := build_event("output", [
            "category": "console";
            "output": "[answered Y; input not from terminal]\n"])
         writes(sock, event)
         push_cmdQueue("Y")
      }
   end

   method processBreakpointResult(res)
   local body
      if \res["success"] == "__false__" then {
         response := build_response(currentRequestBody["seq"], "__false__", currentRequestBody["command"])
         writes(sock, response)
         return
      }

      bpSuccess +:= 1
      if res["type"] == "setBreakpoint" then {
         bp := [
            "id": res["breakpoint"]["id"];
            "line": res["breakpoint"]["line"];
            "verified": "__true__";
            "source": [
               "path": filePath||".icn"
            ]
         ]
         push(breakpointList, bp)
      }
      if bpSuccess == numBreakpoints then {
         body := table("breakpoints", breakpointList)
         response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], body)
         writes(sock, response)

         bpSuccess := 0
         breakpointList := []
      }
   end

   method processWatchpointResult(res)
      if \res["success"] == "__false__" then {
         response := build_response(request_seq, "__false__", request_command)
         writes(sock, response)
         return
      }

      wpSuccess +:= 1
      if res["type"] == "addWatch" then {
         wp := [
            "reason": "new";
            "breakpoint": [
               "id": res["id"];
               "verified": "__true__";
               "source": [
                  "path": filePath||".icn"
               ]
            ]
         ]
         push(watchpointList, wp)
      }
      if wpSuccess == numWatchpoints then {
         body := table("breakpoints", watchpointList)
         response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], body)
         writes(sock, response)

         wpSuccess := 0
         watchpointList := []
      }
   end

   method processStackTraceResult(res)
      local response
      static frames := []

      if \res["success"] == "__false__" then {
         response := build_response(currentRequestBody["seq"], "__false__", currentRequestBody["command"])
         writes(sock, response)
         return
      }

      if member(res, "type") then {
         if res["type"] == "frame" then {
            res["name"] := replace(res["name"], "\"", "\\\"")
            put(frames, res)

            if *frames = res["levels"] then {
               response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], table("stackFrames", frames))
               writes(sock, response)
               frames := []
            }
         }
      }
   end

   method processScopesResult(res)
   local response
      if \res["success"] == "__false__" then {
         response := build_response(request_seq, "__false__", request_command)
         writes(sock, response)
         return
      }

      if member(res, "type") then {
         if member(res, "variables") then {
            numScopes +:= 1
            if res["type"] == "globals" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Globals", "variablesReference", 1))
            }
            if res["type"] == "locals" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Locals", "variablesReference", 2))
            }
            if res["type"] == "statics" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Statics", "variablesReference", 3))
            }
            if res["type"] == "params" & *res["variables"] > 0 then {
                  put(scopesList, table("name", "Parameters", "variablesReference", 4))
            }
         }
         else if res["type"] == "frame" then {
            if res["success"] == "__true__" then numScopes +:= 1
         }
      }
      if numScopes = 5 then {
         response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], table("scopes", scopesList))
         writes(sock, response)

         numScopes := 0
         scopesList := []
      }

   end

   method processVariablesResult(res)
   local response, variables, var, ref
      if \res["success"] == "__false__" then {
         response := build_response(request_seq, "__false__", request_command)
         writes(sock, response)
         return
      }

      ref := currentRequestBody["arguments"]["variablesReference"]

      if member(res, "type") then {
         if member(res, "variables") then {
            if res["type"] == "globals" | "locals" | "statics" | "params" then {
               variables := res["variables"]

               every var := !variables do {
                  if var["type"] == "table" then {
                     put(currStructuredVars, [
                        "value": var["value"]
                        "name": var["name"]
                     ])
                     var["variablesReference"] := *currStructuredVars
                  }
                  else {
                     var["variablesReference"] := 0
                  }
                  var["value"] := replace(image(var["value"]), "\"", "\\\"")
               }
            }
         }
         response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], table("variables", variables))
         writes(sock, response)
      }
   end

   method processEvaluateResult(res)
   local event, body, response, context, ref
      context := \(\currentRequestBody["arguments"])["context"]
      if \context == "repl" then {
         if res["type"] == "assignVar" then {
            if res["success"] == "__true__" then {
               body := [
                  "result": replace(image(res["result"]), "\"", "\\\"")
                  "type": replace((type(res["result"])), "\"", "\\\"")
                  "variablesReference": 0
               ]
               if type(res["result"]) == "table" then {
                  body["indexedVariables"] := *res["result"]
                  body["result"] := res
               }
               event := build_event("output", body)
               writes(sock, event)
               response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"])
               writes(sock, response)
            }
            else {
               write("assignVar unsuccessful")
            }
         }
         else if res["type"] == "setBreakpoint" then {
            if res["success"] == "__true__" then {
               body := [
                  "reason": "new";
                  "breakpoint": [
                     "id": res["breakpoint"]["id"];
                     "line": res["breakpoint"]["line"];
                     "verified": "__true__";
                     "source": [
                        "path": filePath||".icn"
                     ]
                  ]
               ]
               event := build_event("breakpoint", body)
               writes(sock, event)
            }
            else {
               write("setBreakpoint unsuccessful")
            }
         }
         else if res["type"] == "clearBreakpoint" then {
            if res["success"] == "__true__" then {
               body := [
                  "reason": "removed";
                  "breakpoint": [
                     "id": res["breakpoint"]["id"];
                     "line": res["breakpoint"]["line"];
                     "verified": "__true__";
                     "source": [
                        "path": filePath||".icn"
                     ]
                  ]
               ]
               event := build_event("breakpoint", body)
               writes(sock, event)
            }
            else {
               write("clearBreakpoint unsuccessful")
            }
         }
      }
      else if \context == "watch" then {
         write("***************watch context*******************")
         write(ximage(res))
         if res["type"] ~== "frame" then {
            if res["success"] == "__true__" then {
               if res["type"] == "table" then {
                  body := [
                     "result": image(res["result"])
                     # "variablesReference"
                  ]
               }
               else {
                  body := [
                     "result": replace(image(res["result"]), "\"", "\\\"")
                     "variablesReference": 0
                  ]
               }

               response := build_response(currentRequestBody["seq"], "__true__", currentRequestBody["command"], body)
               writes(sock, response)
            }
            else {
               # send failure response
            }
         }
      }
   end

   # method processUdbResult(res)
   #    if type(res) ~== "table" then {
   #       return ximage(res)
   #    }
   #    else {

   #    }
   # end

   # Handles all the things required from a client "evaluate" request.
   method evaluate(request_body, request_seq, request_command, request_arguments)
      local res, expression, result := "", isEvalExp
      if request_arguments["context"] == "repl" then {
         expression := request_arguments["expression"]
         expression ? {
            if tab(match("-exec ")) then {
               expression := tab()
               lastUdbCmd := expression
            }
            else if expression ~== "" then {
               expression := "p "||expression
            }
            else if \lastUdbCmd then {
               expression := lastUdbCmd
            }
         }

         if member(request_arguments, "frameId") then
            put_cmdQueue("frame "||request_arguments["frameId"], request_body, 1)
         put_cmdQueue(expression, request_body)
      }
      else if request_arguments["context"] == "watch" then {
         expression := "p "||request_arguments["expression"]
         put_cmdQueue("frame "||request_arguments["frameId"], &null, 1)
         put_cmdQueue(expression, request_body, 1)
      }
   end

   # Handle a udb output table of "type" set to "crash".
   method handle_error(outputTable)
      local errorText, errorMessageTable, res, event
      udbError := "__true__"

      errorText := "Unicon Debugger experienced an error during " || currentRequestBody["command"] || " request. "
      if \outputTable then {
         errorText ||:= "Error number: " || outputTable["errornumber"] || ". "
         if member(outputTable, "errortext") then errorText ||:= "Error text: " || outputTable["errortext"] || ". "
         if member(outputTable, "errorvalue") then errorText ||:= "Error value: " || outputTable["errorvalue"] || ". "
      }
      errorText ||:= "Closing Unicon Debugger."

      errorMessageTable := ["format": errorText; "showUser": "__true__"]
      if \outputTable then errorMessageTable["id"] := outputTable["errornumber"]
      else errorMessageTable["id"] := 0

      res := build_response(currentRequestBody["seq"], "__false__", currentRequestBody["command"], ["error": errorMessageTable])
      writes(sock, res)

      event := build_event("terminated")
      writes(sock, event)
   end

   # Disconnect from client and udb and startup as a fresh session.
   method disconnect()
      # Kill terminal running dapcom
      kill(\shellProcessId, 9)
      # End communication with client
      close(\sock)
      # Restart session
      put_cmdQueue("reset")
   end

   # Open a port as a server and block until client connect.
   # Returns communication medium or fails.
   method open_sock(port)
        local sock
        if /port then return "port not declared"
        port := (if &features == "MacOS" then "127.0.0.1" else "") || ":" || port

        every !5 do
            if sock := open(port, "na") then
                return sock
            else
                delay(1000)

        write("udap failed to open port: " || port)
    end

   # Attempt to open communication port for client and set default class parameters.
   method startup()
      local names := [: "-"||!"glsp" :], values := ["Globals", "Locals", "Statics", "Params"]
      sock := open_sock(port)
      if /sock then stop("failed to connect to ",port)

      seq := 1
      currStructuredVars := []
      every i := 1 to 4 do put(currStructuredVars, [
         "name": names[i]
         "value": values[i]
      ])
      udbError := &null
      showResult := &null
      lastUdbCmd := ""
      requestQueue := []
      cmdQueue := []
      numBreakpoints := 0
      breakpointList := []
      bpSuccess := 0
      numWatchpoints := 0
      watchpointsList := []
      wpSuccess := 0
      scopesList := []
      numScopes := 0
   end

   initially
      startup()
end
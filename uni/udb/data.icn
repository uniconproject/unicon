
#
# data.icn
# Handles the print debugging faclities found in debuggers such as GDB
# Author  : Ziad Al-Sharif
# Date    : Feb 24, 2008
#

$include "evdefs.icn"
$include "defaults.icn"

#
# This class contains the classical/standard debugging techniqies
#
class Data(
   DState,   # (Alias) object of type State class
   Keywords, # a set of all Unicon's valid keyword
   GKeywords,# a set of all Unicon's keywords that are Global/General
   Message   # a string formated with the current message
   )

#
# prints out all of the Global Variables state in some level
#
method printGlobals(level)
   local x, i
        
   /level := DState.cur_Frame # 0 if no up/down involved
   
   Message := ""
   every x := !DState.srcCode.vglobals do{
      i := variable(x, Monitored, level)
      Message ||:= "\n   "||x||" = "||image(i)||" : "|| type(i)
   }
   DState.Write(Message)
end

#
# prints out all of the Local Variables for some Level  
#
method printLocals(level)
   local x, i

   /level := DState.cur_Frame # 0 if no up/down involved

   Message := ""
   every x := localnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n   "||x||" = "||image(i)||" : "|| type(i)
   }
   DState.Write(Message)
end

#
# prints out all of the Formal Parameters for some Level  
#
method printParams(level)
   local x, i

   /level := DState.cur_Frame # 0 if no up/down involved

   Message := ""
   every x := paramnames(Monitored,level) do{
      i := variable(x, Monitored, level)
      Message ||:= "\n   "||x||" = "||image(i)||" : "|| type(i)
   }
   DState.Write(Message)
end

#
# returns the expression value or fails
# used by cmdPrint() and assignVar()  
#
method getVarValue(expr, level)
   local Value, ref, var, Var, index:=[]

   index := parsePrintExpression(expr)
   if *index = 0 then fail

   var := get(index)
   if Var := variable(var, Monitored, level) then{
      if (ref := getVarReference(Var, index, level)) & *index = 0 then{
         Value := if integer(ref) = ref then integer(ref) 
                  else if real(ref) = ref then real(ref)
                  else ref
         return Value
         }
      else fail 
      }
   else{
      if *index = 0 then{
         Value := if integer(expr) = expr then integer(expr) 
                  else if real(expr) = expr then real(expr)
                  else string(expr)
         return Value
         }
      else fail 
      } 
   return Value
end


#
# getVarReference is used by printVar and cmdPrint to 
# get a reference for an element of a structure
#
method getVarReference(Var, index, level)
   local v, j, i1, i2, x, fld

   if *index = 0 then return Var

   case type(Var) of{
      "integer"|"real"|"null"|"cset"|"set"|"file"|"window"|
      "procedure"|"co-expression"|"external":{
           return Var
           }
      "string":{
           x := get(index)
           if j := find(":",x) then{
              i1 := integer(x[1:j])
              i2 := integer(x[j+1:0])
              Var := Var[i1:i2]
              return Var
              }
           else if v := variable(x, Monitored, level, 1) | integer(x) then{
              Var := Var[v]
              return Var
              }
           fail
           }
      "list":{
           x := get(index)
           if v := variable(x, Monitored, level, 1) | integer(x) then{
              if type(v) == "integer" & member(Var, v) then{
                 Var := Var[v]
                 return getVarReference(Var, index, level)
                 }
              }
           fail
           }
      "table":{
           x := get(index)
           if v := variable(x, Monitored, level, 1) |
                                      integer(x) | string(x[2:-1]) then{
              if member(Var, v) then{
                 Var := Var[v]
                 return getVarReference(Var, index, level)
                 }
               } 
           fail
           }
      # "record" & "object" do not have the word "record" in their type
      default:{
           x := get(index)
           every fld := fieldnames(Var) do{
              if x === fld then{
                 Var := Var[string(x)]
                 return getVarReference(Var, index, level)
                 }
              }
           fail
           }
      }
end

#
# setVarReference is used by assignVar() and cmdPrint()
# to assign a value to any variable or element of a structure
#
method setVarReference(lvar, index, level, value)
   local v, j, i1, i2, x, fld, Var

   DState.Write("value = ",value)

   if *index = 0 then{
      if variable(lvar, Monitored, level) then{
         variable(lvar, Monitored, level, 1) := value
         return
         }
      else fail
      } 
   
   Var := variable(lvar, Monitored, level, 1)
   if \Var then{
      if *index ~= 0 then{
      while *index > 0 do{
      x := get(index)
      case type(Var) of{
        "integer"|"real"|"null"|"cset"|"set"|"file"|"window"|
        "procedure"|"co-expression"|"external":{
           if *index = 0 then{
              #variable(lvar, Monitored, level, 1) := value 
              Var := value
              return 
              } 
           else fail
           }
        "string":{
           if *index = 0 then{
              if j := find(":",x) then{
                 # what if either of i1 or i2 were variables??
                 i1 := integer(x[1:j])
                 i2 := integer(x[j+1:0])
                 variable(lvar, Monitored, level, 1) := 
                          Var[1:i1]|| string(value) ||Var[i2:0]
                 }
              else if v := variable(x, Monitored, level, 1) | integer(x) then{
                    variable(lvar, Monitored, level, 1) := 
                             Var[1:v]||string(value) || Var[v+1:0]
                 } 
              return
              }
           else{
              fail
              }
           }
        "list":{
           if v := variable(x, Monitored, level, 1) | integer(x) then{
              if type(v) == "integer" & member(Var, v) then{
                 if *index = 0 then{
                    Var[v] := value
                    return
                    } 
                 else Var := Var[v]
                 }
              else fail
              }
           else fail
           }
        "table":{
           if v := variable(x, Monitored, level, 1) |
                                      integer(x) | string(x[2:-1]) then{
              if member(Var, v) then{
                 if *index = 0 then{
                    Var[v] := value
                    return
                    }
                 else Var := Var[v]
                 }
              else fail
              } 
           else fail
           }
        # "record" & "object" do not have the word "record" in their type
        default:{
           every fld := fieldnames(Var) do{
              if x === fld then{
                 if *index = 0 then{
                    Var[string(x)]:= value
                    return 
                    }
                 else{
                    Var := Var[string(x)]
                    break
                    } 
                 }
              }#end every 
           }#end default 
      }#end case
      }#end while
      }#end if *index ~= 0 then
      else{
         variable(lvar, Monitored, level, 1) := value
         DState.Write("hmmmm!!!!")
         return
         }
      }
   else fail
end

#
# finds the var reference and prints its value acording
# to the action such as */! or the value itself
#
method printVar(expr, level)
   local Var, var, index
   local x, j, action, ref

   if j:=find("*"|"!",expr) then{
      action := expr[j]
      expr := expr[j+1:0]
      }

   index := parsePrintExpression(expr)
   if *index = 0 then{
      Message :="\n   \""||expr||"\" is Unkown Expression !!!"
      DState.Write(Message)
      return
      }
   
   var := get(index)
   if Var := variable(var, Monitored, level) then
      if (ref := getVarReference(Var, index, level)) & *index = 0 then{
         Message := "\n   " || expr || " = "
         case action of{
            "*" :{ Message ||:= *ref }
            "!" :{ Message ||:="{ "
                   every x := !ref do
                      Message ||:= image(x)||", "
                   Message:=Message[1:-2] || " }"
                 }
             default:{
                 #DState.Write("---type of ",expr," is : ", type(ref))
                 if (type(ref) == ("list" | "table" | "set" | "foreign-local" )|
                     find("record",image(ref))) & *ref >= 1 then
                        Message ||:= ximage(ref)
                 else{
                        Message ||:= image(ref)
                        #Message ||:= "\n   ..................!"
                     }
                 }
             }
         }
      else Message :="\n   \""||expr||"\" is Unkown Expression !!!"
   else Message := "\n   The variable \""|| var ||
                   "\" is not within the current frame"
   DState.Write(Message)
end

#
# changes the var value according to the user input
#
method assignVar(expr, level)
   local j, lexpr, rexpr, lhs, lvar , rvalue

   if j := find(":=", expr) then{
       lexpr := expr[1:j]
       rexpr := expr[j+2:0]
       }
   else if j := find("=", expr) then{
       lexpr := expr[1:j]
       rexpr := expr[j+1:0]
       }

   lhs := parsePrintExpression(lexpr)
   if *lhs = 0 then{
      Message :="\n   The expression \""||expr||"\" is Unkown !!!"
      DState.Write(Message)
      return
      }

   if rvalue := getVarValue(rexpr, level) then{
      lvar := get(lhs)
      if setVarReference(lvar, lhs, level, rvalue) then
         Message :="\n   Assigning \""||lexpr||"\" with \""||
                    rexpr||"\" has been succeeded"
      else
         Message :="\n   Assigning \""||lexpr||"\" with \""||
                    rexpr||"\" has been failed"
      }
   else 
      Message := "\n   The RHS expr \""||rexpr||"\" is Unknown !!!"

   DState.Write(Message)
end

#
# Prints out a variable and it's current value. Variables from previous
# procedures that are still in the stack can also be viewed.
#
method cmdPrint(cmd)
   local level, expr, i

   if DState.State ~= PAUSE then{
      DState.State := ERROR
      Message := "\n   The program is not being run._
                  \n   Try \"run\", or Type \"help\" for assistance"
      DState.Write(Message)
      return
      }

   if cmd[3] then  level := integer(cmd[3]) | 0 
   else            level := DState.cur_Frame 
      
   if \cmd[2] & expr := cmd[2] then{
      if expr == ("-g" |"-G" | "-globals") then{
         printGlobals()
         return
         }
      else if expr == ("-l" | "-L" | "-locals") then{
         printLocals()
         return
         }
      else if expr == ("-p" | "-P" | "-params") then{
         printParams()
         return
         }
      else if i := find("&", expr) then{ # keywords
         handleKeyword(expr, i, level)
         }
      else
         if find("=", expr) then assignVar(expr, level)
         else                    printVar(expr, level)
      }
   else{
      #printFrame(level)
      write("OPSSSSS")
      #Message := ""
      }
end

#
# handles keywords in the print expression
#
method handleKeyword(expr, i, level)
   local lexpr, rexpr, data, j

   if j := find(":=",expr) then{ # p &pos:=10
      lexpr := expr[i:j]
      rexpr := expr[j+2:0]
      if isValidKeyword(lexpr[2:0]) then{
         data := getVarValue(rexpr,level)
         variable(lexpr, Monitored, 0, 1) := data 
         return
         }
      else{
         Message := "\n   "||lexpr ||" : is not a valid keyword."
         DState.Write(Message)
         fail 
         }
      }
   else if j := find("=", expr) then{ # p &pos=10
      lexpr := expr[i:j]
      rexpr := expr[j+1:0]
      if isValidKeyword(lexpr[2:0]) then{
         data := getVarValue(rexpr,level)
         variable(lexpr, Monitored, 0, 1) := data
         return
         }
      else{
         Message := "\n   "||lexpr ||" : is not a valid keyword."
         DState.Write(Message)
         fail 
         }
      }
   else{ # p &pos or p *&subject
      if isValidKeyword(expr[i+1:0]) then{
         if data := isGlobalKeyword(expr[i+1:0]) then{
              Message :="\n   "|| expr ||" = "|| data
              DState.Write(Message)
              return
              }
         else if data := keyword(expr[i:0], Monitored) then{
            if find("*",expr) then
               data := *data
            else if not (type(data) == ("string"|"integer"|"real")) then
               data := image(data)
            Message :="\n   "|| expr ||" = "|| data
            DState.Write(Message)
            return
            }
         else{
            Message :="\n   "|| expr || " : is not a valid operation yet !!!."
            DState.Write(Message)
            fail 
            }
         }
      else{
         Message :="\n   "|| expr || " : is not a valid keyword."
         DState.Write(Message)
         fail 
         }
      }
end

#
# check whether keyword is valid or not  
#
method isValidKeyword(expr)

   if member(Keywords, expr) then 
      return 
   fail
end

#
# check whether a keyword is not suppoted by the keyword() function
# and return its value or list of valuses  
#
method isGlobalKeyword(expr)
   local x, data

   if member(GKeywords, expr) then{
      case expr of{
        "features":{
            data:=""
            every x := &features do data ||:="\n      "|| x
            return data
            }
         "clock":   { return data := &clock       }
         "date":    { return data := &date        }
         "now":     { return data := &now         }
         "dateline":{ return data := &dateline    }
         "digits":  { return data := &digits      }
         "e":       { return data := &e           }
         "fail":    { return data := "&fail"      }
         "host":    { return data := &host        }
         "lcase":   { return data := &lcase       }
         "letters": { return data := &letters     }
         "null":    { return data := image(&null) }
         "phi":     { return data := &phi         }
         "pi":      { return data := &pi          }
         "dump":    { return data := &dump        }
         "ucase":   { return data := &ucase       }
         "version": { return data := &version     }
         "lpress":  { return data := &lpress      }
         "mpress":  { return data := &mpress      }
         "rpress":  { return data := &rpress      }
         "lrelease":{ return data := &lrelease    }
         "mrelease":{ return data := &mrelease    }
         "rrelease":{ return data := &rrelease    }
         "ldrag":   { return data := &ldrag       }
         "mdrag":   { return data := &mdrag       }
         "rdrag":   { return data := &rdrag       }
         "resize":  { return data := &resize      }
         "ascii":   { return data := &ascii       }
         "cset":    { return data := &cset        }
         default:   { fail }
         }
      }
   fail
end

#
# parse the expression into tokens, mainVar is tokens[1]
# ie L[2], L[3][4], L[1].x, S[5:-5]
#
method parsePrintExpression(expr)
   local x, old_x, j, valid_char, tokens := []
   
   valid_char := CHARACTER ++ cset('-_:\"') 
   
   expr ? {
        if x := tab(many(valid_char)) then{
           put(tokens, x)
           while (j := move(1)) ==("["|"]"|"."|",") do{
               if j == "." & old_x := integer(x) then{
                 if x := tab(many(valid_char)) then{
                    if integer(x) then{
                       old_x := pop(tokens)
                       old_x ||:="."||x
                       put(tokens, old_x)
                       old_x := &null
                       }
                    else 
                       put(tokens,x)
                    } 
                 }
              else if x := tab(many(valid_char)) then
                    put(tokens,x)
              }
           } 
        }

#   every x:=!tokens do
#      write("-----x=",x)
   return tokens
end

#
# used by cmdList to print a bunch of src lines
#
method printSrcLines(cur_file, cur_line, offset)
   local i, line, max_line

   /offset := 10
   max_line := DState.srcFile.getFileTotalLines(cur_file)

   if cur_line <= 5 then
      line := 1
   else if cur_line <= max_line then
      line := cur_line - 5
   else if cur_line > max_line then{
      Message := "\n   Line number "||cur_line||" out of range; "||
                  cur_file||" has "||max_line||" lines."
      DState.Write(Message)
      fail
      }

   Message :="" 
   every i:= 1 to offset do{
      if line = cur_line then
         Message ||:="\n-->"||line ||":"||
                     DState.srcFile.getSrcLine(cur_file, line)
      else
         Message ||:="\n   "||line ||":"||
                     DState.srcFile.getSrcLine(cur_file, line)
      line +:= 1
      }
   DState.Write(Message)
end

#
# The list command from gdb, as in gdb defaults are 10 lines from
# the current file are printed centered around the curent line 
#
method cmdList(cmd)
   static cur_line, cur_file, max_line
   local name, line
   
   if DState.RunCode ~= LIST then{
      DState.RunCode := LIST
      if DState.State = LOAD then{
         cur_file := DState.srcFile.procMainFile
         cur_line := DState.srcFile.procMainLine
         max_line := DState.srcFile.getFileTotalLines(cur_file)
         } 
      else if DState.State = PAUSE then{
         cur_file := keyword("file", Monitored)
         cur_line := keyword("line", Monitored)
         max_line := DState.srcFile.getFileTotalLines(cur_file)
         }
      else{
         DState.RunCode := DState.State := ERROR
         Message := "\n   No Program is Loaded nor Running_
                     \n   Type \"help\" for assistance"
         DState.Write(Message)
         return
         }
      }
   else if *cmd = 1 then{
      if (cur_line + 10) < max_line then  cur_line +:= 10
      else if cur_line < max_line   then  cur_line := max_line
      else if cur_line = max_line   then  cur_line := max_line + 1
      }

   if *cmd >= 2 then{
      if line := integer(cmd[2]) then{
         if line > 0 then 
            cur_line := line
         else if line < 0 then{
            cur_line := max_line + line
            }
         }
      else if cmd[2] == "+" then{
         if (cur_line + 10) < max_line then  cur_line +:= 10
         else if cur_line < max_line   then  cur_line := max_line
         else if cur_line = max_line   then  cur_line := max_line + 1
         }
      else if cmd[2] == "-" then{
         if (cur_line - 10) >= 1 then  cur_line -:= 10
         else                          cur_line := 1
         }
      else{
         name := cmd[2]
         if line := DState.srcFile.searchFileProcs(cur_file, name) then{
            cur_line := line
            }
         else{
            name ||:=".icn"          
            if DState.srcFile.isSrcFile(name) then{
               cur_file := name
               max_line := DState.srcFile.getFileTotalLines(cur_file)
               if *cmd = 2 then
                  cur_line := 1
               else if line := integer(cmd[3]) then{
                  if line > 0 then
                     cur_line := line
                  else if line < 0 then
                     cur_line := max_line
                  }
               }
            else{
               DState.RunCode := DState.State := ERROR
               Message  := "\n   "||name||" is not a source file in: \""||
                           DState.TP[1]||"\"."
               Message||:= "\n   Try \"src\", or Type \"help\" for assistance."
               DState.Write(Message)
               return
               } 
            }
         }
      }

   if DState.srcFile.isLoaded(cur_file) then{
      printSrcLines(cur_file, cur_line)
      }
   else{
      Message := "\n   Source File \""||cur_file||"\" is NOT loaded !!!"
      DState.Write(Message)
      }
end

#
# used to print the name of the file names, it print 10 at a time
#
method printFileNames(fnames, ftype)
   local i:=0, cur:=0, ans, total

   total := *fnames
   Message := "\n   Total of "||total||"-"||ftype||":\n"
   while *fnames > 0 do{
     i +:= 1
     Message ||:= "   "||(cur+:=1)||"# "||get(fnames) ||"\n"
     if i = 10 & *fnames ~= 0 then{
        Message ||:="   (["||total-cur||"] More file names follow...)\n"
        Message ||:="---Type <return> to continue, or q <return> to quit---"
        DState.Writes(Message)
        if *(ans:=read())~=0 & ans[1]==("q"|"Q") then break
        Message := "\n"
        i := 0
        }
     else if *fnames = 0 then
        DState.Writes(Message)
     }
end

#
# used to print a summery of all used files 
#
method printSrcSummery(detail)
   local found, missing, ftotal

   found   := *DState.srcFile.foundFiles
   missing := *DState.srcFile.missingFiles
   ftotal  := found + missing
   Message   :="\n   A total of ["||ftotal||"] source files are used"
   Message ||:="\n   "||left(found,5)  ||"source files are found"
   Message ||:="\n   "||left(missing,5)||"source files are missing"
   if \detail then{   
      Message ||:="\n   ---------------------------------------"
      Message ||:="\n   "||left(*DState.srcCode.packages,5)||"packages, with "||
              DState.srcCode.getTotalPackageClasses() ||" classes, "||
              DState.srcCode.getTotalPackageProcs()   ||" procedures, and "||
              DState.srcCode.getTotalPackageVars()    ||" global variables."
      Message ||:="\n   "||left(*DState.srcCode.classes,5) ||"classes"
      Message ||:="\n   "||left(*DState.srcCode.records,5) ||"records"
      Message ||:="\n   "||left(*DState.srcCode.pglobals,5)||"procedures"
      Message ||:="\n   "||left(*DState.srcCode.fglobals,5)||"functions"
      Message ||:="\n   "||left(*DState.srcCode.pglobals,5)||"global variables"
      }
   Message ||:="\n   Type \"help src\" for assistance.\n"
   DState.Writes(Message)
end

#
# prints the found/missing source files
#
method cmdSource(cmd)
   local op, names, found, missing

   # src fname
   if cmd[3] then{
      Message := DState.srcFile.getSrcCode(cmd[3])
      DState.Write(Message)
      return
      }

   op := cmd[2] | ""
   case op of{
      "-f"|"-found":{
          if names := DState.srcFile.getFoundFiles() then
             printFileNames(names,"Found Source Files")
          else
             DState.Write("\n   No found source file(s) !!")
          }
      "-m"|"-missing":{
          if names := DState.srcFile.getMissingFiles() then
             printFileNames(names,"Missing Source Files")
          else
            DState.Write("\n   No missing source file(s) !!")
          }
      "-file":{
          if names := DState.srcFile.getSourceFiles() then
             printFileNames(names,"Used source files:")
          else
            DState.Write("\n   No missing source file(s) !!")
          }
      "-pkg"|"-pk"|"-package":{
          if names := DState.srcCode.getPackages() then
             printFileNames(names,"Used packages:")
          else
            DState.Write("\n   No packages used !!")
          }
      "-c"|"-cls"|"-class":{
          if names := DState.srcCode.getClasses() then
             printFileNames(names,"Used no package classes:")
          else
            DState.Write("\n   No classes used !!")
          }
      "-p"|"-proc"|"-procedure":{
          if names := DState.srcCode.getProcedures() then
             printFileNames(names,"Used procedures:")
          else
            DState.Write("\n   No procedures used !!")
          }
      "-g"|"-glb"|"-global":{
          if names := DState.srcCode.getGlobals() then
             printFileNames(names,"Used global variables:")
          else
            DState.Write("\n   No global variables used !!")
          }
      "-r"|"-rec"|"-record":{
          if names := DState.srcCode.getRecords() then
             printFileNames(names,"Used records:")
          else
            DState.Write("\n   No global records used !!")
          }
      "-a"|"-all":{
          printSrcSummery(1)
          }
      default:{
          printSrcSummery()
          } 
      }
end

#
# Initialization
#
initially()

   Keywords := 
      set("allocated","clock","collections","column","current",
          "date","now","dateline","digits","e","error",
          "errornumber","errortext","errorvalue","errout","fail",
          "eventcode","eventsource","eventvalue","features",
          "file","host","input","lcase","letters","level",
          "line","main","null","output","phi","pi","pos",
          "progname","random","regions","source","storage",
          "subject","time","trace","dump","ucase","version",
          "errno","window","col","row","x","y","interval",
          "control","shift","meta","lpress","mpress","rpress",
          "lrelease","mrelease","rrelease","ldrag","mdrag",
          "rdrag","resize","ascii","cset"
          )
   GKeywords := 
      set("clock","date","now","dateline","digits","e","fail",
          "features","host","lcase","letters","null","phi","pi",
          "dump","ucase","version","lpress","mpress","rpress",
          "lrelease","mrelease","rrelease","ldrag","mdrag","rdrag",
          "resize","ascii","cset"
          )
   Message := ""
end

 

#
# session.icn
# Handles the main debugging session properties such as initialization
# Author : Ziad Al-Sharif
# Date   : Feb 24, 2008 
#


$include "evdefs.icn"
$include "defaults.icn"

#
# This class is used to handle the current debugging state 
#
class Session(
   DState,       # an object of the class State()
   Message,      # the formatted output message
   Debug         # An object of the class Evaluator() 
   )

#
# Here where the udb Session starts on
#
method startSession()
   local arg

   #-- it may need to be in EvInit() for the sake of re-run
   &eventsource := &null

   EvInit(DState.TP) | stop("cant start evinit on " || DState.TP[1])
   Message :="   Starting program: "
   every arg := !DState.TP do Message ||:=" "||arg
   Message ||:="\n"
   DState.Write(Message)

   DState.srcCode.analyzeGlobalNames()

   if DState.State = RUN  then {
      # a generator that ends when TP is over and no more events out of it.
      # every udb_evalTree(eventMask, activation_record) do{
      every Debug.startEvaluator() do{
         if DState.State = PAUSE then{
            # suspends the loop and go back to udb_Console() for a new cmd.
            suspend
            }
         if DState.State = END then{
            # The program exit normally
            break
            }
      }#end every 
   }

  DState.State := END
  Message := "\n   "||DState.TP[1]||" program exited normally."
  DState.Write(Message)
  return
end

#
# Parse a command
#
method parse_Command(cmd)

   case cmd[1] of{
     #-The start of the standard debugging commands
     "load"   :{  cmdLoad(cmd)                 }
     "r"      |
     "run"    :{  cmdRun(cmd)                  }
     "q"      |
     "quit"   :{  cmdQuit()                    }
     "p"      |
     "print"  :{  cmdPrint(cmd)                }
     "b"      |
     "break"  :{  Debug.Break.cmdBreak(cmd)    }
     "watch"  :{  Debug.Watch.cmdWatch(cmd)    }
     "s"      |
     "step"   :{  Debug.Step.cmdStep(cmd)      }
     "n"      |
     "next"   :{  Debug.Step.cmdNext(cmd)      }
     "f"      |
     "frame"  :{  Debug.Frame.cmdFrame(cmd)    }
     "up"     :{  Debug.Frame.cmdUp()          }
     "down"   :{  Debug.Frame.cmdDown()        }
     "?"      |
     "h"      |
     "help"   :{  cmdHelp(cmd)                 }
     "c"      |
     "cont"   :{  Debug.Step.cmdContinue()     }
     "w"      |
     "where"  |
     "bt"     :{  Debug.Frame.cmdBacktrace(cmd)}
     "l"      |
     "list"   :{  Debug.Print.cmdList(cmd)     }
     "clear"  :{  Debug.Break.cmdClear(cmd)    }
     #-cmds that are not in GDB
     "src"    :{  Debug.Print.cmdSource(cmd)            }
     "trace"  :{  Debug.Trace.cmdTrace(cmd)             }
     "enable" :{  cmdEnable(cmd)                        }
     "disable":{  cmdDisable(cmd)                       }
     "info"   :{  cmdInfo(cmd)                          }
     "analyze":{  Debug.Internal.cmdAnalyzeInfo(cmd[3]) }
     #-new set of commands for the UDB config script 
     "loadscript" :{ }
     "runscript"  :{ }
     default  :{   
        # anything else
        DState.State := ERROR
        Message   := "\n   Undefined Command: \""|| cmd[1] ||"\"" ||
                     "\n   Try \"help\" for assistance."
        DState.Write(Message)
     }
   }
end

#
# Loads a file after running the UDB Session 
# or loads an external monitor: load -external name
#
method cmdLoad(cmd)
   
   if cmd[2][1] == "-" then{
      #load -external name
      if find("external", cmd[2]) & \cmd[3] then
         Debug.External.cmdLoad(cmd[3])
      #load -semi-internal name 
      else if find("semi-internal", cmd[2]) & \cmd[3] then
         Debug.SemiInternal.cmdLoad(cmd[3])
      else{
         DState.State := ERROR
         Message := "\n   Undefined Command: \""|| cmd[1] ||" "||cmd[2]||"\""||
                    "\n   Try \"help\" for assistance."
         DState.Write(Message)
         }
      }
   else
      DState.initializeState(cmd[2:0])
end

#
# Runs the pre-loaded file, it can be used to re-run the program again
#
method cmdRun(cmd)
   local i, ans, args:=[]
   
   if *cmd >= 2 then{
      if DState.State = (LOAD | PAUSE | END) then{
         put(args, DState.TP[1])
         every i:=2 to *cmd do
            put(args, cmd[i])
         DState.TP := args
         }
      }
   
   if DState.State = (LOAD | END | PAUSE) then{ 
      if DState.State = PAUSE then{
         Message  :="\n   The program being debugged has been started already."
         Message||:="\n   Start it from the beginning? (Y/n)?: "
         DState.Writes(Message)
         if *(ans:=read())=0 | not(ans[1] == ("n"|"N")) then
            DState.Update(RERUN)
         else{
            DState.State := SKIP
            return
            }
         } 
      else  
         DState.Update(RUN)
      }
   else{
      DState.State := ERROR
      Message   := "\n   No program to RUN, load program first_
                    \n   Type \"help\" for assistance"
      DState.Write(Message)
   }
end

#
# Allows you to quit the program.
#
method cmdQuit()
   local ans

   # check whether a program is running or not, Paused, etc??????
   # do not exit directlly if the program is in the running state
   if DState.State = (RUN | PAUSE) then{
      DState.Writes("\n   The program is running.  Exit anyway (Y/n)?: ")
      if *(ans:=read())=0 | ans[1] == ("y"|"Y") then
         DState.State := QUIT
      else
         DState.State := SKIP
      }
   else
      DState.State := QUIT
end

#
# Enables some debugging commands
#
method cmdPrint(cmd)

   case cmd[2] of{
      "-internal": { Debug.Internal.cmdPrintInfo(cmd[3])   }
      default:     { Debug.Print.cmdPrint(cmd)             }
      }
end

#
# Enables some debugging commands
#
method cmdEnable(cmd)

   case cmd[2] of{
      "-trace"   : { Debug.Trace.cmdEnableTraceVar(cmd) }
      "-internal": { Debug.Internal.cmdEnable(cmd[3])   }
      "-external": { Debug.External.cmdEnable(cmd[3])   }
      default: {
          DState.Write("\n   OPS, do not know what to enable ?_
                        \n   Type \"help\" for assistance ")
          }
      }
end

#
# Disables some debugging commands
#
method cmdDisable(cmd)

   case cmd[2] of{
      "-trace "  : { Debug.Trace.cmdDisableTraceVar(cmd) }
      "-internal": { Debug.Internal.cmdDisable(cmd[3])   }
      "-external": { Debug.External.cmdDisable(cmd[3])   }
      default: {
          DState.Write("\n   OPS, do not know what to disable ?_
                        \n   Type \"help\" for assistance")
          }
      }
end

#
# Finds out information about some of the debugging commands
#
method cmdInfo(cmd)

   case cmd[2] of{
      "-trace"   : { Debug.Trace.cmdTraceInfo(cmd)   }
      "-internal": { Debug.Internal.cmdInfo(cmd[3])  }
      "-external": { Debug.External.cmdInfo(cmd[3])  }
      default: {
          DState.Write("\n   OPS, do not know what to find info for ?_
                        \n   Type \"help\" for assistance")
          }
      }
end

#         
# General Help Command
#
method cmdHelp(cmd)

   #write("This is command " || cmd[1])
   if *cmd = 1 then {
   case DState.State of {
    NONE | LOAD | END:{
      Message:="_
      \n   Applicable Commands are:_
      \n   load  : loads a new program into udb_
      \n   run   : runs the pre-loaded program under udb_
      \n   break : sets a breakpoint in the source code_
      \n   clear : deletes an existing breakpoint_
      \n   trace : to trace some of the program behaviors_
      \n   list  : prints out lines of the source code_
      \n   src   : prints out a list of the source files_
      \n   quit  : quits the current UDB Session_
      \n   help cmd : shows more info about a specific command"
      }
    PAUSE:{
      Message:="_
      \n   Applicable Commands are:_
      \n   cont  : continue on a full speed execution after a PAUSE_
      \n   step  : stepping one or more lines in the source code_
      \n   next  : same as step command except treating a_
      \n           procedure call as one command or one line of code_
      \n   load  : loads a new program into udb_
      \n   run   : restarts the execution from the begining_
      \n   where : shows the current location info_
      \n   frame : shows the current stack frame info_
      \n   up    : moves up one or more stack frame_
      \n   down  : moves down one or more stack frame_
      \n   print : prints out the value of a var in current frame_
      \n   bt    : prints out the back trace_
      \n   break : sets a breakpoint in the source code_
      \n   clear : deletes an existing breakpoint_
      \n   trace : to trace some of the program behaviors_
      \n   list  : to print out lines of the source code_
      \n   src   : prints out a list of the source files_
      \n   quit  : quits the current UDB Session_
      \n   help cmd : shows more info about a specific command"
      }
    ERROR:{
      Message:="_
      \n   Applicable Commands are:_
      \n   where : shows the current location info_
      \n   bt    : prints out the back trace_
      \n   print : prints out the value of a var in current frame_
      \n   load  : loads a new program into udb_
      \n   run   : restarts the execution from the begining_
      \n   break : sets a breakpoint in the source code_
      \n   clear : deletes an existing breakpoint_
      \n   trace : to trace some of the program behaviors_
      \n   list  : to print out lines of the source code_
      \n   src   : prints out a list of the source files_
      \n   quit  : quits the current UDB Session_
      \n   help cmd : shows more info about a specific command"
      }
   }# end of case   
   }
   else{
   case cmd[2] of {
    "load":{
      Message:="_
      \n   Loads a program into UDB. Use: \"load program\"_
      \n   load p     : loads program (p)_
      \n   load p arg : loads program (p) with argument (arg)"
      }
    "step":{
      Message:="_
      \n   Steps into the next line in the source code_
      \n   step   : steps one line_
      \n   step n : steps (n) lines"
      }
    "run":{
      Message:="_
      \n   Starts (or restarts) program execution_
      \n   run      : runs current loaded program_
      \n   run args : args list passed to program"
      }
    "next":{
      Message:="_
      \n   next steps to next line even on function calls_
      \n   treats function call as only one operation_
      \n   next   : steps one line_
      \n   next n : steps (n) lines"
      }
    "frame":{
      Message:="_
      \n   Prints out the Stack Frame info_
      \n   frame   : prints current stack frame info_
      \n   frame n : prints info about stack frame number (n)_
      \n             n=0 current frame, oldest frame has the bigest number_
      \n   look for \"help up\" and \"help down"
      }
    "up":{
      Message:="_
      \n   Moves current frame pointer up in the execution stack_
      \n   up   : moves current frame pointer one frame up_
      \n   up n : moves current frame pointer (n) frames up_
      \n   look for \"help down\" and \"help frame\""
      }
    "down":{
      Message:="_
      \n   Moves current frame pointer down in the stack_
      \n   down   : moves current frame pointer one frame down_
      \n   down n : moves current frame pointer (n) frames down_
      \n   look for \"help up\" and \"help frame\""
      }
    "quit":{
      Message:="\n   quit: Exits UDB. Use: \"quit\""
      }
    "help":{
      Message:="\n   help: for more help. Try \"help command\""
      }
    "print":{
      Message:="_
      \n   Prints variable information:_
      \n   print       : prints globals and locals of current frame_
      \n   print var   : prints the var value from current frame_
      \n   print var i : prints tha var value from frame number i_
      \n   print -G    : prints all global vars_
      \n   print -L    : prints all local vars in current frame_
      \n   print -P    : prints all Formal Parameters"
      }
    "where":{
      Message:="_
      \n   Prints the current position in the Source Code_
      \n   where_
      \n   look for \"help break\""
      }
    "cont":{
      Message:="_
      \n   Continue to run at full speed after a breakpoint_
      \n   continue_
      \n   look for \"help cont\""
      }
    "break":{
      Message:="_
      \n   Sets a breakpoint_
      \n   break        : prints all of the pre-set breakpoints_
      \n   break num    : Sets a break at line number (num)_
      \n   break f num  : Sets a break in file f at line number num_
      \n   break Proc   : Sets a break at procedure named \"Proc\"_
      \n   break f Proc : Sets a break in file f at procedure \"Proc\""
      }
    "clear":{
      Message:="_
      \n   Clears a breakpoint_
      \n   clear        : Clears all of the pre-set breakpoints_
      \n   clear num    : Clears break at line num in the current file_
      \n   clear f num  : Clears break in file f at line num_
      \n   clear Proc   : Clears break at procedure Proc in the current file_
      \n   clear f Proc : Clears break in file f at procedure Proc"
      }
    "watch":{
      Message:="_
      \n   Sets a watchpoint on some var_
      \n   watch          : prints a list of all pre-set watch vars_
      \n   watch var      : break at every line the var can change,_
      \n                    if the program is running, it watche for_ 
      \n                    var in the local scope, otherwize it_
      \n                    assumes that var is a global variable_
      \n   watch var proc : watch for local var in procedure proc"
      }
    "list":{
      Message:="_
      \n   Prints out some source code lines_
      \n   list [+]  : prints 10 lines from the current file centered_
      \n               around the current line, another list cmd will_
      \n               print the next 10 lines and so on._
      \n               if program is not running yet, current line is the_
      \n               line of procedure main(). Otherwise, current line is_
      \n               where the execution paused_ 
      \n   list -    : prints the previous 10 lines from the current print_
      \n   list num  : prints 10 lines centered around the line num_
      \n   list Proc : prints 10 lines centered around the precedure Proc_
      \n   list f    : prints 10 lines from the begining of file f_
      \n   list f n  : prints 10 lines centered around the line n of file f"
      }
    "src":{
      Message:="_
      \n   Prints out a list of the source file names_
      \n   src    : prints all of the found & missing source file names_
      \n   src -f : prints only the loaded source file names_
      \n   src -m : prints only the unloaded source file names_
      \n   src -a : prints all of the source file names along with their path"
      }
    "trace":{
      Message:="_
      \n   Sets a tracer on any variable or execution behavior of the program:_
      \n   trace var | var=[on|off]_
      \n      -proc | -proc=[on | off] |_
      \n      -proc [ call | fail | suspend | resume ]=[on | off]_
      \n      -func | -func=[on | off] |_
      \n      -func [ call | fail | suspend | resume ]=[on | off]_
      \n      -oper | -oper=[on | off] |_
      \n      -oper [ call | fail | suspend | resume ]=[on | off]_
      \n      -scan | -scan=[on | off] |_
      \n      -scan [ new  | fail | suspend | resume ]=[on | off]_
      \n   \"on\" and \"off\" are used to turn the tracer on and off_
      \n   when there is no on/off then the action is printing info_
      \n   ----------------------_
      \n   trace var             : prints the traced var info_
      \n                           if the program is running, it assumes the_ 
      \n                           var is in the local scope, otherwise it_
      \n                           assumes that var is a global variable_
      \n   trace var p           : prints traced var info that is local to p_
      \n   trace var=[on|off]    : traces every value the var can have,_
      \n   trace var=[on|off] p  : traces a local var in procedure p_
      \n   --In oreder to set any of the following behavior tracers ON,_
      \n     it must be set before the program is running/rerunning_
      \n   trace -proc           : prints all the traced procedure info_
      \n   trace -proc=[on|off]  : Sets the procdure tracer on/off _
      \n   trace -proc call      : prints the traced procedure calls_
      \n   trace -proc call=on   : Sets a tracer ON on every procedure call_
      \n   trace -proc call=off  : Sets a tracer OFF on every procedure call_
      \n   and the rest ar going in the same fashion"
      }
    default:{
      Message:="\n   Command not found. Type \"help\" for assistance"
      } 
   }#end of case
   }# end of else
   #make udb console takes no actions 
   DState.State := SKIP
   DState.Write(Message)
end

#
# Initialization
#
initially()

   Debug  := Evaluator()

   DState := Debug.DState           := 
             Debug.Break.DState     := 
             Debug.Watch.DState     := 
             Debug.Step.DState      := 
             Debug.Frame.DState     := 
             Debug.Print.DState     := 
             Debug.Trace.DState     :=
             Debug.Internal.DState  := 
             Debug.External.DState  := State()

# Test : To test the inter-program event forwarding
#        DState.external := debug.external
end

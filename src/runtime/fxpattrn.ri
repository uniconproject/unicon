#ifdef PatternType

/* #define PRINTF_DEBUG 1 or some other level if you want debugging */
#ifdef PRINTF_DEBUG
#define DEBUGF(lev, x) if (lev <= PRINTF_DEBUG) fprintf x
#else  /* DEBUG not defined */
#define DEBUGF(lev, x)
#endif /* DEBUG not defined */

dptr processFuncCallList(struct b_list *list);
dptr processMethodCallList(struct b_list *list);
#ifndef MultiProgram
int internal_match(char * pat_sub, int Length, int Pat_S, struct descrip op,
                   struct b_pelem * pattern, int *Start, int *Stop,
                   int initial_cursor, int Anchored_Mode);
#endif                                  /* MultiProgram */

struct b_pelem EOP = {T_Pelem, PC_EOP,(union block *)NULL, 0, 0, {D_Null,0}};
struct b_pattern emptypattern = { T_Pattern, 0, 0, (union block *)&EOP };

union block *pattern_make(int stck_size, struct b_pelem * pnext,
                          int pattern_code, int index, struct descrip param)
{
   tended struct b_pelem *lpnext = pnext;
   tended struct descrip lparam = param;
   tended struct b_pelem *pelem;
   tended union block * bp;
   bp = (union block *)alcpattern(stck_size);
#if COMPILER
   pelem = alcpelem(pattern_code);
#else                                   /* COMPILER */
   pelem = alcpelem(pattern_code, ipc.opnd);
#endif                                  /* COMPILER */
   pelem->pthen = (union block *) lpnext;
   pelem->parameter = lparam;
   pelem->index = index;
   /*
    * BlkPH is not showing up as an lvalue under gcc 4.8.4 and presumably other
    * common compilers, needed for DebugHeap. Instead of the simple assignment,
    * we resort to a lower level replacement technique for the following. Note
    * that DebugHeap BlkPH was only for sets and tables anyhow.
    * BlkPH(bp,Pattern,pe) = (union block *)pelem;
    */
   Blk(bp,Pattern)->pe = (union block *)pelem;
   return bp;
}

union block *pattern_make_pelem(int stck_size, struct b_pelem * pe)
{
   tended struct b_pelem *lpe = pe;
   union block * bp = (union block *)alcpattern(stck_size);
   Blk(bp,Pattern)->pe = (union block *)lpe;
   return bp;
}

union block *pelem_make(struct b_pelem * pnext, int pattern_code, int index,
                        struct descrip param)
{
   struct b_pelem *pelem;
   union block * bp;
   tended struct b_pelem *lpnext = pnext;
   tended struct descrip lparam = param;
#if COMPILER
   bp = (union block *)alcpelem(pattern_code);
#else                                   /* COMPILER */
   bp = (union block *)alcpelem(pattern_code, ipc.opnd);
#endif                                  /* COMPILER */
   pelem  = (struct b_pelem *)bp;
   pelem->pthen =(union block *) lpnext;
   pelem->parameter = lparam;
   pelem->index = index;
   return bp;
}

union block *pelem_copy(struct b_pelem * p2copy)
{
   struct b_pelem *pelem;
   union block * bp;
   tended struct b_pelem *lp2copy = p2copy;
#if COMPILER
   bp = (union block *)alcpelem(lp2copy->pcode);
#else                                   /* COMPILER */
   bp = (union block *)alcpelem(lp2copy->pcode, lp2copy->origin_ipc);
#endif                                  /* COMPILER */
   pelem  = (struct b_pelem *)bp;
   pelem->pthen = lp2copy->pthen;
   pelem->parameter = lp2copy->parameter;
   pelem->index = lp2copy->index;
   return bp;
}

#begdef Has_Alt(pcode)
(
(pcode == PC_Alt) ||
(pcode == PC_Arb_X) ||
(pcode == PC_Arbno_S)||
(pcode == PC_Arbno_X)
)
#enddef

/*
 * Recursive function that walks through a pelem linked list and fills in
 * an array of pelems, indexed by pelem indices.
 */
void Record_PE (struct b_pelem * E, struct b_pelem *RA[])
{
   DEBUGF(20, (stdout,"  Record_PE called\n"));
   if (E ==  &EOP || RA[E->index] != NULL){
      DEBUGF(20, (stdout," nothing to do\n"));
      return;
      }
   else {
      DEBUGF(20, (stdout," recording %ld\n",E->index));
      RA[E->index] = E;
      Record_PE ((struct b_pelem *)E->pthen, RA);
      if (Has_Alt(E->pcode))
         Record_PE ((struct b_pelem *)BlkLoc(E->parameter),RA);
      }
}

/*
 * What "Resolve" means is probably: turn string names into pointers to
 * actual variables in some execution context.  Copy/transform a list
 * into a list with actual pointers in it.
 */
struct b_list *ResolveList(struct b_list *lp)
{
   struct descrip proc;
   tended struct b_lelem *elsrc;
   tended struct b_lelem *eldest;
   int i, b, nargs;
   tended struct b_list *lpsrc;
   tended struct b_list *lpdest;
   struct b_list *lptemp;
   int complement;
   struct b_cset *cp, *cpx;

   lpsrc = lp;
   lpdest = alclist(lpsrc->size,lpsrc->size);
   DEBUGF(20,(stdout, "Resolving function name and parameters from list\n"));
   nargs = lpsrc->size -1;
   elsrc = (struct b_lelem *)lpsrc->listhead;

   proc.dword = D_Proc;
   /* The first element of the list must be string. */
   if (!is:string(elsrc->lslots[0])) {
      ReturnErrVal(103, elsrc->lslots[0], NULL);
      }
   /* convert string into procedure and store in proc */
   BlkLoc(proc)= (union block *)strprc(&elsrc->lslots[0],nargs);
   if (BlkLoc(proc) == NULL) {
      ReturnErrVal(106, elsrc->lslots[0], NULL);
      }
   eldest = (struct b_lelem *)lpdest->listhead;
   eldest->lslots[0] = proc;
   /*
    * For now, there is a limitation of only handling single-element-block
    * lists. Deemed OK for something only called internally for our own
    * constructed lists for unevaluated expressions.
    */
   if (BlkType(elsrc->listnext) == T_Lelem) {
      proc.dword = D_List;
      proc.vword.bptr = (union block *)lpsrc;
      ReturnErrVal(164, proc, NULL);
      }

   for (i = 1; i < elsrc->nused; i++) {
      tended char * varname;
      struct descrip parm;
      /* dptr pvar;  No longer used -- see below */
      if (is:string(elsrc->lslots[i])) {
         /*
          * if a string constant, drop double quotes,
          * else lookup using getvar()
          */
         cnv:C_string(elsrc->lslots[i], varname);
         if (StrLen(elsrc->lslots[i])>0) {
            complement = 0;
            if (strcspn(varname, "~") == 0) {
               /* resolve complement */
               StrLoc(elsrc->lslots[i]) = StrLoc(elsrc->lslots[i]) + 1;
               StrLen(elsrc->lslots[i]) = StrLen(elsrc->lslots[i]) - 1;
               cnv:C_string(elsrc->lslots[i], varname);
               complement = 1;
               }

            if (strcspn(varname, "\"") == 0) {
               /* drop the quotes, pass string contents */
               StrLoc(elsrc->lslots[i]) = StrLoc(elsrc->lslots[i]) + 1;
               StrLen(elsrc->lslots[i]) = StrLen(elsrc->lslots[i]) - 2;
               cnv:string(elsrc->lslots[i], elsrc->lslots[i]);
               }
            else if (strcspn(varname, "\'") == 0) {
               /* drop the quotes, but pass string as a cset */
               StrLoc(elsrc->lslots[i]) = StrLoc(elsrc->lslots[i]) + 1;
               StrLen(elsrc->lslots[i]) = StrLen(elsrc->lslots[i]) - 2;
               cnv:cset(elsrc->lslots[i], elsrc->lslots[i]);
               }
            else if (strcspn(varname, "&") == 0) {
               if (getkeyword(varname, &parm) == Failed) {
                  AsgnCStr(proc, varname);
                  ReturnErrVal(160, proc, NULL);
                  }
               cnv:cset(parm, elsrc->lslots[i]);
               if(complement) {
                  Protect(cp = alccset(), ReturnErrNum(307, NULL));
                  cpx = (struct b_cset *)BlkD(elsrc->lslots[i], Cset);
                  for (b = 0; b < CsetSize; b++)
                     cp->bits[b] = ~cpx->bits[b];
                  elsrc->lslots[i].vword.bptr = (union block *)cp;
                  }
               }
            else if (strcspn(varname, "1234567890") == 0) {
               cnv:integer(elsrc->lslots[i], elsrc->lslots[i]);
               }
            else {
               if (getvar(varname, &parm) == Failed) {
                  AsgnCStr(parm, varname);
                  ReturnErrVal(160, parm, NULL);
                  }
               /* pvar = VarLoc(parm); */
               elsrc->lslots[i] = parm; /* = *pvar too aggressive */

               if (complement) {
                  Protect(cp = alccset(), ReturnErrNum(307, NULL));
                  cpx = (struct b_cset *)StrLoc(elsrc->lslots[i]);
                  for (b = 0; b < CsetSize; b++)
                     cp->bits[b] = ~cpx->bits[b];
                  elsrc->lslots[i].vword.bptr = (union block *)cp;
                  }
               }
            parm = elsrc->lslots[i];
            }
         else {
            ReturnErrNum(164, NULL);
            }
         }
      else if (is:list(elsrc->lslots[i])) {
         /* recursively visit sublists, do same stuff */
         lptemp = (struct b_list *)BlkD(elsrc->lslots[i], List);
         parm.dword = D_List;
         if ((parm.vword.bptr = (union block *)ResolveList(lptemp)) == NULL)
            return NULL;
         }
      else {
         /* cset, integer constant, ... */
         parm = elsrc->lslots[i];
         }
      eldest->lslots[i] = parm;
      }
   return lpdest;
   }

/*
 *  ----------
 *  -- Resolve References --
 *  ----------
 *  Maps identifier names to variable references
 */
static struct b_pelem * ResolveReferences(struct b_pelem * P )
{
   tended struct b_pelem *tP;
   tP = P;
   if (tP == NULL) {
      ReturnErrNum(163, NULL);
      }
   else {
      /*            --  References to elements in P, indexed by Index field */
      struct b_pelem ** Refs;
      /*            --  Copies of elements of P, indexed by Index field. */
      struct b_pelem **Copy;
      tended struct b_pelem * E;
      int J;
      int RefLen = P->index + 1;
      if (!reserve(Blocks, RefLen * sizeof(struct b_pelem)))
         ReturnErrNum(307, NULL);

      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Copy = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));

      Record_PE(tP, Refs);

      /*
       * Now copy all nodes
       */
      for(J = 1; J < RefLen; J++)
         Copy[J] = (struct b_pelem *)pelem_copy(Refs[J]);

      /*
       * Adjust all internal references
       */
      for(J = 1; J < RefLen; J++) {
         E = Copy[J];
         /*
          * Adjust successor pointer to point to copy
          */
         if (E->pthen !=(union block *) &EOP)
            E->pthen =(union block *)
               Copy[((struct b_pelem *)(E->pthen))->index];
         /*
          * Adjust Alt pointer if there is one to point to copy
          */
         if (Has_Alt(E->pcode) &&
             ((struct b_pelem *)(BlkLoc(E->parameter)) != &EOP))
            (BlkLoc(E->parameter)) = (union block *)
               Copy[((struct b_pelem *)(BlkLoc(E->parameter)))->index];
         /*
          * Resolve references
          */
         switch(E->pcode){
         case PC_Pos_NP:
         case PC_Len_NP:
         case PC_RPos_NP:
         case PC_RTab_NP:
         case PC_Tab_NP:
         case PC_Any_VP:
         case PC_Break_VP:
         case PC_BreakX_VP:
         case PC_NotAny_VP:
         case PC_NSpan_VP:
         case PC_Span_VP:
         case PC_Assign_OnM:
         case PC_Assign_Imm:
         case PC_Rpat:{
            tended char * varname;
            if (is:list(E->parameter)) {
               /*
                * we know our list
                * it has only 2 elements object variable name and field name
                * so we dont perform all the sanity checks
                */
               tended struct b_lelem *ep;
               tended struct b_record *rp;
               tended struct b_list *lp = (struct b_list *)BlkLoc(E->parameter);
               ep = (struct b_lelem *)lp->listhead;
               if (is:string(ep->lslots[0])) {
                  cnv:C_string(ep->lslots[0],varname);
                  if (getvar(varname, &ep->lslots[0])== Failed) {
                     AsgnCStr(ep->lslots[0], varname);
                     ReturnErrVal(160, ep->lslots[0], NULL);
                     }
                  }
               }
            else {
               if (is:string(E->parameter)){
                  cnv:C_string(E->parameter, varname);
                  DEBUGF(2, (stdout, "Looking up variable name = %s\n",
                                   varname));
                  if (getvar(varname,&E->parameter)== Failed) {
                     AsgnCStr(E->parameter, varname);
                     ReturnErrVal(160, E->parameter, NULL);
                     }
                  }
               }
            break;
            }
         case PC_Pos_NF:
         case PC_Len_NF:
         case PC_RPos_NF:
         case PC_RTab_NF:
         case PC_Tab_NF:
         case PC_Any_VF:
         case PC_Break_VF:
         case PC_BreakX_VF:
         case PC_NotAny_VF:
         case PC_NSpan_VF:
         case PC_Span_VF:
         case PC_Pred_Func:
         case PC_String_VF:{
            tended struct b_list *lpsrc;
            tended struct b_list *lpdest;
            lpsrc = (struct b_list *)BlkD(E->parameter, List);
            if ((lpdest = ResolveList(lpsrc)) == NULL)
               return NULL;
            E->parameter.dword = D_List;
            E->parameter.vword.bptr = (union block *) lpdest;
            }
         }
      }
   E =  Copy[tP->index];
   free(Refs);
   free(Copy);
   return E;
   }
}

/*
 * Copy a pattern element.
 */
struct b_pelem * Copy(struct b_pelem * P)
{
   if (P == NULL) {
      fatalerr(162, NULL);
      }
   else {
      /* References to elements in P, indexed by Index field */
      struct b_pelem ** Refs;
      /* Holds copies of elements of P, indexed by Index field. */
      struct b_pelem **Copy;
      struct b_pelem * E;
      int J;
      int RefLen = P->index + 1;

      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Copy = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));

      Record_PE(P, Refs);

      /* Now copy all nodes */
      for(J = 1; J < RefLen; J++)
         Copy[J] = (struct b_pelem *)pelem_copy(Refs[J]);
      /* Adjust all internal references */
      for(J = 1; J < RefLen; J++){
         E = Copy[J];
         /*
          * Adjust successor pointer to point to copy
          */
         if (E->pthen !=(union block *) &EOP)
            E->pthen =(union block *)
               Copy[((struct b_pelem *)(E->pthen))->index];

         /*
          * Adjust Alt pointer if there is one to point to copy
          */
         if (Has_Alt(E->pcode) &&
             ((struct b_pelem *)(BlkLoc(E->parameter)) != &EOP))
            (BlkLoc(E->parameter)) = (union block *)Copy[((struct b_pelem *)
                                        (BlkLoc(E->parameter)))->index];
         }
      E =  Copy[P->index];
      free(Refs);
      free(Copy);
      return E;
      }
}


struct b_pelem * Concat (struct b_pelem * L, struct b_pelem *R, int Incr )
{
   tended struct b_pelem *lpe = L;
   tended struct b_pelem *rpe = R;
   EVVal(PC_Concat, E_PatCode);
   if (lpe == &EOP)
      return rpe;
   else if (rpe == &EOP)
      return lpe;
   else {
      struct b_pelem **Refs;
      /*
       * We build a reference array for L whose N'th element points to
       * the pattern element of L whose original Index value is N.
       */
      struct b_pelem * P;
      int J;
      int RefLen = lpe->index + 1;
      Refs=(struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Record_PE(lpe, Refs);
      for (J = 1; J < RefLen;J++) {
         P = Refs[J];
         P->index += rpe->index;
         if (P->pcode == PC_Arbno_Y){
            IntVal(P->parameter) += Incr;
            }
         if ((struct b_pelem *)P->pthen == &EOP)
            P->pthen = (union block *)rpe;
         if (Has_Alt(P->pcode) &&
             (BlkLoc(P->parameter) == (union block *)&EOP)) {
            tended struct descrip param;
            param.dword = D_Pelem;
            param.vword.bptr = (union block *) rpe;
            P->parameter = param;
            }
         }
      free(Refs);
      return lpe;
      }
}

#begdef OK_For_Simple_Arbno(pcode)
(
(pcode  == PC_Any_CS)     ||
(pcode  == PC_Any_VF)     ||
(pcode  == PC_Any_VP)     ||
(pcode  == PC_Len_Nat)    ||
(pcode  == PC_NotAny_CS)  ||
(pcode  == PC_NotAny_VF)  ||
(pcode  == PC_NotAny_VP)  ||
(pcode  == PC_Span_CS)    ||
(pcode  == PC_Span_VF)    ||
(pcode  == PC_Span_VP)    ||
(pcode  == PC_String)
)
#enddef

struct b_pelem * ResolvePattern(struct b_pattern *pat)
{
   struct descrip key; /* not tended because its always an int */
   tended struct b_pattern *tpat;
   tended struct descrip val;
   int res;
   uword hn;
   struct b_telem *te; /* not tended because no gc between def and uses */
   tended struct b_pelem *phead;
   union block **pd;   /* not tended because no gc between def and uses */

   tpat = pat;

   key.dword = D_Integer;
   IntVal(key) = tpat->id;
   hn = hash(&key);
   if (pfp->pattern_cache == NULL) {
      pfp->pattern_cache =  (struct b_table *)hmake(T_Table, (word)0,(word)0);
      pfp->pattern_cache->defvalue = nulldesc;
      }
   else { /* we have a table check if the pattern is already resolved */
      if ((pfp->pattern_cache)->title != T_Table) {
         syserr("corrupt pattern_cache\n");
         }

      pd = memb( (union block *)pfp->pattern_cache,&key,hn,&res);
      if (res != 0) { /*the element is in the table*/
         te = (struct b_telem *) *pd;
         return (struct b_pelem *)BlkLoc(te->tval);
         }
      }
   /* if it is not in table, first resolve references */
   if ((phead = ResolveReferences(&(tpat->pe->Pelem))) == NULL) return NULL;
   val.dword = D_Pelem;
   BlkLoc(val) = (union block *)phead;
   /* get table element now because can't tend pb */
   Protect(te = alctelem(), ReturnErrNum(307, NULL));
   /* find where to insert cannot just reuse pd as it cannot be tended*/
   pd = memb( (union block *)pfp->pattern_cache,&key,hn,&res);
   pfp->pattern_cache->size++;
   te->clink = *pd;
   *pd =  (union block *)te;
   te->hashnum = hn;
   te->tref = key;
   te->tval = val;
   if (TooCrowded(pfp->pattern_cache))
      hgrow( (union block *)pfp->pattern_cache);
   return phead;
}


function {*} pattern_match(underef psub -> dpsub, pat)
   declare {
      int use_trap = 0;
      }
   /*
    *  psub must either be a string or be convertible to one. Decide
    *  whether a substring trapped variable can be created.
    */
   if is:variable(psub) && is:string(dpsub) then {
      abstract {
         return new tvsubs(type(psub))
         }
      inline {
         use_trap = 1;
         }
      }
   else if cnv:tmp_string(dpsub) then
      abstract {
         return string
         }
   else
      runerr(114, dpsub);

   body {
      int start, stop;
      tended struct b_pelem *phead;

      int subject_len;
#if !ConcurrentCOMPILER
      CURTSTATE();
#endif                                  /* ConcurrentCOMPILER */

      DEBUGF(20,(stdout, "(729)begin pattern_match()\n"));
      /*
       * Assign new values to &subject/&pos to execute a match.
       * Save & restore of old values is done by a surrounding ?
       * implemented in the code generation for ??
       */
      k_pos = 1;
      k_subject = dpsub;
      subject_len = StrLen(k_subject);

      if (! cnv_pattern(&pat, &pat)) {
         runerr(127, pat);
         }

      if ((phead = ResolvePattern((struct b_pattern *)BlkLoc(pat))) == NULL) runerr(0);

      while ((k_pos >= 0) &&
             internal_match(StrLoc(k_subject), subject_len, ((struct b_pattern *)BlkLoc(pat))->stck_size,
                           pat,  phead, &start, &stop, k_pos, 0)
             ){
         /* check if psub no longer refers to what k_subject holds.
          * if so, we can't suspend a trapped variable reference to it.
          */
         if ((use_trap == 1) &&
             (StrLoc(*(psub.vword.descptr)) == StrLoc(k_subject)) &&
             (StrLen(*(psub.vword.descptr)) == StrLen(k_subject)) ) {

            /* if it is &subject, we can't make a tvsubs from it. */
            if (psub.vword.descptr == &k_subject) {
               suspend string(stop - start, StrLoc(dpsub)+ start);
               }
            else {
               suspend tvsubs(&psub, start+1,stop - start);
               }
            }
         else {
            suspend string(stop - start, StrLoc(dpsub)+ start);
            }
         /* Deref again, in case psub was altered. */
         deref(&psub,&dpsub);
 k_subject = dpsub;
         /*
          * Someone has monkeyed with the string we are scanning.
          * Update &pos, and check that it remains in bounds.
          * This interpretation -- that a longer string means
          * move pos forward and shorter means move the pos
          * backward, is somewhat dubious but could be useful.
          */
         if (subject_len != StrLen(dpsub)) {
            k_pos += StrLen(dpsub) - subject_len;
            subject_len = StrLen(dpsub);
            if (k_pos < 1) k_pos = 1;
            else if (k_pos > StrLen(dpsub)+1) k_pos = StrLen(dpsub);
            EVVal(k_pos, E_Spos);
            }
         }
      fail;
      }
end

#begdef cnv_pattern_macro(f,e_aconv,e_tconv,e_nconv,e_sconv,e_fconv,e_patcode)
/*
 * convert to a pattern. Modeled after cnv_cset or similar in cnv.r.
 */
int f(dptr s, dptr p)
{
   tended struct descrip emptypatternd;
   emptypatternd.dword = D_Pattern;
   emptypatternd.vword.bptr = (union block *)&emptypattern;

   EVValD(s, e_aconv);
   EVValD(&emptypatternd, e_tconv);
   type_case *s of {
   cset: {
      tended union block *bp = pattern_make(0, &EOP,PC_Any_CS,1, *s);
      EVVal(PC_Any_CS, e_patcode);
      p->dword = D_Pattern;
      BlkLoc(*p) = bp;
      EVValD(p, e_sconv);
      return 1;
      }
   pattern: {
      EVValD(s, e_nconv);
      return 1;
      }
   default: {
      tended union block *bp = NULL;
      if (!cnv:string(*s, *s)) {
         EVValD(s, e_fconv);
         return 0;
         }
      bp = pattern_make(0, &EOP,PC_String,1, *s);
      EVVal(PC_String, e_patcode);
      p->dword = D_Pattern;
      BlkLoc(*p) = bp;
      EVValD(p, e_sconv);
      return 1;
      }
      }
}
#enddef

#ifdef MultiProgram
cnv_pattern_macro(cnv_pattern_0,0,0,0,0,0,0)
cnv_pattern_macro(cnv_pattern_1,E_Aconv,E_Tconv,E_Nconv,E_Sconv,E_Fconv,E_PatCode)
#else                                   /* MultiProgram */
cnv_pattern_macro(cnv_pattern,0,0,0,0,0,0)
#endif                                  /* MultiProgram */

/*
 *
 * Set_Successor
 *
 * Note: this procedure is not used by the normal concatenation circuit,
 * since other fixups are required on the left operand in this case, and
 * they might as well be done all together.
 */
static void Set_Successor (struct b_pelem * Pat , struct b_pelem *Succ)
{
   if (Pat == NULL) {
      syserr("set_successor NULL pattern error");
      }
   else if (Pat == &EOP) {
      syserr("set_successor logic error");
      }
   else {
      struct b_pelem **Refs;
      /*
       * We build a reference array for L whose N'th element points to
       * the pattern element of L whose original Index value is N.
       */
      struct b_pelem * P ;
      int J;
      int RefLen = Pat->index + 1;
      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Record_PE(Pat, Refs);
      for (J = 1; J < RefLen;J++){
         P = Refs[J];
         if ((struct b_pelem *)P->pthen == &EOP)
            P->pthen = (union block *)Succ;
         if (Has_Alt(P->pcode) &&
             ((struct b_pelem *)BlkLoc(P->parameter) == &EOP)){
            P->parameter.dword = D_Pelem;
            P->parameter.vword.bptr = (union block *) Succ;
            }
         }
      free(Refs);
      }
}

/*
 * Bracket
 */
struct b_pelem *Bracket(struct b_pelem *E,struct b_pelem * P,
                            struct b_pelem * A)
{
   if (P == &EOP) {
      E->pthen =  (union block *)A;
      E->index = 2;
      A->index = 1;
      }
   else {
      E->pthen =  (union block *)P;
      Set_Successor (P, A);
      E->index = P->index + 2;
      A->index = P->index + 1;
      }
   return E;
}

#begdef ConvertPatternArgumentCset(arg, bp, ptype)
   type_case arg of {
      pattern: {
         struct b_pattern *pat = (struct b_pattern *)BlkLoc(arg);
         tended struct b_pelem *pe = (struct b_pelem *)pat->pe;
         switch(pe->pcode) {
         case PC_Rpat: {
            bp = pattern_make(0, &EOP,ptype ## _VP,1, pe->parameter);
            EVVal(ptype ## _VP, E_PatCode);
            break;
            }
         case PC_Pred_Func:
         case PC_String_VF: {
            bp = pattern_make(0, &EOP,ptype ## _VF,1, pe->parameter);
            EVVal(ptype ## _VF, E_PatCode);
            break;
            }
         case PC_Pred_MF:
         case PC_String_MF: {
            bp = pattern_make(0, &EOP,ptype ## _MF,1, pe->parameter);
            EVVal(ptype ## _MF, E_PatCode);
            break;
            }
         default: {
            runerr(127);
            }
            }
         }
      default: {
         if (!cnv_cset(&arg, &arg))
            runerr(104, arg);
         bp = pattern_make(0, &EOP, ptype ## _CS,1, arg);
         EVVal(ptype ## _CS, E_PatCode);
         }
   }
#enddef

function {1} Any(charset)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      ConvertPatternArgumentCset(charset, bp, PC_Any);
      return pattern(bp);
      }
end

function {1} Break(charset)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      ConvertPatternArgumentCset(charset, bp, PC_Break);
      return pattern(bp);
      }
end

function {1} NotAny(char_set)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      ConvertPatternArgumentCset(char_set, bp, PC_NotAny);
      return pattern(bp);
      }
end

function {1} Span(char_set)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      ConvertPatternArgumentCset(char_set, bp, PC_Span);
      return pattern(bp);
      }
end

function {1} Nspan(char_set)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      ConvertPatternArgumentCset(char_set, bp, PC_NSpan);
      return pattern(bp);
      }
end


struct b_pattern * breakx_make(struct b_pelem * B)
{
   tended struct b_pelem *X =  pelem_make(B,PC_BreakX_X, 2, nulldesc);
   tended struct descrip param;
   tended struct b_pelem *A;
   param.dword = D_Pelem;
   BlkLoc(param) =  (union block *)X;
   A =  (struct b_pelem *)pelem_make(&EOP,PC_Alt, 1, param);
   B->pthen =  (union block *)A;
   return (struct b_pattern *)pattern_make_pelem(2, B);
}

/*
 * BreakX
 */
function {1} Breakx(char_set)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      struct b_pelem *peBreakx;
      type_case char_set of {
      pattern: {
         struct b_pattern *pat = (struct b_pattern *)BlkLoc(char_set);
         tended struct b_pelem *pe = (struct b_pelem *)pat->pe;

         switch(pe->pcode){
         case PC_Rpat:{
            peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_VP, 3,
                                                    pe->parameter);
            EVVal(PC_BreakX_VP, E_PatCode);
            break;
            }
         case PC_Pred_Func:
         case PC_String_VF: {
            peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_VF, 3,
                                                    pe->parameter);
            EVVal(PC_BreakX_VF, E_PatCode);
            break;
            }
         case PC_Pred_MF:
         case PC_String_MF: {
            peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_MF, 3,
                                                    pe->parameter);
            EVVal(PC_BreakX_MF, E_PatCode);
            break;
            }
         default: {
            runerr(128);
            }
            }
         }
      default: {
         if (!cnv_cset(&char_set, &char_set))
            runerr(104, char_set);
         peBreakx = (struct b_pelem *)pelem_make(NULL,PC_BreakX_CS,3,char_set);
         EVVal(PC_BreakX_CS, E_PatCode);
         }
         }
      bp = (union block *)breakx_make(peBreakx);
      return pattern(bp);
      }
end

/*
 * ConvertPatternArgumentInt() - macro for the bodies of integer-argument
 * functions that construct patterns.
 *
 * The negint_ptype, if non-zero, means that there is a "reverse" pattern
 * whose integer indices are interpreted as distance backward from the end,
 * so if we have a negative literal, we might as well use the pattern for that.
 * Since the integers values are more generally not known until pattern match
 * time, the regular version of the pattern had better handle/interpret negative
 * indices anyhow. Maybe this feels like overkill, it is just trying to utilize
 * the pattern types that were translated over from the Ada.
 */
#begdef ConvertPatternArgumentInt(arg, ptype, negflag, negintptype)
   abstract {
      return pattern;
      }
   if is:pattern(arg) then body {
         union block *bp;
         struct b_pattern *pat = (struct b_pattern *)BlkLoc(arg);
         tended struct b_pelem *pe = (struct b_pelem *)pat->pe;
         switch(pe->pcode){
         case PC_Rpat: {
            bp =  (union block *)pattern_make(0, &EOP,ptype ## _NP,
                                              1, pe->parameter);
            EVVal(ptype ## _NP, E_PatCode);
            break;
            }
         case PC_Pred_Func:
         case PC_String_VF: {
            bp =  (union block *)pattern_make(0, &EOP,ptype ## _NF,
                                              1, pe->parameter);
            EVVal(ptype ## _NF, E_PatCode);
            break;
            }
         case PC_Pred_MF:
         case PC_String_MF: {
            bp =  (union block *)pattern_make(0, &EOP,ptype ## _NMF,
                                              1, pe->parameter);
            EVVal(ptype ## _NMF, E_PatCode);
            break;
            }
         default: {
            runerr(128);
            }
            }
      return pattern(bp);
      }
   else if cnv:integer(arg) then body {
      union block *bp;
#if negflag
      if (IntVal(arg) <= 0) {
         IntVal(arg) = -IntVal(arg);
         bp =  (union block *)pattern_make(0, &EOP, negintptype ## _Nat,1, arg);
         EVVal(negintptype ## _Nat, E_PatCode);
         }
      else
#endif
         {
         bp =  (union block *)pattern_make(0, &EOP, ptype ## _Nat,1, arg);
         EVVal(ptype ## _Nat, E_PatCode);
         }
      return pattern(bp);
      }
   else runerr(102, arg)
#enddef


function {1} Len(count)
   ConvertPatternArgumentInt(count, PC_Len, 0, 0)
end

function {1} Pos(position)
   ConvertPatternArgumentInt(position, PC_Pos, 1, PC_RPos)
end

function {1} Rpos(position)
   ConvertPatternArgumentInt(position, PC_RPos, 0, 0)
end

function {1} Tab(count)
   ConvertPatternArgumentInt(count, PC_Tab, 1, PC_RTab)
end

function {1} Rtab(count)
   ConvertPatternArgumentInt(count, PC_RTab, 0, 0)
end


/*
 * Arb
 *    +---+
 *    | X |---->
 *    +---+
 *      .
 *      .
 *    +---+
 *    | Y |---->
 *    +---+
 *
 *  The PC_Arb_X element is numbered 2, and the PC_Arb_Y element is 1.
*/

function {1} Arb()
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      tended struct descrip var;
      tended struct b_pelem * X;
      tended struct b_pelem * Y = pelem_make(&EOP,PC_Arb_Y,1,nulldesc);
      EVVal(PC_Arb_Y, E_PatCode);
      var.dword = D_Pelem;
      BlkLoc(var) =  (union block *)Y;
      X = (struct b_pelem *)pelem_make(&EOP,PC_Arb_X,2,var);
      EVVal(PC_Arb_X, E_PatCode);
      bp = pattern_make_pelem(1,X);
      return pattern(bp);
      }
end


/*
 * Arbno
 */

struct b_pelem * Arbno_Simple(struct b_pelem *pe)
{
   tended struct descrip var;
   tended struct b_pelem *S;
   var.dword = D_Pelem;
   BlkLoc(var) =  (union block *)pe;
   S = (struct b_pelem *)pelem_make(&EOP,PC_Arbno_S, pe->index + 1, var);
   EVVal(PC_Arbno_S, E_PatCode);
   Set_Successor(pe,S);
   return S;
}

function {1} Arbno(ARBPAT)
   abstract {
      return pattern;
      }
   body {
      int pattype;
      union block *bp;
      struct b_pattern * P;
      tended struct b_pelem * X;
      if (is:string(ARBPAT) || is:cset(ARBPAT)) pattype = 1;
      else if (is:pattern(ARBPAT)) pattype = 2;

      if (!cnv_pattern(&ARBPAT, &ARBPAT)) runerr(127, ARBPAT);

      if (pattype == 1) {
         P =  (struct b_pattern *)BlkLoc(ARBPAT);
         X = Arbno_Simple((struct b_pelem *)P->pe);
         bp = pattern_make_pelem(0,X);
         EVVal(PC_Arbno_S, E_PatCode);
         return pattern(bp);
         }
      else {
         tended struct b_pelem *Pat;
         P =  (struct b_pattern *)BlkLoc(ARBPAT);
         Pat = Copy((struct b_pelem *)P->pe);
         if ((P->stck_size == 0) && OK_For_Simple_Arbno(Pat->pcode)) {
            /*
             *
             * Arbno_Simple
             *
             *
             *      +-------------+
             *      |             ^
             *      V             |
             *    +---+           |
             *    | S |---->      |
             *    +---+           |
             *      .             |
             *      .             |
             *    +---+           |
             *    | P |---------->+
             *    +---+
             *
             *  The node numbering of the constituent pattern P is not
             *  affected. The S node has a node number of P.Index + 1.
             *
             *  Note that we know that P cannot be EOP, because a null
             *  pattern does not meet the requirements for simple Arbno.
             */
            X = Arbno_Simple(Pat);
            bp = pattern_make_pelem(1,X);
            EVVal(PC_Arbno_S, E_PatCode);
            return pattern(bp);
            }
         else {
            /*
             *  This is the complex case, either the pattern makes stack
             *  entries or it is possible for the pattern to match the null
             *  string (more accurately, we don't know that this is not the
             * case).
             *
             *      +--------------------------+
             *      |                          ^
             *      V                          |
             *    +---+                        |
             *    | X |---->                   |
             *    +---+                        |
             *      .                          |
             *      .                          |
             *    +---+     +---+     +---+    |
             *    | E |---->| P |---->| Y |--->+
             *    +---+     +---+     +---+
             *
             * The node numbering of the constituent pattern P is not
             * affected. Where N is the number of nodes in P, the Y node is
             * numbered N + 1, the E node is N + 2, and the X node is N + 3.
             */
            tended struct b_pelem * E;
            tended struct b_pelem * Y;
            tended struct b_pelem *EPY;
            tended struct descrip var;
            E =  (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,
                                              0,nulldesc);
            var.dword = D_Pelem;
            BlkLoc(var) =  (union block *)E;
            X =  (struct b_pelem *)pelem_make(&EOP,PC_Arbno_X,0,var);
            EVVal(PC_Arbno_X, E_PatCode);
            var.dword = D_Integer;
            IntVal(var) = P->stck_size + 3;
            Y =  (struct b_pelem *)pelem_make(X,PC_Arbno_Y,0,var);
            EVVal(PC_Arbno_X, E_PatCode);
            EPY = Bracket (E, Pat, Y);
            var.dword = D_Pelem;
            BlkLoc(var) =  (union block *)EPY;
            X->parameter = var;
            X->index = EPY->index + 1;
            bp = pattern_make_pelem(P->stck_size,X);
            return pattern(bp);
            }
         }
      }
end


/*
 * Succeed
 */
function {1} Succeed()
   abstract {
      return pattern;
      }
   body {
      union block *bp = pattern_make(1, &EOP,PC_Succeed,1, nulldesc);
      EVVal(PC_Succeed, E_PatCode);
      return pattern(bp);
      }
end

/*
 * bal
 */
function {1} Bal()
   abstract {
      return pattern;
      }
   body {
      union block *bp = pattern_make(1, &EOP,PC_Bal,1, nulldesc);
      EVVal(PC_Bal, E_PatCode);
      return pattern(bp);
      }
end

function {1} pattern_stringfunccall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      bp = pattern_make(0, &EOP,PC_String_VF,1, var_list);
      EVVal(PC_String_VF, E_PatCode);
      return pattern(bp);
      }
end

function {1} pattern_stringmethodcall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      bp = pattern_make(0, &EOP,PC_String_MF,1, var_list);
      EVVal(PC_String_MF, E_PatCode);
      return pattern(bp);
      }
end

function {1} pattern_boolfunccall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      bp = pattern_make(0, &EOP,PC_Pred_Func,1, var_list);
      EVVal(PC_Pred_Func, E_PatCode);
      return pattern(bp);
      }
end

function {1} pattern_boolmethodcall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      bp = pattern_make(0, &EOP,PC_Pred_MF,1, var_list);
      EVVal(PC_Pred_MF, E_PatCode);
      return pattern(bp);
      }
end

/*
 * Unevaluated variables
 */

function {1} pattern_unevalvar (name)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      bp = pattern_make(3, &EOP,PC_Rpat,1, name);
      EVVal(PC_Rpat, E_PatCode);
      return pattern(bp);
      }
end

function {1} pattern_concat(L, R)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      tended struct b_pattern *lpattern;
      tended struct b_pattern *rpattern;
      struct b_pelem *pe;

      if (!cnv_pattern(&L, &L)) runerr(127, L);
      if (!cnv_pattern(&R, &R)) runerr(127, R);

      lpattern = (struct b_pattern *)BlkLoc(L);
      rpattern = (struct b_pattern *)BlkLoc(R);
      pe = Concat(Copy((struct b_pelem *)lpattern->pe),
                  Copy((struct b_pelem *)rpattern->pe), rpattern->stck_size);
      bp = pattern_make_pelem(lpattern->stck_size + rpattern->stck_size,pe);
      return pattern(bp);
      }
end

struct b_pelem * Alternate(struct b_pelem * L,struct b_pelem * R)
{
   tended struct b_pelem *lpe = L;
   tended struct b_pelem *rpe = R;
   tended struct descrip param;
   param.dword = D_Pelem;
   param.vword.bptr = (union block *)rpe;
   EVVal(PC_Alt, E_PatCode);
   if (lpe == &EOP) {
      return (struct b_pelem *)pelem_make(&EOP, (word)PC_Alt,
                                          (word)rpe->index + 1, param);
      }
   /*
    *  If the left pattern is non-null, then build a reference vector
    *  for its elements, and adjust their index values to acccomodate
    *  the right hand elements. Then add the alternation node.
    */
   else {
      struct b_pelem **Refs;
      /*
       *  We build a reference array for L whose N'th element points to
       *  the pattern element of L whose original Index value is N.
       */
      struct b_pelem * P ;
      int J;
      int RefLen = lpe->index + 1;
      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Record_PE(lpe, Refs);
      for (J = 1; J < RefLen;J++){
         P = Refs[J];
         P->index += rpe->index;
         }
      return (struct b_pelem *)pelem_make(lpe, PC_Alt, lpe->index + 1, param);
      }
}

#begdef MAX(x,y)
((x) > (y)? (x):(y))
#enddef

function{1} pattern_alternate (LPAT, RPAT )
   abstract {
      return pattern;
      }
   body {
      tended struct b_pattern * lpattern;
      tended struct b_pattern * rpattern;
      struct b_pelem *pe;
      union block *bp;

      if (!cnv_pattern(&LPAT, &LPAT))
         runerr(127, LPAT);
      if (!cnv_pattern(&RPAT, &RPAT))
         runerr(127, RPAT);

      lpattern = (struct b_pattern *)BlkLoc(LPAT);
      rpattern = (struct b_pattern *)BlkLoc(RPAT);
      pe = Alternate(Copy((struct b_pelem *)lpattern->pe),
                     Copy((struct b_pelem *)rpattern->pe)
                     );
      bp =pattern_make_pelem(MAX(lpattern->stck_size, rpattern->stck_size),pe);
      return pattern(bp);
      }
end

/*
 * Setcur
 */
function {1} pattern_setcur ( name )
   abstract{
      return pattern;
      }
   body {
      union block *bp = pattern_make(0, &EOP,PC_Setcur,1, name);
      EVVal(PC_Setcur, E_PatCode);
      return pattern(bp);
      }
end

/*
 *  Assign immediate
 *
 *    +---+     +---+     +---+
 *    | E |---->| P |---->| A |---->
 *    +---+     +---+     +---+
 *
 *  The node numbering of the constituent pattern P is not affected.
 *  Where N is the number of nodes in P, the A node is numbered N + 1,
 *  and the E node is N + 2.
 */
function {1} pattern_assign_immediate (PAT, name)
   abstract {
      return pattern;
      }
   body {
      tended struct b_pattern * p;
      union block *bp;
      tended struct b_pelem *P;
      tended struct b_pelem *E;
      struct b_pelem *A;
      struct b_pelem *pe;

      if (!cnv_pattern(&PAT, &PAT)) runerr(127, PAT);

      p = (struct b_pattern *)BlkLoc(PAT);
      P = Copy((struct b_pelem *)p->pe);
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc);
      A = (struct b_pelem *)pelem_make(&EOP,PC_Assign_Imm,0,name);
      EVVal(PC_Assign_Imm, E_PatCode);
      pe = Bracket(E,P,A);
      bp = pattern_make_pelem(p->stck_size + 3,pe);
      return pattern(bp);
      }
end

/*
 *  Fence
 *
 *    +---+     +---+     +---+
 *    | E |---->| P |---->| X |---->
 *    +---+     +---+     +---+
 *
 *  The node numbering of the constituent pattern P is not affected.
 *  Where N is the number of nodes in P, the X node is numbered N + 1,
 *  and the E node is N + 2.
 */
function {1} Fence(P)
   abstract {
      return pattern;
      }
   if is:null (P) then
   body {
      union block *bp;
      bp = pattern_make(1, &EOP,PC_Fence,1, nulldesc);
      EVVal(PC_Fence, E_PatCode);
      return pattern(bp);
      }
   else
   body {
       struct b_pattern * p;
      union block *bp;
      struct b_pelem *Pat;
      struct b_pelem *E;
      struct b_pelem *X;

      if (!cnv_pattern(&P, &P)) runerr(127, P);

      p = (struct b_pattern *)BlkLoc(P);
      Pat = Copy((struct b_pelem *)p->pe);
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc);
      X = (struct b_pelem *)pelem_make(&EOP,PC_Fence_X,0, nulldesc);
      bp = pattern_make_pelem(p->stck_size + 1,Bracket(E,Pat,X));
      return pattern(bp);
      }
end

/*
 *  Assign on match
 *
 *    +---+     +---+     +---+
 *    | E |---->| P |---->| A |---->
 *    +---+     +---+     +---+
 *
 *  The node numbering of the constituent pattern P is not affected.
 *  Where N is the number of nodes in P, the A node is numbered N + 1,
 *  and the E node is N + 2.
 */

function {1} pattern_assign_onmatch (PAT, name)
   abstract {
      return pattern;
      }
   body {
      struct b_pattern *p;
      union block *bp;
      struct b_pelem *P;
      struct b_pelem *E;
      struct b_pelem *A;
      struct b_pelem *pe;

      if (!cnv_pattern(&PAT, &PAT)) runerr(127, PAT);

      p = (struct b_pattern *)BlkLoc(PAT);
      P = Copy((struct b_pelem *)p->pe);
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc);
      A = (struct b_pelem *)pelem_make(&EOP,PC_Assign_OnM,0,name);
      EVVal(PC_Assign_OnM, E_PatCode);
      pe = Bracket(E,P,A);
      bp = pattern_make_pelem(p->stck_size + 3,pe);
      return pattern(bp);
      }
end

function {1} Abort()
   abstract {
      return pattern;
      }
   body {
      union block *bp = pattern_make(0, &EOP,PC_Abort,1, nulldesc);
      EVVal(PC_Abort, E_PatCode);
      return pattern(bp);
      }
end


function {1} Rem()
   abstract {
      return pattern;
      }
   body {
      union block *bp = pattern_make(0, &EOP,PC_Rest,1, nulldesc);
      EVVal(PC_Rest, E_PatCode);
      return pattern(bp);
      }
end

/* PFail() moved to bottom (function Fail()) */

/*
 * Constant Pattern elements used only on stack
 *  CP_Assign    : aliased PE := (PC_Assign,    0, N);
 *  CP_Abort    : aliased PE := (PC_Abort,    0, N);
 *  CP_Fence_Y   : aliased PE := (PC_Fence_Y,   0, N);
 *  CP_R_Remove  : aliased PE := (PC_R_Remove  0, N);
 *  CP_R_Restore : aliased PE := (PC_R_Restore, 0, N);
 */

static struct b_pelem CP_Assign    =
   {T_Pelem, PC_Assign,    (union block *)NULL, 0, 0, {D_Null,0}};
static struct b_pelem CP_Abort    =
   {T_Pelem, PC_Abort,    (union block *)NULL, 0, 0, {D_Null,0}};
static struct b_pelem CP_Fence_Y   =
   {T_Pelem, PC_Fence_Y,   (union block *)NULL, 0, 0, {D_Null,0}};
static struct b_pelem CP_R_Remove  =
   {T_Pelem, PC_R_Remove,  (union block *)NULL, 0, 0, {D_Null,0}};
static struct b_pelem CP_R_Restore =
   {T_Pelem, PC_R_Restore, (union block *)NULL, 0, 0, {D_Null,0}};

/*
 *
 * Pop_Region
 *
 *
 *     procedure Pop_Region is
 *     begin
 *        -- If nothing was pushed in the inner region, we can just get
 *        -- rid of it entirely, leaving no traces that it was ever there
 *
 *       if Stack_Ptr = Stack_Base then
 *          Stack_Ptr := Stack_Base - 2;
 *          Stack_Base := Stack (Stack_Ptr + 2).Cursor;
 *
 *       --  If stuff was pushed in the inner region, then we have to
 *       --  push a PC_R_Restore node so that we properly handle possible
 *       --  rematches within the region.
 *
 *       else
 *          Stack_Ptr := Stack_Ptr + 1;
 *          Stack (Stack_Ptr).Cursor := Stack_Base;
 *          Stack (Stack_Ptr).Node   := CP_R_Restore'Access;
emacs *          Stack_Base := Stack (Stack_Base).Cursor;
 *       end if;
 *    end Pop_Region;
 */

/* Stack is now a struct b_cons *, and its cursors are in Stack->data as a
 * struct b_intarray and its nodes are now in Stack->next as a struct b_lelem.
 * Stack[i].cursor is now Stack->data->a[i]
 * Stack[i].node is now Stack->next->lslots[i].vword.bptr
 * Let's define macros!
 */
#define StackCursor(i) (Stack->data->Intarray.a[i])
#define StackNode(i) (Stack->next->Lelem.lslots[i].vword.bptr)

#begdef Pop_Region()
if (Stack_Ptr == Stack_Base) {
   EVVal(0, E_PatPop);
   Stack_Ptr = Stack_Base - 2;
   Stack_Base = StackCursor(Stack_Ptr + 2);
   Stack->next->Lelem.nused -= 2;
}
else {
   EVVal(1, E_PatPop);
   Stack_Ptr++;
   StackCursor(Stack_Ptr) = Stack_Base;
   StackNode(Stack_Ptr) = (union block *)&CP_R_Restore;
   Stack_Base = StackCursor(Stack_Base);
   Stack->next->Lelem.nused++;
}
#enddef
/*
 * Push
 *
 *    procedure Push (Node : PE_Ptr) is
 *    begin
 *       Stack_Ptr := Stack_Ptr + 1;
 *       Stack (Stack_Ptr).Cursor := k_pos - 1;
 *       Stack (Stack_Ptr).Node   := Node;
 *    end Push;
 */

#begdef Push(Node)
EVVal(0, E_PatPush);
Stack_Ptr++;
StackCursor(Stack_Ptr) = k_pos - 1;
StackNode(Stack_Ptr)   = (union block *)Node;
Stack->next->Lelem.lslots[Stack_Ptr].dword = D_Pelem;
Stack->next->Lelem.nused++;
#enddef

/*
 * Push_Region
 *
 *    procedure Push_Region is
 *    begin
 *       Stack_Ptr := Stack_Ptr + 2;
 *       Stack (Stack_Ptr).Cursor := Stack_Base;
 *       Stack (Stack_Ptr).Node   := CP_R_Remove'Access;
 *       Stack_Base := Stack_Ptr;
 *    end Push_Region;
 */
#begdef Push_Region()
EVVal(1, E_PatPush);
Stack_Ptr = Stack_Ptr + 2;
StackCursor(Stack_Ptr) = Stack_Base;
StackNode(Stack_Ptr)   = (union block *)&CP_R_Remove;
Stack_Base = Stack_Ptr;
Stack->next->Lelem.lslots[Stack_Ptr].dword = D_Pelem;
Stack->next->Lelem.nused += 2;
#enddef

/*
 * GetVarFromNodeParameter() is a macro used many many times in
 * internal_match(). Since internal_match uses its return value to
 * indicate whether a successful/resumable match was found, it is not
 * free to return an error code, so errors in here are fatalerr().
 *
 * The macro is used to convert the string or list stored in the parameter
 * field of a node to the variable location and value the variable location
 * is stored in the pvar (used when the variable needs to be assigned to)
 * the variable value is stored in var
 */
#begdef GetVarFromNodeParameter(Node)
tended struct descrip var;
tended struct descrip varref;
dptr pvar;
tended char * varname;
if (is:list(Node->parameter)) {
   tended struct b_lelem *ep;
   tended struct b_record *rp;
   union block *bptr;
   struct descrip fieldptr;
   int i,nfields, fnum;
   struct b_list *lp = (struct b_list *)BlkLoc(Node->parameter);
   ep = (struct b_lelem *)lp->listhead;
   var = ep->lslots[0];
   deref(&var, &var);

   if (!is:record(var))
      fatalerr(107, &var);

   fieldptr = ep->lslots[1];
   if (!is:string(fieldptr)) {
      fatalerr(103, &fieldptr);
      }
   rp = (struct b_record *)BlkLoc(var);
   bptr = rp->recdesc;
   nfields = bptr->Proc.nfields;
   for (i=0;i<nfields;i++) {
      if ((StrLen(fieldptr) == StrLen(bptr->Proc.lnames[i])) &&
          !strncmp(StrLoc(fieldptr),
                   StrLoc(bptr->Proc.lnames[i]),StrLen(fieldptr)))
         break;
      }
   if (i<nfields)
      fnum = i;
   else {
      fatalerr(160, &(ep->lslots[1]));
      }
   pvar = &rp->fields[fnum];
   varref.dword = D_Var + ((word *)pvar - (word *)rp);
   VarLoc(varref) = (dptr)rp;
   var = rp->fields[fnum];
   EVValD(&var, E_PatVal);
   }
else {
   tended char *varnam;
   if (is:string(Node->parameter)) {
      cnv:C_string(Node->parameter, varnam);
      if (getvar(varnam, &varref) == Failed) {
         fatalerr(160, &(Node->parameter));
         }
      deref(&varref, &var);
      pvar = VarLoc(varref);
      EVValD(&var, E_PatVal);
      }
   else if (Var(Node->parameter)) {
      varref = Node->parameter;
      deref(&(Node->parameter), &var);
      pvar = VarLoc(Node->parameter);
      EVValD(&var, E_PatVal);
      }
   else if (is:null(Node->parameter)) {
      fatalerr(165, NULL);
      }
   else {
      fprintf(stderr, "parameter\n\n\t%16lx\n\t%16lx\n",
          (unsigned long int)Node->parameter.dword,
          (unsigned long int)Node->parameter.vword.integr);
      syserr("bad descriptor in .> or some such");
      }
   }
#enddef

int isMethod(struct b_lelem *ep){
   struct b_record *rp;
   union block *bptr;
   int i, found__m = -1;
   if (is:record(ep->lslots[0])){
      rp = (struct b_record *)BlkLoc(ep->lslots[0]);
      bptr = rp->recdesc;
      }
   else if (is:proc(ep->lslots[0])){
      bptr = ep->lslots[0].vword.bptr;
      }
   else fatalerr(107, &(ep->lslots[0]));
   for( i = 0; i < bptr->Proc.nfields;i++) {
      if ((StrLoc(bptr->Proc.lnames[i]) != NULL) &&
          !strcmp(StrLoc(bptr->Proc.lnames[i]), "__m")) {
         found__m = i;
         break;
         }
      }/* for ... nfields */
   return found__m;
   }

dptr processFuncCallList(struct b_list *lp)
{
   tended struct b_lelem *ep;
   struct descrip proc;
   int i, nargs = lp->size - 1;
   dptr rv;
   struct descrip *procargs;
   tended struct descrip cresult;
   dptr call_result;
   tended char *temp;

   ep = (struct b_lelem *)lp->listhead;
   proc = ep->lslots[0];
   if ((procargs = calloc(ep->nused, sizeof(struct descrip))) == NULL) {
      fatalerr(307, &nulldesc);
      }

   DEBUGF(25,(stdout, "processFuncCallList\n"));
   DEBUGF(25,(stdout, "nargs %d\n", nargs));
   for (i = 1; i < ep->nused; i++) {
      if(i == 1 && is:list(ep->lslots[i])) {
         /*check for method call else function call*/
         DEBUGF(25,(stdout, "is a list\n"));
         if(isMethod(ep) >= 0) {
            rv = processMethodCallList(BlkD(ep->lslots[i], List));
            }
         else {
            rv = processFuncCallList(BlkD(ep->lslots[i], List));
            }
         if (rv == 0) { free(procargs); return 0; }
         procargs[i - 1] = *rv;
         }
      else if (is:variable(ep->lslots[i])) {
         DEBUGF(25,(stdout, "replacing var %16lx : %16lx\n",
                  ep->lslots[i].dword,
                  (long)ep->lslots[i].vword.bptr));
         procargs[i - 1] = *(ep->lslots[i].vword.descptr);
         }
      else {
         procargs[i - 1] = ep->lslots[i];
         DEBUGF(25,(stdout, "nargs %d arg %d val %16lx : %16lx\n",
                  nargs, i-1, procargs[i-1].dword, (long)procargs
                  [i-1].vword.bptr));
         }
      }
   DEBUGF(25,(stdout, "proc %16lx : %16lx\n", proc.dword,
          (unsigned long int)proc.vword.bptr));
   DEBUGF(25,(stdout, "nargs %d\n", nargs));
   call_result = (dptr)calliconproc(proc,procargs,nargs);
   free(procargs);
   return call_result;
   }

dptr processMethodCallList(struct b_list *lp)
{
   int nargs;
   tended struct b_lelem *ep;
   tended struct b_record *rp;
   union block *bptr;
   struct descrip methodptr;
   struct descrip proc;
   struct descrip self;
   struct descrip argmnt;
   dptr rv;
   struct descrip procargs[10];
   dptr call_result;
   tended struct descrip var;
   tended char *varname;
   tended char *classname;
   int nfields, fnum, cnlen;
   int i, found__m = 0;

   nargs = lp->size;

   ep = (struct b_lelem *)lp->listhead;
   if (!cnv:C_string(ep->lslots[0], varname)) {
      ReturnErrVal(103, ep->lslots[0], NULL);
      }
   if (getvar(varname, &var) == Failed) {
      AsgnCStr(proc, varname);
      ReturnErrVal(160, proc, NULL);
      }
   procargs[0] = var;
   deref(&var,&var);
   if (!is:record(var)) {
      ReturnErrVal(107, var, NULL);
      }
   ep->lslots[0] = var;
   self = var;
   classname = var.vword.bptr->Record.recdesc->Proc.pname.vword.sptr;
   cnlen = strcspn(classname, "_");
   classname = strncpy(classname, classname, cnlen);
   classname[cnlen] = '_';
   classname[cnlen + 1] = '\0';
   methodptr = ep->lslots[1];
   if (!is:string(methodptr)) ReturnErrVal(103, methodptr, NULL);
   rp = (struct b_record *)BlkLoc(var);
   bptr = rp->recdesc;

   found__m = isMethod(ep);

   if (found__m == -1) {
      fatalerr(163, NULL);
      }
   var = rp->fields[found__m];
   if (!is:record(var)) {
      ReturnErrVal(107, var, NULL);
      }
   rp = (struct b_record *)BlkLoc(var);
   bptr = rp->recdesc;
   nfields = bptr->Proc.nfields;
   for (i=0; i<nfields; i++) {
      if ((StrLen(methodptr) == StrLen(bptr->Proc.lnames[i])) &&
          !strncmp(StrLoc(methodptr),
                   StrLoc(bptr->Proc.lnames[i]),StrLen(methodptr)))
         break;
      }
   if (i<nfields)
      fnum = i;
   else fatalerr(207, &methodptr);
   proc = rp->fields[fnum];
   bptr = rp->recdesc;
   /* given that slots[0] was the object, and slots[1] is the method,
    * evaluate slots[2] through the rest of the list as procargs[1]...
    */
   procargs[0] = self;
   for (i = 2; i < ep->nused; i++) {
      if(is:list(ep->lslots[i])) {
         /* check for method call else function call*/
         if(isMethod((struct b_lelem *)(BlkD(ep->lslots[i],List)->listhead)) >= 0) {
            /* slot is a method */
            rv = processMethodCallList(BlkD(ep->lslots[i], List));
            }
         else {
            /* slot is a procedure */
            rv = processFuncCallList(BlkD(ep->lslots[i], List));
            }
         if (rv == 0) {
            return 0;
            }
         procargs[i - 1] = *rv;
         }
      else if (is:variable(ep->lslots[i])) {
         procargs[i - 1] = *(ep->lslots[i].vword.descptr);
         }
      else if (cnv:integer(ep->lslots[i], argmnt)) {
         procargs[i - 1] = argmnt;
         }
      else if (is:string(ep->lslots[i])) { /* "string" needs interpreting */
         if ((StrLen(ep->lslots[i])>0) && StrLoc(ep->lslots[i])[0]=='\"') {
            procargs[i - 1] = ep->lslots[i];
            StrLoc(procargs[i-1])++;
            StrLen(procargs[i-1]) -= 2;
            }
         else if ((StrLen(ep->lslots[i])>0) && StrLoc(ep->lslots[i])[0]=='\''){
            procargs[i - 1] = ep->lslots[i];
            StrLoc(procargs[i-1])++;
            StrLen(procargs[i-1]) -= 2;
            cnv:cset(procargs[i-1], procargs[i-1]);
            }
         else {
            tended char * varname;
            tended char * varstring;
            tended struct descrip parm;
            cnv:C_string(ep->lslots[i], varname);
            /*
             * We are evaluating a parameter in a variable name.
             * Probably needs more thought than getvar().
             */
            if (getvar(varname, &parm) == Failed) {
               AsgnCStr(parm, varname);
               ReturnErrVal(160, parm, NULL);
               }
            deref(&parm,&(procargs[i-1]));
            }
         }
      }
   call_result = (dptr)calliconproc(proc,procargs,nargs-1);
   return call_result;
   }

/*
 * uses the list stored in the parameter field of a node to
 * 1. obtains the name of the procedure from the first element of the list
 * 2. the remaining elements of the list are used as paramters to the function
 */
#begdef GetResultFromFuncCall()
   tended struct descrip cresult;
   dptr call_result;
   tended struct b_list *lp = (struct b_list *)BlkLoc(Node->parameter);
   call_result = processFuncCallList(lp);
   if (call_result != 0) {
      EVValD(call_result, E_PatVal);
      cresult = *call_result;
      }
   else goto Node_Fail;
#enddef

/*
 * uses the list stored in the parameter field of a node to
 * 1. first obtain the object from the first element of the list
 * 2. access the method from the object using the second element of the list
 * 3. remaining elements of the list are parameters to the method invocation
 */
#begdef GetResultFromMethodCall()
tended struct descrip cresult;
dptr call_result;
tended struct b_list *lp = (struct b_list *)BlkLoc(Node->parameter);

if (is:list(Node->parameter)) {
   call_result = processMethodCallList(lp);
   if (call_result != 0) {
      EVValD(call_result, E_PatVal);
      cresult = *call_result;
      }
   }
else {
   fatalerr(163, NULL);
   }
#enddef

#define Stack_Init 1
#define Stack_Size 200

#begdef internal_match_macro(f,e_patfail,e_patmatch,e_patarg,e_pelemattempt,e_pelemmatch,e_pelemfail,e_assign,e_value,e_spos)
/*
 * internal_match() - primary pattern match engine.
 */
int f(char * pat_sub, int Length, int Pat_S, struct descrip op,
                   struct b_pelem * pat, int *Start, int *Stop,
                   int initial_cursor,
                   int Anchored_Mode
                   )
{
   int i, Stack_Ptr, Stack_Base;
   int Assign_OnM = 0, Region_Level = 0;
   tended struct b_cons *Stack;
   tended struct b_pelem *tpattern;
   tended struct descrip evalue;
   tended struct b_pelem * Node;
#if COMPILER
   tended struct b_pelem * PE_Unanchored;
#else                                   /* COMPILER */
   tended struct b_pelem * PE_Unanchored;
#endif                                  /* COMPILER */

   /*
    * And now for something weird.  A pattern stack, allocated on the stack,
    * which is an array, which we have to tend, which rtt does not support.
    * If you change struct b_intarray or struct b_lelem in h/rstructs.h, you
    * must change this compatibly.
    */
   struct b_sized_intarray {
      word title;
      word blksize;
      union block *listp;
      union block *dims;
      word a[Stack_Size];
      } bsia;
   struct b_sized_lelem {
      word title;
      word blksize;
      union block *listprev;
      union block *listnext;
      word nslots;
      word first;
      word nused;
      struct descrip lslots[Stack_Size];
      } bsle;
   struct b_cons bcons;

   EVValD(&op, E_PatAttempt);

   tpattern = pat;
   Node = NULL;
#if COMPILER
   PE_Unanchored = alcpelem(PC_Unanchored);
#else                                   /* COMPILER */
   PE_Unanchored = alcpelem(PC_Unanchored, ipc.opnd);
#endif                                  /* COMPILER */
   PE_Unanchored->pthen = (union block *)tpattern;
   PE_Unanchored->parameter = nulldesc;

   bsia.title = T_Intarray;
   bsia.blksize = sizeof(bsia);
   bsia.dims = NULL; bsia.listp = NULL;

   bsle.title = T_Lelem;
   bsle.blksize = sizeof(bsle);
   bsle.listprev = NULL;
   bsle.listnext = NULL;
   bsle.nslots = Stack_Size;
   bsle.first = 0;
   bsle.nused = 0;
   for(i=0; i<Stack_Size; i++) bsle.lslots[i] = nulldesc;

   bcons.title = T_Cons;
   bcons.data = (union block *)&bsia;
   bcons.next = (union block *)&bsle;

   Stack = &bcons;

   DEBUGF(2, (stdout,
          "Initiating pattern match\nsubject = \"%*s\", len = %d, pos = %ld\n",
              Length,pat_sub,Length, k_pos));

   if (tpattern == NULL) {
      fatalerr(162, NULL);
      }
   if (Pat_S > Stack_Size - 1) {
      fatalerr(309, NULL);
      }
   /* In anchored mode, the bottom entry on the stack is a cancel entry */
   if (Anchored_Mode) {
      StackNode(Stack_Init) = (union block *)&CP_Abort;
      StackCursor(Stack_Init) = initial_cursor - 1;
      }
/*
 *       --  In unanchored mode, the bottom entry on the stack references
 *       --  the special pattern element PE_Unanchored, whose Pthen field
 *       --  points to the initial pattern element. The cursor value in this
 *       --  entry is the number of anchor moves so far.
 */
   else {
      StackNode(Stack_Init) = (union block *)PE_Unanchored;
      StackCursor(Stack_Init) = initial_cursor - 1;
      }
   Stack_Ptr = Stack_Init;
   Stack->next->Lelem.nused = 1;
   Stack_Base = Stack_Ptr;
   Node = tpattern;
   goto Match;
   /*
    *
    * Main Pattern Matching State Control
    *
    *       --  This is a state machine which uses gotos to change state. The
    *       --  initial state is Match, to initiate the matching of the first
    *       --  element, so the goto Match above starts the match. In the
    *       --  following descriptions, we indicate the global values that
    *       --  are relevant for the state transition.
    */

/*
 *       --  Come here if entire match fails
 */

Match_Fail:
   DEBUGF(20,(stdout,"Match fails\n"));
   *Start = 0;
   *Stop = 0;
   EVVal(Node->pcode, e_patfail);
   return 0;
/*
 *       --  Come here if entire match succeeds
 *
 *       --  k_pos        current position in subject string (1 based)
 */
Match_Succeed:
   DEBUGF(2,(stdout,"Match Succeeds\n"));
   *Start = StackCursor(Stack_Init);
   *Stop = k_pos - 1;
#if e_patmatch
   StrLen(evalue) = *Stop - *Start;
   StrLoc(evalue) = pat_sub + *Start;
   EVValD(&evalue, e_patmatch);
#endif                                  /* e_patmatch */
   DEBUGF(2,(stdout, "first matched character index =%d\n", *Start));
   DEBUGF(2,(stdout, "last matched character index =%d\n" ,*Stop));
   if (Assign_OnM) {
      int S;
      for ( S = Stack_Init; S <= Stack_Ptr; S++) {
         if (StackNode(S) == (union block *)&CP_Assign){
            int Inner_Base = StackCursor(S + 1);
            int Special_Entry =  Inner_Base - 1;
            tended struct b_pelem * Node_OnM = StackNode(Special_Entry);
            int Start = StackCursor(Special_Entry);
            int Stop = StackCursor(S);
            GetVarFromNodeParameter(Node_OnM);
            if (Node_OnM->pcode == PC_Assign_OnM){
               if (var.dword == D_File) {
                  struct b_file *f;
                  f = (struct b_file *)BlkLoc(var);
                  fwrite(pat_sub + Start, 1, Stop - Start, f->fd.fp);
                  fputc('\n', f->fd.fp);
                  fflush(f->fd.fp);
                  }
               else {
                  EVVar(&varref, e_assign);
                  StrLen(*pvar) = Stop - Start;
                  StrLoc(*pvar) = pat_sub + Start;
                  EVValD(pvar, e_value);
                  }
               }
            else {
               syserr("logic error in internal_match");
               }
            }
         }
      }
   return 1;
Node_Fail:
/*
 *       --  Come here if attempt to match current element fails
 *
 *       --    Stack_Base    current stack base
 *       --    Stack_Ptr     current stack pointer
 */
   EVVal(Node->pcode, e_pelemfail);
   k_pos = StackCursor(Stack_Ptr) + 1;
   Node   = (struct b_pelem *)StackNode(Stack_Ptr);
   Stack_Ptr--;
   Stack->next->Lelem.nused--;
   goto Match;
Node_Succeed:
/*
 *       --  Come here if attempt to match current element succeeds
 *
 *       --    k_pos         current position in subject string (1 based, hence the -1 or +1)
 *       --    Node          pointer to node successfully matched
 *       --    Stack_Base    current stack base
 *       --    Stack_Ptr     current stack pointer
 */

    EVVal(Node->pcode, e_pelemmatch);
    Node = (struct b_pelem *)Node->pthen;
/*
 *       --  Come here to match the next pattern element
 *
 *       --    k_pos         current position in subject string (1 based, hence the -1 or +1)
 *       --    Node          pointer to node to be matched
 *       --    Stack_Base    current stack base
 *       --    Stack_Ptr     current stack pointer
 */
 Match:
/*
 *
 *       -- Main Pattern Match Element Matching Routines --
 *
 *
 *       --  Here is the case statement that processes the current node. The
 *       --  processing for each element does one of five things:
 *
 *       --    goto Succeed        to move to the successor
 *       --    goto Match_Succeed  if the entire match succeeds
 *       --    goto Match_Fail     if the entire match fails
 *       --    goto Fail           to signal failure of current match
 */
   DEBUGF(5, (stdout, "match: %ld, Pos: %ld\n", Node->pcode, k_pos));

   /* The next block is for execution monitoring. We see if the Node
    * has a parameter, if it does it must be a specific code. The problem
    * encountered is with arg_image. We must know if the code is evaluated or
    * unevaluated. Thus the sanity check with the numbers. If the codes change
    * this will not work.
    *
    * Instrumented internal_match will be on if monitoring any of 10
    * different event codes. Even if using the instrumented version of
    * the function, don't call arg_image() unless we asked for E_PatArg.
    */
#if e_patarg
   switch (Node->pcode) {
   case PC_Any_CS: case PC_Break_CS: case PC_BreakX_CS: case PC_NotAny_CS:
   case PC_NSpan_CS: case PC_Span_CS: case PC_Len_Nat: case PC_Pos_Nat:
   case PC_RPos_Nat: case PC_RTab_Nat: case PC_Tab_Nat: case PC_String:
      /* if a CS or a Nat or a String */

/* used in EVValDEx but not meaningful out here */
#define ExInterp_sp /* noop */
#define EntInterp_sp /* noop */

      EVValDEx(&nulldesc,e_patarg,/*noop*/,arg_image(Node->parameter,-1,PT_EVAL,&(mycurpstate->parent->eventval)),/*noop*/);
      break;
   case PC_Any_VP: case PC_Break_VP: case PC_BreakX_VP: case PC_NotAny_VP:
   case PC_NSpan_VP: case PC_Span_VP: case PC_String_VP: case PC_Pos_NP:
   case PC_Len_NP: case PC_RPos_NP: case PC_RTab_NP: case PC_Tab_NP:
   case PC_Rpat:
      /* if a VP or a NP or an Rpat */
      EVValDEx(&nulldesc,e_patarg,/*noop*/,arg_image(Node->parameter,-1,PT_VP,&(mycurpstate->parent->eventval)),/*noop*/);
      break;
   case PC_Any_VF: case PC_Break_VF: case PC_BreakX_VF: case PC_NotAny_VF:
   case PC_NSpan_VF: case PC_Span_VF: case PC_Pos_NF: case PC_Len_NF:
   case PC_RPos_NF: case PC_RTab_NF: case PC_Tab_NF: case PC_Pred_Func:
      /* if a VF or NF or PC_Pred_Func */
      EVValDEx(&nulldesc,e_patarg,/*noop*/,arg_image(Node->parameter,-1,PT_VF,&(mycurpstate->parent->eventval)),/*noop*/);
      break;
   case PC_String_VF:
      EVValDEx(&nulldesc,e_patarg,/*noop*/,arg_image(Node->parameter,PC_String_VF,PT_VF,&(mycurpstate->parent->eventval)),/*noop*/);
      break;
   case PC_String_MF:
      EVValDEx(&nulldesc,e_patarg,/*noop*/,arg_image(Node->parameter,PC_String_MF,PT_VF,&(mycurpstate->parent->eventval)),/*noop*/);
      break;
   case PC_Pred_MF: case PC_Any_MF: case PC_Break_MF: case PC_BreakX_MF:
   case PC_NotAny_MF: case PC_NSpan_MF: case PC_Span_MF: case PC_Pos_NMF:
   case PC_Len_NMF: case PC_RPos_NMF: case PC_RTab_NMF: case PC_Tab_NMF:
      /* if a MF or NMF or PC_Pred_MF */
      EVValDEx(&nulldesc,e_patarg,/*noop*/,arg_image(Node->parameter,-1,PT_MF,&(mycurpstate->parent->eventval)),/*noop*/);
      break;
      }
#endif                                  /* e_patarg */

#if !COMPILER
   k_patindex = Node->index;
#endif                                 /*COMPILER */

   EVVal(Node->pcode, e_pelemattempt);

   switch(Node->pcode) {
   case PC_Alt: {
      DEBUGF(20,(stdout,"Setting up alternative \n"));
      Push((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
   case PC_Any_CS:{
      DEBUGF(20,(stdout,"Matching Any\n"));
      if ((k_pos <= Length) && Testb(ToAscii(pat_sub[k_pos - 1]), Node->parameter)){
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      break;
      }
   case PC_Any_VP:{
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Any unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
         fatalerr(104, &var);
         }
      if ((k_pos <= Length) && Testb(ToAscii(pat_sub[k_pos - 1]), var)) {
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      break;
      }
   case PC_Any_VF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Any unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      if ((k_pos <= Length) && Testb(ToAscii(pat_sub[k_pos - 1]), cresult)) {
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      break;
      }
   case PC_Any_MF: {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Any unevaluated method call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      if ((k_pos <= Length) && Testb(ToAscii(pat_sub[k_pos - 1]), cresult)) {
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      break;
      }

      /*
       *  Arb (initial match)
       */
   case PC_Arb_X : {
      DEBUGF(20,(stdout, "matching Arb\n"));
      Push ((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
      /*
       *  Arb (extension)
       */
   case PC_Arb_Y : {
      DEBUGF(20,(stdout, "extending Arb"));
      if (k_pos <= Length){
         k_pos++;
         Push (Node);
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      break;
      }
      /*
       *  Arbno_S (simple Arbno initialize). This is the node that
       *  initiates the match of a simple Arbno structure.
       */
   case PC_Arbno_S : {
      DEBUGF(20,(stdout,"setting up Arbno alternative "));
      Push ((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
      /*
       *   Arbno_X (Arbno initialize). This is the node that initiates
       *   the match of a complex Arbno structure.
       */
   case PC_Arbno_X: {
      DEBUGF(20,(stdout,"setting up Arbno alternative "));
      Push ((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
      /*
       *   Arbno_Y (Arbno rematch). This is the node that is executed
       *   following successful matching of one instance of a complex
       *   Arbno pattern.
       */
   case PC_Arbno_Y : {
      int  Null_Match = 0;
      if ((k_pos - 1) == StackCursor(Stack_Base - 1))
         Null_Match = 1;
      DEBUGF(20,(stdout,"extending Arbno"));
      Pop_Region();

      /*
       *   If arbno extension matched null, then immediately fail
       */
      if (Null_Match){
         DEBUGF(20,(stdout,"Arbno extension matched null, so fails"));
         goto Node_Fail;
         }
      /*
       *   Here we must do a stack check to make sure enough stack
       *   is left. This check will happen once for each instance of
       *   the Arbno pattern that is matched. The parameter field of a
       *   PC_Arbno pattern contains the maximum stack entries needed
       *   for the Arbno with one instance and the successor pattern
       */
      if (Stack_Ptr + IntVal(Node->parameter) >= Stack_Size){
         fatalerr(309, NULL);
         }
      goto Node_Succeed;
      }
      /*
       *  Assign. If this node is executed, it means the assign-on-match
       *  or write-on-match operation will not happen after all, so we
       *  is propagate the failure, removing the PC_Assign node.
       */
   case PC_Assign : {
      goto Node_Fail;
      }
      /*
       *   Assign immediate. This node performs the actual assignment.
       */
   case  PC_Assign_Imm : {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout, "executing immediate assignment\n"));
      if (var.dword == D_File) {
         struct b_file *f;
         f = (struct b_file *)BlkLoc(var);
         fwrite(pat_sub + StackCursor(Stack_Base - 1), 1,
                (k_pos - 1) - StackCursor(Stack_Base - 1), f->fd.fp);
         fputc('\n', f->fd.fp);
         fflush(f->fd.fp);
         }
      else {
         EVVar(&varref, E_Assign);
         StrLen(*pvar) = (k_pos - 1) - StackCursor(Stack_Base - 1);
         StrLoc(*pvar) = pat_sub + StackCursor(Stack_Base - 1);
         EVValD(pvar, E_Value);
         }
      Pop_Region();
      goto Node_Succeed;
      }
      /*
       * Assign on match. This node sets up for the eventual assignment
       */
   case PC_Assign_OnM : {
      StackNode(Stack_Base - 1) = (union block *)Node;
      Push (&CP_Assign);
      Pop_Region();
      Assign_OnM = 1;
      goto Node_Succeed;
      }
      /*
       * Abort
       */
   case PC_Abort: {
      DEBUGF(20,(stdout, "matching Abort"));
      goto Match_Fail;
      }
      /*
       *   Bal
       */
   case PC_Bal : {
      DEBUGF(2,(stdout,"matching or extending Bal\n"));
      if (((k_pos - 1) >= Length) || pat_sub[k_pos - 1] == ')')
         goto Node_Fail;
      else if (pat_sub[k_pos - 1] == '('){
         int Paren_Count = 1;
         DEBUGF(2,(stdout,
                   "Paren_Count = %d  Pos = %ld\n", Paren_Count, k_pos));
         while(1) {
            k_pos++;
            if ((k_pos - 1) >= Length) {
               goto Node_Fail;
               }
            else if (pat_sub[k_pos - 1] == '(' ){
               Paren_Count++;
               DEBUGF(2,(stdout,
                         " Found ( Paren_Count = %d  Pos = %ld\n",
                         Paren_Count,k_pos));
               }
            else if (pat_sub[k_pos - 1] == ')'){
               Paren_Count--;
               DEBUGF(2,(stdout,
                         "Found ) Paren_Count = %d  Pos = %ld\n",
                         Paren_Count,k_pos));
               }
            if (Paren_Count == 0) {
               DEBUGF(2,(stdout,
                         "Paren_Count = %d  Pos = %ld\n",
                         Paren_Count,k_pos));
               break;
               }
            }
         }
        k_pos++;
        Push (Node);
        DEBUGF(2,(stdout,
                  "matching or extending Bal succeeded, Pos = %ld\n",
                  k_pos));
        EVVal(k_pos, e_spos);
        goto Node_Succeed;
    }

      /*
       * Break (character set case)
       */
   case PC_Break_CS : {
      int start_kpos = k_pos;
      DEBUGF(20,(stdout, "matching Break\n"));
      while( k_pos <= Length ){
         if (Testb(ToAscii(pat_sub[k_pos - 1]), Node->parameter)) {
            if (k_pos != start_kpos)
               EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      /* probably discarded, but if Break() failed, k_pos didn't change. */
      if (k_pos != start_kpos)
         k_pos = start_kpos;
      goto Node_Fail;
      break;
      }
   case PC_Break_VP :{
      int start_kpos = k_pos;
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Break unevaluated variable\n"));
      if (!cnv_cset(&var,&var)){
         fatalerr(104, &var);
         }
      while( k_pos <= Length ){
         if (Testb(ToAscii(pat_sub[k_pos - 1]), var)) {
            if (k_pos != start_kpos)
               EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      if (k_pos != start_kpos)
         k_pos = start_kpos;
      goto Node_Fail;
      break;
      }
   case PC_Break_VF :{
      int start_kpos = k_pos;
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Break unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while (k_pos <= Length ){
         if (Testb(ToAscii(pat_sub[k_pos - 1]), cresult)) {
            if (k_pos != start_kpos)
               EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      if (k_pos != start_kpos)
         k_pos = start_kpos;
      goto Node_Fail;
      break;
      }

   case PC_Break_MF :{
      int start_kpos = k_pos;
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Break unevaluated method call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while( k_pos <= Length ){
         if (Testb(ToAscii(pat_sub[k_pos - 1]), cresult)) {
            if (k_pos != start_kpos)
               EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      /* if a Break has failed, should &pos have changed at all? */
      if (k_pos != start_kpos)
         k_pos = start_kpos;
      goto Node_Fail;
      break;
      }

      /*
       * BreakX (character set case). By themselves, these are incorrect.
       * BreakX starts like Break, but on failure it looks for more.
       * That is what the BreakX_X node is for.
       */
   case PC_BreakX_CS: {
      DEBUGF(20,(stdout, "matching Breakx\n"));
      while( k_pos <= Length ){
         if (Testb(ToAscii(pat_sub[k_pos - 1]), Node->parameter)) {
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      EVVal(k_pos, e_spos);
      goto Node_Fail;
      break;
      }
   case PC_BreakX_VP : {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Breakx unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
         fatalerr(104, &var);
         }

      while (k_pos <= Length) {
         if (Testb(ToAscii(pat_sub[k_pos - 1]), var)) {
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      EVVal(k_pos, e_spos);
      goto Node_Fail;
      break;
      }
   case PC_BreakX_VF : {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Breakx unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while (k_pos <= Length) {
         if (Testb(ToAscii(pat_sub[k_pos - 1]), cresult)) {
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      EVVal(k_pos, e_spos);
      goto Node_Fail;
      break;
      }
   case PC_BreakX_MF : {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Breakx unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while (k_pos <= Length) {
         if (Testb(ToAscii(pat_sub[k_pos - 1]), cresult)) {
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            k_pos++;
            }
         }
      EVVal(k_pos, e_spos);
      goto Node_Fail;
      break;
      }

      /*
       *   BreakX_X (BreakX extension). See section on "Compound Pattern
       *   Structures". This node is the alternative that is stacked to
       *   skip past the break character and extend the break.
       */
   case  PC_BreakX_X : {
      k_pos++;
      EVVal(k_pos, e_spos);
      goto Node_Succeed;
      }

      /*
       * Fail
       */
   case PC_Fail: {
      DEBUGF(20,(stdout, "matching Fail"));
      goto Node_Fail;
      }

      /*
       *   Fence (built in pattern)
       */
   case PC_Fence : {
      Push (&CP_Abort);
      goto Node_Succeed;
      }

      /*
       *   Fence function node X. This is the node that gets control
       *   after a successful match of the fenced pattern.
       */
   case  PC_Fence_X : {
      Stack_Ptr++;
      Stack->next->Lelem.nused++;
      StackCursor(Stack_Ptr) = Stack_Base;
      StackNode(Stack_Ptr)   = (union block *)&CP_Fence_Y;
      Stack_Base = StackCursor(Stack_Base);
      goto Node_Succeed;
      }

      /*
       *   Fence function node Y. This is the node that gets control on
       *   a failure that occurs after the fenced pattern has matched.
       *
       *   Note: the position at this stage is actually the inner stack
       *   base value. We don't reset this, but we do use it to strip
       *   off all the entries made by the fenced pattern.
       */
   case PC_Fence_Y : {
      Stack_Ptr = k_pos - 3;
      Stack->next->Lelem.nused = k_pos - 3;
      goto Node_Fail;
      }

      /*
       *  Unevaluated function call
       */
   case  PC_Pred_Func: {
      GetResultFromFuncCall();
      /*
       * If the func failed, call_result would have been NULL and the
       * above macro would have failed.  Otherwise, it succeeded and
       * points at a return value.
       */
      goto Node_Succeed;
      }

   case  PC_Pred_MF:{
      GetResultFromMethodCall();
      if (call_result == 0)
         goto Node_Fail;
      else {
         if(is:string(cresult)) {
            int LV_Len = StrLen(cresult);
            DEBUGF(20,(stdout, "Matching unevaluated String variable \n"));
            if ((Length - (k_pos - 1) >= LV_Len )
                && !strncmp(pat_sub + (k_pos - 1), StrLoc(cresult), LV_Len)){
               k_pos += LV_Len;
               EVVal(k_pos, e_spos);
               goto Node_Succeed;
               }
            else {
               goto Node_Fail;
               }
            }
          goto Node_Succeed;
          }
      break;
      }

   case PC_Len_Nat: {
      DEBUGF(20,(stdout, "matching Len Nat\n"));
      /*
       * k_pos is 1-based. k_pos + Len should be allowed, as a legal value,
       * to go up to Length+1.  Greater than Length+1 it is out of range.
       */
      if (k_pos + IntVal(Node->parameter) > Length+1) {
         goto Node_Fail;
         }
      else {
         k_pos += IntVal(Node->parameter);
         EVVal(k_pos, e_spos);
         }
      goto Node_Succeed;
      break;
      }
   case PC_Len_NP: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Len unevaluated variable\n"));
      if (!cnv_int(&var,&var)) {
         fatalerr(101, &var);
         }
      DEBUGF(20,(stdout, "matching Len\n"));
      if (k_pos + IntVal(var) > Length+1) {
         goto Node_Fail;
         }
      else {
         k_pos += IntVal(var);
         EVVal(k_pos, e_spos);
         }
      goto Node_Succeed;
      break;
      }

   case PC_Len_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Len unevaluated function call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if (k_pos + IntVal(cresult) > Length+1) {
         goto Node_Fail;
         }
      k_pos += IntVal(cresult);
      EVVal(k_pos, e_spos);
      goto Node_Succeed;
      break;
      }

   case PC_Len_NMF:{
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Len unevaluated function call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if (k_pos + IntVal(cresult) > Length+1) {
         goto Node_Fail;
         }
      k_pos += IntVal(cresult);
      EVVal(k_pos, e_spos);
      goto Node_Succeed;
      break;
      }

   case PC_NotAny_CS : {
      DEBUGF(20,(stdout, "matching NotAny\n"));
      if ((k_pos <= Length) &&
          !Testb(ToAscii(pat_sub[k_pos - 1]), Node->parameter)) {
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case PC_NotAny_VP : {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching NotAny unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
         fatalerr(104, &var);
         }
      DEBUGF(20,(stdout, "matching NotAny_VP\n"));
      if ((k_pos <= Length) &&
          !Testb(ToAscii(pat_sub[k_pos - 1]), var)){
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case PC_NotAny_VF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching NotAny unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      DEBUGF(20,(stdout, "matching NotAny\n"));
      if ((k_pos <= Length) &&
          !Testb(ToAscii(pat_sub[k_pos - 1]), cresult)){
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case PC_NotAny_MF : {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching NotAny unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      DEBUGF(20,(stdout, "matching NotAny\n"));
      if ((k_pos <= Length) &&
          !Testb(ToAscii(pat_sub[k_pos - 1]), cresult)){
         k_pos++;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

      /*
       *  Initiate recursive match (pattern pointer case)
       */
   case PC_Rpat: {
      GetVarFromNodeParameter(Node);
      type_case var of {
      string: {
         int LV_Len = StrLen(var);
         DEBUGF(20,(stdout, "Matching unevaluated String variable \n"));
         if ((Length - (k_pos - 1) >= LV_Len )
             && !strncmp(pat_sub + (k_pos - 1), StrLoc(var), LV_Len)){
            k_pos += LV_Len;
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            goto Node_Fail;
            }
         break;
         }

      cset: {
         DEBUGF(20,(stdout,"Matching unevaluated cset variable\n"));
         if ((k_pos <= Length) && Testb(ToAscii(pat_sub[k_pos - 1]), var)) {
            k_pos++;
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            goto Node_Fail;
            }
         break;
         }
      pattern: {
         DEBUGF(20,(stdout, "Matching unevaluated pattern variable\n"));
         StackNode(Stack_Ptr + 1) = Node->pthen;
         Push_Region();
         if (Stack_Ptr +
             ((struct b_pattern *)BlkLoc(var))->stck_size >= Stack_Size) {
            fatalerr(309, NULL);
            }
         else {
            Node = (struct b_pelem *) ((struct b_pattern *)BlkLoc(var))->pe;
            goto Match;
            }
         break;
         }
      default: {
         fatalerr(161, NULL);
         }
         }
      }

      /*
       *  Pos
       */
   case PC_Pos_Nat: {
      if (k_pos == IntVal(Node->parameter))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

   case PC_Pos_NP:{
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Pos unevaluated variable\n"));
      if (!cnv_int(&var,&var)) {
         fatalerr(101, &var);
         }
      DEBUGF(20,(stdout, "matching Len\n"));
      if (k_pos == IntVal(var))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

   case PC_Pos_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Len unevaluated function call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if (k_pos == IntVal(cresult))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

   case PC_Pos_NMF: {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Len unevaluated function call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if (k_pos == IntVal(cresult))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

      /*
       *   Tab (integer case)
       */
   case  PC_Tab_Nat: {
      if (IntVal(Node->parameter) - 1 <= Length){
         k_pos = IntVal(Node->parameter);
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_Tab_NP: {
      GetVarFromNodeParameter(Node);
      if (!cnv_int(&var,&var)) {
         fatalerr(101, &var);
         }
      if (IntVal(var) - 1 <= Length) {
         k_pos = IntVal(var);
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_Tab_NF: {
      GetResultFromFuncCall();
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if (IntVal(cresult) - 1 <= Length) {
         k_pos = IntVal(cresult);
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_Tab_NMF: {
      GetResultFromMethodCall();
      if (call_result == 0) {
         goto Node_Fail;
         }
      else {
         if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
            fatalerr(101, &cresult);
         cresult.dword = D_Integer;
         }
      if (IntVal(cresult) - 1 <= Length) {
         k_pos = IntVal(cresult);
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

      /*
       * Rest
       */
   case PC_Rest: {
      k_pos = Length + 1;
      EVVal(k_pos, e_spos);
      goto Node_Succeed;
      }

      /*
       *  RPos
       */
   case PC_RPos_Nat: {
      if ((k_pos - 1) == (Length - IntVal(Node->parameter)))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

   case PC_RPos_NP: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Rpos unevaluated variable\n"));
      if (!cnv_int(&var,&var)){
         fatalerr(101, &var);
         }
      DEBUGF(20,(stdout, "matching Len\n"));
      if ((k_pos - 1) == (Length - IntVal(var)))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

   case PC_RPos_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching RPos unevaluated function call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if ((k_pos - 1) == (Length - IntVal(cresult)))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

   case PC_RPos_NMF: {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching RPos unevaluated function call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if ((k_pos - 1) == (Length - IntVal(cresult)))
         goto Node_Succeed;
      else {
         goto Node_Fail;
         }
      }

      /*
       *   RTab (integer case).
       */
   case  PC_RTab_Nat: {
      if ((0<=IntVal(Node->parameter)) & (IntVal(Node->parameter) <= Length)) {
         k_pos = Length - IntVal(Node->parameter) + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_RTab_NP: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching RTab unevaluated variable\n"));
      if (!cnv_int(&var,&var)){
         fatalerr(101, &var);
         }
      DEBUGF(20,(stdout, "matching Len\n"));
      if ((0<=IntVal(var)) & (IntVal(var) <= Length)) {
         k_pos = Length - IntVal(var) + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_RTab_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching RTab unevaluated function call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if ((0<=IntVal(cresult)) & (IntVal(cresult) <= Length)) {
         k_pos = Length - IntVal(cresult) + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_RTab_NMF: {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching RTab unevaluated method call\n"));
      if (!cnv_c_int(&cresult, &(cresult.vword.integr)))
         fatalerr(101, &cresult);
      cresult.dword = D_Integer;
      if ((0<=IntVal(cresult)) & (IntVal(cresult) <= Length)) {
         k_pos = Length - IntVal(cresult) + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

      /*
       *   Region Enter. Initiate new pattern history stack region
       */
   case PC_R_Enter : {
      DEBUGF(20,(stdout, "starting match of nested pattern\n"));
      StackCursor(Stack_Ptr + 1) = k_pos - 1;
      Push_Region();
      goto Node_Succeed;
      }

      /*
       *   Region Remove node. This is the node stacked by an R_Enter.
       *   It removes the special format stack entry right underneath, and
       *   then restores the outer level stack base and signals failure.
       *
       *   Note: the cursor value at this stage is actually the (negative)
       *   stack base value for the outer level.
       */
   case PC_R_Remove : {
      DEBUGF(20,(stdout,"failure, match of nested pattern terminated\n"));
      Stack_Base = k_pos - 1;
      Region_Level--;
      Stack_Ptr--;
      Stack->next->Lelem.nused--;
      goto Node_Fail;
      }

      /*
       *   Region restore node. This is the node stacked at the end of an
       *   inner level match. Its function is to restore the inner level
       *   region, so that alternatives in this region can be sought.
       *
       *   Note: the position at this stage is actually the negative of the
       *   inner stack base value, which we use to restore the inner region.
       */
   case  PC_R_Restore : {
      DEBUGF(20,(stdout,
                 "failure, search for alternatives in nested pattern\n"));
      Region_Level = Region_Level + 1;
      Stack_Base = k_pos - 1;
      goto Node_Fail;
      }

   case PC_Setcur: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout, "Matching Setcur assigning Position = %ld\n", k_pos));
      EVVar(&varref, e_assign);
      pvar->dword = D_Integer;
      IntVal(*pvar) = k_pos;
      EVValD(pvar, e_value);
      goto Node_Succeed;
      }

   case  PC_Span_CS : {
      int P = k_pos - 1;
      DEBUGF(20,(stdout,"Matching Span_CS\n"));
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),Node->parameter))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_Span_VP : {
      int P = k_pos - 1;
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Span unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
         fatalerr(104, &var);
         }
      DEBUGF(20,(stdout,"Matching Span_VP\n"));
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),var))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_Span_VF: {
      int P = k_pos - 1;
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Span_VF unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),cresult))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_Span_MF: {
      int P = k_pos - 1;
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Span_MF unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),cresult))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_NSpan_CS : {
      int P = k_pos - 1;
      DEBUGF(20,(stdout,"Matching NSpan_CS\n"));
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),Node->parameter))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         }
      goto Node_Succeed;
      }

   case  PC_NSpan_VP : {
      int P = k_pos - 1;
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching NSpan unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
         fatalerr(104, &var);
         }
      DEBUGF(20,(stdout,"Matching NSpan_VP\n"));
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),var))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         }
      goto Node_Succeed;
      }

   case  PC_NSpan_VF: {
      int P = k_pos - 1;
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching NSpan_VF unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),cresult))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         }
      goto Node_Succeed;
      }

   case  PC_NSpan_MF: {
      int P = k_pos - 1;
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching NSpan_MF unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
         fatalerr(104, &cresult);
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),cresult))
         P++;
      if (P != (k_pos - 1)) {
         k_pos = P + 1;
         EVVal(k_pos, e_spos);
         }
      goto Node_Succeed;
      }

   case  PC_String : {
      int LV_Len = StrLen(Node->parameter);
      DEBUGF(20,(stdout,"Matching String \"%*s\" against %s, Length %d Pos %ld Len %d\n", LV_Len, StrLoc(Node->parameter), pat_sub, Length, k_pos, LV_Len));
      if ((Length - (k_pos - 1) >= LV_Len) &&
          !strncmp(pat_sub + (k_pos - 1), StrLoc(Node->parameter), LV_Len)) {
         k_pos += LV_Len;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

   case  PC_String_VP : {
      int LV_Len;
      GetVarFromNodeParameter(Node);
      LV_Len = StrLen(var);
      DEBUGF(20,(stdout,"Matching String\n"));
      if ((Length -(k_pos - 1) >= LV_Len) &&
          !strncmp(pat_sub + (k_pos - 1), StrLoc(var), LV_Len)) {
         k_pos += LV_Len;
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      else {
         goto Node_Fail;
         }
      }

      /*
       */
   case  PC_String_VF: {
      GetResultFromFuncCall();
      if (cnv_str(&cresult,&cresult)) {
         int LV_Len = StrLen(cresult);
         DEBUGF(20,(stdout,"Matching String\n"));
         if ((Length - (k_pos - 1) >= LV_Len) &&
             !strncmp(pat_sub + (k_pos - 1), StrLoc(cresult), LV_Len)) {
            k_pos += LV_Len;
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            goto Node_Fail;
            }
         }
      /* should instead probably be a runtime error */
      goto Node_Succeed;
      }

   case PC_String_MF: {
      GetResultFromMethodCall();
      if (cnv_str(&cresult,&cresult)) {
         int LV_Len = StrLen(cresult);
         DEBUGF(20,(stdout,"Matching String\n"));
         if ((Length - (k_pos - 1) >= LV_Len) &&
             !strncmp(pat_sub + (k_pos - 1), StrLoc(cresult), LV_Len)) {
            k_pos += LV_Len;
            EVVal(k_pos, e_spos);
            goto Node_Succeed;
            }
         else {
            goto Node_Fail;
            }
         }
      /* should instead probably be a runtime error */
      goto Node_Succeed;
      }

      /*
       *  Succeed
       */
   case PC_Succeed: {
      DEBUGF(20,(stdout,"matching Succeed"));
      Push (Node);
      goto Node_Succeed;
      }

   case PC_Unanchored : {
      /* --  All done if we tried every position  */
      if (k_pos >= Length )
         goto Match_Fail;
      /* --  Otherwise extend the anchor point, and restack ourself */
      else{
         k_pos++;
         Push (Node);
         EVVal(k_pos, e_spos);
         goto Node_Succeed;
         }
      }

      /*
       *  End of Pattern
       */
   case  PC_EOP: {
      if (Stack_Base == Stack_Init) {
         goto Match_Succeed;
         }
      /*
       *   End of recursive inner match. See separate section on
       *   handing of recursive pattern matches for details.
       */
      else {
         Node = (struct b_pelem *)StackNode(Stack_Base - 1);
         Pop_Region();
         goto Match;
         }
      }
      }
   {
   char buf[64];
   sprintf(buf, "Unrecognized pcode %ld in internal match.", (long)Node->pcode);
   syserr(buf);
   }
}
#enddef

#ifdef MultiProgram
internal_match_macro(internal_match_0,0,0,0,0,0,0,0,0,0)
internal_match_macro(internal_match_1,E_PatFail,E_PatMatch,E_PatArg,E_PelemAttempt,E_PelemMatch,E_PelemFail,E_Assign,E_Value,E_Spos)
#else                                   /* MultiProgram */
internal_match_macro(internal_match,0,0,0,0,0,0,0,0,0)
#endif                                  /* MultiProgram */

/* keep this at the end so the #undef Fail affects no-one else */
#undef Fail
function {1} Fail()
   abstract {
      return pattern;
      }
   body {
      union block *bp = pattern_make(0, &EOP,PC_Fail,1, nulldesc);
      EVVal(PC_Fail, E_PatCode);
      return pattern(bp);
      }
end

#endif                                  /* PatternType */

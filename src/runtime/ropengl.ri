/*
 *  File: ropengl.ri
 *     3D facilities OpenGL support routines
 */
int alcinstalltex(int k, wdp wd, GLubyte *tex, int width, int height);
int bltex(wbp w, int width, int height, int ch, char *s, word len);
int determinematerial(char *, C_integer, C_integer, C_integer, C_integer);
int lookup_texture_byname(wbp w, char *name, int len, int type, int curtex);
int texture(int width, int height, GLubyte *tex, int texmode);
int texture_24img(wbp w, struct imgdata im);
int textureimg(wbp w, int width, int height,
		struct palentry *e, unsigned char *s, word len);
int init_3dcontext(wcp wc);

FILE *wopengl(char *name, struct b_list *lp, dptr attr, int n, int *err_index)
{
   FILE *f;
   wbp  w;
   wcp  wc;
   int  query;

#ifdef XWindows
   /*
    * Allocate a display structure. Note that this is just to check
    * whether the X server has GLX; wopen() will call it again and
    * initialize ws->display and wc->display. So this is under #ifdef XWindows.
    * The redundant calls to alc_display() is harmless as it will just return
    * pointer to already-allocated connection but:
    *
    * BUG: this code looks to be ignoring any explicit display= assignment
    * in attr, if anyone still uses non-local displays any more then we
    * should fix it.  alc_display() honors/uses a DISPLAY environment variable.
    */
   wdp wd = alc_display(NULL);
   if (wd==NULL) {
      fprintf(stderr, "can't allocate a new display: ");
      return NULL;
      }

    if (setglXVisual(wd) == 0)
       return NULL;
#endif					/* XWindows */

   f = wopen(name, lp, attr, n, err_index, 1);

   if (!f) return NULL;
   w = (wbp) f;
   wc = w->context;

   if (init_3dcontext(wc) == Failed) return NULL;

   /* create displaylist moved up into wopen so it exists during attrib sets */

   /* initialize opengl state*/
   if (init_3dcanvas(w) == Failed) return NULL;

   return f;
}

/*
 * Initialize texture names.
 */

/*
 * Initialize the 3D subsystem for rendering.
 */
/*
 * Initialize the 3D subsystem for rendering.
 */
int init_3dcanvas(wbp  w)
{
/*   GLfloat ambient_model[] = {0.2, 0.2, 0.2, 1.0}; */
   wsp ws;
   wcp wc;

   ws= w->window;
   wc= w->context;

   /* set up the appropriate opengl states */
   glViewport(0, 0, (GLsizei)ws->width, (GLsizei)ws->height);
   glClearColor(RED(wc->bg)/(GLfloat)255, GREEN(wc->bg)/(GLfloat)255,
		BLUE(wc->bg)/(GLfloat)255, 0.0);

   glShadeModel(GL_SMOOTH);

   if (wc->display->stex == NULL) {
      wc->display->ntextures = 0;
      wc->display->maxstex = INITTEXTURENUM;

      wc->display->stex =
	 (struct _wtexture *) malloc(INITTEXTURENUM*sizeof(struct _wtexture));
      if (wc->display->stex == NULL) return Failed;

      if (init_texnames(w->context) == Failed) return Failed ;

      }
   
   /*glPolygonMode(GL_FRONT, GL_FILL);*/
   glEnable(GL_DEPTH_TEST);
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glEnable(GL_TEXTURE_GEN_S);
   glEnable(GL_TEXTURE_GEN_T);
   glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);
   glEnable(GL_NORMALIZE);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	     0.125 * ws->height / ws->width, 0.25, 50000.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   return Succeeded;
}

/*
* release_3d_resources - free all resources used for 3D graphics
*/
int release_3d_resources(wbp w)
{
   int i;
   wcp wc = w->context;
   wdp wd = w->window->display;

#if 0
   /* need to consider what 3D resources can be freed in the wdp and when */
   for (i=0; i < wd->ntextures; i++) {
      free(wd->stex[i].tex);
      wd->stex[i].w=0;
   }
   free(wd->stex);
   wd->stex = NULL;
#endif
   i = wc->selectionnamecount;
   while (i){
      free(wc->selectionnamelist[--i]);
   }
   free(wc->selectionnamelist);
#ifdef XWindows
   glXDestroyContext( wd->display, wc->ctx);
#endif					/* XWindows */
   return 0;
}

/*
 * check if we have enough textures names (and records)
 * try to allocate if we need more
 */

int make_enough_texture_space(wdp wd)
{
   GLuint *texName;
   int i, newmax;
   if (wd->ntextures >= wd->maxstex) {
      SUSPEND_THREADS();

      /* 
       * Allocate space and create new opengl texture names
       */
      if (wd->ntextures >= wd->maxstex) {
         texName = malloc(wd->maxstex * sizeof(GLuint));
         if (texName == NULL) {
            RESUME_THREADS();
            return Failed;
            }
         glGenTextures(wd->maxstex, texName);

    	 newmax = wd->maxstex * 2;

	 /*
	  * Expand the texture storage and copy the new OpenGL names into place
	  */
      	 wd->stex = realloc(wd->stex, sizeof(struct _wtexture) * newmax);
     	 if (wd->stex == NULL) {
           RESUME_THREADS();
	   free(texName);
       	   return Failed;
	   }
         for (i=wd->maxstex; i<newmax; i++)
            wd->stex[i].texName = texName[i-wd->maxstex];

         wd->maxstex = newmax;

      	 RESUME_THREADS();
      	 free(texName);
      	 }
      }
   return Succeeded;
}

int init_texnames(wcp wc)
{
   wdp wd = wc->display;
   GLuint texNames[INITTEXTURENUM];
   int i;

   if (wd->stex == NULL) 
      return Failed;
 
   glGenTextures(INITTEXTURENUM, texNames);
 
   for (i=0; i<INITTEXTURENUM; i++){
      wd->stex[i].texName = texNames[i];
}

   return Succeeded;
}

/*
 * Emergent piece of redundant code for installing a texture, growing if needed
 */
int alcinstalltex(int k, wdp wd, GLubyte *tex, int width, int height)
{
   if (k >= wd->maxstex) {
      if (make_enough_texture_space(wd)==Failed) return Failed;
      }
   wd->stex[k].tex = tex;
   wd->stex[k].width = width;
   wd->stex[k].height = height;
   return Succeeded;
}


/* calculates the surface normal "n" given three vertices on the surface */
void calcNormal( double* v0, double* v1, double *v2, double* n )
{
    double a, b, c;
    double d, e, f;
/*    double l;
*/
    a = v1[0] - v0[0];
    b = v1[1] - v0[1];
    c = v1[2] - v0[2];

    d = v2[0] - v0[0];
    e = v2[1] - v0[1];
    f = v2[2] - v0[2];

    n[0] = b * f - c * e;
    n[1] = c * d - a * f;
    n[2] = a * e - b * d;

    /* no need for normalization for now. OpenGL do it for us */
    /*l = (GLfloat)sqrt((n[0] * n[0]) + (n[1] * n[1]) + (n[2] * n[2]));

    n[0] = n[0] / l;
    n[1] = n[1] / l;
    n[2] = n[2] / l;
    */
}

int setnormals(double *norm){
 
  return 0;
}



/*
 * code for primitives -- polygon, lines, points, segments, filled polygons,
 * tori, spheres, cubes, cylinders, and disks.
 */

/*
 * drawpoly() - draws polygons, lines, points, segments, and filled polygons
 */
int drawpoly(wbp w, double* v, int num, int type, int dim)
{
   int i, j;
   double n[3] = {0.0, 0.0, 1.0};
   wcp wc = w->context;

   makecurrent(w);
   
   /* each vertex has an x-coordinate and a y-coordinate */
   if (dim == 2){
      /* must reset the current normal vector */
      glNormal3dv(n);
      /* no texturing */
      if (!wc->texmode) {
         glBegin(type);
         for (i = 0; i < num; i=i+2)
            glVertex2d(v[i], v[i+1]);
         glEnd();
        }
      else {
         /* opengl will generate texture coordinates */
         if (wc->autogen) {
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+2)
               glVertex2d(v[i], v[i+1]);
            glEnd();
           }
         else {
	    double *atex=wc->texcoords->a;
            /*
             * There must be at least the same number of texture coordinate
             * pairs as there are vertices. If not, fail.
             */
            if (num/2 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i = i+2) {
               glTexCoord2f(atex[j], atex[j+1]);
               glVertex2d(v[i], v[i+1]);
               j += 2;
             }
            glEnd();
           }
        }
     }

   /* each vertex is of the form (x, y, z) */
   if (dim == 3){
      double *vnorm;
/*      int vcount;
      int normcount;
*/      
      /*prepare normals for normals auto mode*/
      if(wc->normode==1){ 
         /*vnorm = malloc (num*sizeof(double));*
/*	 if (type==GL_TRIANGLES || type==GL_TRIANGLE_FAN || type ==GL_TRIANGLE_STRIP)
	   vcount=3;
	 else if (type==GL_QUADS || type==GL_QUAD_STRIP)
	   vcount = 4;
	 else  if (type==GL_POLYGON)
	   vcount = 3;
	 normcount = num - num % (vcount);
 */	if (num>9){
	  calcNormal(&v[0], &v[3], &v[6], n );
	  }
	  glNormal3dv(n);
	  
         /*for (i = 0; i < num; i = i+3){
	    vnorm[i] = n[0];
	    vnorm[i+1] = n[1];
	    vnorm[i+2] = n[2];
	   }
	   */
	}
      else if(wc->normode==2){ /* normals are supplied by the user*/
	  if (num > wc->numnormals) return Failed;
	  vnorm = wc->normals->a;
	  }
      else
	/* must reset the current normal vector */
	glNormal3dv(n);
      
      if (!wc->texmode) {
	  if(wc->normode==2){
	    glBegin(type);
	    for (i = 0; i < num; i = i+3){
	       glNormal3dv(&vnorm[i]);
	       glVertex3dv(&v[i]);
	       }
	    glEnd();
	    }
	 else{
	    glBegin(type);
	    for (i = 0; i < num; i = i+3)
	       glVertex3dv(&v[i]);
	    glEnd();
	    }
	}
      else {

	 /* opengl should generate the texture coordinate */
         if (wc->autogen){

            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);

	    if(wc->normode==2){
	       glBegin(type);
	       for (i = 0; i < num; i = i+3){
		  glNormal3dv(&(vnorm[i]));
		  glVertex3dv(&v[i]);
		  }
	       glEnd();
	       }
	    else{
	       glBegin(type);
	       for (i = 0; i < num; i = i+3)
		  glVertex3dv(&v[i]);
	       glEnd();
	       }
           }
         else {
            /*
	     * If there are not the same number of texture coordinate pairs
	     * as there are vertices, fail.
	     */
            if (num/3 > wc->numtexcoords/2)
              return Failed;
	    j = 0;
	    if(wc->normode==2){
	      /*
	       glEnableClientState(GL_VERTEX_ARRAY);
	       glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	       glEnableClientState(GL_NORMAL_ARRAY);
	       glVertexPointer(3, GL_DOUBLE, 0, v);
	       glNormalPointer(GL_DOUBLE, 0, vnorm);
	       glTexCoordPointer(2, GL_DOUBLE, 0, wc->texcoords->a);
	       glDrawArrays(type, 0, num);
	       glDisableClientState(GL_VERTEX_ARRAY);
	       glDisableClientState(GL_TEXTURE_COORD_ARRAY);
	       glDisableClientState(GL_NORMAL_ARRAY);
	       */
	       glBegin(type);
	       for (i = 0; i < num; i = i+3){
		  glNormal3dv(&(vnorm[i]));
		  glTexCoord2f(wc->texcoords->a[j], wc->texcoords->a[j+1]);
		  j = j + 2;
		  glVertex3dv(&v[i]);
		  }
	       glEnd();
	       
	       }
	    else {
	      /*
	       glEnableClientState(GL_VERTEX_ARRAY);
	       glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	       glVertexPointer(3, GL_DOUBLE, 0, v);
	       glTexCoordPointer(2, GL_DOUBLE, 0, wc->texcoords->a);
	       glDrawArrays(type, 0, num);
	       glDisableClientState(GL_VERTEX_ARRAY);
	       glDisableClientState(GL_TEXTURE_COORD_ARRAY);
	       */

	       glBegin(type);
	       for (i = 0; i < num; i = i+3){
		  glTexCoord2f(wc->texcoords->a[j], wc->texcoords->a[j+1]);
		  j = j + 2;
		  glVertex3dv(&v[i]);
		  }
	       glEnd();
	       }
         }
      }
      
   }
   /* each vertex is of the form (x, y, z, w) */
   if (dim == 4){
      if (!wc->texmode){
         glBegin(type);
         for (i = 0; i < num; i=i+4)
            glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
         glEnd();
        }
      else {
         /* have opengl generate texture coordinates */
         if (wc->autogen){
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glBegin(type);
            for (i = 0; i < num; i=i+4)
              glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
            glEnd();
           }
	 else {
	    /*
	     * fail if the number of vertices is more than
	     * the number of texture coordinate pairs
	     */
            if (num/4 > wc->numtexcoords/2)
               return Failed;
            glBegin(type);
            j = 0;
            for (i = 0; i < num; i=i+4) {
               glTexCoord2f(wc->texcoords->a[j], wc->texcoords->a[j+1]);
               glVertex4d(v[i], v[i+1], v[i+2], v[i+3]);
               j = j + 2;
              }
            glEnd();
           }
         }
       }
   return Succeeded;
}


/* helper function to draw a torus */
void torus(double radius1, double radius2, double x,double y, double z,
	   int slices, int rings, int gen)
{
   int i, j;
   GLfloat theta, phi, theta1;
   GLfloat cosTheta, sinTheta;
   GLfloat cosTheta1, sinTheta1;
   GLfloat ringDelta, sliceDelta;

   /* generate texture coordinates if needed */
   if (gen == 1){
      glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
      }

   /* push matrix to preform the needed translation */
   glPushMatrix();
   glTranslatef(x, y, z);

#ifndef M_PI
#define M_PI        3.14159265358979323846264338327950288419716939937511
#endif					/* M_PI */

   /* rotate to make the torus look nicer */
   glRotatef(130.0, 1.0, 0.0, 0.0);
   ringDelta = 2.0 * M_PI / rings;
   sliceDelta = 2.0 * M_PI / slices;
   theta = 0.0;
   cosTheta = 1.0;
   sinTheta = 0.0;

   /* draw the torus */
   for (i = rings - 1; i >= 0; i--) {
      theta1 = theta + ringDelta;
      cosTheta1 = cos(theta1);
      sinTheta1 = sin(theta1);
      glBegin(GL_QUAD_STRIP);
      phi = 0.0;
      for (j = slices; j >= 0; j--) {
         GLfloat cosPhi, sinPhi, dist;
         phi += sliceDelta;
         cosPhi = cos(phi);
         sinPhi = sin(phi);
         dist = radius2 + radius1 * cosPhi;
         glNormal3f(cosTheta1 * cosPhi, -sinTheta1 * cosPhi, sinPhi);
         glVertex3f(cosTheta1 * dist, -sinTheta1 * dist, radius1 * sinPhi);
         glNormal3f(cosTheta * cosPhi, -sinTheta * cosPhi, sinPhi);
         glVertex3f(cosTheta * dist, -sinTheta * dist,  radius1 * sinPhi);
         }
      glEnd();
      theta = theta1;
      cosTheta = cosTheta1;
      sinTheta = sinTheta1;
     }
   glPopMatrix();
   glFlush();
}

/* draw a cube */
void cube(double length, double x, double y, double z, int gen)
{
   static GLfloat n[6][3] = {
      {0.0, 0.0, 1.0}, {1.0, 0.0, 0.0},{0.0, 0.0,-1.0},
      {-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0},{0.0, -1.0, 0.0}
      };

    static GLint faces[6][4] = {
      {0, 1, 2, 3}, {1, 4, 7, 2}, {4, 5, 6, 7},
      {5, 0, 3, 6}, {3, 2, 7, 6}, {5, 4, 1, 0}
      };

   GLfloat v[8][3], len_div_2 = length / 2;
   GLint i;

   glPushMatrix();

   glTranslatef(x, y, z);

/*   static GLfloat v[8][3] = {
      {-1.0, -1.0,  1.0}, 
      { 1.0, -1.0,  1.0},
      { 1.0,  1.0,  1.0},
      {-1.0,  1.0,  1.0},
      { 1.0, -1.0, -1.0}, 
      {-1.0, -1.0, -1.0},
      {-1.0,  1.0, -1.0},
      { 1.0,  1.0, -1.0},
      };
*/
   v[0][0] = v[0][1] = v[1][1] = v[3][0] = v[4][1] = v[4][2] =
   v[5][0] = v[5][1] = v[5][2] = v[6][0] = v[6][2] = v[7][2] = -len_div_2;

   v[0][2] = v[1][0] = v[1][2] = v[2][0] = v[2][1] = v[2][2] =
   v[3][1] = v[3][2] = v[4][0] = v[6][1] = v[7][0] = v[7][1] = len_div_2;

   /* set default coordinates if needed */

   if (gen == 1) {
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      for (i = 0; i <=5 ; i++) {
	 glBegin(GL_QUADS);
	 glNormal3fv(&n[i][0]);
	 glTexCoord2f(0.0, 0.0);
	 glVertex3fv(&v[faces[i][0]][0]);
	 glTexCoord2f(1.0, 0.0);
	 glVertex3fv(&v[faces[i][1]][0]);
	 glTexCoord2f(1.0, 1.0);
	 glVertex3fv(&v[faces[i][2]][0]);
	 glTexCoord2f(0.0, 1.0);
	 glVertex3fv(&v[faces[i][3]][0]);
	 glEnd();
	 }
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   else {
      for (i = 5; i >= 0; i--) {
	 glBegin(GL_QUADS);
	 glNormal3fv(&n[i][0]);
	 glVertex3fv(&v[faces[i][0]][0]);
	 glVertex3fv(&v[faces[i][1]][0]);
	 glVertex3fv(&v[faces[i][2]][0]);
	 glVertex3fv(&v[faces[i][3]][0]);
	 glEnd();
	 }
      }
   glPopMatrix();
}

/*
 * draw a sphere. This routine makes use of the glu library
 */
void sphere(double radius, double x, double y, double z, int slices, int rings, int gen)
{
   GLUquadricObj *qobj;
   glPushMatrix();
   glTranslatef(x, y, z);
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* use the glu texture coordinates if texcoord ="auto" */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
      }
   gluSphere(qobj, radius, slices, rings);
   gluDeleteQuadric(qobj);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   glPopMatrix();
}


/*
 * draw a cylinder. makes use of the glu library.
 */
void cylinder(double radius1, double radius2, double height,
              double x,  double y, double z, int slices, int rings, int gen)
{
   GLUquadricObj *qobj;

   /*
    * translate to the specified x,y, and z
    */
   glPushMatrix();
   glTranslatef(x, y, z);
   /*
    * rotate so cylinder points "up" by default
    */
   glRotated(270.0, 1.0, 0.0, 0.0);
   qobj = gluNewQuadric();

   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* if needed generate texture coordinates */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
     }
   /* draw the cylinder */
   gluCylinder(qobj, radius1, radius2, height, slices, rings);
   gluDeleteQuadric(qobj);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
     }
   glPopMatrix();
}

/*
 * draw a disk. angle2 < 360 degrees specifies a partial disk.
 */
void disk(double radius1, double radius2, double angle1, double angle2,
          double x, double y, double z, int slices, int rings, int gen)
{
   GLUquadricObj *qobj;

   /* translate to the given x, y, z */
   glPushMatrix();
   glTranslatef(x, y, z);

   /* create the glu quadric */
   qobj = gluNewQuadric();
   gluQuadricDrawStyle(qobj, GLU_FILL);
   gluQuadricNormals(qobj,  GLU_SMOOTH);

   /* generate texture coordinate if needed. */
   if (gen == 1){
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      gluQuadricTexture(qobj, GL_TRUE);
      }

   /* draw a disk */
   if (angle2 < 360.0)
      gluPartialDisk(qobj, radius1, radius2, slices, rings, angle1, angle2);
   else
      gluDisk(qobj, radius1, radius2, 15, 5);
   gluDeleteQuadric(qobj);
   if (gen == 1){
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      }
   glPopMatrix();
}

/* other helper functions */

/*
 * pop a matrix from either the projection or the modelview matrix stack
 */
int popmatrix()
{
   int params1, params2;

   /* determine what is the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {
      /*
       * check the stack depth. return failed if the
       * matrix stack is one
       */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 > 1)
         glPopMatrix();
      else{
	 /*printf(" PROJECTION MODE ... POP is failing...!! %d \n", params2 );*/
	 return Failed;
      }
      }

   else {
      /*
       * We are using the Modelview stack (what about texture stack?).
       * check to see if there is more than one
       * matrix on the stack. if not return Failed
       */
      glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
	 if (params2 > 1)
	    glPopMatrix();
    	 else {
	    /*printf(" MODELVIEW------- MODE ... POP is failing...!! %d \n", params2 );*/
	    return Failed;
            }
      }
   return Succeeded;
}


/* push a matrix onto the current stack -- that is
   either the modelview of projection matrix stack */
int pushmatrix()
{
   int params1, params2;

   /* determine the current matrix stack */
   glGetIntegerv(GL_MATRIX_MODE, &params1);
   if (params1 == GL_PROJECTION) {
      /*
       * check the stack depth. If there is already 2
       * matrices on the stack return Failed
       */
      glGetIntegerv(GL_PROJECTION_STACK_DEPTH, &params2);
      if (params2 < 2) {
         glPushMatrix();
         }
      else{
	 /*printf(" PROJECTION MODE ... PUUUUUUUUUUUUSH is failing...!! %d \n", params2 );*/
	 return Failed;
      }
      }

   else {
      /* must be the Modelview matrix stack
       * if the stack depth is greater than 32, fail
       */
      glGetIntegerv(GL_MODELVIEW_STACK_DEPTH, &params2);
      if (params2 < 32)
	 glPushMatrix();
      else{
	 /*printf(" MODELVIEW------- MODE ... PUUUUUUUUUUUUSH is failing...!! %d \n", params2 );*/
	 return Failed;
      }
      }
   return Succeeded;
}

int compare_GLuint (const void * xx, const void * yy)
{
   GLuint *x = (GLuint *) xx;
   GLuint *y = (GLuint *) yy;
   if (*x > *y)
      return 1;
   else if (*x < *y)
      return -1;
   else
      return 0;
}

GLfloat deflt_ambient[4] = {0.2, 0.2, 0.2, 1.0};
GLfloat deflt_diffuse[4] = {0.8, 0.8, 0.8, 1.0};
GLfloat deflt_emission[4] = {0.0, 0.0, 0.0, 1.0};
GLfloat deflt_specular[4] = {0.0, 0.0, 0.0, 1.0};

/*
 * Functions that implement redrawing of windows.
 */

/*
 * redraws a opengl window by traversing the specifed list
 */
int redraw3D(wbp w)
{
   wcp wc = w->context;
   wsp ws = w->window;

   makecurrent(w);

   /*
    * reset the defaults for those objects that used them
    */
   glClear(GL_COLOR_BUFFER_BIT |GL_DEPTH_BUFFER_BIT);

   setlinewidth(w, 1);
   glLineWidth(1.0);
   wc->dim = 3;

  /*
   *  render in GL_RENDER mode otherwise GL_SELECT
   */
   if (!wc->selectionrendermode) {      /* GL_RENDER mode  */

    /* restore the viewing volume to the default  */
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	         0.125 * ws->height / ws->width, 0.25, 50000.0);

      glMatrixMode(GL_MODELVIEW);
      glPushMatrix();
      glLoadIdentity();
      gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
		wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);

      glMaterialfv(GL_FRONT, GL_AMBIENT, deflt_ambient);
      glMaterialfv(GL_FRONT, GL_DIFFUSE, deflt_diffuse);
      glMaterialfv(GL_FRONT, GL_SPECULAR, deflt_specular);
      glMaterialfv(GL_FRONT, GL_EMISSION, deflt_emission);
      glMaterialf(GL_FRONT, GL_SHININESS, 50.0);

      if (!wc->autogen) {
	 glEnable(GL_TEXTURE_GEN_S);
	 glEnable(GL_TEXTURE_GEN_T);
	 wc->autogen = 1;
	 }
/*
      if (wc->texmode) {
	 glDisable(GL_TEXTURE_2D);
	 wc->texmode = 0;
	 }
*/
      if (w->window->funclist.vword.bptr != NULL) {
	 if (traversefunctionlist(w) == Failed)
	    return Failed;
	 }

      glPopMatrix();
      glXSwapBuffers(w->window->display->display, w->window->win);
      }
   else {	/* GL_SELECT mode  */
      GLint viewport[4];
      GLuint        selectionbuf[1024];        /* selection buffer */
      GLint        selectionhits=0;           /* number of hits   */
      GLuint *bufp = selectionbuf;
      unsigned int j;


      /*  change the view volume  so that it is only restricted
       *  to a small region under the mouse cursor
       */
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();

      glGetIntegerv(GL_VIEWPORT, viewport);
      gluPickMatrix((GLdouble)ws->pointerx,
                   (GLdouble)(viewport[3]-ws->pointery),
                    3.0, 3.0,    /*  picking region width and height  */
                    viewport);

      glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	         0.125 * ws->height / ws->width, 0.25, 50000.0);

     glMatrixMode(GL_MODELVIEW);
     glPushMatrix();
     glLoadIdentity();
     gluLookAt(wc->eyeposx, wc->eyeposy, wc->eyeposz, wc->eyedirx, wc->eyediry,
	       wc->eyedirz, wc->eyeupx, wc->eyeupy, wc->eyeupz);

      /* switch to GL_SELECT render mode  */

      glSelectBuffer(1024, selectionbuf);
      glRenderMode(GL_SELECT);
      glInitNames();

      if (w->window->funclist.vword.bptr != NULL) {
	 /* render the scene in GL_SELECT render mode */
         if (traversefunctionlist(w) == Failed)
             return Failed;
      }

      /* switch back to GL_RENDER render mode and save the hits  */
      /*glFlush(); */
      selectionhits = glRenderMode(GL_RENDER);

      if (selectionhits < 0)
	 return Failed;
      else if (selectionhits > 256) { /* too many hits? maybe nonsense then. */
	 return Failed;
	 }
      else if (selectionhits != 0) { /* > 0, hits were found */ 
         GLuint name, numnames, z1, z_buf[256];
         tended struct b_list *namelist;
         tended struct descrip selectednameslist;
         GLuint savedhits=0;
         int newnameadded=0;

         if ((namelist = alclist(0, MinListSlots)) == NULL)
	    return Failed;
         selectednameslist.dword = D_List;
         selectednameslist.vword.bptr = (union block*) namelist;

	 /*
	  * First pass over the selection buffer to collect and sort z values.
	  */
         bufp = selectionbuf;
         for(j = 0; j < selectionhits; j++){
	    if (bufp - selectionbuf > 1024 - 4) {
	       /* Reading this would go past the end of the selection buffer. */
	       selectionhits = j;
	       break;
	       }
       	    numnames = *bufp++;
 	    z_buf[j] = *bufp++;
	    bufp++;           /* skip z2 */
	    bufp+=numnames;   /* skip names */
            }

	 qsort(z_buf,selectionhits, sizeof(GLuint), compare_GLuint);

         /* second pass : get the data  */
         savedhits=0;
         while (savedhits<selectionhits){
            bufp = selectionbuf;
            for(j = 0; j < selectionhits; j++){
	       numnames = *bufp++;
	       z1 = *bufp++;
	       bufp++; /* skip z2 */

	       if (z1 == 1 || z1>z_buf[savedhits]) {
		  bufp+=numnames;   /* skip names */
		  continue;
		  }
	       else {
		  tended char *tmpname;
		  tended struct descrip the_newselectedname;
		  int numnam=numnames, memsize=0;
		  GLuint *bufp2 = bufp;
		  /*
		   * z is 2 locations back. set it to 1 so that
		   * it will be skipped next time
		   */
		  *(bufp-2)=1;
		  savedhits++;
		  while (numnam--) {
		     int i = *bufp2++;
		     if ((0 <= i) && (i < wc->selectionnamecount))
			memsize += strlen(wc->selectionnamelist[i])+1;
		     }

	          Protect(tmpname = alcstr(NULL, memsize), return RunError);
	          tmpname[0] = '\0';

		  while (numnames) {
		     name = *bufp++;
		     --numnames;
		     /*
		      * Name being unsigned, it will never be negative,
		      * but it may be out of range.
		      */
		     if (name < wc->selectionnamecount) {
			strcat(tmpname, wc->selectionnamelist[name]);
			if (numnames)strcat(tmpname, "-");
			}
                     } /* while */

                  if ( strlen(tmpname) > 0 ){
		     newnameadded=1;
                     MakeStr(tmpname, strlen(tmpname), &the_newselectedname);
   	             c_put(&selectednameslist, &the_newselectedname);
   	             }
   	          }/* else*/
               } /*  for j  */
            } /* savedhits */

           if (newnameadded)
              c_put(&(ws->listp), &selectednameslist);     /*stick the new list of selected names to the pending event queue  */
         } /* selection hits  */
      glPopMatrix();
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glFrustum(-0.125, 0.125, -0.125 * ws->height / ws->width,
	         0.125 * ws->height / ws->width, 0.25, 50000.0);
      glMatrixMode(GL_MODELVIEW);
   }
   return Succeeded;
}

/*
 * traverse the given list and write its contents from subscript m through n,
 * which must be reals, to a C array of doubles.  m and n are 1-based
 * subscripts. Replaces a loop of calls to c_traverse().
 */
int c_realarray(struct b_list *hp, int m, int n, double *a)
{
   register word i;
   tended struct b_lelem *bp;
   tended struct descrip d;
   int j, used;

   /*
    * Fail if the list is not big enough (caller should check this first)
    */
   if (hp->size < n)
      return 0;

   /*
    * Point bp at the first list block.  If the first block has no
    *  elements in use, point bp at the next list block.
    */
   bp = (struct b_lelem *) hp->listhead;
   if (bp->nused <= 0) {
      bp = (struct b_lelem *) bp->listnext;
      hp->listhead = (union block *) bp;
      bp->listprev = (union block *) hp;
      }

   /*
    * Parse through the list blocks to find the specified element.
    */
   i = bp->first;
   used = bp->nused;
   for (j=0; j < n; j++){
      if (j >= (m-1)) {
	 d = bp->lslots[i];
         if (!cnv:real(d, d)) return 0;
	 bp->lslots[i] = d;
#ifdef DescriptorDouble
	 a[j-(m-1)] = d.vword.realval;
#else					/* DescriptorDouble */
	 a[j-(m-1)] = BlkD(d, Real)->realval;
#endif					/* DescriptorDouble */
	 }
      if (used <= 1){
	 bp = (struct b_lelem *) bp->listnext;
         used = bp->nused;
         i = bp->first;
         }
      else {
	 if (i++ >= bp->nslots) i = 0;
	 used--;
         }
      }
   return 1;
}

/*
 * Traverse the list of functions and redraw the scene.
 */
int traversefunctionlist(wbp w)
{
   wcp wc = w->context;
   wsp ws = w->window;
   double  *v, v2[256];
   C_integer num, dim;
   C_integer r, g, b, a;
   int i, j, tmp, vsize=256;
   tended struct descrip flist, fname, var1, var2, d;
   tended struct b_list *funclist;
   tended char *temp;
   tended struct b_record *rp;
   tended char *s;
   tended struct b_list *hp;
   tended struct b_lelem *bp, *bp1;
   int used, used1, count=0;
   word k,k1;
   int elements;

   hp = (struct b_list *) ws->funclist.vword.bptr;
   elements = hp->size;

   if (elements <= 0) return Succeeded;
   bp = (struct b_lelem *) hp->listhead;

   if (bp->nused<=0) {
        bp = (struct b_lelem *) bp->listnext;
        hp->listhead = (union block *) bp;
        bp->listprev = (union block *) hp;
   }
   k = bp->first;
   used =bp->nused;

   /*
    * The ith element of the list is a list with information
    * about the function call made on the window.
    */
   v = v2;
   for (i=0; i< elements; i++) {

      if (count>2) { /* skip forward as much as possible */
	 int asmuchaspossible = count-1;
	 if (used <= asmuchaspossible) asmuchaspossible = used-1;
	 if (asmuchaspossible >1) {
	    used -= asmuchaspossible;
	    k = (k+asmuchaspossible) % (bp->nslots);
	    count -= asmuchaspossible;
	    i += asmuchaspossible;
	    }
	 }
      flist = bp->lslots[k];
      k++;
      used--;
      if (k>=bp->nslots) k=0;

      if (used<=0) {
  	 bp = (struct b_lelem *) bp->listnext;
	 used = bp->nused;
         k = bp->first;
         }

      if (count) {
         count--;
         continue;
	 }

      if (v != v2) free(v);
      v = v2;
      vsize = 256;

      if (is:record(flist)) {
	 rp = BlkD(flist, Record);
	 fname = rp->fields[0];

         tmp = IntVal(rp->fields[1]);
	 if (tmp == -1) {
	    return Failed; /* probably should runerr on this */
	    }
	 for (j=0; j < (tmp&15); j++) {
	    var1 = rp->fields[j+2];
	    if (!cnv:C_double(var1, v[j])) goto free_v_and_fail;
	    }

	 switch(tmp & ~0xf) {
	 case REDRAW_TORUS:
	    torus(v[3], v[4], v[0], v[1], v[2],
		 wc->slices,				/*  slices  */
		 wc->rings,				/*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_CUBE:
	    cube(v[3], v[0], v[1], v[2], (wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_SPHERE:
	    sphere(v[3], v[0], v[1], v[2],
		 wc->slices,				/*  slices  */
		 wc->rings,				/*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_CYLINDER:
	    cylinder(v[4], v[5], v[3], v[0], v[1], v[2],
		 wc->slices,				/*  slices  */
		 wc->rings,				/*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_DISK:
	    disk(v[3], v[4], v[5], v[6], v[0], v[1], v[2],
		 wc->slices,				/*  slices  */
		 wc->rings,				/*  rings   */
		(wc->texmode?wc->autogen:0));
	    break;
	 case REDRAW_ROTATE:
	    glRotated(v[3], v[0], v[1], v[2]);
	    break;
	 case REDRAW_TRANSLATE:
	    glTranslated(v[0], v[1], v[2]);
	    break;
	 case REDRAW_SCALE:
	    glScaled(v[0], v[1], v[2]);
	    break;
	 case REDRAW_POPMATRIX:
	    if (popmatrix() != Succeeded) goto free_v_and_fail;
	    break;
	 case REDRAW_PUSHMATRIX:
	    if (pushmatrix() != Succeeded) goto free_v_and_fail;
	    break;
	 case REDRAW_IDENTITY:
	    glLoadIdentity();
	    break;
	 case REDRAW_MATRIXMODE:
	    if (!cnv:C_string(rp->fields[2], temp)) goto free_v_and_fail;
	    if (!strcmp("modelview", temp)) glMatrixMode(GL_MODELVIEW);
	    else if (!strcmp("projection", temp)) glMatrixMode(GL_PROJECTION);
	    break;
	 case REDRAW_TEXTURE:
	    /*
	     * lookup the name of the texture and bind it
             * the objects using glBindTexture()
	     */
	    if (!cnv:C_integer(rp->fields[2], num)) {
	       goto free_v_and_fail;
	       }
	    glBindTexture(GL_TEXTURE_2D, wc->display->stex[num].texName);
	    if (wc->texmode)
	       glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, wc->texmode);
	    break;
         case REDRAW_FONT3D:
#if HAVE_LIBFTGL
	    curr_font = (wfont *) IntVal(rp->fields[2]);
#endif					/* HAVE_LIBFTGL */
	    break;
         case REDRAW_DRAWSTRING3D:
#if HAVE_LIBFTGL
	    if (!cnv:C_double(rp->fields[2], v[0])) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[3], v[1])) goto free_v_and_fail;
	    if (!cnv:C_double(rp->fields[4], v[2])) goto free_v_and_fail;
	    if (!cnv:C_string(rp->fields[5], s)) goto free_v_and_fail;
	    drawstrng3d(w,v[0],v[1],v[2],s);
#endif					/* HAVE_LIBFTGL */
            break;
         case REDRAW_MARK: {
	    struct descrip d = BlkLoc(flist)->Record.fields[3];
            if (is:integer(d) && IntVal(d)==1) {
	       count = IntVal(BlkLoc(flist)->Record.fields[4]);
               }
            else count=0;

	   if (!count && wc->selectionenabled && wc->selectionrendermode ){
	      GLuint int_code = IntVal(BlkLoc(flist)->Record.fields[5]);
              glPushName(int_code);
              }
	    }
	    break;
	 case REDRAW_ENDMARK:
	    if (wc->selectionenabled && wc->selectionrendermode)
		    glPopName();
	    break;
	 case REDRAW_MESHMODE:
            if (!cnv:C_integer(rp->fields[2], num)) goto free_v_and_fail;
            w->context->meshmode = num;
            break;
	 default:
	    fprintf(stderr,"invalid displaylist entry '%s'\n",
		    (is:string(fname) ? StrLoc(fname) : "(corrupted)"));
            goto free_v_and_fail;
	    }
	 continue;
	 }
      else if (is:list(flist)) {
	 funclist = (struct b_list*)flist.vword.bptr;
         if (funclist->size<=1) continue;
         bp1 = (struct b_lelem *) funclist->listhead;
         if (bp1->nused<=0) {
            bp1 = (struct b_lelem *) bp1->listnext;
            funclist->listhead = (union block *) bp1;
            bp1->listprev = (union block *) funclist;
         }
         k1 = bp1->first;
         fname = bp1->lslots[k1];

         if (k1++>=bp1->nslots) k1=0;
         used1 = bp1->nused-1;
         if (used1<=0) {
            bp1 = (struct b_lelem *) bp1->listnext;
	    k1 = bp1->first;
            funclist->listhead = (union block *) bp1;
            bp1->listprev = (union block *) funclist;
         }
	 if (! is:integer(bp1->lslots[k1])) { /* should check for large int! */
	    return RunError;
	    }
         tmp = IntVal(bp1->lslots[k1]);

/* OK, at this point, k1 has been preset to refer to the int code */

	 if (funclist->size-1 > vsize) {
	    if (v == v2)
	       v = calloc(funclist->size, sizeof (double));
	    else {
	       v = realloc(v, funclist->size * sizeof (double));
	       }
	    vsize = funclist->size-1;
	    if (v == NULL) return RunError;
	    }

         switch(tmp & ~0xf) {
         case REDRAW_FG:
	    /* Fg() or WAttrib("fg=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_string(d, temp))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, r))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, g))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, b))
	       return Failed;

            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
                if (k1++>=bp1->nslots) k1=0;
                used1--;
                }

            d = bp1->lslots[k1];
            if (!cnv:C_integer(d, a))
	       return Failed;

	    if(!determinematerial(temp, r, g, b, a)) {
		/*
        		if(!determinematerial(funclist)) {
		*/
               free_v_and_fail:
	       if (v != v2) free(v);
	          return Failed;
	       }
	    break;
         case REDRAW_DIM:
	    /* WAttrib("dim=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
            }
            var1 = bp1->lslots[k1];

    	    if ((!cnv:C_integer(var1, dim))||(dim<1)||(dim>3))
	       goto free_v_and_fail;
            wc->dim = dim;
	    break;
         case REDRAW_LINEWIDTH:
	    /* WAttrib("linewidth=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;
	       setlinewidth(w, num);
               glLineWidth(num);
	    break;
         case REDRAW_PICK:
	    /* WAttrib("pick=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
	       }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;

	    wc->selectionenabled = num;
	    break;
         case REDRAW_TEXMODE:
	    /* WAttrib("texmode=...") */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;

            /* texturing is on */
            if (num) {
               if (wc->texmode == 0)
	          glEnable(GL_TEXTURE_2D);

               wc->texmode = num;
               }
               /* texturing is off */
            else {
               if (wc->texmode != 0)
                  glDisable(GL_TEXTURE_2D);
               wc->texmode = 0;
	       }
	    break;
	 case REDRAW_SLICES:
	    /* WAttrib("slices=...") */
            if (used1<=1) {
	       bp1=(struct b_lelem *) bp1->listnext;
	       used1 = bp1->nused;
	       k1 = bp1->first;
	    }
	    else {
	       if (k1++>=bp1->nslots) k1=0;
	       used1--;
	    }
	    var1 = bp1->lslots[k1];
	    
	    if (!cnv:C_integer(var1, num)) goto free_v_and_fail;
	    
	    /* make sure slice is more than 0, otherwise just ignore */
            if (num>0)
	       wc->slices = num;
	    break;
	 case REDRAW_RINGS:
	    /* WAttrib("rings=...") */
            if (used1<=1) {
	       bp1=(struct b_lelem *) bp1->listnext;
	       used1 = bp1->nused;
	       k1 = bp1->first;
	    }
	    else {
	       if (k1++>=bp1->nslots) k1=0;
	       used1--;
	    }
	    var1 = bp1->lslots[k1];
	    
	    if (!cnv:C_integer(var1, num)) goto free_v_and_fail;
	    
	    /* make sure rings is more than 0, otherwise just ignore */
            if (num>0)
	       wc->rings = num;
	    break;
	 case REDRAW_NORMODE:
	    /* WAttrib("normode=...") */
            if (used1<=1) {
	       bp1=(struct b_lelem *) bp1->listnext;
	       used1 = bp1->nused;
	       k1 = bp1->first;
	    }
	    else {
	       if (k1++>=bp1->nslots) k1=0;
	       used1--;
	    }
	    var1 = bp1->lslots[k1];
	    
	    if (!cnv:C_integer(var1, num)) goto free_v_and_fail;
	    
	    /* normals is off */
            if (num==0)
	       wc->normode = 0;
	    /* normals is on */
            else if (num==2)
	       wc->normode = 2;
	    /* default is auto*/
            else
	       wc->normode = 1;
	    break;
         case REDRAW_TEXCOORD:      /* Texcoord() or WAttrib("texcoord=...") */
            /*
	     * first element tells us if opengl generates texture coordinates
	     */
            if (used1<=1) {
               bp1=(struct b_lelem *) bp1->listnext;
               used1 = bp1->nused;
               k1 = bp1->first;
               }
            else {
               if (k1++>=bp1->nslots) k1=0;
               used1--;
               }
            var1 = bp1->lslots[k1];

            if (!cnv:C_integer(var1, num)) goto free_v_and_fail;

            if (num) {
               glEnable(GL_TEXTURE_GEN_S);
               glEnable(GL_TEXTURE_GEN_T);
               wc->autogen = 1;
               }

            /* there is a list of texture coordinates to use */
            else {
	       struct b_realarray *ap;
               glDisable(GL_TEXTURE_GEN_S);
               glDisable(GL_TEXTURE_GEN_T);
               wc->autogen = 0;
	       
                  if (used1 <= 1){
	             bp1 = (struct b_lelem *) bp1->listnext;
                     used1 = bp1->nused;
                     k1 = bp1->first;
                     }
                  else {
	             if (k1++ >= bp1->nslots) k1 = 0;
	             used1--;
                     }

                  if (used1>0) {
	             d = bp1->lslots[k1];
		     ap = (struct b_realarray *) BlkD(d, List)->listhead;
		     if (ap->title != T_Realarray) {
			fprintf(stderr,"traversefunctionlist/Texcoord: "
				"real array expected\n");
			return Failed;
			}
		     wc->numtexcoords = BlkD(d, List)->size;
		     wc->texcoords = ap;
                     }
               }
	    break;
         case REDRAW_NORMALS:     /* Normals() */
            /* there is a list of normal coordinates to use */
               if (used1 <= 1){
	          bp1 = (struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
	          if (k1++ >= bp1->nslots) k1 = 0;
	          used1--;
                  }

               if (used1>0) {
		  struct b_realarray *ap;
	          d = bp1->lslots[k1];
		  ap = (struct b_realarray *) BlkD(d, List)->listhead;
		  if (ap->title!=T_Realarray){
		     printf("REDRAW_NORMALS: NOT a real Array!!..\n");
		     return Failed;
		     }
		  wc->numnormals = BlkD(d, List)->size;
		  wc->normals = ap;
                  }
	    break;
         case REDRAW_MULTMATRIX:      /* MultMatrix() */
               /* check if we have a list of size 16 */
                  if (used1 <= 1){
	             bp1 = (struct b_lelem *) bp1->listnext;
                     used1 = bp1->nused;
                     k1 = bp1->first;
                     }
                  else {
	             if (k1++ >= bp1->nslots) k1 = 0;
	             used1--;
                     }

                  if (used1>0) {
		      struct b_realarray *ap;
		      d = bp1->lslots[k1];
		      ap = (struct b_realarray *) BlkD(d, List)->listhead;
		      if (ap->title!=T_Realarray){
			printf("REDRAW_MULTMATRIX: NOT a real Array!!..\n");
			return Failed;
		      }
#if HAVE_LIBGL
		      glMultMatrixd((GLdouble *)ap->a);
#endif					/* HAVE_LIBGL */
                     } /*used1>0 */
	    break;
         case REDRAW_POLYGON:      /* DrawPolygon() */
            /* element in position 1 is the dim attribute */
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }

               if (used1>0) {
		 struct b_realarray *ap;
		 d = bp1->lslots[k1];
		 ap = (struct b_realarray *) BlkD(d, List)->listhead;
		 if (ap->title!=T_Realarray){
		   printf("REDRAW_POLYGON: NOT a real Array!!..\n");
		   return Failed;
		 }
		 /* call drawpoly with meshmode to get something polygonish */
		 drawpoly(w, ap->a, BlkD(d, List)->size , w->context->meshmode, wc->dim);
	       } /*used1>0 */
	    break;
         case REDRAW_FILLPOLYGON:      /* FillPolygon() */
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }
               
               if (used1>0) {
		 struct b_realarray *ap;
		 d = bp1->lslots[k1];
		 ap = (struct b_realarray *) BlkD(d, List)->listhead;
		 if (ap->title!=T_Realarray){
		   printf("REDRAW_FILLPOLYGON: NOT a real Array!!..\n");
		   return Failed;
		 }
		 /* call drawpoly with meshmode to get something polygonish */
		 drawpoly(w, ap->a, BlkD(d, List)->size , w->context->meshmode, wc->dim);
	       } /*used1>0 */
	    break;
         case REDRAW_SEGMENT:      /* DrawSegment() */
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
               }
               
               if (used1>0) {
		 struct b_realarray *ap;
		 d = bp1->lslots[k1];
		 ap = (struct b_realarray *) BlkD(d, List)->listhead;
		 if (ap->title!=T_Realarray){
		   printf("REDRAW_SEGMENT: NOT a real Array!!..\n");
		   return Failed;
		 }
		 /* call drawpoly with GL_LINES to get segments */
		 drawpoly(w, ap->a, BlkD(d, List)->size , GL_LINES, wc->dim);
	       } /*used1>0 */
	    break;
         case REDRAW_LINE:       /* DrawLine() */
               if (used1<=0) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }

	       if (used1>0) {
		 struct b_realarray *ap;
		 d = bp1->lslots[k1];
		 ap = (struct b_realarray *) BlkD(d, List)->listhead;
		 if (ap->title!=T_Realarray){
		   printf("REDRAW_LINE: NOT a real Array!!..\n");
		   return Failed;
		 }
		 /* call drawpoly with GL_LINE_STRIP to get lines */
		 drawpoly(w, ap->a, BlkD(d, List)->size , GL_LINE_STRIP, wc->dim);
	       } /*used1>0 */
	    break;
         case REDRAW_POINT:       /* DrawPoint() */
               if (used1<=1) {
                  bp1=(struct b_lelem *) bp1->listnext;
                  used1 = bp1->nused;
                  k1 = bp1->first;
                  }
               else {
                  if (k1++>=bp1->nslots) k1=0;
                  used1--;
                  }
	       if (used1>0) {
		 struct b_realarray *ap;
		 d = bp1->lslots[k1];
		 ap = (struct b_realarray *) BlkD(d, List)->listhead;
		 if (ap->title!=T_Realarray){
		   printf("REDRAW_POINT: NOT a real Array!!..\n");
		   return Failed;
		 }
		 /* call drawpoly with GL_POINTS to get points */
		 drawpoly(w, ap->a, BlkD(d, List)->size , GL_POINTS, wc->dim);
	       } /*used1>0 */
	    break;
         default:
      	    fprintf(stderr,"invalid displaylist entry '%s'\n",
	       (is:string(fname) ? StrLoc(fname) : "(corrupted)"));
	       goto free_v_and_fail;
	 } /* switch tmp */
         } /* else if is:list  */
      else {
	 return Failed;
	 }
      }

   if (v!=v2) free(v);
   return Succeeded;
}

/*
 * traverse the given list and set material properties
 */
int determinematerial(temp, r, g, b, a)
char *temp;
C_integer r, g, b, a;
{
   GLfloat color[4];

   /*
    * must convert from an integer between 0 and 65535
    * to a float between 0.0 and 0.0
    */
   color[0] = r/(GLfloat)65535;
   color[1] = g/(GLfloat)65535;
   color[2] = b/(GLfloat)65535;
   color[3] = a/(GLfloat)65535;  /* alpha value */

  /* set the material property */
   if (!strcmp(temp, "ambient"))
      glMaterialfv(GL_FRONT, GL_AMBIENT, color);
   else if (!strcmp(temp, "diffuse"))
      glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
   else if (!strcmp(temp, "specular"))
      glMaterialfv(GL_FRONT, GL_SPECULAR, color);
   else if (!strcmp(temp, "emission"))
      glMaterialfv(GL_FRONT, GL_EMISSION, color);
   else if(!strcmp(temp, "shininess"))
      glMateriali(GL_FRONT, GL_SHININESS, r);

   /*
    * if it is not a material property, change the
    * current foreground color to r, g, b
    */
   if (!strcmp(temp, "none")) {
      glColor4f(color[0], color[1], color[2], color[3]);
      }

   return Succeeded;
}

/* routines to return an attribute vale */

/* returns the current value of the specified light */
int getlight(int light, char* buf)
{
   GLfloat pos[4];
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];

   glGetLightfv(GL_LIGHT0 + light, GL_POSITION, pos);
   glGetLightfv(GL_LIGHT0 + light, GL_AMBIENT, amb);
   glGetLightfv(GL_LIGHT0 + light, GL_DIFFUSE, diff);
   glGetLightfv(GL_LIGHT0 + light, GL_SPECULAR, spec);

   sprintf(buf, "position %.2f,%.2f,%.2f; ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f",  pos[0], pos[1], pos[2], amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2]);
   return Succeeded;
}

/* returns the current material properties */
int getmaterials(char* buf)
{
   GLfloat amb[4];
   GLfloat diff[4];
   GLfloat spec[4];
   GLfloat emis[4];
   GLfloat shine;

   /* query opengl for current values */
   glGetMaterialfv(GL_FRONT, GL_EMISSION, emis);
   glGetMaterialfv(GL_FRONT, GL_AMBIENT, amb);
   glGetMaterialfv(GL_FRONT, GL_DIFFUSE, diff);
   glGetMaterialfv(GL_FRONT, GL_SPECULAR, spec);
   glGetMaterialfv(GL_FRONT, GL_SHININESS, &shine);

   sprintf(buf, "ambient %.2f,%.2f,%.2f; diffuse %.2f,%.2f,%.2f; specular %.2f,%.2f,%.2f; emission %.2f,%.2f,%.2f; shininess %.2f", amb[0], amb[1], amb[2],  diff[0], diff[1], diff[2], spec[0], spec[1], spec[2], emis[0], emis[1], emis[2], shine);
   return Succeeded;
}

/* routines to set attribute values */

/* set the linewidth */
int setlinewidth3D(wbp w, LONG linewid)
{
   tended struct descrip f;
   struct descrip  width;

   if (linewid < 0) return RunError;
   makecurrent(w);
   setlinewidth(w, linewid);
   glLineWidth(linewid);

   /* create a list */
   if (create3Dlisthdr(&f, "linewidth", 4)!=Succeeded)
     return RunError;

   MakeInt(linewid, &width);
   c_put(&f, &width);
   c_put(&(w->window->funclist), &f);

   return Succeeded;
}

/*
 * Given a string of semi-colon separated material properties
 * (ambient, diffuse, specular, emission, and shininess),
 * parse the string and set material properties.
 */
int setmaterials(wbp w, char* s)
{
   int k, j, i = 0;
   long rd, gr, bl, al;
   GLfloat shine;
   GLfloat color[4];
   char sbuf1[MaxCvtLen];
   char sbuf2[MaxCvtLen];
   tended struct descrip f;
   struct descrip material, r, b, g, a;

   makecurrent(w);
   while(s[i]) {
      j = 0;
      k = 0;

      /* create a list element for each material property */
      if (create3Dlisthdr(&f, "Fg", 7)!=Succeeded)
	return RunError;
      
     /*
      * parse the string to determine the material property and its value
      */
      while(isspace(s[i])) i++;
      while(s[i] && isalpha(s[i])) {
         sbuf1[k] = s[i];
         i++; k++;
	 }
      sbuf1[k] = '\0';

      /* ambient */
      if (!strcmp(sbuf1, "ambient")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
            sbuf2[j] = s[i];
            i++; j++;
	    }
         sbuf2[j] = '\0';
         /* determine the icon color */
         if(parsecolor(w,sbuf2, &rd, &gr, &bl, &al)== Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535; /* alpha value */

         /* set the property */
         glMaterialfv(GL_FRONT, GL_AMBIENT, color);
         MakeStr("ambient", 7, &material);
         c_put(&f, &material);
	   }

      /* diffuse */
      else if(!strcmp(sbuf1, "diffuse")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

         /* determine the appropriate icon color */
	 if(parsecolor(w,sbuf2, &rd, &gr, &bl, &al)==Failed)
            return Failed;

         /* convert values to floats between 0.0 and 1.0 */
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;

         /* set the property */
	 glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
	 MakeStr("diffuse", 7, &material);
	 c_put(&f, &material);
	 }

      /* specular */
      else if (!strcmp(sbuf1, "specular")) {
         while(isspace(s[i])) i++;
         if(s[i] == '\0') return Failed;
         while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

         /*
	  * determine the icon color and convert to a float between 0.0 and 1.0
	  */
         if(parsecolor(w, sbuf2, &rd, &gr,&bl,&al)==Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the property */
         glMaterialfv(GL_FRONT, GL_SPECULAR, color);
         MakeStr("specular", 8, &material);
         c_put(&f, &material);
	 }

      /* shininess */
      else if(!strcmp(sbuf1, "shininess")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

	 /* set the shininess */
	 shine = atof(sbuf2);
	 glMaterialf(GL_FRONT, GL_SHININESS, shine);
         MakeStr("shininess", 9, &material);
	 c_put(&f, &material);
	 rd = shine;
	 gr = 0;
	 bl = 0;
	 }
      /* emission */
      else if(!strcmp(sbuf1, "emission")) {
	 while(isspace(s[i])) i++;
	 if(s[i] == '\0') return Failed;
	 while(s[i] != '\0' && s[i] != ';') {
	    sbuf2[j] = s[i];
	    i++; j++;
	    }
	 sbuf2[j] = '\0';

	 /*
	  * determine r, g, b and convert them to floats between 0.0 and 1.0
	  */
	 if(parsecolor(w, sbuf2, &rd, &gr,&bl,&al)==Failed)
	    return Failed;
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;

	 /* set the emission color */
	 glMaterialfv(GL_FRONT, GL_EMISSION, color);
         MakeStr("emission", 8, &material);
	 c_put(&f, &material);
	 }

      /* otherwise set the current foreground color; treat as diffuse */
      else {
	 if(setfg(w, s) == Failed) return Failed;
         if(parsecolor(w, s, &rd, &gr, &bl, &al)==Failed)
            return Failed;
	 i = strlen(s);
	 color[0] = rd/(GLfloat)65535;
	 color[1] = gr/(GLfloat)65535;
	 color[2] = bl/(GLfloat)65535;
	 color[3] = al/(GLfloat)65535;
 	 glColor4f(color[0], color[1], color[2], color[3]);
	 glMaterialfv(GL_FRONT, GL_DIFFUSE, color);
         MakeStr("diffuse", 7, &material);
	 c_put(&f, &material);
         }

      /* put material property values on the list */
      MakeInt(rd, &r);
      c_put(&f, &r);
      MakeInt(gr, &g);
      c_put(&f, &g);
      MakeInt(bl, &b);
      c_put(&f, &b);
      MakeInt(al, &a);
      c_put(&f, &a);
      c_put(&(w->window->funclist), &f);

      /* fail if string is not in the correct format */
      if(s[i] != '\0' && s[i] != ';') return Failed;
      if (s[i])
         i++;
     }
   return Succeeded;
}


/*
 * set the lighting properties (position, ambient,
 * diffuse, specular, and "on" or "off")of a light
 */
int setlight(wbp w, char* s, int light)
{
   char* s2 = s;
   char s3[MaxCvtLen];
   GLboolean params;
   int i, j;
   GLfloat color[4];
   long rd, gr, bl, al;

   makecurrent(w);

   while(isspace(*s2)) s2++;

   /* turn on a light */
   if (!strncmp(s2, "on", 2)) {
      /* query opengl to see if it is already on */
      glGetBooleanv(light, &params);
      if (!params)
         glEnable(light);
      s2 = s2+2;
      if(*s2 != ',' && *s2 != '\0') return Failed;
      if(*s2 == ',') s2++;
      }
   /* turn off the light */
   if (!strncmp(s2, "off", 3)) {
      /* query opengl to make sure the light is not already off */
      glGetBooleanv(light, &params);
      if (params)
	 glDisable(light);
      s2 = s2 + 3;
      if(*s2 != ',' && *s2 != '\0') return Failed;
      if(*s2 == ',') s2++;
      }
   while(*s2 != '\0'){
      while(isspace(*s2)) s2++;

      /* set the ambient lighting values */
      if (!strncmp(s2, "ambient", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /*
	  * Determine the r, g, b values. Convert from an integer between
	  * 0 and 65535 to a float between 0.0 and 1.0
	  */
         if(parsecolor(w, s3, &rd, &gr, &bl, &al) ==Failed)
	      return Failed;

         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the ambient light value */
         glLightfv(light, GL_AMBIENT, color);
         s2 = s2 + i;
	 if(*s2 != ';' && *s2 != '\0') return Failed;
	 if(*s2 != '\0') s2++;
         }

      /* set the diffuse lighting values */
      if (!strncmp(s2, "diffuse", 7)) {
         s2 = s2 + 7;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert the icon r, g, b values to floats
            between 0.0 and 1.0 */
         if(parsecolor(w, s3, &rd, &gr, &bl,&al) == Failed)
	      return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;

         /* set the diffuse value of the light */
         glLightfv(light, GL_DIFFUSE, color);
         s2 = s2 + i;
	 if (*s2 != ';' && *s2 != '\0') return Failed;
	 if (*s2 != '\0') s2++;
         }
      /* set the specular lighting values */
      if (!strncmp(s2, "specular", 8)) {
         s2 = s2 + 8;
         i = 0;
         if(*s2 == '\0') return Failed;
         while(s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         /* convert to appropriate values */
	 if (parsecolor(w, s3, &rd, &gr, &bl, &al) == Failed)
            return Failed;
         color[0] = rd/(GLfloat)65535;
         color[1] = gr/(GLfloat)65535;
         color[2] = bl/(GLfloat)65535;
         color[3] = al/(GLfloat)65535;
         glLightfv(light, GL_SPECULAR, color);
         s2 = s2 + i;
	 if (*s2 != ';' && *s2 != '\0') return Failed;
	 if (*s2 != '\0') s2++;
         }
      /* set the positon of the light */
	if (!strncmp(s2, "position", 8)) {
         s2 = s2 + 8;
	   for (j = 0; j < 2; j++) {
	   while (isspace(*s2)) s2++;
           i = 0;
	   if (*s2 == '\0') return Failed;
	   while (s2[i] != '\0' && s2[i] != ',') {
              s3[i] = s2[i];
              i++;
              }
           s3[i] = '\0';
           color[j] = atof(s3);
           s2 = s2 + i;
	   if (*s2 != ',') return Failed;
           s2++;
           }
	 while (isspace(*s2)) s2++;
	 if (*s2 == '\0') return Failed;
	 while (s2[i] != '\0' && s2[i] != ';') {
            s3[i] = s2[i];
            i++;
            }
         s3[i] = '\0';
         color[2] = atof(s3);
         color[3] = 0.0;
         s2 = s2  + i;
	 if (*s2 != ';' && *s2 != '\0') return Failed;
	 if (*s2 != '\0') s2++;
         glLightfv(light, GL_POSITION, color);
         }
      }

      /* the lighting on the scene has changed, we must redraw the window */
      redraw3D(w);
      return Succeeded;
}

/*
 * the matrix mode controls whether subsequent operations (e.g. push and pop)
 * affect the "modelview" or the "projection" matrix stack.
 */
int setmatrixmode(char *s)
{
   if (!strcmp("modelview", s)) { glMatrixMode(GL_MODELVIEW); }
   else if (!strcmp("projection", s)) { glMatrixMode(GL_PROJECTION); }
   else return RunError;
   return Succeeded;
}


/*
 * Call to direct OpenGL to change the texture mode.
 */
void apply_texmodechange(wbp w)
{
   if (w->context->texmode) glEnable(GL_TEXTURE_2D);
   else glDisable(GL_TEXTURE_2D);
}

/*
 * Enable/use automatic texture coordinates for standard 3D primitives
 */
void applyAutomaticTextureCoords(int enable)
{
   if (enable) {
      if (!glIsEnabled(GL_TEXTURE_GEN_S))
	 glEnable(GL_TEXTURE_GEN_S);
      if (!glIsEnabled(GL_TEXTURE_GEN_T))
	 glEnable(GL_TEXTURE_GEN_T);
      }
   else {
      if (glIsEnabled(GL_TEXTURE_GEN_S))
	 glDisable(GL_TEXTURE_GEN_S);
      if (glIsEnabled(GL_TEXTURE_GEN_T))
	 glDisable(GL_TEXTURE_GEN_T);
      }
}


/* set texture coordinates */
int settexcoords(wbp w, char* s)
{
   double r;
   char* s2 = s;
   char s3[MaxCvtLen];
   int j, i =0;
   tended struct descrip f, val = nulldesc;
   tended struct descrip d, mode;
   tended struct b_realarray *ap;


   makecurrent(w);

   /* create a list */
   if (create3Dlisthdr(&f, "Texcoord", 4)!=Succeeded)
     return RunError;

   while(isspace(*s2)) s2++;

   /*
    * check if we need to generate texture coordinates
    */
   if (!strcmp(s2, "auto")){
      w->context->autogen = 1;
      if (!glIsEnabled(GL_TEXTURE_GEN_S))
         glEnable(GL_TEXTURE_GEN_S);
      if (!glIsEnabled(GL_TEXTURE_GEN_T))
         glEnable(GL_TEXTURE_GEN_T);
      mode = onedesc;
      c_put(&f, &mode);
      c_put(&(w->window->funclist), &f);
      return Succeeded;
      }

   /*
    * otherwise a string of texture coordinates should be given
    */
   else if(isdigit(*s2)) {
      mode = zerodesc;
      c_put(&f, &mode);
      j = w->context->numtexcoords = 0;
      w->context->autogen = 0;
      
      /* must turn off automatic texture generation */
      if (glIsEnabled(GL_TEXTURE_GEN_S))
         glDisable(GL_TEXTURE_GEN_S);
      if (glIsEnabled(GL_TEXTURE_GEN_T))
         glDisable(GL_TEXTURE_GEN_T);
      /* parse string */
      /* The first pass counts the # of texcoords */ 
      while(*s2 != '\0') {
         while(*s2 != ',' && *s2 != '\0' ) {
            s3[i] = *s2;
            i++; s2++;
           }
         s3[i]='\0';
         j++;
	 if (*s2 == ',') {
	    s2++;
	    i=0;
	    }
         else break;
         }


      Protect(ap = (struct b_realarray *) alcrealarray(j), return RunError);
      d.vword.bptr = (union block *) alclisthdr(j, (union block *) ap);
      d.dword = D_List;
      w->context->texcoords = ap;
      c_put(&f, &d);

      /* second pass to collect texcoord data */
      s2 = s;
      i = 0;
      j = 0;
      while(*s2 != '\0') {
         while(*s2 != ',' && *s2 != '\0' ) {
            s3[i] = *s2;
            i++; s2++;
           }
         s3[i]='\0';
         ap->a[j] = r = atof(s3);
         j++;
	 if (*s2 == ',') {
	    s2++;
	    i=0;
	    }
         else break;
         }

      /* Number of texture coordinates must be even */
      if (j % 2)
	 return RunError;
      /* save the number of texture coordinates */
      w->context->numtexcoords = j;
      c_put(&(w->window->funclist), &f);
     }
   /* return an error for any other value */
   else return RunError;
   return Succeeded;
}


/*
 * convert a icon image string into a useable opengl texture
 */
int imagestr(wbp w, char* str)
{
   struct palentry *e;
   int c, i, width, height, row, p;
   word nchars;
   unsigned char *t, *z, *s;

   /* Extract the Width and skip the following comma.*/

   s = (unsigned char *)str;
   z = s + strlen(str);		/* end+1 of string */
   width = 0;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   while (s < z && isdigit(*s))	/* scan number */
      width = 10 * width + *s++ - '0';
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (width == 0 || *s++ != ',') /* skip comma */
      return Failed;
   while (s < z && *s == ' ')	/* skip blanks */
      s++;
   if (s >= z)			     /* if end of string */
	 return Failed;

 /* Check for a bilevel format */
   if ((c = *s) == '#' || c == '~') {
      s++;
      nchars = 0;
      for (t = s; t < z; t++)
         if (isxdigit(*t))
            nchars++;	         /* count hex digits */
         else if (*t != PCH1 && *t != PCH2)
            return Failed;	  /* illegal punctuation */
      if (nchars == 0)
         return Failed;
      row = (width + 3) / 4;	/* digits per row */
      if (nchars % row != 0)
         return Failed;
      height = nchars / row;

      i = bltex(w, width, height, c, (char *)s, (word)(z - s));
      if (i == Succeeded)
	   return Succeeded;
      else
	   return Failed;
      }


 /* Extract the palette name and skip its comma.*/
   c = *s++;		     /* save initial character */
   p = 0;
   while (s < z && isdigit(*s))    /* scan digits */
      p = 10 * p + *s++ - '0';
   while (s < z && *s == ' ')	  /* skip blanks */
	 s++;
   if (s >= z || p == 0 || *s++ != ',')/* skip comma */
      return Failed;
   if (c == 'g' && p >= 2 && p <= 256)	/* validate grayscale number */
      p = -p;
   else if (c != 'c' || p < 1 || p > 6)	/* validate color number */
      return Failed;

   /* Scan the image to see which colors are needed. */
   e = palsetup(p);
   if (e == NULL)
      return Failed;
   for (i = 0; i < 256; i++)
      e[i].used = 0;
   nchars = 0;
   for (t = s; t < z; t++) {
      c = *t;
      e[c].used = 1;
      if (e[c].valid || e[c].transpt)
         nchars++;	/* valid color, or transparent */
      else if (c != PCH1 && c != PCH2)
         return Failed;
      }
   if (nchars == 0)
      return Failed;			/* empty image */
   if (nchars % width != 0){
      return Failed;			/* not rectangular */
      }

   /* Create the texture */

   height = nchars/width;

   i = textureimg(w, width, height, e, s, (word)(z-s));
   if (i == Succeeded)
      return Succeeded;
   else
      return Failed;
}

/* convert a file into a opengl texture */
int fileimage(wbp w, char* filename)
{
   int r, i;
   int status;
   struct imgdata im;

   im.format = UCOLOR_RGB;
   im.is_bottom_up = 1;

   /* a gif file */
   if ((r = readGIF(filename, 0, &im)) == Succeeded){
      i = textureimg(w, im.width, im.height, im.paltbl, im.data,
                     (word)im.width*(word)im.height);
      free(im.data);
      free(im.paltbl);

      }
   else {
      /*
       * Not a gif file. We need to handle other cases beside gif...
       * what are those cases ? ... look at ReadImage
       */
     i = SCREENDEPTH(w);
     i = i / 8;

     if ((r = readImage(filename, i, &im)) == Succeeded) {
        switch (i) {
        case 1: i = textureimg(w, im.width, im.height, im.paltbl, im.data,
                        (word)im.width*(word)im.height);
                if (im.data){ free(im.data); im.data = NULL;}
                if (im.paltbl){ free(im.paltbl); im.paltbl = NULL;}
                break;
        case 2: /* 16-bit display, but opengl does the right thing for us */
        case 3:
        case 4: i = texture_24img(w, im);
                if (im.data){ free(im.data); im.data = NULL;}
                if (im.paltbl){ free(im.paltbl); im.paltbl = NULL;}
                break;
        }
      }
     else
        r = readimage(w, filename, 0, 0, &status);
   }

   if (i == Succeeded)
	 return Succeeded;
   else
      return Failed;
}


/*
 * converts the icon representation of an image into
 * a format accepted by opengl
 */
int textureimg(wbp w, int width, int height,
               struct palentry *e, unsigned char *s, word len)
{
   wcp wc = w->context;
   int c, v, i;
   unsigned int ix = 0, iy = height -1;
   GLubyte *tex = (GLubyte *)malloc(height * width * 4 + 1);
   if (tex == NULL)
      return Failed;
     
   makecurrent(w);

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   while (len--) {
      c = *s++;
      v = e[c].valid;
      if (v) {
         /* r,g,b component must be between 0 and 256 */
	   tex[(iy*width+ix)*3+0] = e[c].clr.red/256;
	   tex[(iy*width+ix)*3+1] = e[c].clr.green/256;
 	   tex[(iy*width+ix)*3+2] = e[c].clr.blue/256;
        }
      if (v || e[c].transpt) {		/* advance if valid or transparent */
	   if (e[c].transpt) { /* if transparent use background color */
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
 
           tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
         }
         if (++ix >= width) {
            ix = 0;
	  	/* reset for new row */
            iy--;
            }
         }
      }
      if (ix > 0) {	/* pad final row if incomplete */
         while (ix < width) {
            tex[(iy*width+ix)*3+0] = (GLint)RED(w->context->bg);
            tex[(iy*width+ix)*3+1] = (GLint)GREEN(w->context->bg);
            tex[(iy*width+ix)*3+2] = (GLint)BLUE(w->context->bg);
            ix++;
           }
	 }

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   if (i == Succeeded) {
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc->display)==Failed) return Failed;*/
      return alcinstalltex(wc->curtexture, wc->display, tex, width, height);
      }
   else {
      free(tex);
      return Failed;
      }
}

/* convert a bi-level image into an opengl texture */
int bltex(wbp w, int width, int height, int ch, char *s, word len)
{
   wcp wc = w->context;
   unsigned int m, msk1, c, ix, iy;
   int r, b, g, i, l;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);
   if (tex == NULL)
      return Failed;

   makecurrent(w);

   m = width % 4;
   if (m == 0)
      msk1 = 8;
   else               /* mask for first byte of row */
      msk1 = 1 << (m - 1);
   ix = width;
   iy = height-1;
   m = msk1;
   while (len--) {
      /* if hexadecimal character */
      if (isxdigit(c = *s++)) {
         if (!isdigit(c))
            c += 9;
         while (m > 0) {
	    --ix;
	    if (c & m){
	       r = (GLint)RED(w->context->fg);
	       g = (GLint)GREEN(w->context->fg);
 	       b = (GLint)BLUE(w->context->fg);
               l = (iy*width+ix)*3;
               tex[l] = r;	/* [ix][iy][0] */
               tex[l+1] = g;	/* [ix][iy][1] */
               tex[l+2] = b;	/* [ix][iy][2] */
            }
	    else if (ch != TCH1) {
    	       r = (GLint)RED(w->context->bg);
	       g = (GLint)GREEN(w->context->bg);
  	       b = (GLint)BLUE(w->context->bg);
               l = (iy*width+ix)*3;
               tex[l] = r;	/* [iy][ix][0] */
               tex[l+1] = g;	/* [iy][ix][1] */
               tex[l+2] = b;	/* [iy][ix][2] */
            }
            m >>= 1;
          }
         if (ix == 0) {	    /* if end of row */
            ix = width;
            iy--;
            m = msk1;
            }
         else
            m = 8;
         }
      }
   if (ix > 0)				/* pad final row if incomplete */
      while (ix < width){
         r = (GLint)RED(w->context->bg);
         g = (GLint)GREEN(w->context->bg);
         b = (GLint)BLUE(w->context->bg);
         l = (iy*width+ix)*3;
         tex[l] = r;	/* [iy][ix][0] */
         tex[l+1] = g;	/* [iy][ix][1] */
         tex[l+2] = b;	/* [iy][ix][2] */
         ix++;
       }

   i = texture(width, height, (GLubyte *)tex, w->context->texmode);
   if (i == Succeeded)  {
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc->display)==Failed) return Failed;*/
      return alcinstalltex(wc->curtexture, wc->display, tex, width, height);
      }
   else {
     free(tex);
     return Failed;
     }
}

/* apply a texture to a scene */
int texture(int width, int height, GLubyte *tex, int texmode)
{
   GLubyte *tex2;

   /* if not a power of two, scale image to closest power of two */
   if (not_poweroftwo(width) || not_poweroftwo(height)) {
      int neww=1, newh=1, rv;
      while (neww * 2 < width) neww *= 2;
      while (newh * 2 < height) newh *= 2;
      tex2 = (GLubyte *) malloc(neww * newh * 3);
      if (tex2 == NULL) return Failed;
      rv = gluScaleImage(GL_RGB, width, height, GL_UNSIGNED_BYTE, tex,
			 neww, newh, GL_UNSIGNED_BYTE, tex2);
      if (rv) { free(tex2); return Failed; }
      width = neww;
      height = newh;
      }
   else tex2 = tex;

   glTexImage2D(GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB,
		GL_UNSIGNED_BYTE, tex2);

   if (tex2 != tex) free(tex2);

   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, texmode);
   return Succeeded;
}

int texture1(int width, int height, GLubyte *tex, int texmode)
{
   GLubyte *tex2;

   /* if not a power of two, scale image to closest power of two */
   if (not_poweroftwo(width) || not_poweroftwo(height)) {
      int neww=1, newh=1, rv;
      while (neww * 2 < width) neww *= 2;
      while (newh * 2 < height) newh *= 2;
      tex2 = (GLubyte *) malloc(neww * newh * 3);
      if (tex2 == NULL) return Failed;
      rv = gluScaleImage(GL_RGB, width, height, GL_UNSIGNED_BYTE, tex,
			 neww, newh, GL_UNSIGNED_BYTE, tex2);
      if (rv) { free(tex2); return Failed; }
      width = neww;
      height = newh;
      }
   else tex2 = tex;
   glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_RGB,
                GL_UNSIGNED_BYTE, tex2);

   if (tex2 != tex) free(tex2);

   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, texmode);
   return Succeeded;
}


/*
 * do a translation
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int translate(wbp w, dptr argv, int i, dptr f)
{
   static dptr constr;
   double coords[3];
   int j, nfields, draw_code;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_translate")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * convert parameters and perform the translation
    */
   for (j=0; j<3; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return (-(i+j)-1);

   makecurrent(w);
   glTranslated(coords[0], coords[1], coords[2]);

   /*
    * Create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Translate", 9, &(rp->fields[0]));

   draw_code = si_s2i(redraw3Dnames, "Translate");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   for (j = i; j < i+3; j++)
      rp->fields[2 + j - i] = argv[j];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * do a rotation
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int rotate(wbp w, dptr argv, int i, dptr f)
{
   int nfields, j, draw_code;
   double coords[4];
   static dptr constr;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_rotate")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /* convert parameters and perform the rotation */
   for (j=0; j < 4; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return (-(i+j)-1);
   makecurrent(w);
   glRotated(coords[0], coords[1], coords[2], coords[3]);

   /*
    * create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Rotate", 6, &(rp->fields[0]));

   draw_code = si_s2i(redraw3Dnames, "Rotate");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   /* strangeness here preserves name,x,y,z,... field ordering */
   rp->fields[5] = argv[i];
   rp->fields[2] = argv[i+1];
   rp->fields[3] = argv[i+2];
   rp->fields[4] = argv[i+3];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * do a scaling
 * return -i for runerr 102 on arg i; return 1 for runerr(0) on alloc failure
 */
int scale(wbp w, dptr argv, int i, dptr f)
{
   int nfields, j, draw_code;
   double coords[3];
   static dptr constr;
   tended struct b_record *rp;

   if (!constr)
      if (!(constr = rec_structor3d("gl_scale")))
	 syserr("failed to create opengl record constructor");
   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   /*
    * convert parameters and perform scaling
    */
   for(j=0; j<3; j++)
      if (!cnv:C_double(argv[i+j], coords[j])) return -(i+j)-1;
   makecurrent(w);
   glScaled(coords[0], coords[1], coords[2]);

   /*
    * create a record of the graphical object and its parameters
    */
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return 1);
   f->dword = D_Record;
   f->vword.bptr = (union block *)rp;
   MakeStr("Scale", 5, &(rp->fields[0]));
   draw_code = si_s2i(redraw3Dnames, "Scale");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   for (j = i; j < i+3; j++)
      rp->fields[2 + j - i] = argv[j];
   c_put(&(w->window->funclist), f);
   return 0;
}

/*
 * Lookup a texture given its name (filename), and reuse it insted of reloading
 * it from disk. Otherwise create a new texture.
 * NOTE: The lookup is a linear search! not good enough for a program
 * with large number of textures. We should improve this.
 * returns:
 *         The index of the texture if found
 *         Succeeded, if a new texture is created
 *         Failed, if a new texture could not be created
 */

int lookup_texture_byname(wbp w, char *name, int len, int ttype, int curtex)
{
   char filename[MaxFileName +1];
   wcp wc = w->context;
   wtp wt;
   wdp wd = wc->display;
   int i, saved_tex;

   makecurrent(w);
   i=0;
   while (i<wd->ntextures) {
      wt = &(wd->stex[i]);
      if (wt->textype == ttype) {
	 switch (ttype) {
	 case 1: /* file */
	    if ((StrLen(wt->d) == len) && strncmp(StrLoc(wt->d),name,len)==0) {
	       wc->curtexture = i;
	       return i;
	       }
	    break;
	 case 2: /* window */
	    break;
	 case 3: /* string */
	    break;
	    }
	 }
      i++;
      }

   saved_tex = wc->curtexture;
   if (curtex == -1) {
      /*
       * need a new texture name, make room for it if necessary
       */
      if (!make_enough_texture_space(wc->display)) return Failed ;
      wc->curtexture = wc->display->ntextures;
      }
   else /* replace the curtex */
      wc->curtexture = curtex;

   wt = &(wd->stex[wc->curtexture]);
   wt->textype = ttype;
   StrLoc(wt->d) = strdup(name);
   StrLen(wt->d) = len;
   wt->w = w;

   glBindTexture(GL_TEXTURE_2D, wt->texName);

   if (ttype == 3)
      i = imagestr(w, name);
   else {
      strncpy(filename, name, MaxFileName);
      filename[MaxFileName] = '\0';
      i = fileimage(w, filename);
      }

   if (i == Succeeded){
      wd->ntextures++;
      return Succeeded;
      }
   else{
      wc->curtexture=saved_tex;
      return Failed;
      }
}

int texture_24img(wbp w, struct imgdata im)
{
   wcp wc = w->context;
   int width=im.width, height=im.height;
   word l, wd3x2=width*3*2;
   int i, j;
   unsigned char *t;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);
   if (tex == NULL)
      return Failed;
   makecurrent(w);

   /*
    * convert string s into an array that can be used by opengl as a texture.
    * we must start at height=height-1 and width=0 to make this look right
    */

   t = im.data;

#ifdef XWindows
   l =  (height-1) * width * 3;
   for(j=0; j < height; j++){
	for(i=0; i < width; i++) {
           tex[l] = t[0]; tex[l+1] = t[1]; tex[l+2] = t[2];
	   l = l + 3; t += 3;
	   }
   	l -= wd3x2;
	}
#else					/* XWindows */
   {
   word l, wd3x2=width*3*2, wh3=width*height*3;
   for(l=0; l < wh3; l+=3, t+=3) {
      tex[l] = t[0]; tex[l+1] = t[1]; tex[l+2] = t[2];
      }
   }
#endif					/* XWindows */

   /* set the texture */
   i = texture(width, height, (GLubyte *)tex, w->context->texmode);

   if (i == Succeeded) {
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc->display)==Failed) return Failed;*/
      return alcinstalltex(wc->curtexture, wc->display, tex, width, height);
      }
   else {
      free(tex);
      return Failed;
      }
}

int drawstrng3d(wbp w, double x, double y, double z, char *s)
{
#if HAVE_LIBFTGL
   int xx=0;
   char *p, *q;
#ifdef WIN32
   char path[255] = "..\\dat\\fonts\\";
#else
   char path[255] = "../dat/fonts/";
#endif
   static char *full_name = NULL;
   FILE *f = 0;
#if NT
   struct _stat sb;
#else					/* NT */
   struct stat sb;
#endif					/* NT */

   int len_full_name=0, len_path=0, len_font;

   if (!curr_font) {
      add_3dfont("nimbu26.ttf", 5, 5);
      curr_font = end_font;
      }
   len_font=strlen(curr_font->name);
   makecurrent(w);
   if (full_name==NULL) {
      full_name = (char *) malloc(sizeof(char)*255);
      findonpath("unicon", full_name, 255);
      q = full_name + strlen(full_name);
      while (q > full_name && q[-1] != '/')
	 q--;
      *q = '\0';
      }
   len_path = strlen(path);
   len_full_name = strlen(full_name);
   p = (char *) malloc(sizeof(char)*(len_full_name+len_path+len_font+1));
   if (!p) return Failed;
   strcpy(p, full_name);
   strcat(p,path);
   strcat(p,curr_font->name);

   if (stat(p, &sb) == -1) {
      fprintf(stderr, "can't stat font file %s\n", p);
      fflush(stderr);
      free(p);
      return Failed;
      }

   xx=cpp_drawstring3d(x*64,y*64,z*64,s,p,curr_font->type, curr_font->size,
		       &(curr_font->fonts));

   switch (xx) {
   case 1: fprintf(stderr, "Error:file does not support point size\n"); break;
   case 2: fprintf(stderr, "Insufficient Memory to allocate font\n"); break;
   case 3: fprintf(stderr, "Return 3\n"); break;
      }

   free(p);
   return ((xx==0)?Succeeded:Failed);
#else					/* HAVE_LIBFTGL */
   return Failed;
#endif					/* HAVE_LIBFTGL */
}

int add_3dfont(char *fname, int fsize, char ftype)
{
#if HAVE_LIBFTGL
  if (end_font) {
     end_font->next = (struct _wfont *) malloc(sizeof(struct _wfont));
     end_font = end_font->next;
     if (!end_font) return 0;
     }
  else {
     end_font = (struct _wfont *) malloc(sizeof(struct _wfont));
     if (!end_font) return 0;
     start_font = end_font;
     }
   end_font->name = (char *) strdup(fname);
   if (!end_font->name)
	return 0;
   end_font->size = fsize;
   end_font->type = ftype;
   end_font->fonts = 0;
   end_font->next = 0;
#endif					/* HAVE_LIBFTGL */
   return 1;
}

wfp
srch_3dfont(char *fname, int fsize, char ftype)
{
#if HAVE_LIBFTGL
   wfp g = start_font;
   while (g) {
      if (!strcmp(g->name, fname) && g->size==fsize && g->type==ftype) {
	 return g;
	 }
      g = g->next;
      }
#endif					/* HAVE_LIBFTGL */
  return 0;
}

int setmeshmode(wbp w, char* s)
{
   int draw_code, t=0;
   static dptr constr;
   int nfields;
   tended struct b_record *rp;
   tended struct descrip f;

   if (!constr && !(constr = rec_structor3d("gl_meshmode")))
      syserr("failed to create opengl record constructor");

   nfields = (int) ((struct b_proc *)BlkLoc(*constr))->nfields;

   makecurrent(w);

   /*
    * create a record of the graphical object
    */

   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return -1);

   f.dword = D_Record;
   f.vword.bptr = (union block *)rp;

   MakeStr("MeshMode", 8 ,&(rp->fields[0]));


   draw_code = si_s2i(redraw3Dnames, "MeshMode");
   if (draw_code == -1)
       return Failed;
   MakeInt(draw_code, &(rp->fields[1]));

   if (!strcmp(s, "points")) t=GL_POINTS;
   else if (!strcmp(s, "lines")) t=GL_LINES;
   else if (!strcmp(s, "linestrip")) t=GL_LINE_STRIP;
   else if (!strcmp(s, "lineloop")) t=GL_LINE_LOOP;
   else if (!strcmp(s, "triangles")) t=GL_TRIANGLES;
   else if (!strcmp(s, "trianglefan")) t=GL_TRIANGLE_FAN;
   else if (!strcmp(s, "trianglestrip")) t=GL_TRIANGLE_STRIP;
   else if (!strcmp(s, "quads")) t=GL_QUADS;
   else if (!strcmp(s, "quadstrip")) t=GL_QUAD_STRIP;
   else if (!strcmp(s, "polygon")) t=GL_POLYGON;
   else return Failed;

   MakeInt(t, &(rp->fields[2]));
   c_put(&(w->window->funclist), &f);

   w->context->meshmode = t;
   return Succeeded;
}

int setselectionmode(wbp w, char* s)
{
   tended struct descrip f;
   tended struct descrip mode;
   wcp wc = w->context;

   makecurrent(w);
   /* create a list to store function information */
   if (create3Dlisthdr(&f, "Pick", 4)!=Succeeded)
     return RunError;

   if (!strcmp("on", s))
	   wc->selectionenabled = 1;
   else if (!strcmp("off", s))
	   wc->selectionenabled = 0;
   else
	   return RunError;

   wc->app_use_selection3D = 1;

   MakeInt(wc->selectionenabled, &mode);
   c_put(&f, &mode);

   c_put(&(w->window->funclist), &f);
   return Succeeded;
}

/*
 *                     Dynamic Texture Functions
 */

#define INVISIBLE(a, b, start, finish) (a>finish || b<start)

#define SWAPINT(x, y) do{ int t=x; x=y; y=t; }while(0)

#define CLIPENDS(a, b, start, finish) do {\
 	if (a<start) a=start; if (b>finish) b=finish; } while(0)

#define FCLIPENDS(a, b, start, finish, flag1, flag2) do {\
	if (a<start) { a=start;  flag1=1;} else flag1=0; \
	if (b>finish){ b=finish; flag2=1;} else flag2=0;} while (0)


#ifdef XWindows
#define MKCURRENT3D(w3d) \
   glXMakeCurrent(w3d->window->display->display, w3d->window->win, w3d->context->ctx);
#endif					/* XWindows */

#ifdef MSWindows
#define MKCURRENT3D(w3d){ \
   HDC stddc = CreateWinDC(w3d); \
   wglMakeCurrent(stddc, w3d->context->ctx); \
   ReleaseDC(w3d->window->iconwin, stddc);}
#endif					/* MSWindows */

#define TEXUPDATE(win, wc, texhand, tex, wd, ht) \
      if (wc->buffermode) { \
      	  wc->curtexture = texhand; \
      	  MKCURRENT3D(wc->display->stex[texhand].w); \
	  glBindTexture(GL_TEXTURE_2D, wc->display->stex[texhand].texName); \
	  texture1(wd, ht, tex, \
	    wc->display->stex[texhand].w->context->texmode); }


int TexDrawLine(wbp w, int texhandle, int x1, int y1, int x2, int y2)
{
   wcp wc=w->context;
   wdp wdptr=wc->display;
   char steep, ystep;
   int cred, cgreen, cblue;
   int wd3, wd, ht, yy, xx, l, yb, yt, xl, xr,
        dx, dy, ee, tx, clip1, clip2, y0, x0,
	top, rit, pixelshift;
   GLubyte *tex;

   cred = (GLint) RED(wc->fg);
   cgreen = (GLint) GREEN(wc->fg);
   cblue = (GLint) BLUE(wc->fg);

   tex = wdptr->stex[texhandle].tex;
   wd  = wdptr->stex[texhandle].width;
   ht  = wdptr->stex[texhandle].height;

   /* Bresenham algorithm for line drawing */
   if (x2==x1) {
      if (x2 < 0 || x2 >= wd) return Failed;
      /* Vertical line (i.e. y-direction) */
      if (y2 < y1) SWAPINT(y1, y2);
      CLIPENDS(y1, y2, 0, ht-1);
      if INVISIBLE(y1, y2, 0, ht-1) return Failed;
      wd3 = wd * 3;
      l = wd3 * (ht-y1-1) + x1 * 3;
      for (yy = y1; yy <= y2; yy++) {
	 tex[l] = cred; tex[l+1]=cgreen; tex[l+2]=cblue;
	 l -= wd3;
	 }
      }
   else if (y2==y1){
      if (y2 < 0 || y2 >= wd) return Failed;
      /* Horizonal line (i.e. x-direction) */
      if (x2 < x1) SWAPINT(x1, x2);
      CLIPENDS(x1, x2, 0, wd-1);
      if INVISIBLE(x1, x2, 0, wd-1) return Failed;
      wd3 = wd * 3;
      l = wd3 * (ht-y1-1) + x1 * 3;
      for (xx = x1; xx <= x2; xx++) {
	 tex[l] = cred; tex[l+1]=cgreen; tex[l+2]=cblue;
	 l += 3;
	 }
      }
   else {  /* All other lines */
      steep = abs(y2 - y1) > abs(x2 - x1);
      if (steep) {
         SWAPINT(x1, y1);
      	 SWAPINT(x2, y2);
      	 top = wd - 1; rit = ht -1; 
         }
      else{ top = ht-1; rit = wd-1;  }

      if (x1 > x2) { SWAPINT(x1, x2); SWAPINT(y1, y2);} 

      dx = x2 - x1;
      ee  = 0;
      y0 = y1;
      x0 = x1;
      if (y1 < y2){
      	 ystep = 1;
      	 if (steep)
	    { wd3 = wd * -3; tx=3;} 
	 else 
	    { wd3 = wd * -3; tx=3;}
      	 dy = y2 - y1;
      	 FCLIPENDS(y1, y2, 0, top, yb, yt);
      	 if INVISIBLE(y1, y2, 0, top) return Failed;
      	 if (yb){
      	    clip1 = (0-y0)* dx/(ystep*dy) + x0;
      	    if (clip1<0) clip1=0;
            }
      	 else clip1=0;

      	 if (yt){
            clip2 = (top-y0)* dx/(ystep*dy) + x0;
            if(clip2>rit) clip2=rit;
            }
      	 else clip2=rit;

      	 if (y2==y1) return Failed;
      	 FCLIPENDS(x1, x2, clip1, clip2, xl, xr);
      	 if INVISIBLE(x1, x2, 0, rit) return Failed;

      	 if (xl){
      	    clip1 = (0-x0)* (ystep*dy)/dx + y0;
      	    if(clip1<0 || clip1>top) clip1=0;
            }
	 else clip1=0;

      	 if (xr){
      	    clip2 = (rit-x0)* (ystep*dy)/dx + y0;
      	    if(clip2<0 || clip2>top) clip2=top;
            }
	 else clip2=top;

	 CLIPENDS(y1, y2, clip1, clip2);
      	 if INVISIBLE(y1, y2, 0, top) return Failed;	

         }
      else{ /* y1 > y2 */
         ystep = -1;
      	 if (steep)
	    { wd3 = wd * -3; tx=-3;} 
	 else 
	    { wd3 = wd * 3; tx=3;}
      	 dy = y1 - y2;
      	 FCLIPENDS(y2, y1, 0, top, yb, yt);
      	 if INVISIBLE(y2, y1, 0, top) return Failed;
      	 if (yb){
      	    clip2 = (0-y0)* dx/(ystep*dy) + x0;
      	    if(clip2>rit) clip2=rit;
            }
      	 else clip2=rit;

      	 if (yt){
            clip1 = (top-y0)* dx/(ystep*dy) + x0;
            if(clip1<0)clip1=0;
            }
      	 else clip1=0;

      	 if (y2==y1) return Failed;
      	 FCLIPENDS(x1, x2, clip1, clip2, xl, xr);
      	 if INVISIBLE(x1, x2, 0, rit) return Failed;

      	 if (xl){
      	    clip1 = (0-x0)* (ystep*dy)/dx + y0;
      	    if(clip1<0 || clip1>top) clip1=top;
            }
	 else clip1=top;

      	 if (xr){
      	    clip2 = (rit-x0)* (ystep*dy)/dx + y0;
      	    if(clip2<0 || clip2>top) clip2=0;
            }
	 else clip2=0;

	 CLIPENDS(y2, y1, clip2, clip1);
      	 if INVISIBLE(y2, y1, 0, top) return Failed;
	   
         }

      dx = x2 - x1;
      dy = abs(y2 - y1);

      if (steep){
         l = (wd * (ht-x1-1) + y1) * 3;
         pixelshift = wd3;
         }
      else{
         l = (wd * (ht-y1-1) + x1) * 3;
         pixelshift = 3;
         }

      for (xx=x1; xx<=x2; xx++) {
         tex[l] = cred; tex[l+1] = cgreen; tex[l+2] = cblue;
      	 ee += dy;
      	 if (2 * ee >= dx) { l+=wd3+tx; ee -= dx; }
      	 else l += pixelshift;
         }
   }

   TEXUPDATE(w, wc, texhandle, tex, wd, ht);
   return Succeeded;
}

int TexDrawRect(wbp w, int texhandle, int x, int y, int width, int height)
{
   wcp wc=w->context;
   int x2, y2;
   int cred, cgreen, cblue;
   int wd3, wd, ht, yy, xx, l;
   GLubyte *tex;
   int skipTop=0, skipBottom=0, skipLeft=0, skipRight=0,
       flipx=0, flipy=0; 

   cred = (GLint) RED(wc->fg);
   cgreen = (GLint) GREEN(wc->fg);
   cblue = (GLint) BLUE(wc->fg);

   tex = wc->display->stex[texhandle].tex;
   wd  = wc->display->stex[texhandle].width;
   ht  = wc->display->stex[texhandle].height;

   /* if width/height is negative, flip it and readjust x and y accroridngly */
   if (width < 0){ x+= width; width=-width; flipx=1;}
   if (height < 0){ y+= height; height=-height; flipy=1;}

   if (x+width<0 || x>wd || y+height<0 || y>ht) return Failed;

   if (x<0){ 
      width+=x; x=0; 
      if (flipx) skipRight=1; else skipLeft=1;
      }
   if (x+width >= wd ) { 
      width=wd-x-1; 
      if (flipx) skipLeft=1; else skipRight=1;
      }
   if (y<0){ 
      height+=y; y=0; 
      if (flipy) skipTop=1; else skipBottom=1;
      }
   if (y+height >= ht ) {
      height=ht-y-1; 
      if (flipy)  skipBottom=1; else skipTop=1;
      }

   if (width==0 || height==0) return Failed;

   wd3 = wd * 3;

   /* Horizontal 1 */
   x2=width+x;
   if (!skipBottom){
      l =  wd3 * (ht - y-1) + x * 3;
      for (xx = x; xx <= x2; xx++) {
       	  l = l + 3;
       	  tex[l] = cred; tex[l+1]=cgreen; tex[l+2]=cblue;
       	  }
       }

   /* Horizontal 2 */
   y2=y+height;
   if (!skipTop){
      l =  wd3 * (ht - y2-1) + x * 3;
      for (xx = x; xx <= x2; xx++) {
       	  l = l + 3;
       	  tex[l] = cred; tex[l+1]=cgreen; tex[l+2]=cblue;
       	  }
      }

   /* verticals 1 & 2 */
   if (!skipLeft){
      l =  wd3 * (ht-y - 1) + x * 3;
      for (yy = y; yy <= y2; yy++) {
       	  tex[l] = cred; tex[l+1]=cgreen; tex[l+2]=cblue;
       	  l -=  wd3;
       	  }
      }

   if (!skipRight){
      l =  wd3 * (ht-y - 1) + x * 3 + width * 3;
      for (yy = y; yy <= y2; yy++) {
       	  tex[l] = cred; tex[l+1]=cgreen; tex[l+2]=cblue;
       	  l -=  wd3;
       	  }
      }

   TEXUPDATE(w, wc, texhandle, tex, wd, ht);
   return Succeeded;
}

int TexFillRect(wbp w, int texh, int x, int y, int width, int height, int isfg)
{
   wcp wc=w->context;
   int x2, y2;
   int cred, cgreen, cblue;
   int wd3, wd, ht, yy, xx, l;
   GLubyte *tex;

   if (isfg){
      cred = (GLint) RED(wc->fg);
      cgreen = (GLint) GREEN(wc->fg);
      cblue = (GLint) BLUE(wc->fg);
      }
   else{
      cred = (GLint) RED(wc->bg);
      cgreen = (GLint) GREEN(wc->bg);;
      cblue = (GLint) BLUE(wc->bg);
      }

   tex = wc->display->stex[texh].tex;
   wd  = wc->display->stex[texh].width;
   ht  = wc->display->stex[texh].height;

   /* if width/height is negative, flip it and readjust x and y accordingly */
   if (width < 0){ x+= width; width=-width; }
   if (height < 0){ y+= height; height=-height; }

   if (x+width<0 || x>=wd || y+height<0 || y>=ht) {
      return Failed;
      }

   if (x<0){ width+=x; x=0;}
   if (x+width > wd ) width=wd-x-1;
   if (y<0){ height+=y; y=0;}
   if (y+height > ht ) height=ht-y-1;

   if ((width==0) || (height==0)) {
      return Failed;
      }

   wd3 = wd * 3;

   /* Horizontal 1 */
   x2=width+x; y2=y+height;

   for (yy=y; yy<y2; yy++){
       l =  wd3 * (ht-yy - 1) + x * 3;
       for (xx = x; xx < x2; xx++) {
       	   tex[l] = cred;
       	   tex[l+1]=cgreen;
       	   tex[l+2]=cblue;
       	   l = l + 3;
       	   }
	}
   TEXUPDATE(w, wc, texh, tex, wd, ht);
   return Succeeded;
}

int TexDrawPoint(wbp w, int texhandle, int x, int y)
{
   wcp wc=w->context;
   int cred, cgreen, cblue, l, wd, ht;
   GLubyte *tex;

   cred = (GLint) RED(wc->fg);
   cgreen = (GLint) GREEN(wc->fg);
   cblue = (GLint) BLUE(wc->fg);

   tex = wc->display->stex[texhandle].tex;
   wd  = wc->display->stex[texhandle].width;
   ht  = wc->display->stex[texhandle].height;

   if (x<0 || x>=wd || y<0 || y>=ht) 
      return Failed;

   l = 3 * (x + wd * (ht-y - 1));
   tex[l] = cred;
   tex[l+1]=cgreen;
   tex[l+2]=cblue;

   TEXUPDATE(w, wc, texhandle, tex, wd, ht);
   return Succeeded;
}

/*
 * Update Texture with new image data
 */

int TexReadImage(wbp w, int texhandle, int x, int y, struct imgdata *imd)
{
   wcp wc=w->context;
   int wd, ht, l, nextLineOffset, i, j;
   GLubyte *tex;
   unsigned char *s;

   tex = wc->display->stex[texhandle].tex;
   wd  = wc->display->stex[texhandle].width;
   ht  = wc->display->stex[texhandle].height;

   /*  check for width and height.  the old texture with the new image  */
   if (wd<x+imd->width || ht<y+imd->height)
      return Failed;

   s = imd->data ;  /* point to the image data*/

   l = (ht-y-imd->height)*wd*3 + ( x)*3; /* first byte in texture data to be updated */
   nextLineOffset = (wd-imd->width)*3;

   for (i=0; i<imd->height; i++) {
      for (j=0; j<imd->width; j++) {
	 tex[l] = (GLubyte) *s++;
	 tex[l+1] = (GLubyte) *s++;
	 tex[l+2] = (GLubyte) *s++;
	 l+=3;
	 }
      l += nextLineOffset;
      }

   TEXUPDATE(w, wc, texhandle, tex, wd, ht);
   return Succeeded;
}

int copyareaTexToTex(wbp w, int texhandle, int dest_texhandle,
		     int x, int y, int width, int height, /* box to copy */
		     int xt, int yt)    /* dest loc */
{
   wdp wd = w->window->display;
   GLubyte *src = wd->stex[texhandle].tex;
   GLubyte *dest = wd->stex[dest_texhandle].tex;
   int srcwd = wd->stex[texhandle].width;
   int srcht = wd->stex[texhandle].height;                /* src dims */
   int txw = wd->stex[dest_texhandle].width;
   int txh = wd->stex[dest_texhandle].height;
   int i, j;
   int srcl;              /* source index */
   int dstl;              /* destination index */
   int tws3 = srcwd * 3;
   int twd3 = txw * 3;
   GLubyte b;

   for(j=0; j < height; j++){
      srcl = (srcht-y-j-1)*tws3 + x * 3;
      dstl = (txh-yt-j-1)*twd3 + xt * 3;
      for(i=0; i < width; i++) {
	 b = src[srcl];
           dest[dstl] =b;
           dest[dstl+1] = src[srcl+1];
           dest[dstl+2] = src[srcl+2];
	   srcl += 3;
	   dstl += 3;
	   }
	}

   MKCURRENT3D(w);
   glBindTexture(GL_TEXTURE_2D,
		 wd->stex[dest_texhandle].texName);
   texture(wd->stex[dest_texhandle].width,
	   wd->stex[dest_texhandle].height,
	   wd->stex[dest_texhandle].tex,
	   w->context->texmode
	   );
   return Succeeded;
}

/* copy from a 2D window to a texture */
int copyareaToTex2D(wbp w2d, GLubyte *tex, int x, int y,  
    int width, int height, int xt, int yt, int txw, int txh)
{
   struct imgmem imem;
   int i, j, l, twd3;
   long rv;
   LinearColor clr;
   unsigned long c;
#ifdef XWindows
   wdp wd = w2d->window->display;
   Display *stddpy = wd->display;
   Visual *vis = w2d->window->vis;
   XColor clrcell;
/*   wclrp cp, lastcp = wd->colors; */
   TRUECOLOR_DECLARE_AND_INIT_RGB_VARS(vis->red_mask, vis->green_mask,vis->blue_mask);
#endif					/* XWindows */

   imem.x = x;
   imem.y = y;
   imem.width = width;
   imem.height = height;
   /* call get pixel to get pixel information */
   if (getpixel_init(w2d, &imem) == Failed)
      return Failed;

   twd3 = txw * 3;

#ifdef XWindows
   if(vis->class==TrueColor){ 

      for(j=0; j < height; j++){
   	l = (txh-1-yt-j)*twd3 + xt * 3;
	for(i=0; i < width; i++) {
	   c =  XGetPixel(imem.im, i, j);
           tex[l] = TRUECOLOR_GET_RGB_RED(c);
           tex[l+1] = TRUECOLOR_GET_RGB_GREEN(c);
           tex[l+2] = TRUECOLOR_GET_RGB_BLUE(c);
	   l = l + 3;
	   }
	}
      return Succeeded;
      }
#endif

   for(j=0; j < height; j++){
   	l = (yt+j)*twd3 + xt * 3;
	for(i=0; i < width; i++) {
#ifdef XWindows
	   clrcell.pixel = XGetPixel(imem.im, i, j);
/*	   rv = 0xff000000;
	   if  (lastcp->c == c){
	      tex[l] = lastcp ->r>>8;
	      tex[l+1] = lastcp->g>>8;
	      tex[l+2] = lastcp->b>>8;
	      l = l + 3;
	      continue;
	      }
	   else
	      for (cp = wd->colors ; cp < wd->colors + wd->numColors; cp++) {
		 if (cp->c == c) {
		    lastcp = cp;
		    tex[l] = cp->r>>8;
		    tex[l+1] = cp->g>>8;
		    tex[l+2] = cp->b>>8;
		    l = l + 3;
		    continue;
		    }
		 }
	   if (rv == 0xff000000) {
*/
	      XQueryColor(stddpy, wd->cmap, &clrcell);
	      rv = 1;
	      clr = lcolor(w2d, clrcell);
              tex[l] = clr.red>>8;
              tex[l+1] = clr.green>>8;
              tex[l+2] = clr.blue>>8;
	      l = l + 3;
/*	      } */
#else
	   {
	   char *s2, strout[50];

	   if (getpixel(w2d, i, height-j-1, &rv, strout, &imem) == Failed)
               return Failed;

           s2 = strout;
           /* parse string to get pixel values */
	   while(isspace(*s2)) s2++;
           tex[l] = atoi(s2)/256;
  	   while(isdigit(*s2)) s2++;
   	   s2++;
           tex[l+1] = atoi(s2)/256;
   	   while (isdigit(*s2)) s2++;
  	   s2++;
           tex[l+2] = atoi(s2)/256;
	   l = l + 3;
	   }
#endif
        }
      }
   return Succeeded;
}

/*
 * Copy from a 3D window to a texture. As written here, it comes out
 * in four-byte RGBA format, and we copy just the RGB part over.
 */
int copyareaToTex3D(wbp w3d, GLubyte *tex, int x, int y,  
    int width, int height, int xt, int yt, int txw, int txh)
{
   wcp wc = w3d->context;
   int i, j, twd3, l, m;
   GLubyte *tex2;

   tex2 = (GLubyte *) malloc((height) * (width) * 4);
   if (!tex2) return Failed;

   /* change the current context to w2's context */
#ifdef XWindows
   glXMakeCurrent(w3d->window->display->display, w3d->window->win, wc->ctx);
   glReadPixels( (GLint) x, (GLint)y, (GLint) width, (GLint) height, 
   		 GL_RGBA, GL_UNSIGNED_BYTE, tex2);
#endif					/* XWindows */
#ifdef MSWindows
   {
   HDC stddc = CreateWinDC(w3d);
   wglMakeCurrent(stddc, w3d->context->ctx);
   glReadPixels( (GLint) x, (GLint)y, (GLint) width, (GLint) height, 
   		 GL_RGBA, GL_UNSIGNED_BYTE, tex2);
   ReleaseDC(w3d->window->iconwin, stddc);
   }
#endif					/* MSWindows */
   twd3 = txw * 3;

   m=0;
      for(j=0; j < height; j++){
   	l = (yt+j)* twd3 + xt * 3;
	for(i=0; i < width; i++) {
           tex[l] =  tex2[m];
           tex[l+1] =  tex2[m+1];
           tex[l+2] =  tex2[m+2];
	   l = l + 3;
	   m = m +4;
	   }
	}    
   free(tex2);
   return Succeeded;
}


/* convert a 2D window into a texture */
int texwindow2D(wbp w, wbp w2d)
{
   int r;
   wsp ws = w2d->window;
   /*
    * Allocate one extra row of memory so as to avoid invalid memory reads
    * past the end of the source texture in gluScaleImage().
    * Per https://bugs.freedesktop.org/show_bug.cgi?id=2510
    */
   GLubyte *tex = (GLubyte *)malloc((ws->height+1) * ws->width * 3);
   wcp wc = w->context;
   makecurrent(w);

   if (tex == NULL)
      return Failed;

   copyareaToTex2D(w2d, tex, 0, 0, ws->width, ws->height, 
   		      0, 0, ws->width, ws->height);

   /* apply the texture */

   MKCURRENT3D(w);
   glBindTexture(GL_TEXTURE_2D, wc->display->stex[wc->curtexture].texName);

   r = texture(ws->width, ws->height, (GLubyte*)tex, w->context->texmode);
   if (r == Succeeded)  {
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc->display)==Failed) return Failed;*/
      r = alcinstalltex(wc->curtexture,wc->display,tex,ws->width,ws->height);
      if (r == Succeeded) wc->display->stex[wc->curtexture].w = w;
      return r;
      }
   else {
     free(tex);
     return Failed;
     }
}

/* use another opengl window as a texture source */
int texwindow3D(wbp w1, wbp w2)
{
   wsp ws = w2->window;
   wcp wc = w2->context, w1c = w1->context;
   int width = ws->width;
   int height = ws->height;
   int i;
   GLubyte *tex = (GLubyte *)malloc(height * width * 3);
   if (tex == NULL)
      return Failed;   

   /* change the current context to w2's context */
#ifdef XWindows
   glXMakeCurrent(ws->display->display, ws->win, wc->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   glXMakeCurrent(w1->window->display->display, w1->window->win, w1c->ctx);
   glBindTexture(GL_TEXTURE_2D, w1c->display->stex[w1c->curtexture].texName);
    i = texture(width, height, (GLubyte *)tex, w1->context->texmode);
#endif					/* XWindows */
#ifdef MSWindows
   {
   HDC stddc = CreateWinDC(w2);
   wglMakeCurrent(stddc, wc->ctx);
   glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, tex);
   ReleaseDC(ws->iconwin, stddc);
   stddc = CreateWinDC(w1);
   wglMakeCurrent(stddc, w1c->ctx);
   glBindTexture(GL_TEXTURE_2D,
		 w1c->display->stex[w1c->curtexture].texName);
   i = texture(width, height, (GLubyte *)tex, w1c->texmode);
   ReleaseDC(w1->window->iconwin, stddc);
   }
#endif					/* MSWindows */
    if (i == Succeeded) {
      /* no need to re-check, the check was made earlier in the code */
      /*if (make_enough_texture_space(wc->display)==Failed) return Failed;*/
      i = alcinstalltex(wc->curtexture, wc->display, tex, width, height);
      if (i == Succeeded) wc->display->stex[wc->curtexture].w = w1;
      return i;
      }
    else {
       free(tex);
       return Failed;
       }
}

/*
 * TexCopyArea copies source image data into a destination texture.
 */
int TexCopyArea(wbp w, wbp w2, int texhandle, int x, int y, int width,
    		 int height, int xt, int yt, int width2, int height2)
{
   wcp wc=w2->context;
   int wd, ht, wwd, wht;
   GLubyte *tex;
 
   wwd =  (int)w->window->width;
   wht =  (int)w->window->height;
   tex = wc->display->stex[texhandle].tex;
   wd  = wc->display->stex[texhandle].width;
   ht  = wc->display->stex[texhandle].height;

   /* if width/height is negative, flip it and readjust x and y accroridngly */
   if (width < 0){  x+= width;  xt+=width;  width=-width;   }
   if (height < 0){ y+= height; yt+=height; height=-height; }


   if (x+width<0 || x>wwd || y+height<0 || y>wht) return Failed;
   if (xt+width<0 || xt>=wd || yt+height<0 || yt>=ht) return Failed;

   if (x<0){ width+=x; x=0;}
   if (xt<0){width+=xt; xt=0;} 
   if (y<0){ height+=y; y=0;}
   if (yt<0){ height+=yt; yt=0;}

   if (x+width > wwd ) width=wwd-x;
   if (xt+width > wd ) width=wd-xt;

   if (y+height > wht ) height=wht-y;
   if (yt+height >= ht ) height=ht-y-1;

   if (width<=0 || height<=0) return Failed;

   if (w->context->is_3D){
      y = wht-y - height;
      yt = ht-yt - height;
      if (copyareaToTex3D(w, tex, x, y, width, height, xt, yt, wd, ht)==Failed)
      	 return Failed;
      }
   else{
      if (copyareaToTex2D(w, tex, x, y, width, height, xt, yt, wd, ht)==Failed)
      	 return Failed;
      }

   TEXUPDATE(w2, wc, texhandle, tex, wd, ht);   
   return Succeeded;
}


int identitymatrix()
{
   glLoadIdentity();
   return Succeeded;
}

/*
 * Swap buffers after output to make it visible on-screen.
 */
void swapbuffers(wbp w, int flush)
{
   if (flush) glFlush();
   glXSwapBuffers(w->window->display->display, w->window->win);
}

/*
 * Erase/Set the 3D window to background color given by r,g,b.
 * Does this need a window argument?
 */
void erasetocolor(int r,int g,int b)
{
   glClearColor(r/(GLfloat)256,	g/(GLfloat)256, b/(GLfloat)256, 0.0);
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    
}

/*
 * Apply/use a texture given by integer texturehandle as the current texture
 * used on subsequent 3D primitives.  Texturehandles are integer indices
 * used internal to our 3D runtime system code to identify previous textures;
 * they must be created/produced by some other call in here, which one?
 */
void bindtexture(wbp w, int texturehandle)
{
   wcp wc = w->context;
   wc->curtexture = texturehandle;
   glBindTexture(GL_TEXTURE_2D, wc->display->stex[wc->curtexture].texName);
}

int create3Dcontext(wbp w)
{
   wcp wc = w->context;
   wdp wd = w->window->display;
#ifdef MSWindows
   HDC hdc = CreateWinDC(w);
   wc->ctx = wglCreateContext (hdc);
   wglMakeCurrent (hdc, wc->ctx);
#else
   wc->ctx = glXCreateContext(wd->display, wd->vis, None, GL_TRUE);
   if (wc->ctx == NULL) 
      return Failed;
   glXMakeCurrent(wd->display, w->window->win, wc->ctx);
#endif
   return Succeeded;
}

/*
 * File: rxwin.ri - X11 system-specific graphics interface code.
 */

#ifdef Graphics

#define RootState IconicState+1

/*
 * Global variables specific to X
 */
XSizeHints size_hints;

/*
 * Utility macros to extract RGB color components when dealing with
 * TRUE COLOR visuals.
 */

#define TRUECOLOR_DECLARE_AND_INIT_RGB_VARS(red_mask, green_mask, blue_mask) \
   unsigned long rshift=0, rbits=0, gshift=0, gbits=0, bshift=0, bbits=0;    \
   do {	    	 	   	    	      	       		 	     \
      unsigned long rmask = red_mask, gmask = green_mask, bmask = blue_mask; \
      while (!(rmask & 1)) { rshift++; rmask >>= 1; }			     \
      while (rmask & 1) { rbits++; rmask >>= 1; } 			     \
      if (rbits>8) { rshift += rbits-8; rbits = 8; } 			     \
      while (!(gmask & 1)) { gshift++; gmask >>= 1; }			     \
      while (gmask & 1) { gbits++; gmask >>= 1; } 			     \
      if (gbits>8) { gshift += gbits-8; gbits = 8;} 			     \
      while (!(bmask & 1)) { bshift++; bmask >>= 1; }			     \
      while (bmask & 1) { bbits++; bmask >>= 1; }  			     \
      if (bbits>8) { bshift += bbits-8; bbits = 8; }			     \
   } while (0)

#define TRUECOLOR_GET_RGB_BYTE(c, cshifts, cbits) (((c >> cshift) & ((1 << cbits)-1)) << (8-cbits))
#define TRUECOLOR_GET_RGB_RED(c)   (((c >> rshift) & ((1 << rbits)-1))  << (8-rbits))
#define TRUECOLOR_GET_RGB_GREEN(c) (((c >> gshift) & ((1 << gbits)-1))  << (8-gbits))
#define TRUECOLOR_GET_RGB_BLUE(c)  (((c >> bshift) & ((1 << bbits)-1))  << (8-bbits))

/*
 * function prototypes
 */
int                  seticonicstate   (wbp w, char *s);
int		     seticonpos       (wbp w, char *s);
int		     handle_misc      (wdp display, wbp w);
static int	     handle_config    (wbp w, XConfigureEvent *event);
static int           handle_exposures (wbp w, XExposeEvent *event);
static void       handle_mouse     (wbp w, XButtonEvent *event);
static void       handle_keypress  (wbp w, XKeyEvent *event);
 void	     postcursor       (wbp w);
 void	     scrubcursor      (wbp w);
static XImage *	     getximage	      (wbp w, int x, int y,
					      int width, int height, int init);
void              moveWindow       (wbp w, int x, int y);
int                  setdisplay       (wbp w, char *s);
void              makeIcon         (wbp w, int x, int y);
int		     wmap	      (wbp w);
Pixmap		     loadimage	      (wbp w, char *filename, unsigned int *height, unsigned int *width, int atorigin, int *status);
void unsetclip (wbp w);


/*
 * write some text to both the window and the pixmap
 */
void xdis(w,s,n)
register wbp w;
char *s;
int n;
   {
   int x, y, delta_x;
   CURTSTATE();
   STDLOCALS(w);

   pollctr>>=1; pollctr++;
   x = ws->x;
   y = ws->y;
   delta_x = XTextWidth(wc->font->fsp,s,n);
   RENDER4(XDrawImageString,x,y,s,n);
   ws->x += delta_x;
   }



/*
 * Routines to convert property data into text strings.
 */

#define NUMBER_ATOMS    14

char*   atom_names[NUMBER_ATOMS]= {
   "CHARACTER_POSITION",
   "CLIENT_WINDOW",
   "CLIPBOARD",
   "HOST_NAME",
   "HOSTNAME",
   "LENGTH",
   "LIST_LENGTH",
   "NAME",
   "OWNER_OS",
   "SPAN",
   "STRING",
   "TARGETS",
   "TIMESTAMP",
   "USER"
};

static Atom     atom_array[NUMBER_ATOMS];

/* Macros to access elements in atom_names array. */
#define CHARACTER_POSITION	0
#define CLIENT_WINDOW		1
#define CLIPBOARD		2
#define HOST_NAME		3
#define HOSTNAME		4
#define LENGTH			5
#define LIST_LENGTH		6
#define NAME			7
#define OWNER_OS		8
#define SPAN			9
#define STRING			10
#define TARGETS			11
#define TIMESTAMP		12
#define USER			13


static int InternAtoms(Display* display)
{
   int i;

#if XlibSpecificationRelease > 5
   /*
    * X11R6 introduces XInternAtoms.
    */
   return XInternAtoms(display, atom_names, NUMBER_ATOMS, False, atom_array);

#else					/* R5 and below. */

   for (i = 0; i < NUMBER_ATOMS; i++) {
      atom_array[i] = XInternAtom(display, atom_names[i], False);

      if (atom_array[i] == None) {
	 return 0;
	 }
      }

   return 1;

#endif					/* R5 and below. */
}

/* TODO: move this into a field on the display structure */
int  intern_status = 0;

Atom ConvertTarget(Display* display, Atom desired_target)
{
   /* Ensure that our atoms are interned. */
   if (intern_status == 0) intern_status = InternAtoms(display);

   /* Check for common cases. */
   if ( (desired_target == atom_array[TIMESTAMP])    ||
       (desired_target == atom_array[LIST_LENGTH] ) ||
       (desired_target == atom_array[LENGTH] ) ) {
      return XA_INTEGER;
      }

   if ( desired_target == atom_array[CHARACTER_POSITION] ) {
      return atom_array[SPAN];
      }

   if ( desired_target == atom_array[TARGETS] ) {
      return XA_ATOM;
      }

   if ( desired_target == atom_array[CLIENT_WINDOW] ) {
      return XA_WINDOW;
      }

   if (( desired_target == atom_array[HOST_NAME] ) ||
       ( desired_target == atom_array[HOSTNAME] ) ||
       ( desired_target == atom_array[NAME] ) ||
       ( desired_target == atom_array[OWNER_OS] ) ||
       ( desired_target == atom_array[USER] ) ) {
      return XA_STRING;
      }
   /* Otherwise, no need to convert target. */
   return desired_target;
}

char* PropertyToString(Display* display, Atom target, int number_items,
    char* data)
{
   Atom            new_target;
   unsigned long*  long_array;
   int*            int_array;
   char*           string = NULL;
   int             i, length;
   char            temp[100];
   char*           atom_name;

   /* Ensure that our atoms are interned. */
   if (intern_status == 0) intern_status = InternAtoms(display);

   /* Convert target, if necessary. */
   new_target = ConvertTarget(display, target);

   if (new_target == XA_ATOM) {

      long_array = (unsigned long*) data;

      length = number_items * 30;
      string = (char*) malloc( length + 1 );
      string[0] = '\0';

      /* Convert to atom names. */
      for (i = 0; i < number_items; i++) {
	 atom_name = XGetAtomName(display, long_array[i] );

	 if (atom_name != NULL) {

	    /* Check that space is available. */
	    length -= strlen(atom_name);
 
	    if (length > 1) {
	       strcat(string, atom_name);
	       strcat(string, "\n");
	       }
	    XFree(atom_name);
            }
	 }
      }
   else if (new_target == XA_STRING) {
      string = (char*) malloc(number_items + 1);
      strcpy(string, data);
      }
   else if ((new_target == XA_INTEGER) ||
            (new_target == atom_array[SPAN]) ||
            (new_target == atom_array[TIMESTAMP]) ) {

      int_array = (int*) data;

      length = number_items * 20;
      string = (char*) malloc( length + 1 );
      string[0] = '\0';

      for (i = 0; i < number_items; i++) {
	 sprintf(temp, "%d ", int_array[i]);

	 /* Check that space is available. */
	 length -= strlen(temp);
	 if (length > 0) {
	    strcat(string, temp);
            }
	 }
      }
   else if (new_target == XA_WINDOW) {

      long_array = (unsigned long*) data;

      length = number_items * 12;
      string = (char*) malloc( length + 1 );
      string[0] = '\0';

      for (i = 0; i < number_items; i++) {
	 sprintf(temp, "0x%8.8ld ", long_array[i]);
	 strcat(string, temp);
	 }

      }
   else {
      /* Add extra cases as necessary... */
      }

   return string;

}

XEvent selectfoo, *bar;

XSelectionEvent *getselectionnotify(wsp ws)
{
   bar = NULL;
   XSelectInput(ws->display->display, ws->win,
		XMasks(ws->inputmask | PropertyChangeMask));
   XFlush(ws->display->display);
   while(bar == NULL) {
      handle_misc(ws->display, NULL);
      }
   XSelectInput(ws->display->display, ws->win, XMasks(ws->inputmask));
   return (XSelectionEvent *)bar;
}

Window requestor;
Atom selection, target;
Time timestmp;

/*
 * Copy from selection/clipboard into our program. Ask for it by asking
 *  to convert, then wait for a notify.
 */
char *copyselection(wsp ws, char* s, int *ip)
{
   Display *display = ws->display->display;
   Window window = ws->win;
   Time	timestamp = (Time) ws->timestamp;
   XSelectionEvent* event;
   int                status;
   unsigned char*     data;
   Atom               actual_target, new_target;
   int                actual_format;
   unsigned long      bytes_remaining, number_items;
   char*              string = NULL;
   unsigned long      str_len = 0;

   /* Ensure that our atoms are interned. */
   if (intern_status == 0) intern_status = InternAtoms(display);
   target = atom_array[STRING];

   XConvertSelection(display, XA_PRIMARY, XA_STRING, target,
		     window, timestamp);
   timestmp = timestamp;
   requestor = window;
   XFlush(display);

   event = getselectionnotify(ws);

   /* Check that property is not NULL. */
   if ((event->property == (Atom) None) ||
       ((event->selection != XA_PRIMARY) &&
		 (event->selection != atom_array[CLIPBOARD])) ||
       (event->requestor == (Window) None) ) {

      /* printf("Owning program failed to convert data."); */

      *ip = 0;
      return NULL;
      }

   /* Check if we need to convert target. */
   new_target = ConvertTarget(display, event->target);

   /*
    * Read data from property identified in SelectionNotify event.
    */
   status = XGetWindowProperty(display, event->requestor, event->property,
                0L,        /* offset */
#define FULL_LENGTH 8192L
                FULL_LENGTH,
                True,      /* Delete when read. */
                new_target,
                &actual_target,
                &actual_format,
                &number_items,
                &bytes_remaining,
                &data);

    if ( ( status == Success ) && (number_items > 0)) {

       /* Convert data to text string. */
       string = PropertyToString(display,
				 new_target, number_items, (char*) data);

       if (string != NULL) {
	  str_len = strlen(string);
	  if (str_len > 4000) s = strdup(string);
	  else strcpy(s, string);
	  XFree(string);
	  }
       if (data)
	  XFree( data );
       }
   *ip = str_len;
   return s;
}

char *getselection(wbp w, char *buf)
{
   int i;
   char *s;

   s = copyselection(w->window, buf, &i);
   if (i == -1) return NULL;

   return s;
}


/*
 * Function to append data to an X property.
 */

static int     ErrorFlag = False;
static int     LastError = None;

#define BUFSIZE     1024

#define NUMBER_ERRORS   18

char*  ErrorCodes[ NUMBER_ERRORS ] = {
   "Success",           /* 0  */
   "BadRequest",        /* 1  */
   "BadValue",          /* 2  */
   "BadWindow",         /* 3  */
   "BadPixmap",         /* 4  */
   "BadAtom",           /* 5  */
   "BadCursor",         /* 6  */
   "BadFont",           /* 7  */
   "BadMatch",          /* 8  */
   "BadDrawable",       /* 9  */
   "BadAccess",         /* 10 */
   "BadAlloc",          /* 11 */
   "BadColor",          /* 12 */
   "BadGC",             /* 13 */
   "BadIDChoice",       /* 14 */
   "BadName",           /* 15 */
   "BadLength",         /* 16 */
   "BadImplementation"  /* 17 */
};


static void ErrorHandler(Display* display, XErrorEvent* error_event)
{   
   char string[BUFSIZE + 1];

   ErrorFlag = True;
   LastError = (int) error_event->error_code;

   /* Find out the error message and print it. */
   XGetErrorText(display, error_event->error_code, string, BUFSIZE);

   fprintf(stderr, "X Error on display %s.i\nResource %ld:  ",
	   DisplayString( display ), error_event->resourceid );

   if ((error_event->error_code > 0 ) && 
       (error_event->error_code < NUMBER_ERRORS ) ) {

      fprintf( stderr, "%s (%s).\n", string,
	      ErrorCodes[ error_event->error_code ] );
      }
   else {
      fprintf( stderr, "%s.\n", string );
      }

   fprintf(stderr, "Op code %d.%d, Error code %d\n", error_event->request_code,
	   error_event->minor_code, error_event->error_code );
   }

int CheckErrorFlag()
{ 
   return ErrorFlag;
} 

void ResetErrorFlag()
{  
   ErrorFlag = False;
   LastError = None;
}

void SetErrorHandler()
{   
   (void) XSetErrorHandler((XErrorHandler) ErrorHandler);
}

int AppendProperty(Display* display, Window window,
    Atom  property,			    /* you should pass "property" */
    Atom  target,			    /* XA_STRING */
    int   format,			    /* 8 */
    unsigned char* data,		    /* data to append */
    int   number_items)			    /* length of data to append */
{   
   SetErrorHandler();			    /* the error handler is set up. */
   ResetErrorFlag();
   if (target != XA_STRING) {
      /* fprintf(stderr, "target %x XA_STRING %x\n", target, XA_STRING); */
      }

   if (number_items > 0) {
      XChangeProperty(display, window, property, target, format, 
			PropModeReplace, data, number_items);
      XSync(display, False);
      if (CheckErrorFlag()) {
	 return False;
	 }
      }
   return True;
}   


int ownselection(Display* display,Window window,Atom selection, Time timestamp)
{   
   Window owner;
   if ((window == (Window) None ) || (selection == (Atom) None ) ) {
      /* printf("No selection was selected"); */
      return False;
      }

   /* Assert ownership of selection. */
   XSetSelectionOwner(display, selection, window, timestamp);

   /* Now check if we made it. */
   owner = XGetSelectionOwner(display, selection);

   if (owner != window) {
      /* fprintf(stderr, "Failed to ownselection\n"); */
      return False;
      }
   return True;
}


/*
 * put a character out to a window using the current attributes
 */
int wputc(ci,w)
int ci;
wbp w;
   {
   int lh, width, height, over;
   char c = (char)ci;
   STDLOCALS(w);

   lh = wc->leading;
   width = ws->width;
   height = ws->height;

   switch(c) {
   case '\r': {
      ws->x = wc->dx;
      break;
      }
   case '\n': {
      if (ISCEOLON(w)) {
         /*
	  * Clear the rest of the line, like a terminal would.
	  * Its arguable whether this should clear to the window
	  * background or the current context background.  If you
	  * change it to use the context background you have to
	  * change the XClearArea call to another XFillRectangle
	  * (cf. eraseArea()).
	  */
	 if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
	 XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
	 XClearArea(stddpy, stdwin,
		    ws->x, ws->y-wc->font->fsp->max_bounds.ascent,
		    width-ws->x, lh, False);
	 XFillRectangle(stddpy, stdpix, stdgc,
			ws->x, ws->y - wc->font->fsp->max_bounds.ascent,
			width - ws->x, lh);
	 XSetForeground(stddpy, stdgc,
			wd->colors[wc->fg].c^(ISXORREVERSE(w)?
					      wd->colors[wc->bg].c:0));
	 if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
         }
      ws->y += lh;
      ws->x = wc->dx;
      /*
       * Now for the exciting part: do we scroll the window?
       * Copy the pixmap upward, then repaint the window.
       */
      over = ws->y + wc->font->fsp->max_bounds.descent - height;
      if (over > 0) {
	 ws->y -= over;

	 if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
	 XCopyArea(stddpy, stdpix, stdpix, stdgc,
		   0, over,			/* x, y */
		   width, height - over,	/* w, h */
		   0, 0);			/* dstx,dsty */
	 XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
	 XFillRectangle(stddpy, stdpix, stdgc,
		   0, height - over, width, over);
	 XSetForeground(stddpy, stdgc,wd->colors[wc->fg].c^(ISXORREVERSE(w)?
							    wd->colors[wc->bg].c:0));
	 if (stdwin)
	    XCopyArea(stddpy, stdpix, stdwin, stdgc, 0, 0, width, height, 0,0);
	 if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
         }
      break;
      }
   case '\t': {
      xdis(w, "        ", 8 - ((XTOCOL(w,ws->x))&7));
      break;
      }
   /*
    * Handle backspaces.  This implements cooked mode echo handling.
    */
   case '\177':
   case '\010': {
      int i = 0, pre_x;
      /*
       * Start with the last character queued up.
       */
      i--;
      /*
       * Trot back to the control-H itself.
       */
      while ((i>-EQUEUELEN) && (EVQUESUB(w,i) != c)) i--;
      if (i == -EQUEUELEN) break;
      /*
       * Go past the control-H.
       */
      i--;
      /*
       * Go back through any number of control-H's from prior lifetimes.
       */
      while((i > -EQUEUELEN) && !isprint(EVQUESUB(w,i))) i--;
      if (i == -EQUEUELEN) break;

      /*
       * OK, here's the character we're actually rubbing out.  Back up.
       */
      c = EVQUESUB(w,i);
      pre_x = ws->x;
      ws->x -= XTextWidth(wc->font->fsp, &c, 1);
      /*
       * Physically erase the character from the queue.  This results in
       * two control-H's present in the queue.
       */
      *evquesub(w,i) = '\010';
      /*
       * Save the backed-up position, and draw spaces through the erased.
       */
      i = ws->x;
      while(ws->x < pre_x) xdis(w," ",1);
      ws->x = i;
      break;
      }
   default: {
      xdis(w,&c,1);
      }
   }
   return 1;
   }

/*
 * handle_misc processes pending events on display.
 * if w is non-null, block until a returnable event arrives.
 * returns 1 on success, 0 on failure, and -1 on error.
 */
int handle_misc(wdp wd, wbp w)
{
   XEvent event;
   Window evwin;
   static int presscount = 0;
   wbp wb;
   wsp ws;

   while ((w != NULL) || XPending(wd->display)) {

      XNextEvent(wd->display, &event);
      evwin = event.xexpose.window;  /* go ahead, criticize all you like */

/* could avoid doing this search every event by handling 1 window at a time */
      for (wb = wbndngs; wb; wb=wb->next) {
	 ws = wb->window;

	 if (ws->display == wd) {
	    if (ws->win == evwin) break;
	    if (ws->iconwin == evwin) break;
	    if (ws->pix == evwin) break;
	    if (ws->initialPix == evwin) break;
	    }
         }
      if (!wb) continue;
      if (evwin == ws->iconwin) {
         switch (event.type) {
	    case Expose:
               if (ws->iconpix)
	          XCopyArea(wd->display, ws->iconpix, ws->iconwin,
			    wd->icongc, 0, 0, ws->iconw, ws->iconh, 3, 3);
	       else
#ifdef GraphicsGL
                  if (!ws->is_gl)
#endif					/* GraphicsGL */
	          XDrawString(wd->display, evwin, wd->icongc, 4,
	                      ws->display->fonts->fsp->max_bounds.ascent + 2,
		              ws->iconlabel, strlen(ws->iconlabel));
	       if (ws->iconic == IconicState)
		  SETEXPOSED(wb);
	       break;
	    case KeyRelease: {
	       if (ws->inputmask & KeyReleaseMask) {
		  handle_keypress(wb, (XKeyEvent *)&event);
		  }
	       break;
	       }
	    case KeyPress:
	       handle_keypress(wb, (XKeyEvent *)&event);
	       break;
	    case ButtonPress:
	       if (ws->iconic == IconicState)
	          XMapWindow(ws->display->display, ws->win);
	       ws->iconic = NormalState;        /* set the current state */
	       break;
	    case ConfigureNotify:
	       ws->iconx = ((XConfigureEvent *)&event)->x;
	       ws->icony = ((XConfigureEvent *)&event)->y;
	       break;
	    }
	 }
      else {
      switch (event.type) {
         case SelectionRequest: {
	    XEvent theevent;

	    /* Ensure that our atoms are interned. */
	    if (intern_status == 0)
	       intern_status = InternAtoms(ws->display->display);

	    if ((event.xselectionrequest.selection != XA_PRIMARY) &&
	        (event.xselectionrequest.selection != atom_array[CLIPBOARD])) {
	       fprintf(stderr, "unknown selectionrequest\n");
	       }

	    if (event.xselectionrequest.target == atom_array[TARGETS]) {
	       Atom xastring = XA_STRING;
	       XChangeProperty(ws->display->display,
			       event.xselectionrequest.requestor,
			       event.xselectionrequest.property,
			       XA_ATOM, 32, PropModeReplace,
			       (unsigned char *)&xastring, 1);
	       goto sendevent;
	       }
	    else if (event.xselectionrequest.target != XA_STRING) {
	       Atom ct, cs, ut, mu;
	       ct = XInternAtom(ws->display->display, "COMPOUND_TEXT", False);
	       cs = XInternAtom(ws->display->display, "COMPOUND_STRING", False);
	       ut = XInternAtom(ws->display->display, "UTF8_STRING", False);
	       mu = XInternAtom(ws->display->display, "MULTIPLE", False);
	       if (event.xselectionrequest.target == cs)
		  fprintf(stderr, "compoundstring\n");
	       else if (event.xselectionrequest.target == ut)
		  fprintf(stderr, "UTF8\n");
	       else if (event.xselectionrequest.target == mu)
		  fprintf(stderr, "MULTIPLE\n");
	       else if (event.xselectionrequest.target == ct)
		  fprintf(stderr, "unlikely\n");
	       else
		  fprintf(stderr, "idk\n");
	       }

/* TODO: check timestamp to verify that we owned selection at that time. */

	    if (ws->selectiondata != NULL) {
	       if (AppendProperty(ws->display->display,
				  event.xselectionrequest.requestor,
			      event.xselectionrequest.property, XA_STRING, 8,
			      (unsigned char *)ws->selectiondata,
			      strlen(ws->selectiondata)) == False) {
		  fprintf(stderr, "selection property error\n");
		  }

 sendevent:
	       memset(&theevent, 0, sizeof(theevent));
	       theevent.type = SelectionNotify;
	       theevent.xselection.property = event.xselectionrequest.property;
	       theevent.xselection.serial = event.xselectionrequest.serial;
	       theevent.xselection.send_event = False;/* Was True. Why? */
	       theevent.xselection.display = event.xselectionrequest.display;
	       theevent.xselection.requestor = event.xselectionrequest.requestor;
	       theevent.xselection.selection = event.xselectionrequest.selection;
	       theevent.xselection.target = event.xselectionrequest.target;
	       theevent.xselection.time = event.xselectionrequest.time;
	       XSendEvent(ws->display->display,
			  event.xselectionrequest.requestor,
			  False, 0, &theevent);
	       XSync(ws->display->display, False);
	       }
	    }
	    break;
	 case SelectionClear:
	    /* printf("selectionclear\n"); */
	    ws->inputmask &= ~(PropertyChangeMask);
	    if (ws->selectiondata) {
	       free(ws->selectiondata);
	       ws->selectiondata = 0;
	       }
	    break;
         case SelectionNotify:
	    if ((event.xselection.selection == XA_PRIMARY) &&
		(event.xselection.time == timestmp) &&
		(event.xselection.requestor == requestor) &&
		(event.xselection.target == target)
		) {
	       selectfoo = event;
	       bar = &selectfoo;
	    }
	    break;
	 case KeyRelease: {
	       if (ws->inputmask & KeyReleaseMask) {
		  handle_keypress(wb, (XKeyEvent *)&event);
		  }
	       break;
	       }
	 case KeyPress:
	    handle_keypress(wb, (XKeyEvent *)&event);
	    break;
	 case ButtonPress:
	    presscount++;
	    handle_mouse(wb, (XButtonEvent *)&event);
#ifdef Graphics3D
	    if (wb->window->is_3D && wb->context->app_use_selection3D) {
	       wb->context->selectionrendermode = 1;
	       redraw3D(wb);
	       wb->context->selectionrendermode = 0;
	       }
#endif					/* Graphics3D */
	    break;
	 case ButtonRelease:
	    if (--presscount < 0) presscount = 0;
	    handle_mouse(wb, (XButtonEvent *)&event);
	    break;
	 case MotionNotify:
	    if (presscount || wb->window->inputmask)
	       handle_mouse(wb, (XButtonEvent *)&event);
	    break;
         case NoExpose:
	    break;
	 case Expose:
	    if (!handle_exposures(wb, (XExposeEvent *)&event))
	       return 1;
	    continue;
         case UnmapNotify:
	    wb->window->iconic = IconicState;
            continue;
	 case MapNotify:
	    if ((ws->width != DisplayWidth(wd->display, wd->screen)) ||
		(ws->height != DisplayHeight(wd->display, wd->screen)))
	       ws->iconic = NormalState;
	    else
	       ws->iconic = MaximizedState;
	    continue;
	 case ConfigureNotify:
	    if (!handle_config(wb, (XConfigureEvent *)&event)) {
	       return 0;
               }
	    break;
	 case ClientMessage: {
	    /*
	     * only client message we handle at present are destroy requests
	     */
	    struct descrip d;
	    int ret = 0;
	    if (w && (evwin == w->window->win)) ret = 1;
            if (ws->inputmask & WindowClosureMask) {
	       MakeInt(WINDOWCLOSED, &d);
               qevent(wb->window, &d, 0, 0, 0, 0);
               return 1;
               }
	    SETCLOSED((wbp)wb);
	    wclose(wb);
	    MakeInt(WINDOWCLOSED, &d);
	    qevent(wb->window, &d, 0, 0, 0, 0);
	    BlkD(lastEventWin,File)->status &= ~(Fs_Write);
	    if (ret) return 1;
	    break;
	    }
	 case DestroyNotify:
	    if (!ISZOMBIE(wb)) return -1; /* error #141 */

	    /*
	     * first of all, we are done with this window
	     */
	    ws->win = (Window) NULL;

	    /*
	     * if there are no more references, we are done with the pixmap
	     *  too.  Free it and the colors allocated for this canvas.
	     */
	    if (ws->refcount == 0) {
	       if (wb->window->pix) {
		  Display *d = ws->display->display;
		  XSync(d, False);
		  if (ws->pix)
		     XFreePixmap(d, ws->pix);
		  ws->pix = (Pixmap) NULL;
	          }
	       if (ws->initialPix != (Pixmap) NULL) {
		  Display *d = ws->display->display;
		  XSync(d, False);
		  XFreePixmap(d, ws->initialPix);
		  ws->initialPix = (Pixmap) NULL;
	          }
               free_xcolors(wb, 2); /* free regular colors */
               free_xcolors(wb, 1); /* free icon colors */
	       }
	    break;
	 default:
	    continue;
	 }
      if ((w != NULL) &&
	  ((evwin == w->window->win) || (evwin == w->window->iconwin))) {
	 return 1;
         }
      }
   }
   return 1;
   }

/*
 * poll for available events on all opened displays.
 * this is where the interpreter calls into the X interface.
 */

#ifdef HELPER_THREAD
int helper_thread_pollevent(){

   wdp wd;
   int hm;
   for (wd = wdsplys; wd; wd = wd->next) {
      if ((hm = handle_misc(wd, NULL)) < 1) {
	if (hm == -1){
	  return -1;
	  }
	 else if (hm == 0) {
	    /* how to handle failure? */
	    }
         }
      }
   return POLL_INTERVAL;

}
#endif					/* HELPER_THREAD */

int pollevent()
   {
#ifndef HELPER_THREAD
   wdp wd;
   int hm;
#ifdef GraphicsGL
   wbp wb;
   static int gpx_poll = FLUSH_POLL_INTERVAL;
#endif					/* GraphicsGL */
#ifdef Concurrent
   int isbusy;
/*   CURTSTATE();
   if (BlkD(k_current, Coexpr)->id>1) return 100000;
*/
   MUTEX_TRYLOCKID(MTX_POLLEVENT, isbusy);

   if (isbusy) return POLL_INTERVAL;
#endif					/* Concurrent */

#ifdef GraphicsGL
   if (gpx_poll) gpx_poll--;
   if (!gpx_poll) {
      for (wb = wbndngs; wb; wb=wb->next) {
         wsp ws = wb->window;
         if (ws->buffermode == UGL_IMMEDIATE) {
            if (ws->redraw_flag && !ws->busy_flag) {
               ws->busy_flag = 1;

               MakeCurrent(wb);
               glFlush();

               ws->redraw_flag = 0;
               ws->busy_flag = 0;
               }
            }
         }
      gpx_poll = FLUSH_POLL_INTERVAL;
      }
#endif					/* GraphicsGL */

   for (wd = wdsplys; wd; wd = wd->next) {
      if ((hm = handle_misc(wd, NULL)) < 1) {
	if (hm == -1){
	  MUTEX_UNLOCKID(MTX_POLLEVENT);
	  return -1;
	  }
	 else if (hm == 0) {
	    /* how to handle failure? */
	    }
         }
      }
   MUTEX_UNLOCKID(MTX_POLLEVENT);
#endif					/* HELPER_THREAD */

   return POLL_INTERVAL;
   }

/*
 * get a single item from w's pending queue
 */
int wgetq(w,res,t)
wbp w;
dptr res;
int t;
   {
   int posted = 0;

   while (1) {
      wdp wd = w->window->display; /* leave inside loop; ws->pix can change! */
      
      if (!EVQUEEMPTY(w)) {
	 EVQUEGET(w,*res);
	 if (posted)
            scrubcursor(w);
	 return 1;
         }
      postcursor(w);		/* post every time in case resize erased it */
      posted = 1;
      /* If we need a timeout, we select right here so we know an event will
         be available when XNextEvent is called by handle_misc */
      if (t > 0 && iselect(XConnectionNumber(wd->display), t) == 0)
            /* timer expired */
            return -2;
      if (handle_misc(wd, w) == -1) {
	 if (posted)
            scrubcursor(w);
	 return -1;
	 }
      }
   }

/*
 * postcursor/scrubcursor calls must be paired without any intervening output.
 */
void postcursor(wbp w)
   {
   wcp wc = w->context;
   wsp ws = w->window;
   wdp wd = ws->display;
   Display *stddpy = wd->display;
   
   if (!ISCURSORON(w) || !ws->win) return;
   if (wc->drawop != GXcopy) XSetFunction(stddpy, wc->gc, GXcopy);
   if (ISXORREVERSE(w)) XSetForeground(stddpy, wc->gc, wd->colors[wc->fg].c);

   /* Draw only on window, not on backing pixmap */
   XFillRectangle(stddpy, ws->win, wc->gc, ws->x, ws->y, FWIDTH(w), DESCENT(w));
   XSync(stddpy, False);
   }

void scrubcursor(wbp w)
   {
   STDLOCALS(w);

   if (!ISCURSORON(w) || !stdwin) return;

   XCopyArea(stddpy, stdpix, stdwin, stdgc,	/* restore window from pixmap */
      ws->x, ws->y, FWIDTH(w), DESCENT(w), ws->x, ws->y);

   if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
   if (ISXORREVERSE(w)) XSetForeground(stddpy, stdgc,
				       wd->colors[wc->fg].c ^ wd->colors[wc->bg].c);
   }
 
/*
 * wclose - close a window.  If is a real on-screen window,
 * wait for a DestroyNotify event from the server before returning.
 */
int wclose(w)
wbp w;
   {
   wbp tmp_wb;
   wbp p;
   struct wbind_list *wbl, *t, *b;
   wsp ws = w->window;
   Display *stddpy = ws->display->display;

   XSync(stddpy, False);
   if (pollevent() == -1) return -1;

   /*
    * Force window to close (turn into a pixmap)
    */

   while (ws->children) {
      tmp_wb = w->window->children->child;
      wbl = ws->children;
#ifdef Graphics3D
      if(tmp_wb->window->is_3D)
	 release_3d_resources(tmp_wb);
#endif						/* Graphics3D */
      ws->children = ws->children->next;
      ws->display->refcount--;
      tmp_wb->refcount--;
      tmp_wb->window->parent=NULL;
      w->refcount--;
      tmp_wb->window->win = (Window) 0;
      /* added next line */
      SETCLOSED(tmp_wb);
      wbl->next=NULL;
      free(wbl);
      }
   p = ws->parent;
   if (p) {
      t = p->window->children;
      b = NULL;
      while (t) {
	 if (t->child->window == w->window) {
	    if (b==NULL)
               p->window->children = t->next;
	    else b->next = t->next;
	    t->next = NULL;
	    t->child = NULL;
	    free(t);
	    w->refcount--;
	    break;
	    }
	 b=t;
	 t = t->next;
	 }
      ws->parent=NULL;
      p->refcount--;
      }

#ifdef Graphics3D
   if (w->window->is_3D)
      release_3d_resources(w);
#endif						/* Graphics3D */
   
   if (ws->win && ws->refcount > 1) {
      SETZOMBIE(w);
#ifdef GraphicsGL
      if (ws->is_gl) {
         ws->busy_flag = 1; /* set so pollevent won't redraw */
         UnbindCurrent(ws->display);
         if (ws->win != (Window) NULL)
            XDestroyWindow(stddpy, ws->win);
         XFlush(stddpy);
         ws->refcount--;
         while (ws->win)
   	    if (pollevent() == -1) return -1;
         ws->win = (Window) NULL; 
         ws->busy_flag = 0;
         }
      else
#endif						/* GraphicsGL */
      {
      XDestroyWindow(stddpy, ws->win);
      XFlush(stddpy);
      ws->refcount--;
      while (ws->win)
	 if (pollevent() == -1) return -1;
      }
      }
   /*
    * Entire canvas terminates
    */
   else {
      free_xcolors(w, 2);
      free_xcolors(w, 1);
      /* free_window(ws);  */
      free_binding(w);
      }
 
   return 0;
   }
   
/*
 * flush a window
 */
void wflush(w)
wbp w;
   {
   XFlush(w->window->display->display);
   }
   
/*
 * flush all windows
 */
void wflushall()
   {
   wdp wd;
   for (wd = wdsplys; wd != NULL; wd = wd->next) {
      XFlush(wd->display);
      }
   }
   
/*
 * sync all the servers
 */
void wsync(w)
wbp w;
   {
   wdp wd;
   if (w == NULL) {
      for (wd = wdsplys; wd != NULL; wd = wd->next) {
	 XSync(wd->display, False);
	 }
      }
   else
      XSync(w->window->display->display, False);
   }

/*
 * open a window
 * This routine really just allocates a window data structure.
 * The interesting part is done in wmap, after the user preferences
 * passed to Icon have been parsed.  Returns NULL on error/failure;
 * err_index is set to one of:
 *  >= 0: the index of an offending attribute value
 *  -1  : ordinary failure
 *  -2  : out of memory
 */
FILE *wopen(char *name, struct b_list *lp, dptr attr, int n, int *err_index, int is_3d, int is_gl)
   {
   wbp w;
   wsp ws;
   wcp wc;
   char dispchrs[256];
   char answer[128];
   char *display = NULL;
   int i;
   tended struct b_list *tlp;
   tended struct descrip attrrslt;

   tlp = lp;
   for(i=0;i<n;i++) {
      if (is:string(attr[i]) &&
	  (StrLen(attr[i])>8) &&
	  !strncmp("display=",StrLoc(attr[i]),8)) {
         strncpy(dispchrs,StrLoc(attr[i])+8,StrLen(attr[i])-8);
	 dispchrs[StrLen(attr[i]) - 8] = '\0';
	 display = dispchrs;
         }
      }

   if ((w = alc_wbinding()) == NULL) {
      *err_index = -2;
      return NULL;
      }
#ifdef GraphicsGL
   if (is_gl) {
      if ((ws = w->window = gl_alc_winstate()) == NULL) {
         *err_index = -2;
         free_binding(w);
         return NULL;
         }
      if ((ws->display = gl_alc_display(display)) == NULL) {
         *err_index = -1;
         free_binding(w);
         set_errortext(145); /* maybe out of memory, probably bad DISPLAY var. */
         return NULL;
         }
      }
   else
#endif					/* GraphicsGL */
   {
   if ((ws = w->window = alc_winstate()) == NULL) {
      *err_index = -2;
      free_binding(w);
      return NULL;
      }

   if ((w->window->display = alc_display(display)) == NULL) {
      *err_index = -1;
      free_binding(w);
      set_errortext(145); /* maybe out of memory, probably bad DISPLAY var. */
      return NULL;
      }
      ws->vis = DefaultVisual(ws->display->display, ws->display->screen); 
   }


   ws->children=NULL;
   ws->parent = NULL;

   ws->listp.dword = D_List;
   BlkLoc(ws->listp) = (union block *)tlp;

   /*
    * some attributes of the display and window are used in the context
    */
	
#ifdef GraphicsGL
   if (is_gl) {
      if ((wc = w->context = gl_alc_context(w)) == NULL) {
         *err_index = -2;
         free_binding(w);
         return NULL;
         }
      }
   else
#endif					/* GraphicsGL */
   if ((wc = w->context = alc_context(w)) == NULL) {
      *err_index = -2;
      free_binding(w);
      return NULL;
      }
	
   /*
    * some attributes of the context determine window defaults
    */
   ws->height = wc->font->height * 12;
#ifdef GraphicsGL
   if (is_gl) {
      ws->width = wc->font->maxwidth * 80;
      ws->y = wc->font->height;
      }
   else
#endif					/* GraphicsGL */
   {
   ws->width  = wc->font->fsp->max_bounds.width * 80;
   ws->y = wc->font->fsp->max_bounds.ascent;
   }
   ws->x = 0;
   ws->y += wc->dy;
   ws->x += wc->dx;

#ifdef GraphicsGL
   if (is_gl) {
      ws->is_3D = wc->rendermode = is_3d;

      /* Allocate display lists */
      if (is_3d) {
         if (create_display_list(w, 40000) == Failed) {
            *err_index = -2;
            return NULL;
	    }
	 }
      if (create_display_list2d(w, 40000) == Failed) {
         *err_index = -2;
         return NULL;
         }

      /*
       * Need to determine a way to initialize the default context for a 
       * window without adding items to the display list.
       */
      if (!ws->initAttrs)
         ws->initAttrs = 1;
      else {
         glprintf("gl_wopen(): need a mutex lock\n"); 
         return NULL;
         }
      }
#endif					/* GraphicsGL */

   /*
    * Loop through any remaining arguments.
    */
   for (i = 0; i < n; i++){
      /*
       * write the attribute,
       *  except "display=" attribute, which is done earlier
       */
      if((StrLen(attr[i])<9)||strncmp(StrLoc(attr[i]),"display=",8)) {
	 switch (wattrib((wbp) w, StrLoc(attr[i]), StrLen(attr[i]), &attrrslt,
			 answer)) {
	 case RunError:
	    *err_index = i;
	    return NULL;
	 case Failed:
	    free_binding((wbp)w);
	    *err_index = -1;
	    set_errortext(145);
	    return NULL;
	    }
	 }
      }
   if (ws->windowlabel == NULL) {
      ws->windowlabel = salloc(name);
      if (ws->windowlabel == NULL) { /* out of memory */
	 *err_index = -2;
	 return NULL;
	 }
      }

#ifdef GraphicsGL
   if (is_gl) {
      if (ws->initAttrs)
         ws->initAttrs = 0;
      else {
         glprintf("gl_wopen(): need a mutex unlock\n"); 
         return NULL;
         }

      if ((i = gl_wmap(w)) != Succeeded) {
         if (i == Failed) {
   	    /* why would wmap() fail? either 144 or 145; have it say which */
   	    *err_index = -1;
	    }
         else *err_index = 0;
         return NULL;
         }
      }
   else
#endif					/* GraphicsGL */
   if ((i = wmap(w)) != Succeeded) {
      if (i == Failed) {
	 /* why would wmap() fail? either 144 or 145; have it say which */
	 *err_index = -1;
	 }
      else *err_index = 0;
      return NULL;
      }
	
   if (ws->win) {
      Atom WMDeleteWindow = XInternAtom(ws->display->display, "WM_DELETE_WINDOW", True);
      XSetWMProtocols(ws->display->display, ws->win, &WMDeleteWindow, 1);
      }
   return (FILE *)w;
   }

/*
 * make an icon for a window
 */
void makeIcon(w, x, y)
wbp w;
int x, y;		/* current mouse position */
{
   int status;
   wcp wc = w->context;
   wsp ws = w->window;
   wdp wd = ws->display;
   Display *stddpy = wd->display;
   
   /* if a pixmap image has been specified, load it */
   if (ws->initicon.width) {
      ws->iconpix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
				  ws->iconw, ws->iconh,
				  DefaultDepth(stddpy,wd->screen));
      }
   else if (ws->iconimage && strcmp(ws->iconimage, "")) {
      ws->iconpix = loadimage(w, ws->iconimage, &(ws->iconh), &(ws->iconw),
			      0, &status);
      ws->iconh += 6;
      ws->iconw += 6;
      }
   else {    /* determine the size of the icon window */
      ws->iconh = wd->fonts->fsp->max_bounds.ascent +
		  wd->fonts->fsp->max_bounds.descent + 5;
      if (ws->iconlabel == NULL) ws->iconlabel = "";
      ws->iconw = XTextWidth(wd->fonts->fsp, ws->iconlabel,
		  strlen(ws->iconlabel)) + 6;
      }

   /* if icon position hint exists, get it */
   if (ws->wmhintflags & IconPositionHint) {
      x = ws->iconx;
      y = ws->icony;
      }

   /* create the icon window */
   ws->iconwin = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy), x, y,
				     ws->iconw, ws->iconh, 2,
				     wd->colors[wc->fg].c,
				     wd->colors[wc->bg].c);

   /* select events for the icon window */
   XSelectInput(stddpy, ws->iconwin,
		ExposureMask | KeyPressMask | ButtonPressMask |
		StructureNotifyMask);

}


/*
 * setclasshints(w) - called by wmap() and my_wmap().
 * Set the class hints that name the program (for reference by the
 * window manager) following conventions given in O'Reilly.
 */
static void setclasshints(wbp w)
{
   int i;
   char *p, *s, sbuf[256];
   XClassHint clhints;
   wsp ws = w->window;
   wdp wd = ws->display;
   
   clhints.res_name = sbuf;
   clhints.res_class = "IconProg";
   if (getenv_r("RESOURCE_NAME", sbuf, 256) == -1) {
      p = StrLoc(kywd_prog);
      s = p + StrLen(kywd_prog);
      while (s > p && s[-1] != '/')
	 s--;				/* find tail of prog_name */
      for (i=0; s < p+StrLen(kywd_prog); ) clhints.res_name[i++] = *s++;
      clhints.res_name[i] = '\0';
      }
   XSetClassHint(wd->display, ws->win, &clhints);
}

/*
 * Create a canvas.
 *  If a window, cause the window to actually become visible on the screen.
 *  returns Succeeded, Failed, or RunError
 */
int wmap(wbp w)
   {
   XWindowAttributes attrs;
   XWMHints wmhints;
   struct imgdata *imd;
   int i, r;

#ifdef GraphicsGL
   if (w->window->is_gl) {

   XSetWindowAttributes attr;
   Display *stddpy;
   Window stdwin = (Window) NULL;
   Window rootwin;

   wsp ws = w->window; 
   wdp wd;
   wcp wc = w->context; 
   wbp wp = ws->parent;
   CURTSTATE();


   /* 
    * Initialize glX and X11 resources. OpenGL does not use backing store 
    * (Pixmap), only a (Window).
    */

   /*
    * Set display and root window defaults for windows/subwindows
    */
   wd = ws->display;
   stddpy = wd->display;
   if (wp == NULL) {
      rootwin = RootWindow(wd->display, wd->vis->screen);
      }
   else { 
      rootwin = wp->window->win ? wp->window->win : RootWindow(wd->display, wd->vis->screen);
      }

   /*
    * Create a context with direct rendering (if possible)
    */
   if (ws->ctx == NULL) {
      /* Create a shared context for textures */
      ws->ctx = glXCreateContext(stddpy, wd->vis, wd->sharedCtx, GL_TRUE);
      if (ws->ctx == NULL) {
         //*err_index = -1;
         free_binding(w);
         set_errortext(145); /* maybe out of memory, probably bad DISPLAY var */
         return RunError;
         }
      }
   ws->vis = DefaultVisual(wd->display, wd->screen);

   /*
    * Find/allocate an XColor for background color and reference it
    */
   {
   wclrp color;
   char buf[MAXCOLORNAME] = {0};
   unsigned short r, g, b, a;

   if (wc->glbg.c == -1) {
      /* allocate bg */
      GetColorUS(w, wc->glbg, r, g, b, a);
      color = alc_rgb(w, buf, r, g, b, 0);
      if (!color) 
         return RunError;
      wc->glbg.c = color->c;
      }

   if (wc->glfg.c == -1) {
      /* allocate fg */
      GetColorUS(w, wc->glfg, r, g, b, a);
      color = alc_rgb(w, buf, r, g, b, 0);
      if (!color) 
         return RunError;
      wc->glfg.c = color->c;
      (void) a;  /* silence "not used" compiler warning */
      }
   } 

   attr.background_pixmap = None;
   attr.background_pixel = wc->glbg.c;
   attr.border_pixel = wc->glfg.c;
   attr.event_mask = StructureNotifyMask | ExposureMask;
   attr.colormap = XCreateColormap(stddpy,rootwin,wd->vis->visual,AllocNone);
   if (attr.colormap == (Colormap) NULL) {
      set_errortext(144);
      return Failed;
      }

   /* 
    * Create X Window and GLX Window
    */
   ws->win = ((ws->iconic == RootState) ? rootwin :
               XCreateWindow (stddpy, rootwin,
	       ws->posx < 0 ? 0 : ws->posx,
	       ws->posy < 0 ? 0 : ws->posy,
	       ws->width,  ws->height, 0,
	       wd->vis->depth, InputOutput,
	       wd->vis->visual,
	       CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &attr));
   if (ws->win == (Window) NULL) {
      /* consider freeing window binding/resources */
      set_errortext(144);
      return Failed;
      }
   stdwin = ws->win;
   XClearWindow(stddpy, stdwin);

   /*
    * Get PBuffer for offscreen rendering (OpenGL rendering only)
    * TODO: migrate to use  framebuffer objects instead,
    * PBuffers are deprecated in OpenGL 3.0 and not available on MacOS
    */
   if (wc->rendermode == UGL2D) {
     int pbufattrs[] = {GLX_PBUFFER_WIDTH, DisplayWidth(stddpy, wd->screen),
			GLX_PBUFFER_HEIGHT, DisplayHeight(stddpy, wd->screen),
			GLX_PRESERVED_CONTENTS, True,
			None};
     ws->pbuf = glXCreatePbuffer(stddpy, wd->configs[0],pbufattrs);
     if (ws->pbuf == (GLXPixmap)NULL) {
       /* consider freeing window binding/resources */
       set_errortext(144);
       return Failed;
     }
   }

   /*
    * Bind context to window
    */
   MakeCurrent(w);

   /*
    * Initialize OpenGL states 
    */
   if (init_canvas(w) == Failed)
      return Failed;

   if (!ISTITLEBAR(ws)) {
      /*
       * Disable title bar.  Code allegedly from GLUT via tonyobryan.com.
       */
      struct {
         unsigned long flags;
         unsigned long functions;
         unsigned long decorations;
         long inputMode;
         unsigned long status;
         } hints;
      Atom property;
      hints.flags = 2;
      hints.decorations = 0;
      if ((property = XInternAtom(stddpy, "_MOTIF_WM_HINTS",True))) {
         XChangeProperty(stddpy, ws->win, property, property, 32,
         PropModeReplace, (unsigned char *)&hints, 5);
         }
      }

   /*
    * Set initial pixmaps, if applicable
    */
   imd = &ws->initimage;
   if (imd->width) {
      r = gl_strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
         imd->data, (word)imd->width * (word)imd->height, 0);
      if (imd->paltbl)
	 free((pointer)imd->paltbl);
      free((pointer)imd->data);
      imd->width = 0;
      if (r < 0) {
	 set_errortext(145);
	 return Failed;
	 }
      }

   imd = &ws->initicon;
   if (imd->width) {
      r = gl_strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
         imd->data, (word)imd->width * (word)imd->height, 1);
      free((pointer)imd->paltbl);
      free((pointer)imd->data);
      imd->width = 0;
      if (r < 0) {
	 set_errortext(145);
	 return Failed;
	 }
      wmhints.icon_window = ws->iconwin;
      ws->wmhintflags |= IconWindowHint;
      }

   /* 
    * Set X hints if not RootState or Icon. 
    */
   if (ws->iconic != RootState) {
      size_hints.flags = PSize | PMinSize | PMaxSize;
      size_hints.width = ws->width;
      size_hints.height= ws->height;
      if (ws->posx == -(MaxInt)) ws->posx = 0;
      else size_hints.flags |= USPosition;
      if (ws->posy == -(MaxInt)) ws->posy = 0;
      else size_hints.flags |= USPosition;
      size_hints.x = ws->posx;
      size_hints.y = ws->posy;
      if (ISRESIZABLE(w)) {
	 size_hints.min_width = 0;
	 size_hints.min_height = 0;
	 size_hints.max_width = DisplayWidth(stddpy, wd->screen);
	 size_hints.max_height = DisplayHeight(stddpy, wd->screen);
	 }
      else {
	 size_hints.min_width = size_hints.max_width = ws->width;
	 size_hints.min_height = size_hints.max_height = ws->height;
	 }
      if (ws->windowlabel == NULL) {
         ws->windowlabel = salloc(wp->window->windowlabel);
         }
      if (ws->iconlabel == NULL) {
	 if ((ws->iconlabel = salloc(ws->windowlabel)) == NULL)
	    ReturnErrNum(305, RunError);
	 }
      XSetStandardProperties(stddpy, stdwin, ws->windowlabel, ws->iconlabel,
			     0,0,0, &size_hints);
      XSelectInput(stddpy, stdwin, XMasks(ws->inputmask));
      }

   wmhints.input = True;
   wmhints.flags = InputHint;
   if (ws->iconic != RootState) {
      if (ws->iconimage != NULL) {
	 makeIcon(w, ws->posx < 0 ? 0 : ws->posx, ws->posy < 0 ? 0 : ws->posy);
	 wmhints.icon_window = ws->iconwin;
	 ws->wmhintflags |= IconWindowHint;
         }
      wmhints.flags |= (ws->wmhintflags | StateHint);
      wmhints.initial_state = ws->iconic;
      wmhints.icon_x = ws->iconx;
      wmhints.icon_y = ws->icony;
      }
   XSetWMHints(stddpy, stdwin, &wmhints);
   setclasshints(w);

   if (wd->cmap != DefaultColormap(stddpy,wd->screen)) {
      XSetWindowColormap(stddpy, stdwin, wd->cmap);
      }
   XSync(stddpy, False);

   /*
    * Map window if not RootState or HiddenState
    *
    * It appears as though mapping brings X windows out of hidden state...
    */
   if (ws->iconic != RootState && ws->iconic != HiddenState) {
      CLREXPOSED(w);
      XMapWindow(stddpy, stdwin);
      }

   /*
    * Get actual size of window allocated by X
    */
   XGetWindowAttributes(stddpy, stdwin, &attrs);
   ws->width = attrs.width;
   ws->height = attrs.height;


   /* 
    * Set a cursor
    */
   if (stdwin) {
      i = ws->theCursor;
      if (!(wd->cursors[i]))
         wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
      XDefineCursor(stddpy, stdwin, wd->cursors[i]);
      }

   /*
    * busy loop for an expose event, unless of course we are starting out
    *  in an iconic state. Does not execute if hidden window
    *
    * Note: Subwindows seem to hang on XNextEvent() in handle_misc(), so 
    * prevent subwindows from waiting for an event that won't come.
    */
   CLRZOMBIE(w);
   if (ws->iconic != HiddenState && !wp) {
      int hm;
      while (!ISEXPOSED(w) && (ws->iconic != IconicState || ws->iconwin)) {
	 if ((hm = handle_misc(wd, w)) < 1) {
	    if (hm == -1) return RunError;
	    else if (hm == 0) {
	       /* how to handle failure? */
	       }
	    }
         }
      }
   XSync(stddpy, False);

   }
   else /* if (!ws->is_gl) */
#endif 					/* GraphicsGL */
   {
   XGCValues gcv;
   unsigned long gcmask =
      GCFont | GCForeground | GCBackground | GCFillStyle | GCCapStyle;
   int new_pixmap = 0;
   CURTSTATE();
   STDLOCALS(w);
#ifdef Graphics3D
   /*wc->maxstex=16;
   wc->stex = (struct _savetexture *) 
                 malloc(wc->maxstex*sizeof(struct _savetexture));
		 */
#endif					/* Graphics3D */
  
   /*
    *  Create a pixmap for this canvas if there isn't one already.
    */
   if (ws->pix == (Pixmap) NULL) {
      if (ws->initialPix) {
	 ws->pix = ws->initialPix;
	 ws->initialPix = (Pixmap) NULL;
	 ws->pixwidth = ws->width;
	 ws->pixheight = ws->height;
	 }
      else {
	 ws->pix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
				 ws->width, ws->height,
				 DefaultDepth(stddpy,wd->screen));
	 ws->pixwidth = ws->width;
	 ws->pixheight = ws->height;
	 new_pixmap = 1;
	 }
      stdpix = ws->pix;
      }


   /*
    * create the X window (or use the DefaultRootWindow if requested)
    */
   if (ws->iconic != HiddenState) {

      XSetWindowAttributes attr;
      attr.background_pixmap = None;
      attr.background_pixel = wd->colors[wc->bg].c;
      attr.border_pixel = wd->colors[wc->fg].c;
      attr.event_mask = StructureNotifyMask | ExposureMask;
 
#ifdef Graphics3D 
      if (ws->is_3D) {
         attr.colormap = 
	    XCreateColormap(wd->display,
			    RootWindow(wd->display, wd->vis->screen),
			    wd->vis->visual, AllocNone);
         ws->win = ((ws->iconic == RootState) ? DefaultRootWindow(stddpy) :
		        XCreateWindow (stddpy, DefaultRootWindow(stddpy), 
				       ws->posx < 0 ? 0 : ws->posx,
				       ws->posy < 0 ? 0 : ws->posy,
				       ws->width,  ws->height, 0,
				       wd->vis->depth, InputOutput,
				       wd->vis->visual,
				       CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &attr));
	 }
      else
#endif					/* Graphics3D */     
	 ws->win = ((ws->iconic == RootState) ? DefaultRootWindow(stddpy) :
		    XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
					ws->posx < 0 ? 0 : ws->posx,
					ws->posy < 0 ? 0 : ws->posy, ws->width,
					ws->height, 1,
					wd->colors[wc->fg].c,
					wd->colors[wc->bg].c));

      if (ws->win == (Window) NULL) {
	 /* consider freeing window binding/resources */
	 set_errortext(144);
	 return Failed;
	 }
      stdwin = ws->win;
      XClearWindow(stddpy, stdwin);

      if (!ISTITLEBAR(ws)) {
	 /*
	  * Disable title bar.  Code allegedly from GLUT via tonyobryan.com.
	  */
	 struct {
	    unsigned long flags;
	    unsigned long functions;
	    unsigned long decorations;
	    long inputMode;
	    unsigned long status;
	    } hints;
	 Atom property;
	 hints.flags = 2;
	 hints.decorations = 0;
	 if ((property = XInternAtom(stddpy, "_MOTIF_WM_HINTS",True))) {
	    XChangeProperty(stddpy, ws->win, property, property, 32,
			    PropModeReplace, (unsigned char *)&hints, 5);
	    }
	 }
      }

   /*
    * before creating the graphics context, construct a description
    * of any non-default initial graphics context values.
    */
   gcv.foreground = wd->colors[wc->fg].c ^ (ISXORREVERSE(w) ? wd->colors[wc->bg].c : 0);
   gcv.background = wd->colors[wc->bg].c;
   gcv.font       = wc->font->fsp->fid;
   if (wc->fillstyle)
      gcv.fill_style = wc->fillstyle;
   else
      gcv.fill_style = wc->fillstyle = FillSolid;
   if (wc->linestyle || wc->linewidth) {
      gcmask |= (GCLineWidth | GCLineStyle);
      gcv.line_width = wc->linewidth;
      gcv.line_style = wc->linestyle;
      if (wc->linewidth > 1) {
         gcv.dashes = 3 * wc->linewidth;
         gcmask |= GCDashList;
         }
      }
   else
      wc->linestyle = LineSolid;
   gcv.cap_style = CapProjecting;

   /*
    * Create a graphics context (or change an existing one to conform
    * with initial values).
    */
   if (stdgc == NULL) {
      wc->gc = XCreateGC(stddpy, stdpix, gcmask, &gcv);
      stdgc = wc->gc;
      if (stdgc == NULL) {
	 /* consider freeing window resources */
	 set_errortext(144);
	 return Failed;
	 }
      }
   else
      XChangeGC(stddpy, stdgc, gcmask, &gcv);

#ifdef Graphics3D
   if (wc->rendermode == UGL3D) {
      if (create3Dcontext(w) == Failed) {
	 set_errortext(144);
	 return Failed;
	 }
      }
#endif					/* Graphics3D */

   if (wc->clipw >= 0)
      setclip(w);

   if (new_pixmap) {
      XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
      XFillRectangle(stddpy, ws->pix, stdgc, 0, 0, ws->width, ws->height);
      XSetForeground(stddpy, stdgc,
		     wd->colors[wc->fg].c ^(ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
      }

   imd = &ws->initimage;
   if (imd->width) {
      r = strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
         imd->data, (word)imd->width * (word)imd->height, 0);
      if (imd->paltbl)
	 free((pointer)imd->paltbl);
      free((pointer)imd->data);
      imd->width = 0;
      if (r < 0) {
	 set_errortext(145);
	 return Failed;
	 }
      }

   imd = &ws->initicon;
   if (imd->width) {
      r = strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
         imd->data, (word)imd->width * (word)imd->height, 1);
      free((pointer)imd->paltbl);
      free((pointer)imd->data);
      imd->width = 0;
      if (r < 0) {
	 set_errortext(145);
	 return Failed;
	 }
      wmhints.icon_window = ws->iconwin;
      ws->wmhintflags |= IconWindowHint;
      }

   if (wc->patternname != NULL) {
      if (SetPattern(w, wc->patternname, strlen(wc->patternname)) != Succeeded) {
	 set_errortext(145);
	 return Failed;
	 }
      }

   /*
    *  if we are opening a pixmap, we are done at this point.
    */
   if (stdwin == (Window) NULL) return Succeeded;

   if (ws->iconic != RootState) {
      size_hints.flags = PSize | PMinSize | PMaxSize;
      size_hints.width = ws->width;
      size_hints.height= ws->height;
      if (ws->posx == -(MaxInt)) ws->posx = 0;
      else size_hints.flags |= USPosition;
      if (ws->posy == -(MaxInt)) ws->posy = 0;
      else size_hints.flags |= USPosition;
      size_hints.x = ws->posx;
      size_hints.y = ws->posy;
      if (ISRESIZABLE(w)) {
	 size_hints.min_width = 0;
	 size_hints.min_height = 0;
	 size_hints.max_width = DisplayWidth(stddpy, wd->screen);
	 size_hints.max_height = DisplayHeight(stddpy, wd->screen);
	 }
      else {
	 size_hints.min_width = size_hints.max_width = ws->width;
	 size_hints.min_height = size_hints.max_height = ws->height;
	 }
      if (ws->iconlabel == NULL) {
	 if ((ws->iconlabel = salloc(ws->windowlabel)) == NULL)
	    ReturnErrNum(305, RunError);
	 }
      XSetStandardProperties(stddpy, stdwin, ws->windowlabel, ws->iconlabel,
			     0,0,0, &size_hints);
      XSelectInput(stddpy, stdwin, XMasks(ws->inputmask));
      }

   wmhints.input = True;
   wmhints.flags = InputHint;
   if (ws->iconic != RootState) {
      if (ws->iconimage != NULL) {
	 makeIcon(w, ws->posx < 0 ? 0 : ws->posx, ws->posy < 0 ? 0 : ws->posy);
	 wmhints.icon_window = ws->iconwin;
	 ws->wmhintflags |= IconWindowHint;
         }
      wmhints.flags |= (ws->wmhintflags | StateHint);
      wmhints.initial_state = ws->iconic;
      wmhints.icon_x = ws->iconx;
      wmhints.icon_y = ws->icony;
      }
   XSetWMHints(stddpy, stdwin, &wmhints);

   setclasshints(w);

   if (wd->cmap != DefaultColormap(stddpy,wd->screen)) {
      XSetWindowColormap(stddpy, stdwin, wd->cmap);
      }
   XSync(stddpy, False);

   if (ws->iconic != RootState) {
      CLREXPOSED(w);
      XMapWindow(stddpy, stdwin);
      }

   XGetWindowAttributes(stddpy, stdwin, &attrs);
   ws->width = attrs.width;
   ws->height = attrs.height;

   if (!resizePixmap(w, ws->width, ws->height)) {
      set_errortext(144);
      return Failed;
      }

   if (stdwin) {
      i = ws->theCursor;
      if (!(wd->cursors[i]))
         wd->cursors[i] = XCreateFontCursor(stddpy, 2 * i);
      XDefineCursor(stddpy, stdwin, wd->cursors[i]);
      }

   /*
    * busy loop for an expose event, unless of course we are starting out
    *  in an iconic state
    */
   CLRZOMBIE(w);
   if (ws->win != (Window) NULL) {
      int hm;
      while (!ISEXPOSED(w) && (ws->iconic != IconicState || ws->iconwin)) {
	 if ((hm = handle_misc(wd, w)) < 1) {
	    if (hm == -1) return RunError;
	    else if (hm == 0) {
	       /* how to handle failure? */
	       }
	    }
         }
      }

   XSetFunction(stddpy, stdgc, wc->drawop);
   XSync(stddpy, False);
   } /* end if (!ws->is_gl) */

   return Succeeded;
}


int do_config(w, status)
wbp w;
int status;
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   int wid = ws->width, ht = ws->height;
   int posx = ws->posx, posy = ws->posy;

   XTextProperty textprop;

   if (! resizePixmap(w, ws->width, ws->height))
      return Failed;
   if (ws->win) {
      XSync(wd->display, False);
      pollevent();
      if (status == 1)
	 moveWindow(w, posx, posy);
      else {
	 if (status == 2)
	    posx = posy = -MaxInt;
	 if (moveResizeWindow(w, posx, posy, wid, ht) == Failed)
	    return Failed;
	 }

      /* XSync is not enough because the window manager gets involved here. */
      XFlush(wd->display);			      /* force out request */
      XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
      XSync(wd->display, False);		      /* NOW sync */

#ifdef GraphicsGL 
      if (ws->is_gl && (status & 2))
         redraw3D(w);
#endif					/* GraphicsGL */
      }
   return Succeeded;
   }

int setheight(w, new_height)
wbp w;
SHORT new_height;
   {
   wsp ws = w->window;
   if (new_height < 0) return Failed;
#ifdef GraphicsGL
   if (ws->is_gl && ws->height != new_height) 
      ws->resize = 1;
#endif					/* GraphicsGL */
   ws->height = size_hints.height = new_height;
   return Succeeded;
   }

int setwidth(w, new_width)
wbp w;
SHORT new_width;
{
   wsp ws = w->window;
   if (new_width < 0) return Failed;
#ifdef GraphicsGL
   if (ws->is_gl && ws->width != new_width) 
      ws->resize = 1;
#endif					/* GraphicsGL */
   ws->width = size_hints.width = new_width;
   return Succeeded;
}

int setgeometry(w, geo)
wbp w;
char *geo;
   {
   int width = 0, height = 0;
   int x = 0, y = 0, status;
   wsp ws = w->window;

   if ((status = parsegeometry(geo, &x, &y, &width, &height)) == 0)
      return RunError;

   if (status & 1) {
#ifdef GraphicsGL
      if (ws->is_gl && (ws->width != width || ws->height != height)) {
         ws->resize = 1;
         }
#endif					/* GraphicsGL */
      {
      ws->width = size_hints.width = width;
      ws->height = size_hints.height = height;
      }

      }
   /*
    * can't set position on hidden windows (but can on opening ones)
    */
   if ((ws->win || !ws->pix) && (status & 2)) {
      ws->posx = x;
      ws->posy = y;
      }
   /* insert assigns here:
    *  ws->posx = ((sign > 0) ? tmp :
    *              DisplayWidth(stdpy,wd->screen) - ws->width - tmp);
    *  ws->posy = ((sign > 0) ? tmp :
    *              DisplayHeight(stddpy,wd->screen) - ws->height - tmp);
    */
   return Succeeded;
   }

int allowresize(w, on)
wbp w;
int on;
   {
   if (on)
      SETRESIZABLE(w);
   else
      CLRRESIZABLE(w);
   return Succeeded;
   }

void warpPointer(w, x, y)
wbp w;
int x, y;
   {
   wsp ws = w->window;
   XWarpPointer(ws->display->display, None, ws->win, 0,0,0,0, x, y);
   }

/*
 * #@#@ This is a bug
 */
int seticonlabel(w, val)
wbp w;
char *val;
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   CURTSTATE();

   if (ws->iconlabel != NULL) free(ws->iconlabel);
   if ((ws->iconlabel = salloc(val)) == NULL)
      ReturnErrNum(305, RunError);
   
   if (wd->display && ws->win) {
      XSetIconName(wd->display, ws->win, ws->iconlabel);
      if (ws->iconic == IconicState && !ws->iconpix && ws->iconwin) {
	 XClearWindow(wd->display, ws->iconwin);
#ifdef GraphicsGL
         if (!ws->is_gl)
#endif					/* GraphicsGL */
	 XDrawString(wd->display, ws->iconwin, wd->icongc, 4,
		     wd->fonts->fsp->max_bounds.ascent + 2,
		     ws->iconlabel, strlen(ws->iconlabel));
	 }
      }
   return Succeeded;
   }

/*
 * setwindowlabel
 */
int setwindowlabel(w, s)
wbp w;
char *s;
{
   wsp ws = w->window;
   CURTSTATE();
   if (ws->windowlabel != NULL) free(ws->windowlabel);
   if ((ws->windowlabel = salloc(s)) == NULL)
      ReturnErrNum(305, RunError);
   if (ws->display && ws->display->display && ws->win)
      XStoreName(ws->display->display, ws->win,
	 *ws->windowlabel ? ws->windowlabel : " ");    /* empty string fails */
   return Succeeded;
}

/*
 * setcursor() - a no-op under X at present
 */
int setcursor(w, on)
wbp w;
int on;
{
   if (on)
      SETCURSORON(w);
   else
      CLRCURSORON(w);
   return Succeeded;
}


/*
 * setpointer() - define a mouse pointer shape
 */
int setpointer(w, val)
wbp w;
char *val;
   {
   int i = si_s2i(cursorsyms,val) >> 1;
   wsp ws = w->window;
   wdp wd = ws->display;
   
   if (i < 0 || i >= NUMCURSORSYMS) return Failed;

   ws->theCursor = i;
   if (!(wd->cursors[i]))
      wd->cursors[i] = XCreateFontCursor(wd->display, 2 * i);
   if (ws->win)
      XDefineCursor(wd->display, ws->win, wd->cursors[i]);
   return Succeeded;
   }

/*
 * setdrawop() - set the drawing operation
 */
int setdrawop(w, val)
wbp w;
char *val;
   {
   wcp wc = w->context;
   wdp wd = w->window->display;
   
   XSync(wd->display, False);
   if (!strcmp(val,"reverse")) {
      if (!ISXORREVERSE(w)) {
	 SETXORREVERSE(w);
	 wc->drawop = GXxor;
	 if (wc->gc)
	    XSetForeground(wd->display, wc->gc,
			   wd->colors[wc->fg].c ^ wd->colors[wc->bg].c);
	 }
      }
   else {
      if (ISXORREVERSE(w)) {
	 CLRXORREVERSE(w);
	 if (wc->gc)
	    XSetForeground(wd->display, wc->gc, wd->colors[wc->fg].c);
	 }
      wc->drawop = si_s2i(drawops,val);
      if (wc->drawop == -1) { wc->drawop = GXcopy; return RunError; }
      }
   if (wc->gc) XSetFunction(wd->display, wc->gc, wc->drawop);
   return Succeeded;
   }

/*
 * rebind() - bind w's context to that of w2.
 */
int rebind(w, w2)
wbp w, w2;
   {
   if (w->window->display != w2->context->display) return Failed;
   w->context = w2->context;
   return Succeeded;
   }


void setclip(w)
wbp w;
   {
   wcp wc = w->context;
   XRectangle rec;
   if (wc->gc) {
      rec.x = wc->clipx;
      rec.y = wc->clipy;
      rec.width = wc->clipw;
      rec.height = wc->cliph;
      XSetClipRectangles(wc->display->display, wc->gc, 0, 0, &rec, 1,Unsorted);
      }
   }

void unsetclip(w)
wbp w;
   {
   wcp wc = w->context;
   if (wc->gc) {
      XSetClipMask(wc->display->display, wc->gc, None);
      }
   }

void getcanvas(w, s)
wbp w;
char *s;
   {
   if (w->window->win == (Window) NULL) {
#ifdef GraphicsGL
      if (w->window->is_gl) sprintf(s, "???");
      else
#endif					/* GraphicsGL */
      sprintf(s, "hidden");
      }
   else
      switch (w->window->iconic) {
      case RootState:
	 sprintf(s, "root");
	 break;
      case NormalState:
	 sprintf(s, "normal");
	 break;
      case IconicState:
	 sprintf(s, "iconic");
	 break;
      case MaximizedState:
	 sprintf(s, "maximal");
	 break;
      case HiddenState:
	 sprintf(s, "hidden");
	 break;
      default:
	 sprintf(s, "???");
      }
   }

int setselection(wbp w, dptr val)
{
   wsp ws = w->window;
   int i, j;

   /* Ensure that our atoms are interned. */
   if (intern_status == 0) intern_status = InternAtoms(ws->display->display);

   i = ownselection(ws->display->display, ws->win, XA_PRIMARY,
			(Time) ws->timestamp);
   j = ownselection(ws->display->display, ws->win, atom_array[CLIPBOARD],
			(Time) ws->timestamp);
   ws->selectiondata = malloc(StrLen(*val)+1);
   if (ws->selectiondata == NULL) return Failed;
   strncpy(ws->selectiondata, StrLoc(*val), StrLen(*val));
   ws->selectiondata[StrLen(*val)] = '\0';

   ws->inputmask |= PropertyChangeMask;
   /* if inputmask changed, maybe need to XSelectInput here */

   /* tried to own PRIMARY and CLIPBOARD; if failure, report */
   if ((i != True) || (j != True)) return Failed;
   return Succeeded;
}

int setinputmask(wbp w, char *val)
{
   wsp ws = w->window;
   if (strchr(val,'k')) {
      ws->inputmask |= KeyReleaseMask;
      }
   else {
      ws->inputmask &= ~KeyReleaseMask;
      }
   if (strchr(val,'m')) {
      ws->inputmask |= PointerMotionMask;
      }
   else {
      ws->inputmask &= ~PointerMotionMask;
      }
   if (strchr(val,'c')) {
      ws->inputmask |= WindowClosureMask;
      }
   else {
      ws->inputmask &= ~WindowClosureMask;
      }

   if (ws->win)
      XSelectInput(ws->display->display, ws->win, XMasks(ws->inputmask));
   return Succeeded;
}

/*
 *  Set the canvas type, either during open (pixmap is null, set a flag)
 *   or change an existing canvas to a different type.
 */
int setcanvas(w,s)
wbp w;
char *s;
   {
   int hm;
   XTextProperty textprop;
   wsp ws = w->window;
   wdp wd = ws->display;
   Display *stddpy = wd->display;
   Window  stdwin  = ws->win;

#ifdef GraphicsGL
   /*
    * For OpenGL implementation:
    *
    * Hidden windows are unmapped instead of being placed off-screen.
    * Since unmapping and iconifying both generate the same events,
    * a little trickery is used to keep ws->iconic straight.
    */
   if (ws->is_gl) {

   if (!strcmp(s, "iconic")) {
      /* uninitialized */
      if (stdwin == (Window) NULL) {
	 ws->wmhintflags |= StateHint;
	 ws->iconic = IconicState;
	 }
      else {
	 if (ws->iconic != IconicState) {
#ifdef Iconify
	    XIconifyWindow(ws->display->display, stdwin, ws->display->screen);
	    XSync(stddpy, False);
	    while (ws->iconic != IconicState)
	       if ((hm = handle_misc(wd, NULL)) < 1) {
		  if (hm == -1) return RunError;
		  else if (hm == 0) {
		     return Failed;
		     }
		  }
#else					/* Iconify */
	    return Failed;
#endif					/* Iconify */
	    }
	 }
      }

   else if (!strcmp(s, "normal")) {
      /* uninitialized */
      if (stdwin == (Window) NULL) {
	 ws->wmhintflags |= StateHint;
	 ws->iconic = NormalState;
	 }
      else {
	 if (ws->iconic == IconicState) {
	    XMapWindow(stddpy, stdwin);
	    XSync(stddpy, False);
	    while (ws->iconic == IconicState)
	       pollevent();
	    }
	 else if (ws->iconic == MaximizedState) {
	    moveResizeWindow(w, ws->normalx, ws->normaly,
			     ws->normalw, ws->normalh);
	    ws->iconic = NormalState;
	    }
	 else if (ws->iconic == HiddenState) {
	    XMapWindow(stddpy, stdwin);
	    XSync(stddpy, False);
	    while (ws->iconic == HiddenState)
	       pollevent();
            }
	 }
      }
   else if (!strcmp(s, "maximal")) {
      if (ws->iconic != MaximizedState) {
	 int expect_config= (ws->width != DisplayWidth(stddpy, wd->screen)) ||
	    (ws->height != DisplayHeight(stddpy, wd->screen));
	 ws->normalx = ws->posx;
	 ws->normaly = ws->posy;
	 ws->normalw = ws->width;
	 ws->normalh = ws->height;
	 ws->width = DisplayWidth(stddpy, wd->screen);
	 ws->height= DisplayHeight(stddpy, wd->screen);

	 if (stdwin != (Window) NULL) {
	    if (ws->iconic == IconicState) {
	       XMapWindow(stddpy, stdwin);
	       XSync(stddpy, False);
	       while (ws->iconic == IconicState)
  	          pollevent();
	       }
	    else if (ws->iconic == HiddenState) {
	       XMapWindow(stddpy, stdwin);
	       XSync(stddpy, False);
	       while (ws->iconic == HiddenState)
	          pollevent();
	       }
	    else if (expect_config) {
	       moveResizeWindow(w, 0, 0, ws->width, ws->height);
	       /* XSync is not enough because the window manager gets involved here. */
	       XFlush(wd->display);			      /* force out request */
	       XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
	       XSync(wd->display, False);		      /* NOW sync */
	       if (pollevent() == -1) return RunError;
	       moveWindow(w, -ws->posx, -ws->posy);
	       XFlush(wd->display);			      /* force out request */
	       XGetWMName(wd->display, stdwin, &textprop);    /* force WM round trip */
	       XSync(wd->display, False);		      /* NOW sync */
	       }
	    }
	 ws->iconic = MaximizedState;
	 }
      }
   else if (!strcmp(s, "hidden")) {
      /* Window initialized and not hidden */
      if (stdwin != (Window) NULL && ws->iconic != HiddenState) {
         //XUnmapWindow(stddpy, stdwin); /* what's the difference? */
         XWithdrawWindow(stddpy, stdwin, wd->vis->screen);
	 XSync(stddpy, False);
	 while (ws->iconic != IconicState) /* Wait for UnmapNotify event */
	    pollevent();
	 } 
      ws->iconic = HiddenState;
      }
   else return RunError;

   } /* end if (ws->is_gl) */
   else
#endif 					/* GraphicsGL */ 
   {
   if (!strcmp(s, "iconic")) {
      if (ws->pix == (Pixmap) NULL) {
	 ws->wmhintflags |= StateHint;
	 ws->iconic = IconicState;
	 }
      else {
	 if (ws->iconic != IconicState) {
#ifdef Iconify
	    if (stdwin == (Window) NULL) {
	       wmap(w);
	       }
	    XIconifyWindow(ws->display->display, stdwin, ws->display->screen);
	    XSync(stddpy, False);
	    while (ws->iconic != IconicState)
	       if ((hm = handle_misc(wd, NULL)) < 1) {
		  if (hm == -1) return RunError;
		  else if (hm == 0) {
		     return Failed;
		     }
		  }
#else					/* Iconify */
	    return Failed;
#endif					/* Iconify */
	    }
	 }
      }

   else if (!strcmp(s, "normal")) {
      if (ws->pix == (Pixmap) NULL) {
	 ws->iconic = NormalState;
	 }
      else {
	 if (stdwin == (Window) NULL) {
	    ws->iconic = NormalState;
	    ws->initialPix = ws->pix;
	    ws->pix = (Window) NULL;
            if (ws->parent) { 
#ifdef GraphicsGL
                gl_wmap(w); 
                if (w->window->is_3D) redraw3D(w); 
#else					/* GraphicsGL */
                my_wmap(w); 
#endif					/* GraphicsGL */
            }
	    else wmap(w);
	    }
	 else if (ws->iconic == IconicState) {
	    XMapWindow(stddpy, stdwin);
	    XSync(stddpy, False);
	    while (ws->iconic == IconicState)
	       pollevent();
	    }
	 else if (ws->iconic == MaximizedState) {
	    moveResizeWindow(w, ws->normalx, ws->normaly,
			     ws->normalw, ws->normalh);
	    ws->iconic = NormalState;
	    }
	 else {
	    /*
	     * Going normal from presumed hidden/offscreen state.
	     * Restore posx/posy from saved values.
	     */
	    ws->posx = ws->real_posx;
	    ws->posy = ws->real_posy;
	    do_config(w, 1);
#ifdef Graphics3D
	    if (ws->is_3D) redraw3D(w);
#endif					/* Graphics3D */
            }
	 }
      }
   else if (!strcmp(s, "maximal")) {
      if (ws->iconic != MaximizedState) {
	 int expect_config= (ws->width != DisplayWidth(stddpy, wd->screen)) ||
	    (ws->height != DisplayHeight(stddpy, wd->screen));
	 ws->normalx = ws->posx;
	 ws->normaly = ws->posy;
	 ws->normalw = ws->width;
	 ws->normalh = ws->height;
	 ws->width = DisplayWidth(stddpy, wd->screen);
	 ws->height= DisplayHeight(stddpy, wd->screen);
	 if (ws->pix != (Pixmap) NULL) {
	    if (stdwin == (Window) NULL) {
	       ws->iconic = MaximizedState;
	       ws->initialPix = ws->pix;
	       ws->pix = (Window) NULL;
	       wmap(w);
	       }
	    else if (ws->iconic == IconicState) {
	       XMapWindow(stddpy, stdwin);
	       XSync(stddpy, False);
	       while (ws->iconic == IconicState)
		  pollevent();
	       }
	    else if (expect_config) {
	       moveResizeWindow(w, 0, 0, ws->width, ws->height);
	       /* XSync is not enough because the window manager gets involved here. */
	       XFlush(wd->display);			      /* force out request */
	       XGetWMName(wd->display, ws->win, &textprop);    /* force WM round trip */
	       XSync(wd->display, False);		      /* NOW sync */
	       if (pollevent() == -1) return RunError;
	       moveWindow(w, -ws->posx, -ws->posy);
	       XFlush(wd->display);			      /* force out request */
	       XGetWMName(wd->display, stdwin, &textprop);    /* force WM round trip */
	       XSync(wd->display, False);		      /* NOW sync */
	       }
	    }
	 ws->iconic = MaximizedState;
	 }
      }
   else if (!strcmp(s, "hidden")) {
      if (ws->pix == (Pixmap)NULL) {
	 ws->iconic = HiddenState;
	 }
      else {
	 if (stdwin != (Window) NULL) {
	    if (ws->iconic == MaximizedState) {
	       ws->posx = ws->normalx;
	       ws->posy = ws->normaly;
	       ws->width = ws->normalw;
	       ws->height = ws->normalh;
	       ws->iconic = NormalState;
	       }
	    if (ws->iconic != IconicState) {
	       /*
		* Going hidden used to be this nice clean, kill-the-window
		* affair.  Some complications are now avoided by not killing
		* the window but instead, moving it off-screen.
		*/
	       ws->real_posx=ws->posx;
	       ws->real_posy=ws->posy;
	       ws->posx=8192;
	       ws->posy=0;
	       do_config(w, 1);
	       XFlush(stddpy);
	       }
	    }
	 }
      }
   else return RunError;
   }

   XSync(ws->display->display, False);
   return Succeeded;
   }

int seticonicstate(w,s)
wbp w;
char *s;
   {
   wsp ws = w->window;

   if (!strcmp(s, "icon")) {
      if (ws->pix == (Pixmap) NULL) {
	 ws->wmhintflags |= StateHint;
	 ws->iconic = IconicState;
	 }
      else {
	 if (ws->iconic != IconicState) {
#ifdef Iconify
	    XIconifyWindow(ws->display->display, ws->win, ws->display->screen);
#else					/* Iconify */
	    return Failed;
#endif					/* Iconify */
	    }
	 }
      }
   else if (!strcmp(s, "window")) {
      if (ws->win != (Window) NULL) {
	 if (ws->iconic == IconicState) {
	    XMapWindow(ws->display->display, ws->win);
	    }
	 }
      }
   else if (!strcmp(s, "root")) {
      if (ws->win == (Window) NULL)
	 ws->iconic = RootState;
      else return Failed;
      }
   else return RunError;
   XSync(ws->display->display, False);
   return Succeeded;
   }

int seticonpos(w,s)
wbp w;
char *s;
   {
   char *s2;
   wsp ws = w->window;

   ws->wmhintflags |= IconPositionHint;
   s2 = s;
   ws->iconx = atol(s2);
   while (isspace(*s2)) s2++;
   while (isdigit(*s2)) s2++;
   if (*s2++ != ',') return RunError;
   ws->icony = atol(s2);

   if (ws->win) {
      if (ws->iconwin == (Window) NULL)
	 makeIcon(w, ws->iconx, ws->icony);
#ifdef GraphicsGL
      if (!ws->is_gl)
#endif 					/* GraphicsGL */
      if (remap(w, ws->iconx, ws->icony) == -1) return RunError;
      }
   return Succeeded;
   }

int geticonpos(w, s)
wbp w;
char *s;
   {
   wsp ws = w->window;
   sprintf(s,"%d,%d", ws->iconx, ws->icony);
   return Succeeded;
   }


/*
 * if the window exists and is visible, set its position to (x,y)
 */
void moveWindow(w,x,y)
wbp w;
int x, y;
   {
   wsp ws = w->window;
   if (ws->posx != x || ws->posy != y) {
      ws->posx = x;
      ws->posy = y;
      if (ws->win) {
         XMoveWindow(ws->display->display, ws->win, ws->posx, ws->posy);
         XSync(ws->display->display, False);
         }
      }
   }

int moveResizeWindow(w, x, y, width, height)
wbp w;
int x, y, width, height;
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   ws->width = width;
   ws->height = height;

   size_hints.flags = PMinSize | PMaxSize;
   if (ISRESIZABLE(w)) {
      size_hints.min_width = 0;
      size_hints.min_height = 0;
      size_hints.max_width = DisplayWidth(wd->display, wd->screen);
      size_hints.max_height = DisplayHeight(wd->display, wd->screen);
      }
   else {
      size_hints.min_width = size_hints.max_width = width;
      size_hints.min_height = size_hints.max_height = height;
      }
   XSetNormalHints(wd->display, ws->win, &size_hints);

   if (resizePixmap(w, width, height) == 0) return Failed;

   if (ws->win != (Window) NULL) {
      if (x == -MaxInt && y == -MaxInt)
	 XResizeWindow(wd->display, ws->win, width, height);
      else
         XMoveResizeWindow(wd->display, ws->win, x, y, width, height);
      XSync(wd->display, False);
      }
   return Succeeded;
   }

/*
 * Set the context's fill style by name.
 */
int setfillstyle(w, s)
wbp w;
char *s;
   {
   wcp wc = w->context;

   if (!strcmp(s, "solid")) {
      wc->fillstyle = FillSolid;
      }
   else if (!strcmp(s, "masked")
	    || !strcmp(s, "stippled") || !strcmp(s, "patterned")) {
      wc->fillstyle = FillStippled;
      }
   else if (!strcmp(s, "textured")
      || !strcmp(s, "opaquestippled") || !strcmp(s, "opaquepatterned")) {
      wc->fillstyle = FillOpaqueStippled;
      }
   else return RunError;
   if (w->window->pix) {
      XSetFillStyle(w->window->display->display, wc->gc, wc->fillstyle);
      }
   return Succeeded;
   }

/*
 * Set the context's line style by name.
 */
int setlinestyle(w, s)
wbp w;
char *s;
   {
   wcp wc = w->context;
   
   if (!strcmp(s, "solid")) {
      wc->linestyle = LineSolid;
      }
   else if (!strcmp(s, "onoff") || !strcmp(s, "dashed")) {
      wc->linestyle = LineOnOffDash;
      }
   else if (!strcmp(s, "doubledash") || !strcmp(s, "striped")) {
      wc->linestyle = LineDoubleDash;
      }
   else return RunError;
   if (w->window->pix) {
      XSetLineAttributes(w->window->display->display, wc->gc,
	 wc->linewidth, wc->linestyle, CapProjecting, JoinMiter);
      }
   return Succeeded;
   }

/*
 * Set the context's line width
 */
int setlinewidth(w, linewid)
wbp w;
LONG linewid;
   {
   unsigned long gcmask;
   XGCValues gcv;
   wcp wc = w->context;

   if (linewid < 0) return RunError;
   wc->linewidth = linewid;
   if (w->window->pix) {
      gcv.line_width = linewid;
      gcv.line_style = wc->linestyle;
      if (linewid > 1)
         gcv.dashes = 3 * wc->linewidth;
      else
	 gcv.dashes = 4;
      gcmask = GCLineWidth | GCLineStyle | GCDashList;
      XChangeGC(w->window->display->display, wc->gc, gcmask, &gcv);
      }
   return Succeeded;
   }

/*
 * Reset the context's foreground color to whatever it is supposed to be.
 */
int resetfg(w)
wbp w;
   {
   wcp wc = w->context;
   wdp wd = wc->display;
   if (wc->gc != NULL)
      XSetForeground(wc->display->display, wc->gc,
		     wd->colors[wc->fg].c ^ (ISXORREVERSE(w) ? wd->colors[wc->bg].c : 0));
   return Succeeded;
   }

/*
 * Set the context's foreground color by name.
 */
int setfg(w,s)
wbp w;
char *s;
   {
   wclrp cp;
   wcp wc = w->context;
   wdp wd = w->window->display;
   Protect(cp = alc_color(w,s), return Failed);
   wc->fg = (cp - wd->colors);
   return resetfg(w);
   }

int setfgrgb(w, r, g, b)
wbp w;
int r, g, b;
{
   char sbuf1[MaxCvtLen];
   sprintf(sbuf1, "%d,%d,%d", r, g, b);
   return setfg(w, sbuf1);
}

/*
 * Set the context's foreground color by color cell.
 */
int isetfg(w,fg)
wbp w;
int fg;
   {
   int i, r, g, b;
   wdp wd = w->window->display;
   
   if (fg >= 0) {
      b = fg & 255;
      fg >>= 8;
      g = fg & 255;
      fg >>= 8;
      r = fg & 255;
      return setfgrgb(w, r * 257, g * 257, b * 257);
      }
   for (i = 2; i < DMAXCOLORS; i++)
      if (wd->colors[i].type == CLR_MUTABLE && wd->colors[i].c == -fg - 1)
	 break;
   if (i == DMAXCOLORS) return Failed;
   w->context->fg = i;
   return resetfg(w);
   }

/*
 * Set the window context's background color by name.
 */
int setbg(w,s)
wbp w;
char *s;
   {
   wclrp cp;
   wcp wc = w->context;
   wdp wd = w->window->display;
   GC stdgc = wc->gc;
   Display *stddpy = wd->display;
   Protect(cp = alc_color(w,s), return Failed);
   wc->bg = (cp - wd->colors);
   if (stdgc != NULL)
      XSetBackground(stddpy, stdgc, cp->c);
   return ISXORREVERSE(w) ? resetfg(w) : Succeeded;
   }

int setbgrgb(w, r, g, b)
wbp w;
int r, g, b;
{
   char sbuf1[MaxCvtLen];
   sprintf(sbuf1, "%d,%d,%d", r, g, b);
   return setbg(w, sbuf1);
}

/*
 * Set the context's background color by color cell.
 */
int isetbg(w,bg)
wbp w;
int bg;
   {
   int i, r, g, b;
   wcp wc = w->context;
   wdp wd = w->window->display;

   if (bg >= 0) {
      b = bg & 255;
      bg >>= 8;
      g = bg & 255;
      bg >>= 8;
      r = bg & 255;
      return setbgrgb(w, r * 257, g * 257, b * 257);
      }
   for (i = 2; i < DMAXCOLORS; i++)
      if (wd->colors[i].type == CLR_MUTABLE && wd->colors[i].c == -bg - 1)
	 break;
   if (i == DMAXCOLORS) return Failed;
   wc->bg = i;
   if (wc->gc != NULL)
      XSetBackground(wd->display, wc->gc, wd->colors[wc->bg].c);
   return ISXORREVERSE(w) ? resetfg(w) : Succeeded;
   }

/*
 * Set the gamma correction value.
 */
int setgamma(w, gamma)
wbp w;
double gamma;
   {
   wcp wc = w->context;
   wdp wd = w->window->display;
   wc->gamma = gamma;
   setfg(w, wd->colors[wc->fg].name);	/* reinterpret current Fg/Bg spec */
   setbg(w, wd->colors[wc->bg].name);
   return Succeeded;
   }

/*
 * Set the display by name.  Really should cache answers as per fonts below;
 * for now just open a new display each time.  Note that this can only be
 * called before a window is instantiated...
 */
int setdisplay(w,s)
wbp w;
char *s;
   {
   wdp d;
   wsp ws = w->window;
   wcp wc = w->context;

#ifdef GraphicsGL
   if (ws->is_gl) {
      /* can't change display for mapped window! */
      if (ws->iconic != HiddenState) return Failed;

      Protect(d = gl_alc_display(s), return 0);
      ws->display = d;

      strcpy(wc->glfg.name, "black");
      wc->glfg.r = 0;
      wc->glfg.g = 0;
      wc->glfg.b = 0;
      wc->glfg.a = 65535;
      wc->glfg.id = 0;

      strcpy(wc->glbg.name, "white");
      wc->glbg.r = 65535;
      wc->glbg.g = 65535;
      wc->glbg.b = 65535;
      wc->glbg.a = 65535;
      wc->glbg.id = 0;
      }
   else
#endif 					/* GraphicsGL */   
   {
   /* can't change display for mapped window! */
   if (w->window->pix != (Pixmap) NULL)
      return Failed;

   Protect(d = alc_display(s), return 0);
   ws->display = d;
   wc->fg = 0;
   wc->bg = 1;
   }

   wc->font = d->fonts;
   return Succeeded;
   }

int setleading(w, i)
wbp w;
int i;
{
   w->context->leading = i;
   return Succeeded;
}

int setimage(w, val)
wbp w;
char *val;
   {
   wsp ws = w->window;
   int status;
   ws->initialPix = loadimage(w, val, &(ws->height), &(ws->width),
			  0, &status);
   if (ws->initialPix == (Pixmap) NULL) return Failed;
   return Succeeded;
   }

void toggle_fgbg(w)
wbp w;
{
   int tmp;
   wcp wc = w->context;
   wdp wd = w->window->display;

   tmp = wc->fg;
   wc->fg = wc->bg;
   wc->bg = tmp;
   if (w->window->pix) {
      XSetForeground(wd->display, wc->gc,
		     wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
      XSetBackground(wd->display, wc->gc, wd->colors[wc->bg].c);
      }
}

void getdisplay(w, answer)
wbp w;
char *answer;
   {
   wdp wd = w->window->display;
   if (!strcmp(wd->name, "")) {
      if (getenv_r("DISPLAY", answer, 256) == -1)
	 *answer = '\0';
      }
   else sprintf(answer, "%s", wd->name);
   }

int getvisual(w, answer)
wbp w;
char *answer;
{
   wdp wd = w->window->display;
   Visual * v = DefaultVisual(wd->display,wd->screen);
   sprintf(answer, "%d,%d,%d", v->class, v->bits_per_rgb, v->map_entries );
   return Succeeded;
}
/*
 * getpos() - update the window state's notion of its current position
 */
int getpos(w)
wbp w;
{
   Window garbage1, garbage2;
   int root_x, root_y, win_x, win_y;
   unsigned int key_buttons;
   wsp ws = w->window;
   
   if (!ws->win) return Failed;
   /*
    * This call is made because it is guaranteed to generate
    * a synchronous request of the server, not just ask Xlib
    * what the window position was last it knew.
    */
   if (XQueryPointer(ws->display->display, ws->win, &garbage1, &garbage2,
		     &root_x, &root_y, &win_x, &win_y, &key_buttons) ==
       False) {
      return Failed;
      }
   ws->posx = root_x - win_x;
   ws->posy = root_y - win_y;
   return Succeeded;
}

void getfg(w, answer)
wbp w;
char *answer;
{
   sprintf(answer, "%s", w->window->display->colors[w->context->fg].name);
}

void getbg(w, answer)
wbp w;
char *answer;
{
   sprintf(answer, "%s", w->window->display->colors[w->context->bg].name);
}

void getlinestyle(w, answer)
wbp w;
char *answer;
{
   wcp wc = w->context;
   sprintf(answer,"%s",
	   (wc->linestyle==LineSolid)?"solid":
	   ((wc->linestyle==LineOnOffDash)?"dashed":"striped"));
}

void getfntnam(w, answer)
wbp w;
char *answer;
{
   sprintf(answer,"%s", w->context->font->name);
}

void getpointername(w, answer)
wbp w;
char *answer;
{
   strcpy(answer, si_i2s(cursorsyms, 2 * w->window->theCursor));
}

void getdrawop(w, answer)
wbp w;
char *answer;
{
   char *s;
   if (ISXORREVERSE(w)) s = "reverse";
   else s = si_i2s(drawops, w->context->drawop);
   if (s) sprintf(answer, "%s", s);
   else strcpy(answer, "copy");
}

void geticonic(w, answer)
wbp w;
char *answer;
{
   switch (w->window->iconic) {
   case RootState:
     sprintf(answer, "root");
     break;
   case NormalState:
     sprintf(answer, "window");
     break;
   case IconicState:
     sprintf(answer, "icon");
     break;
   default:
     sprintf(answer, "???");
   }
}

/*
 * Set the window's font by name.
 */
int setfont(w,s)
wbp w;
char **s;
   {
   wfp tmp;
   wcp wc = w->context;
   wsp ws = w->window;

#ifdef Graphics3D
   if (wc->rendermode == UGL3D) {
      mkfont(*s, 1);
      return Succeeded;
      }
#endif					/* Graphics3D */

   /* could free up previously allocated font here */

   Protect(tmp = alc_font(w,s), return Failed);
   wc->font = tmp;

   if (wc->gc != NULL)
      XSetFont(ws->display->display, wc->gc, wc->font->fsp->fid);

   if (ws->pix == (Pixmap) NULL) {
      ws->y = wc->font->fsp->max_bounds.ascent;
      ws->x = 0;
      }
   return Succeeded;
   }

/*
 * callback procedures
 */

static int handle_exposures(w, event)
wbp w;
XExposeEvent *event;
   {
   int returnval;
   STDLOCALS(w);

   returnval = ISEXPOSED(w);
   SETEXPOSED(w);
   if (stdwin && !ISZOMBIE(w)) {
#ifdef GraphicsGL 
       if (ws->is_gl) {
          /*
           * Go ahead and redraw. Messing with the event queue might 
           * de-sync ConfigureNotify events with exposures, resulting
           * in undefined behavior
           */
          redraw3D(w); 
	  }
       else
#endif					/* GraphicsGL */
      {
      if (wc->drawop != GXcopy)
	 XSetFunction(stddpy, stdgc, GXcopy);
      if (wc->clipw >= 0)
	 unsetclip(w);
      XCopyArea(stddpy, stdpix, stdwin, stdgc, event->x,event->y,
		event->width,event->height, event->x,event->y);
      if (wc->clipw >= 0)
	 setclip(w);
      if (wc->drawop != GXcopy)
	 XSetFunction(stddpy,stdgc,wc->drawop);
      }
      }
   return returnval;
   }
#ifndef min
#define min(x,y) (((x)<(y))?(x):(y))
#define max(x,y) (((x)>(y))?(x):(y))
#endif

/*
 * resizePixmap(w,width,height) -- ensure w's backing pixmap is at least
 * width x height pixels.
 *
 * Resizes the backing pixmap, if needed.  Called when X resize events
 * arrive, as well as when programs make explicit resize requests.
 *
 * Returns 0 on failure.
 */
int resizePixmap(w,width,height)
wbp w;
int width;
int height;
   {
   Pixmap p;
   STDLOCALS(w);
   if (ws->pix == (Pixmap) NULL) return 1;
   if ((width > ws->pixwidth) || (height > ws->pixheight)) {
      int x = ws->pixwidth, y = ws->pixheight;

      ws->pixheight = max(ws->pixheight, height);
      ws->pixwidth  = max(ws->pixwidth, width);
      p = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), ws->pixwidth,
			ws->pixheight, DefaultDepth(stddpy,wd->screen));
      if (p == (Pixmap) NULL)
	 return 0;

      /*
       * This staggering amount of redudancy manages to make sure the new
       * pixmap gets initialized including areas not in the old pixmap.
       * The window is redrawn.
       */
      XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
      if (wc->drawop != GXcopy)
	 XSetFunction(stddpy, stdgc, GXcopy);
      if (wc->fillstyle != FillSolid)
	 XSetFillStyle(stddpy, stdgc, FillSolid);
      if (wc->clipw >= 0)
	 unsetclip(w);
	   
      if (width > x) {
	 XFillRectangle(stddpy, p, stdgc, x, 0, width-x, ws->pixheight);
	 if (stdwin != (Window) NULL)
	    XFillRectangle(stddpy,stdwin,stdgc, x, 0, width-x, ws->pixheight);
         }
      if (height > y) {
	 XFillRectangle(stddpy, p, stdgc, 0, y, x, height - y);
	 if (stdwin != (Window) NULL)
	    XFillRectangle(stddpy, stdwin, stdgc, 0, y, x, height - y);
         }
      XSetForeground(stddpy, stdgc,
		     wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
      XCopyArea(stddpy, stdpix, p, stdgc, 0, 0, x, y, 0, 0);
      if (wc->drawop != GXcopy)
	 XSetFunction(stddpy,stdgc,wc->drawop);
      if (wc->fillstyle != FillSolid)
	 XSetFillStyle(stddpy, stdgc, wc->fillstyle);
      if (wc->clipw >= 0)
	 setclip(w);

      XFreePixmap(stddpy, stdpix);	/* free old pixmap */
      ws->pix = p;
      }
   return 1;
   }

/*
 * Resize operations are made as painless as possible, but the
 * user program is informed anyhow.  The integer coordinates are
 * the new size of the window, in pixels.
 */
static int handle_config(w, event)
wbp w;
XConfigureEvent *event;
   {
   struct descrip d;
   wsp ws = w->window;
   
   /*
    * Update X-Icon's information about the window's configuration
    */
#ifdef GraphicsGL
   if (ws->is_gl)
      ws->x = min(ws->x, event->width - GL_FWIDTH(w));
   else
#endif					/* GraphicsGL */
   ws->x = min(ws->x, event->width - FWIDTH(w));
   ws->y = min(ws->y, event->height);

   ws->posx = event->x;
   ws->posy = event->y;


   /*
    * If this was not a resize, drop it
    */
   if ((event->width == ws->width) && (event->height == ws->height))
      return 1;

   ws->width = event->width;
   ws->height = event->height;

   if (! resizePixmap(w, event->width, event->height)) return 0;

#ifdef GraphicsGL
   if (ws->is_gl) {
      ws->resize = 1;
      redraw3D(w);
      }
#endif					/* GraphicsGL */

   /*
    * The initial configure event generates no Icon-level "events"
    *
    * Commenting this for the ui initial window size bug breaks 
    * the integrated cve demo..
    */
   if (!ISEXPOSED(w))
      return 1;

   MakeInt(RESIZED, &d);
   qevent(w->window, &d, ws->width, ws->height, ~(uword)0, 0);
   return 1;
   }

/*
 * Queue up characters for keypress events.
 */
static void handle_keypress(w,event)
wbp w;
XKeyEvent *event;
   {
   int i,j;
   char s[10];
   struct descrip d;
   KeySym k;

   w->window->pointerx = event->x;
   w->window->pointery = event->y;

   switch (i=translate_key_event(event, s, &k)) {
   case -1:
      return;
   case 0:
      if (event->type == KeyRelease) k = -k - 128;
      MakeInt(k, &d);
      qevent(w->window, &d, event->x, event->y,
	     (uword)event->time, event->state);
      break;
   default:
      StrLen(d) = 1;
      for (j = 0; j < i; j++) {
	 if (event->type == KeyRelease) {
	    MakeInt(-(FromAscii(s[j]) & 0xFF)-128, &d);
	    qevent(w->window, &d, event->x, event->y,
		   (uword)event->time, event->state);
	    }
	 else {
	 StrLoc(d) = (char *)&allchars[FromAscii(s[j]) & 0xFF];
	 qevent(w->window, &d, event->x, event->y,
		(uword)event->time, event->state);
	 }
	 }
      }
   }

#define swap(a,b) { tmp = a; a = b; b = tmp; }
/*
 * Handle button presses and drag events.  In the case of drags, we should
 * really be looking at an XMotionEvent instead of an XButtonEvent, but
 * the structures are identical up to the button field (which we do not
 * examine for drag events).  Mouse coordinates are queued up after the event.
 */
static void handle_mouse(w,event)
wbp w;
XButtonEvent *event;
   {
   static unsigned int buttonorder[3] =
     { Button1Mask, Button2Mask, Button3Mask };
   unsigned int tmp;
   int eventcode = 0;
   struct descrip d;

   if (event->type == MotionNotify) {
      if (event->state & buttonorder[0]) {
         if (buttonorder[0] == Button1Mask)
	    eventcode = MOUSELEFTDRAG;
         else if (buttonorder[0] == Button2Mask)
            eventcode = MOUSEMIDDRAG;
         else
            eventcode = MOUSERIGHTDRAG;
         }
      else if (event->state & buttonorder[1]) {
         if (buttonorder[1] == Button1Mask)
	    eventcode = MOUSELEFTDRAG;
         else if (buttonorder[1] == Button2Mask)
            eventcode = MOUSEMIDDRAG;
         else
            eventcode = MOUSERIGHTDRAG;
         }
      else if (event->state & buttonorder[2]) {
         if (buttonorder[2] == Button1Mask)
	    eventcode = MOUSELEFTDRAG;
         else if (buttonorder[2] == Button2Mask)
            eventcode = MOUSEMIDDRAG;
         else
            eventcode = MOUSERIGHTDRAG;
         }
      else {
	 eventcode = MOUSEMOVED;
	 }
      }
   else switch (event->button) {
      case Button1: {
	 eventcode = MOUSELEFT;
	 if (buttonorder[2] == Button1Mask)
	    swap(buttonorder[1],buttonorder[2]);
	 if (buttonorder[1] == Button1Mask)
	    swap(buttonorder[0],buttonorder[1]);
	 break;
         }
      case Button2: {
	 eventcode = MOUSEMID;
	 if (buttonorder[2] == Button2Mask)
	    swap(buttonorder[1],buttonorder[2]);
	 if (buttonorder[1] == Button2Mask)
	    swap(buttonorder[0],buttonorder[1]);
	 break;
         }
      case Button3: {
	 eventcode = MOUSERIGHT;
	 if (buttonorder[2] == Button3Mask)
	    swap(buttonorder[1],buttonorder[2]);
	 if (buttonorder[1] == Button3Mask)
	    swap(buttonorder[0],buttonorder[1]);
	 break;
         }
      case Button4: {
	 eventcode = SCROLLUP;
	 break;
         }
      case Button5: {
	 eventcode = SCROLLDOWN;
	 break;
         }
      }
   if (event->type == ButtonRelease) {
      if (eventcode >= MOUSERIGHT) {
	 eventcode -= (MOUSELEFT - MOUSELEFTUP);
	 swap(buttonorder[0],buttonorder[1]);
	 swap(buttonorder[1],buttonorder[2]);
	 }
      else return; /* drop scroll wheel release events silently for now */
      }

   w->window->pointerx = event->x;
   w->window->pointery = event->y;

   MakeInt(eventcode,&d);
   qevent(w->window, &d, event->x, event->y, (uword)event->time, event->state);
   }


/*
 * fill a series of rectangles
 */
void fillrectangles(w, recs, nrecs)
wbp w;
XRectangle *recs;
int nrecs;
   {
   STDLOCALS(w);
   /*
    * Free colors if drawop=copy, fillstyle~=masked, no clipping,
    * and a single rectangle that fills the whole window.
    */
   if (!RECX(*recs) && !RECY(*recs) && RECWIDTH(*recs) >= ws->width &&
      RECHEIGHT(*recs) >= ws->height && nrecs == 1 &&
      wc->drawop == GXcopy && wc->fillstyle != FillStippled && wc->clipw < 0) {
         RECWIDTH(*recs) = ws->pixwidth;	/* fill hidden part */
	 RECHEIGHT(*recs) = ws->pixheight;
	 free_xcolors(w, 0);			/* free old colors */
	 }
   RENDER2(XFillRectangles, recs, nrecs);
   }

/*
 * erase an area
 */
void eraseArea(w,x,y,width,height)
wbp w;
int x, y, width, height;
   {
   STDLOCALS(w);

   /*
    * if width >= window width or height >= window height, clear any
    * offscreen portion as well in order to allow the freeing of colors.
    */
   if (x + width  >= ws->width)  width  = ws->pixwidth - x;
   if (y + height >= ws->height) height = ws->pixheight - y;

   /*
    * fill the rectangle with the background color
    */
   XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
   if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
   if (wc->fillstyle != FillSolid) XSetFillStyle(stddpy, stdgc, FillSolid);
   RENDER4(XFillRectangle, x, y, width, height);
   XSetForeground(stddpy, stdgc,
		  wd->colors[wc->fg].c ^ (ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
   if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
   if (wc->fillstyle != FillSolid) XSetFillStyle(stddpy, stdgc, wc->fillstyle);

   /*
    * if the entire window is cleared, free up colors
    */
   if (!x && !y && width >= ws->pixwidth && height >= ws->pixheight &&
      wc->clipw < 0) {
      free_xcolors(w, 0);
      }
   }

/*
 * copy an area
 */
int copyArea(w,w2,x,y,width,height,x2,y2)
wbp w, w2;
int x, y, width, height, x2, y2;
   {
   int lpad, rpad, tpad, bpad;
   Pixmap src;
   wsp ws1 = w->window, ws2 = w2->window;
   wclrp cp, cp2 = NULL;
   STDLOCALS(w2);

   if (w->window->display->display != w2->window->display->display) {
      wdp wd1 = ws1->display;
      unsigned long c = 0;
      int i, j;
      Display *d1 = wd1->display;
      XColor clr;
      XImage *xim;

      /*
       * Copying is between windows on two different displays.
       */
      if (x<0 || y<0 || x+width > ws1->pixwidth || y+height > ws1->pixheight)
	 return Failed;		/*#%#%# BOGUS, NEEDS FIXING */
      xim = XGetImage(d1, ws1->pix, x, y, width, height,
		      (1<<DefaultDepth(d1,wd1->screen))-1,XYPixmap);
      XSetFunction(stddpy, stdgc, GXcopy);
      for (i=0; i < width; i++) {
	 for (j=0; j < height; j++) {
	    clr.pixel = XGetPixel(xim, i, j);
	    if (cp2 != NULL && c == clr.pixel) {
	       XSetForeground(stddpy, stdgc, cp2->c);
	       RENDER2(XDrawPoint, i + x2, j + y2);
	       continue;
	       }
	    c = clr.pixel;
	    cp2 = NULL;
	    for ( cp = wd1->colors; cp < wd->colors + wd->numColors; cp++) {
	       if (cp->c == c) {
		  if (cp->name[0]=='\0') {
		     XQueryColor(d1, wd1->cmap, &clr);
		     cp->r = clr.red;
		     cp->g = clr.green;
		     cp->b = clr.blue;
		     sprintf(cp->name,"%d,%d,%d",cp->r,cp->g,cp->b);
		     }
		  cp2 = alc_rgb(w2, cp->name, cp->r, cp->g, cp->b, 0);
		  if (cp2 == NULL) return Failed;
		  break;
		  }
	       }
	    if (cp2 == NULL) {
	       XQueryColor(d1, wd1->cmap, &clr);
	       cp2 = alc_rgb(w2, "unknown", clr.red, clr.green, clr.blue, 0);
	       }
	    if (cp2 == NULL) return Failed;
	    XSetForeground(stddpy, stdgc, cp2->c);
	    RENDER2(XDrawPoint, i + x2, j + y2);
	    }
	 }
      XSetForeground(stddpy, stdgc,
		     wd->colors[wc->fg].c ^ (ISXORREVERSE(w2) ? wd->colors[wc->bg].c : 0));
      XSetFunction(stddpy, stdgc, wc->drawop);
      XSync(stddpy,False);
      XDestroyImage(xim);
      }
   else {
      /*
       * Copying is between windows on one display, perhaps the same window.
       */
      src = ws1->pix;
      if (src != stdpix) {
	 /* copying between different windows; handle color bookkeeping */
         if (!x2 && !y2 &&
            ((width  >= ws2->pixwidth)  || !width) &&
            ((height >= ws2->pixheight) || !height) && w2->context->clipw < 0){
	       free_xcolors(w2, 0);
	       }
	 copy_colors(w, w2);
	 }
      XSetForeground(stddpy, stdgc, wd->colors[wc->bg].c);
      XSetFunction(stddpy, stdgc, GXcopy);

      if (x+width<0 || y+height<0 || x>=ws1->pixwidth || y>=ws1->pixheight) {
	 /* source is entirely offscreen */
         RENDER4(XFillRectangle, x2, y2, width, height);
         }
      else {
	 /*
	  * Check for source partially offscreen, but copy first and
	  * fill later in case the source and destination overlap.
	  */
	 lpad = rpad = tpad = bpad = 0;
         if (x < 0) {			/* source extends past left edge */
	    lpad = -x;
            width -= lpad;
            x2 += lpad;
            x = 0;
            }
         if (x + width > ws1->pixwidth) {  /* source extends past right edge */
            rpad = x + width - ws1->pixwidth;
            width -= rpad;
            }
         if (y < 0) {			/* source extends above top edge */
	    tpad = -y;
            height -= tpad;
            y2 += tpad;
            y = 0;
            }
         if (y + height > ws1->pixheight) {  /* source extends below bottom */
            bpad = y + height - ws1->pixheight;
            height -= bpad;
            }
	 /*
	  * Copy the area.
	  */
         if (stdwin)
            XCopyArea(stddpy, src, stdwin, stdgc, x, y, width, height, x2, y2);
         XCopyArea(stddpy, src, stdpix, stdgc, x, y, width, height, x2, y2);
	 /*
	  * Fill any edges not provided by source.
	  */
	 if (lpad > 0)
            RENDER4(XFillRectangle, x2-lpad, y2-tpad, lpad, tpad+height+bpad);
	 if (rpad > 0)
            RENDER4(XFillRectangle, x2+width, y2-tpad, rpad, tpad+height+bpad);
	 if (tpad > 0)
	    RENDER4(XFillRectangle, x2, y2-tpad, width, tpad);
	 if (bpad > 0)
	    RENDER4(XFillRectangle, x2, y2+height, width, bpad);
	 }

      XSetForeground(stddpy,stdgc,
		     wd->colors[wc->fg].c^(ISXORREVERSE(w2) ? wd->colors[wc->bg].c :0));
      XSetFunction(stddpy, stdgc, wc->drawop);
      }
   return Succeeded;
   }


wbp sprite;
int tics;
int lastx,lasty;
int animwidth, animheight;

void animHelper(w,p,n)
wbp w;
XPoint p[];
int n;
   {
   int i=0;
   STDLOCALS(w);

   for ( ; i < n; i++) {
      int j;

      /*
       * redraw that portion of the previous image that isn't overlapped
       * by the new image being drawn
       */
      if (lastx >= 0) {
	 int dx = p[i].x - lastx, dy = p[i].y - lasty;
         if (dx > 0) XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx, lasty,
			       dx, animheight, lastx, lasty);
	 else if (dx < 0)
	    XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx+animwidth+dx, lasty,
		      -dx, animheight, lastx+animwidth+dx, lasty);

         if (dy > 0) XCopyArea(stddpy, stdpix, stdwin, stdgc, lastx, lasty,
			       animwidth, dy, lastx, lasty);
	 else if (dy < 0)
	    XCopyArea(stddpy,stdpix,stdwin,stdgc, lastx, lasty+animheight+dy,
		      animwidth, -dy, lastx, lasty+animheight+dy);
         }

      XCopyArea(stddpy, sprite->window->pix, stdwin, stdgc,
		0, 0, animwidth, animheight, p[i].x, p[i].y);
      XFlush(stddpy);
      for (j = 0; j < tics; j++);
/*     
 * erase the whole box approach:
 *      XCopyArea(stddpy, stdpix, stdwin, stdgc,
 *                0, 0, animwidth, animheight, p[i].x, p[i].y);
 */
      lastx = p[i].x;
      lasty = p[i].y;
      }
   }

void animate(w, pixs, npix, p, n, delay)
wbp w;
dptr pixs;
int npix;
XPoint *p;
int n, delay;
   {
   wbp w2 = BlkD(*pixs,File)->fd.wb;
   wsp ws = w->window;
   
   sprite = w2;
   animheight = sprite->window->height;
   animwidth  = sprite->window->width;
   tics = delay;
   lastx = lasty = -1;
   genCurve(w, p, n, animHelper);
   XCopyArea(ws->display->display, ws->pix, ws->win, w->context->gc, lastx, lasty,
	     animwidth, animheight, lastx, lasty);
   }

int getdefault(w, prog, opt, answer)
wbp w;
char *prog, *opt, *answer;
   {
   char *p;
   
   if ((p = XGetDefault(w->window->display->display, prog, opt)) == NULL)
      return Failed;
   strcpy(answer, p);
   return Succeeded;
   }

/*
 * Allocate a mutable color
 */
int mutable_color(w, argv, ac, retval)
wbp w;
dptr argv;
int ac;
int *retval;
   {
   XColor colorcell;
   LinearColor clr;
   unsigned long plane_masks[1], pixels[1];
   char *colorname;
   tended char  *str;
   int i;
   long alpha;
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   Display *stddpy = wd->display;

   /*
    * X11 Bug Warning:  some old versions of the X server, but not X11R5,
    * will crash sometime after a failed call to XNewColor.  This happens
    * only if a virtual colormap has been allocated and completely filled
    * and then XNewColor is called to allocate a new, unshared entry.  The
    * request fails, as it should, but when the program eventually exits
    * the X server crashes.  This has been seen on OpenWindows 3.0,
    * Irix 4.0.1, and HP-UX 7.0.
    */

   if (!XAllocColorCells(stddpy,wd->cmap,False,plane_masks,0,pixels,1)) {
      /*
       * try again with a virtual colormap
       */
      if (!go_virtual(w) ||
	  !XAllocColorCells(stddpy,wd->cmap,False,plane_masks,0,pixels,1))
	 return Failed;                         /* cannot allocate an entry */
      }

   /*
    * allocate a slot in wdisplay->colors and wstate->theColors arrays
    */
   i = alc_centry(wd);
   if (i == 0)
      return Failed;
   wd->colors[i].type = CLR_MUTABLE;
   wd->colors[i].c = pixels[0];


   /* save color index as "name", followed by a null string for value */
   colorname = wd->colors[i].name;
   sprintf(colorname, "%ld", -pixels[0] - 1);	/* index is name */
   colorname = colorname + strlen(colorname) + 1;
   *colorname = '\0';				/* value unknown */

   if (ws->numColors < WMAXCOLORS) {
      if (ws->theColors == NULL) {
	 ws->theColors = (short *)calloc(WMAXCOLORS, sizeof(short));
	 if (ws->theColors == NULL)
	    return RunError;
	 }
      ws->theColors[ws->numColors++] = i;
      }

   if (ac > 0) {                     /* set the color */
      if (ac != 1) return RunError;
      /*
       * old-style check for C integer
       */
      else if (argv[0].dword == D_Integer) {/* check for color cell */
	 if (IntVal(argv[0]) >= 0)
	    return Failed;        /* must be negative */
	 colorcell.pixel = -IntVal(argv[0]) - 1;
	 XQueryColor(stddpy, wd->cmap, &colorcell);
         clr = lcolor(w, colorcell);
         sprintf(colorname, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
	 }
      else {
	 if (!cnv:C_string(argv[0],str)) {
	    ReturnErrVal(103,argv[0], RunError);
	    }
         if (parsecolor(w, str, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded) {
            free_xcolor(w, pixels[0]);
	    return Failed;                   /* invalid color specification */
	    }
	 strcpy(colorname, str);
         colorcell = xcolor(w, clr);
	 }
      colorcell.pixel = pixels[0];
      XStoreColor(stddpy, wd->cmap, &colorcell);
      }

   *retval = (-pixels[0] - 1);
   return Succeeded;
   }
   }

char *get_mutable_name(w, mute_index)
wbp w;
int mute_index;
   {
   wdp dp;
   int i;
   char *colorname;

   dp = w->window->display;

   for (i = 2; i < DMAXCOLORS; i++)
      if (dp->colors[i].type == CLR_MUTABLE && dp->colors[i].c == -mute_index-1)
	    break;
   if (i == DMAXCOLORS)
      return NULL;
   colorname = dp->colors[i].name;			/* color name field */
   colorname = colorname + strlen(colorname) + 1;	/* set value follows */
   return colorname;
   }

int set_mutable(w, i, s)
wbp w;
int i;
char *s;
   {
   LinearColor clr;
   long alpha;
   XColor colorcell;
   wdp dp = w->window->display;

   if (parsecolor(w, s, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded)
      return Failed;                        /* invalid color specification */
   colorcell = xcolor(w, clr);
   colorcell.pixel = -i - 1;
   XStoreColor(dp->display, dp->cmap, &colorcell);
   return Succeeded;
   }

void free_mutable(w, mute_index)
wbp w;
int mute_index;
   {
   wdp dp;
   int i;

   dp = w->window->display;

   for (i = 2; i < DMAXCOLORS; i++)
      if (dp->colors[i].type == CLR_MUTABLE && dp->colors[i].c == -mute_index-1)
            break;
   if (i != DMAXCOLORS)
      free_xcolor(w, dp->colors[i].c); 
   }


void freecolor(w, s)
wbp w;
char *s;
   {
   wdp dp;
   long i, alpha;
   LinearColor clr;
   XColor color;

   if (parsecolor(w, s, &clr.red, &clr.green, &clr.blue, &alpha) != Succeeded)
      return;
   dp = w->window->display;
   color = xcolor(w, clr);

   for (i = 2; i < DMAXCOLORS; i++)
      if (dp->colors[i].r == color.red && dp->colors[i].g == color.green
      && dp->colors[i].b == color.blue && dp->colors[i].type != CLR_MUTABLE)
         break;
   if (i != DMAXCOLORS)
      free_xcolor(w, dp->colors[i].c);
   }

/*
 * Draw a bilevel image
 */
int blimage(w, x, y, width, height, ch, s, len)
wbp w;
int x, y, width, height, ch;
unsigned char *s;
word len;
   {
   unsigned int m, msk1, c, ix, iy;
   long fg, bg;
   XImage *im;
   STDLOCALS(w);

   /*
    * Get an XImage structure and free the old color set if possible.
    */
   im = getximage(w, x, y, width, height, ch == TCH1);
   if (im == NULL)
      return RunError;

   /*
    * Read the image string and set the pixel values.  Note that
    * the hex digits in sequence fill the rows *right to left*.
    */
   m = width % 4;
   if (m == 0)
      msk1 = 8;
   else
      msk1 = 1 << (m - 1);		/* mask for first byte of row */

   fg = wd->colors[wc->fg].c;
   bg = wd->colors[wc->bg].c;
   ix = width;
   iy = 0;
   m = msk1;
   while (len--) {
      if (isxdigit(c = *s++)) {		/* if hexadecimal character */
         if (!isdigit(c))		/* fix bottom 4 bits if necessary */
            c += 9;
         while (m > 0) {		/* set (usually) 4 pixel values */
	    --ix;
	    if (c & m)
	       XPutPixel(im, ix, iy, fg);
	    else if (ch != TCH1)	/* if zeroes aren't transparent */
	       XPutPixel(im, ix, iy, bg);
            m >>= 1;
            }
         if (ix == 0) {			/* if end of row */
            ix = width;
            iy++;
            m = msk1;
            }
         else
            m = 8;
         }
      }
   if (ix > 0)				/* pad final row if incomplete */
      while (ix < width)
         XPutPixel(im, ix++, iy, bg);

   /*
    * Put it on the screen.
    */
   if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
   RENDER7(XPutImage, im, 0, 0, x, y, width, height);
   XDestroyImage(im);
   if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
   return Succeeded;
   }

/*
 * Draw a character-per-pixel image
 */
int strimage(w, x, y, width, height, e, s, len, on_icon)
wbp w;
int x, y, width, height;
struct palentry *e;
unsigned char *s;
word len;
int on_icon;
   {
   int c, v, ret = 0, trans = 0;
   unsigned int r, g, b, ix, iy;
   XImage *im;
   wclrp cp;
   int ciarray[256];
   char tmp[32];
   wcp wc = w->context;
   wsp ws = w->window;
   wdp wd = ws->display;
   Display *stddpy = wd->display;
   GC  stdgc  = wc->gc;

   if (e) {
      /*
       * Get an XImage structure and free the old color set if possible.
       */
      for (c = 0; c < 256; c++)
	 trans |= e[c].used && e[c].transpt;
      }
   im = getximage(w, x, y, width, height, trans);
   if (im == NULL)
      return -1;

   if (e) {
   /*
    * Allocate the colors we need.  Use black or white if unsuccessful.
    */
   ret = 0;
   for (c = 0; c < 256; c++)
      if (e[c].used && e[c].valid) {
         r = e[c].clr.red;
         g = e[c].clr.green;
         b = e[c].clr.blue;
         sprintf(tmp, "%d,%d,%d", r, g, b);
         cp = alc_rgb(w, tmp, r, g, b, 0);
         if (cp == NULL) {
            ret++;
            if ((0.299 * r + 0.587 * g + 0.114 * b) > 32767)
               cp = alc_rgb(w, "white", 65535, 65535, 65535, 0);
            else
               cp = alc_rgb(w, "black", 0, 0, 0, 0);
            }
         ciarray[c] = cp-wd->colors;
         }

   /*
    * Read the image string and set the pixel values.
    */
   ix = iy = 0;
   while (len--) {
      c = *s++;
      v = e[c].valid;
      if (v)				/* put char if valid */
         XPutPixel(im, ix, iy, wd->colors[ciarray[c]].c);
      if (v || e[c].transpt) { 		/* advance if valid or transparent */
         if (++ix >= width) {
            ix = 0;			/* reset for new row */
            iy++;
            }
         }
      }
   if (ix > 0) {			/* pad final row if incomplete */
      while (ix < width)
         XPutPixel(im, ix++, iy, wd->colors[wc->bg].c);
      }
   }
   else {
      int lastr=-1, lastg=-1, lastb=-1, count = 0;
      wclrp cp;
      iy = 0;

      /*
       * test for availability of true color display
       *  otherwise allocate new colors
       */ 
      
	if (ws->vis->class == TrueColor)
	   while (iy < height) {
	      ix = 0;
	      while (ix < width) {
		 int r = *s++ * 257;
		 int g = *s++ * 257;
		 int b = *s++ * 257;
	    	 if (r==lastr && g == lastg && b == lastb){
	            count++;
	         }
	         else{
		    cp = (wclrp) alc_rgbTrueColor(w, r, g, b);
		    lastr = r; lastg = g; lastb = b;
		 }
	         XPutPixel(im, ix++, iy, cp->c);	         
	       }
	     iy++;
	    }
	else
	   while (iy < height) {
	      ix = 0;
	      while (ix < width) {
		 int r = *s++ * 257;
		 int g = *s++ * 257;
		 int b = *s++ * 257;
		 if (r==lastr && g == lastg && b == lastb){
		    count++;
		    }
	         else
		    cp = alc_rgb2(w,"anon", r, g, b);
		 XPutPixel(im, ix++, iy, cp->c);
	         lastr = r; lastg = g; lastb = b;
		 }
	      iy++;
	      }
      }
   /*
    * Put it on the screen.
    */
   if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, GXcopy);
   if (on_icon) {
      if (ws->iconwin == (Window) NULL) makeIcon(w, 0, 0);
      XPutImage(stddpy, ws->iconwin, stdgc, im, 0, 0, x, y, width, height);
      XPutImage(stddpy, ws->iconpix, stdgc, im, 0, 0, x, y, width, height);
      }
   else {
      XPutImage(stddpy, ws->pix, stdgc, im, 0, 0, x, y, width, height);
      if (ws->win)
	 XCopyArea(stddpy, ws->pix, ws->win, stdgc, x, y, width, height, x, y);
      }
   XDestroyImage(im);
   if (wc->drawop != GXcopy) XSetFunction(stddpy, stdgc, wc->drawop);
   return ret;
   }


/*
 * getimstr(w, x, y, width, height, paltbl, data) -- get image as a string.
 *
 * Stores the specified subimage in data, one pixel per byte, and sets
 * entries in paltbl corresponding to the pixel values that were used.
 */

/*
 * The getimstr() code assumes that a maximum of 256 colors can be onscreen
 * at one time.  If DMAXCOLORS maximum is raised, code must be added for the
 * depth>8 case to reduce the local copy of the image to no more than the
 * 256-color maximum allowed in a GIF file.  This reduction operation is
 * nontrivial; look up "color quantization" in computer graphics literature.
 */
#passthru #if (DMAXCOLORS > 256)
#passthru   Deliberate Syntax error
#passthru #endif				/* DMAXCOLORS */

int getimstr(w, x, y, width, height, paltbl, data)
wbp w;
int x, y, width, height;
struct palentry paltbl[DMAXCOLORS];
unsigned char *data;
   {
   XImage *im;
   XColor colorcell;
   wclrp cp;
   unsigned long px, clist[DMAXCOLORS], *lp;
   int i, ncolors;
   wdp wd = w->window->display;
   Display *stddpy = wd->display;


   /*
    * Get an XImage structure containing window pixel values.
    */
   im = getximage(w, x, y, width, height, 1);
   if (!im)
      return 0;
   
   if (im->depth <= 8) {

      /*
       * We can use the pixel values directly as color indices.
       * Put them in the data string, noting which colors are used.
       */
      for (i = 0; i < DMAXCOLORS; i++)
         clist[i] = i;
      for (y = 0; y < height; y++)
         for (x = 0; x < width; x++) {
            *data++ = px = XGetPixel(im, x, y) & 0xFF;
            paltbl[px].used = 1;
            }
      }

   else {

      /*
       * Make a sorted list of the pixel values of the colors that are in
       * use.  Search this list for every pixel and store the resulting
       * list index as the color index.
       */
      lp = clist;
      for (cp = wd->colors; cp < wd->colors + wd->numColors; cp++)
         *lp++ = cp->c;
      ncolors = lp - clist;
      qsort((char *)clist, ncolors, sizeof(*clist), (int (*)())ulcmp);

      for (y = 0; y < height; y++)
         for (x = 0; x < width; x++) {
            px = XGetPixel(im, x, y);
            lp = (unsigned long *)qsearch((char *)&px, (char *)clist,
               ncolors, sizeof(*clist), (int (*)())ulcmp);
            if (lp)
               i = lp - clist;
            else
               i = 0;			/* use black if not found */
            *data++ = i;
            paltbl[i].used = 1;
            }
      }

   /*
    * Query the real color values from X; Icon's data structures
    * may show several entries for any particular pixel value.
    */
   for (i = 0; i < DMAXCOLORS; i++)
      if (paltbl[i].used) {
         colorcell.pixel = clist[i];
         colorcell.flags = DoRed | DoGreen | DoBlue;
         XQueryColor(stddpy, wd->cmap, &colorcell);
         paltbl[i].clr = lcolor(w, colorcell);
         paltbl[i].valid = 1;
         }

   XDestroyImage(im);
   return 1;
   }

/*
 * getimstr24 -- get an image as a string of RGB tuples.
 *
 * Stores the specified subimage in data, three bytes per pixel.
 */
int getimstr24(w, xx, yy, width, height, data)
wbp w;
int xx, yy, width, height;
unsigned char *data;
   {
   XImage *im;
   SysColor px;
   int x, y;
   wsp ws = w->window;
   wdp wd = ws->display;
   Display *stddpy = wd->display;
   
   /*
    * Get an XImage structure containing window pixel values.
    */
   im = getximage(w, xx, yy, width, height, 1);
   if (!im)
      return 0;

   if(ws->vis->class == TrueColor){
      unsigned long c;
      TRUECOLOR_DECLARE_AND_INIT_RGB_VARS(ws->vis->red_mask, 
      		     ws->vis->green_mask, ws->vis->blue_mask);
      for(y=0; y < height; y++){
         for(x=0; x < width; x++) {
            c =  XGetPixel(im, x, y);
            *data++ = TRUECOLOR_GET_RGB_RED(c);
            *data++ = TRUECOLOR_GET_RGB_GREEN(c);
            *data++ = TRUECOLOR_GET_RGB_BLUE(c);
	    }
         }
       }
    else{
      for (y = 0; y < height; y++) {
         for (x = 0; x < width; x++) {
	    px.pixel = XGetPixel(im, x, y);
	    XQueryColor(stddpy, wd->cmap, &px);
	    *data++ = px.red >> 8;
	    *data++ = px.green >> 8;
	    *data++ = px.blue >> 8;
	    }
         }
      }
   XDestroyImage(im);
   return 1;
   }

/*
 * Create an XImage structure corresponding to subimage (x, y, w, h).
 * If init is nonzero, initialize it with current contents.
 * If init is zero and (x,y,w,h) fills the window, free existing color set.
 */
static XImage *getximage(w, x, y, width, height, init)
wbp w;
int x, y, width, height, init;
   {
   int tx, ty;
   XImage *im;
   wcp wc = w->context;
   wsp ws = w->window;
   wdp wd = ws->display;
   Pixmap  stdpix  = ws->pix;
   Display *stddpy = wd->display;

   im = XCreateImage(stddpy, DefaultVisual(stddpy, wd->screen),
      DefaultDepth(stddpy, wd->screen), ZPixmap, 0, NULL, width, height, 32, 0);
   if (im == NULL)
      return NULL;
   im->data = malloc((msize)(im->bytes_per_line * height));
   if (im->data == NULL) {
      XDestroyImage(im);
      return NULL;
      }

   if (!init) {
      if (x <= 0 && y <= 0 && x + width >= ws->pixwidth &&
	 y + height >= ws->pixheight && wc->clipw < 0) {
            free_xcolors(w, 0);
	    }
      return im;
      }

   tx = ty = 0;
   if (x < 0)  { tx -= x; width += x; x = 0; }
   if (y < 0)  { ty -= y; height += y; y = 0; }
   if (x + width > ws->width)  { width = ws->width - x; }
   if (y + height > ws->height) { height = ws->height - y; }
   if (width > 0 && height > 0) {
      XGetSubImage(stddpy, (
#ifdef Graphics3D
         ws->is_3D?ws->win:
#endif
         stdpix), x, y, width, height, AllPlanes, ZPixmap, im, tx, ty);
      }
   return im;
   }

int readimage(w, filename, x, y, status)
wbp w;
char *filename;
int x, y, *status;
   {
   Pixmap p;
   unsigned int width, height;
   STDLOCALS(w);
   if (!x && !y)
      p = loadimage(w, filename, &height, &width, 1, status);
   else
      p = loadimage(w, filename, &height, &width, 0, status);
   if (p == (Pixmap) NULL) return Failed;

   if (wc->drawop != GXcopy)
      XSetFunction(stddpy, stdgc, GXcopy);
   if (stdwin)
      XCopyArea(stddpy, p, stdwin, stdgc, 0, 0, width, height, x, y);
   XCopyArea(stddpy, p, stdpix, stdgc, 0, 0, width, height, x, y);
   if (wc->drawop != GXcopy)
      XSetFunction(stddpy,stdgc,wc->drawop);

   /*
    * Make sure previous ops on p are complete, then free it.
    */
   XSync(stddpy, False);
   XFreePixmap(stddpy, p);
   return Succeeded;
   }


/*
 * Initialize client for producing pixels from a window
 */
int getpixel_init(w, imem)
wbp w;
struct imgmem *imem;
   {
   wdp wd = w->window->display;

   if (imem->width <= 0 || imem->height <= 0) {
      imem->im = NULL;
      return Succeeded;
      }
   imem->im = XGetImage(wd->display, w->window->pix,
			imem->x, imem->y, imem->width, imem->height,
		  (1 << DefaultDepth(wd->display, wd->screen))-1, XYPixmap);
   
   if (imem->im == NULL) return Failed;
   return Succeeded;
   }

static wclrp lastcp;

int getpixel_term(w, imem)
wbp w;
struct imgmem *imem;
   {
   if (imem->im != NULL)
      XDestroyImage(imem->im);
   lastcp = NULL;
   return Succeeded;
   }

/*
 * Return pixel (x,y) from a window in long value (rv)
 */
int getpixel(w, x, y, rv, s, imem)
wbp w;
int x, y;
long *rv;
char *s;
struct imgmem *imem;
   {
   XColor colorcell;
   LinearColor clr;
   wclrp cp;
   unsigned long c;
   wcp wc = w->context;
   wdp wd = w->window->display;
   Display *stddpy = wd->display; 

   if (x < imem->x || x >= imem->x + imem->width ||
       y < imem->y || y >= imem->y + imem->height)
      c = colorcell.pixel = wd->colors[wc->bg].c;
   else
      c = colorcell.pixel = XGetPixel(imem->im, x - imem->x, y - imem->y);
   *rv = 0xff000000;

   if (lastcp && (lastcp->c == c)) { cp = lastcp; goto foundc; }
   else
   for (cp = wd->colors ; cp < wd->colors + wd->numColors; cp++) {
      if (cp->c == c) {
	 lastcp = cp;
      foundc:
	 if (cp->type == CLR_MUTABLE)
	    *rv = -c - 1;
	 else {
            *rv = 1;
            colorcell.red = cp->r;
            colorcell.green = cp->g;
            colorcell.blue = cp->b;
            clr = lcolor(w, colorcell);
            sprintf(s, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
	    }
	 break;
	 }
      }
   if (*rv == 0xff000000) {
      XQueryColor(stddpy, wd->cmap, &colorcell);
      *rv = 1;
      clr = lcolor(w, colorcell);
      sprintf(s, "%ld,%ld,%ld", clr.red, clr.green, clr.blue);
      }
   return Succeeded;
   }


int query_pointer(w, pp)
wbp w;
XPoint *pp;
   {
   Display *theDisplay;
   Window theWindow;
   Window garbage1, garbage2;
   int root_x, root_y, win_x, win_y;
   unsigned int key_buttons;

   theDisplay = w->window->display->display;
   theWindow  = w->window->win;
   if (theWindow == (Window) NULL) return Failed;

   XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
		 &root_x, &root_y, &win_x, &win_y, &key_buttons);
   pp->x = w->window->pointerx = win_x;
   pp->y = w->window->pointery = win_y;
   return Succeeded;
   }

int query_rootpointer(pp)
XPoint *pp;
   {
   Display *theDisplay;
   Window theWindow;
   Window garbage1, garbage2;
   int root_x, root_y, win_x, win_y;
   unsigned int key_buttons;
   wdp wd;
   if (wdsplys == NULL) {
      /*
       * Initialize the window system
       */
      Protect(wd = alc_display(NULL), return Failed);

      theDisplay = wd->display;
      theWindow  = DefaultRootWindow(wd->display);
      }
   else {
      wd = wdsplys;
      theDisplay = wd->display;
      theWindow  = DefaultRootWindow(wd->display);
      }
   XQueryPointer(theDisplay, theWindow, &garbage1, &garbage2,
		 &root_x, &root_y, &win_x, &win_y, &key_buttons);
   pp->x = root_x;
   pp->y = root_y;
   return Succeeded;
   }


int patbits[] = {
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
  0xFE,0xFF,0xEF,0xFF,0xFE,0xFF,0xEF,0xFF,
  0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,
  0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,
  0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
  0x01,0x00,0x10,0x00,0x01,0x00,0x10,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
  0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01,
  0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
  0x10,0x10,0x10,0xFF,0x10,0x10,0x10,0x10,
  0x82,0x44,0x28,0x10,0x28,0x44,0x82,0x01,

  0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,
  0x1B,0x18,0x81,0xB1,0x36,0x06,0x60,0x63,
  0x02,0x02,0x05,0xF8,0x20,0x20,0x50,0x8F,
  0x03,0x84,0x48,0x30,0x03,0x84,0x48,0x30,
};

/*
 * pattern symbols
 */
stringint siPatternSyms[] = {
  {0,		16},
  { "black",	 0},
  { "checkers",	 12},
  { "darkgray",	 2},
  { "diagonal",	 8},
  { "grains",	 13},
  { "gray",	 3},
  { "grid",	 10},
  { "horizontal",9},
  { "lightgray", 4},
  { "scales",	 14},
  { "trellis",	 11},
  { "vertical",	 7},
  { "verydark",	 1},
  { "verylight", 5},
  { "waves",	 15},
  { "white",	 6},
};

/*
 * SetPattern
 */
int SetPattern(w, name, len)
wbp w;
char *name;
int len;
   {
   int width, nbits;
   int i;
   int symbol;
   C_integer v, bits[MAXXOBJS];
   Pixmap p;
   char data[MAXXOBJS];
   char *buf = data;
   wcp wc = w->context;
   Display *stddpy = w->window->display->display;
   CURTSTATE();

   if (wc->patternname != NULL)
      free(wc->patternname);
   wc->patternname = malloc(len+1);
   if (wc->patternname == NULL) ReturnErrNum(305, RunError);
   strncpy(wc->patternname, name, len);
   wc->patternname[len] = '\0';
   
   /*
    * If the pattern starts with a number it is a width , bits encoding
    */
   if ((len > 0) && isdigit(name[0])) {
      nbits = MAXXOBJS;
      switch (parsepattern(name, len, &width, &nbits, bits)) {
      case Failed:
	 return Failed;
      case RunError:
	 ReturnErrNum(145, RunError);
	 }
      if (!wc->gc) return Succeeded;
      return SetPatternBits(w, width, bits, nbits);
      }

   /*
    * Otherwise, it is a named pattern.  Find the symbol id.
    */
   if ((symbol = si_s2i(siPatternSyms, wc->patternname)) >= 0) {
      if (!wc->gc) return Succeeded;
      for(i = 0; i < 8; i++) {
	 v = patbits[symbol * 8 + i];
	 *buf++ = v;
	 }
      p = XCreateBitmapFromData(stddpy, w->window->pix, data, 8, 8);
      XSetStipple(stddpy, wc->gc, p);
      XSync(stddpy, False);
      XFreePixmap(stddpy, p);
      return Succeeded;
      }
   return Failed;
   }

int SetPatternBits(w, width, bits, nbits)
wbp w;
int width;
C_integer *bits;
int nbits;
   {
   C_integer v;
   int i, j;
   Pixmap p;
   char data[MAXXOBJS];
   char *buf = data;
   Display *stddpy = w->window->display->display;

   for(i = 0; i < nbits; i++) {
      v = bits[i];
      for(j=0; j<width; j+=8) {
	 *buf++ = v;
	 v >>= 8;
	 }
      }

   p = XCreateBitmapFromData(stddpy, w->window->pix, data, width, nbits);
   XSetStipple(stddpy, w->context->gc, p);
   XSync(stddpy, False);
   XFreePixmap(stddpy, p);
   return Succeeded;
   }



/*
 * remap a window ... this time with an iconwin
 */
int remap(w,x,y)
wbp w;
int x,y;
   {
   XSizeHints size_hints;
   XWMHints   *wmhints;
   wcp wc = w->context;
   wsp ws = w->window;
   wdp wd = ws->display;
   Window  stdwin  = ws->win;
   Display *stddpy = wd->display;



   XGetSizeHints(stddpy, stdwin, &size_hints, XA_WM_NORMAL_HINTS);
   wmhints = XGetWMHints(stddpy, stdwin);
   if (ws->iconwin)
      XDestroyWindow(stddpy, ws->iconwin);
   if (stdwin)
      XDestroyWindow(stddpy, stdwin);

   ws->win = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
				 ws->posx, ws->posy, ws->width,
				 ws->height, 4,
				 wd->colors[wc->fg].c, wd->colors[wc->bg].c);
   XSetStandardProperties(stddpy, ws->win, ws->windowlabel,
			  ws->iconlabel, 0, 0, 0, &size_hints);
   XSelectInput(stddpy, ws->win, XMasks(ws->inputmask));

   ws->iconwin = XCreateSimpleWindow(stddpy, DefaultRootWindow(stddpy),
				     ws->iconx, ws->icony, ws->iconw,
				     ws->iconh, 2,
				     wd->colors[wc->fg].c,
				     wd->colors[wc->bg].c);
   XSelectInput(stddpy, ws->iconwin,
		ExposureMask | KeyPressMask | ButtonPressMask);

   wmhints->flags |= IconPositionHint;
   wmhints->icon_x = x;
   wmhints->icon_y = y;
   wmhints->initial_state = ws->iconic;
   wmhints->icon_window = ws->iconwin;
   wmhints->flags |= IconWindowHint;
   XSetWMHints(stddpy, ws->win, wmhints);
   CLREXPOSED(w);
   XMapWindow(stddpy, ws->win);
   if (ws->iconic == NormalState) {
      while (!ISEXPOSED(w))
         if (pollevent() == -1) return -1;
      }
   ws->iconx = x;
   ws->icony = y;
   XSync(stddpy, False);
   XFree((char *)wmhints);
   return 1;
   }


int seticonimage(w, dp)
wbp w;
dptr dp;
   {
   int status;
   Pixmap pix;
   tended char *tmp;
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   Display *stddpy = wd->display;
   
   /*
    * get the preloaded (in another window value) pixmap image
    */
   if (is:file(*dp) && (BlkD(*dp,File)->status & Fs_Window)) {
      wbp x = BlkLoc(*dp)->File.fd.wb;
      if ((ws->iconimage = salloc(x->window->windowlabel)) == NULL)
	 ReturnErrNum(305, RunError);
      pix = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
			  x->window->width, x->window->height,
			  DefaultDepth(stddpy,wd->screen));

      XCopyArea(stddpy, x->window->pix, pix, wd->icongc, 0, 0,
		x->window->width, x->window->height, 0, 0);
      if (ws->iconpix) {
	 XSync(stddpy, False);
	 XFreePixmap(stddpy, ws->iconpix);
	 }
      ws->iconpix = pix;
      ws->iconw = x->window->width;
      ws->iconh = x->window->height;
      if (!ws->iconx && !ws->icony) {
	 ws->iconx = ws->x;
	 ws->icony = ws->y;
	 }
      if (remap(w,ws->iconx,ws->icony) == -1)
	 ReturnErrNum(144, RunError);

      }
   /* get the pixmap file named by x */
   else if (is:string(*dp)) {
      unsigned int height, width;
      if (!cnv:C_string(*dp,tmp))
	 ReturnErrVal(103, *dp, RunError);

      if ((ws->iconimage != NULL) && strcmp(ws->iconimage, ""))
	free(ws->iconimage);
      if ((ws->iconimage = salloc(tmp)) == NULL)
	 ReturnErrNum(305, RunError);
      if (ws->iconwin == (Window) NULL) makeIcon(w,0,0);
      else {
	 pix = loadimage(w, ws->iconimage, &height, &width, 0, &status);
	 if (pix == (Pixmap) NULL)
	    return Failed;
	 XCopyArea(stddpy, pix, ws->iconwin, wd->icongc,
		   0, 0, width, height, 0, 0);
	 if (ws->iconpix) {
	    XSync(stddpy, False);
	    XFreePixmap(stddpy, ws->iconpix);
	    }
	 ws->iconpix = pix;
	 ws->iconw = width;
	 ws->iconh = height;
	 if (remap(w,ws->iconx,ws->icony) == -1)
	    ReturnErrNum(144, RunError);
	 }
      }
   else
      return Failed;
   return Succeeded;
   }
   }


/*
 * dumpimage -- write an image to a disk file in an X format.
 *
 * Accepts only .xpm and .xbm file names, returning NoCvt for anything else.
 */

int dumpimage(w,filename,x,y,width,height)
wbp w;
char *filename;
unsigned int x, y, height, width;
   {
   int status, slen;
   wcp wc = w->context;
   wsp ws = w->window;
   wdp wd = ws->display;
   GC  stdgc  = wc->gc;
   Pixmap  stdpix  = ws->pix;
   Display *stddpy = wd->display;

   /*
    * Check for bilevel XBM (X BitMap) format.
    */
   slen = strlen(filename);
   if ((slen > 4) &&
      (!strcmp(".xbm", filename + slen - 4) ||
       !strcmp(".XBM", filename + slen - 4))) {
      /*
       * Write a bitmap from a "color" window (presumed to have only BW in it).
       * BlackPixel ^ WhitePixel will have a 1 in the first bit in which
       * they are different, so this bit is the plane we want to copy.
       */

      if (DefaultDepth(stddpy,wd->screen) != 1) {
         unsigned long bw =
            BlackPixel(stddpy,wd->screen) ^ WhitePixel(stddpy,wd->screen);
	 Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy),
				   width, height, 1);
	 XGCValues xgc;
	 GC thinGC;
	 int i;
	 /*
	  * pick out the bitplane on which Black and White differ
	  */
	 for(i=0;!((1<<i) & bw);i++);
	 bw &= (1<<i);
	 /*
	  * Construct a 1-bit-deep GC for use in copying the plane.
	  */
	 xgc.foreground = BlackPixel(stddpy,wd->screen);
	 xgc.background = WhitePixel(stddpy,wd->screen);
	 thinGC = XCreateGC(stddpy,p1,GCForeground|GCBackground,&xgc);

	 if (i>DefaultDepth(stddpy,wd->screen)) return Failed;
	 XCopyPlane(stddpy,stdpix,p1,thinGC,x,y,width,height,0,0,bw);
	 status= XWriteBitmapFile(stddpy, filename, p1, width, height, -1, -1);

	 XSync(stddpy, False);
	 XFreePixmap(stddpy, p1);
	 XFreeGC(stddpy,thinGC);
	 if (status != BitmapSuccess) return Failed;
         }
      else {
	 if(x || y) {
	    Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), width,
				      height, DefaultDepth(stddpy,wd->screen));

	    XCopyArea(stddpy, stdpix, p1, stdgc, x, y, width, height, 0, 0);
	    XSync(stddpy, False);

	    status = XWriteBitmapFile(stddpy, filename, p1, width, height, -1, -1);

	    XSync(stddpy, False);
	    XFreePixmap(stddpy, p1);

	    if (status != BitmapSuccess) return Failed;

	  }
	 else if (XWriteBitmapFile(stddpy, filename, stdpix,
				   width, height, -1, -1) != BitmapSuccess)
	    return Failed;

       }
   return Succeeded;
   }
   /*
    * Check for XPM (color X PixMap) format.
    */
   else if (((slen > 4) &&
	    (!strcmp(".xpm", filename + slen - 4) ||
	     !strcmp(".XPM", filename + slen - 4))) ||
	    ((slen > 6) && !strcmp(".xpm.Z", filename + slen - 6))) {
#ifdef HAVE_LIBXPM
      /*
       * Could optimize by calling XpmWriteFileFromPixmap directly on the
       * stdpix...
       */
      Pixmap p1 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), width,
			       height, DefaultDepth(stddpy,wd->screen));

      XCopyArea(stddpy, stdpix, p1, stdgc, x, y, width, height, 0, 0);
      XSync(stddpy, False);

      status = XpmWriteFileFromPixmap(stddpy, filename, p1,
				      (Pixmap) NULL, NULL);
      XSync(stddpy, False);
      XFreePixmap(stddpy, p1);

      if (status == XpmSuccess)
         return Succeeded;
#endif					/* HAVE_LIBXPM */
      return Failed;
      }
   else
      return NoCvt;		/* not an X format -- write GIF instead */
   }

/*
 * Load an image, in any format we can figure out.
 */
Pixmap loadimage(w, filename, height, width, atorigin, status)
wbp w;
char *filename;
unsigned int *height, *width;
int atorigin;
int *status;
   {
   Pixmap p1, p2 = (Pixmap) NULL;
   int xhot, yhot, i, j;
   XGCValues gcv;
   unsigned long gcmask = GCFont | GCForeground | GCBackground;
   int isxbm;
   wcp wc = w->context;
   wsp ws = w->window;
   wdp wd = ws->display;
   GC  stdgc  = wc->gc;
   Display *stddpy = wd->display;

   if (!strcmp(".xbm", filename + strlen(filename) - 4))
      isxbm = 1;
   else if (!strcmp(".xpm", filename + strlen(filename) - 4) ||
	    !strcmp(".xpm.Z", filename + strlen(filename) - 6))
      isxbm = 0;
   else {
      /*
       * Not sure what kind of file this is, make a guess
       * For example, the format might be on the first line of the file,
       * so open it up and read some.
       */
      FILE *ftemp = fopen(filename,"r");
      char s[6];
      int  i;

      if (!ftemp) {
	 return (Pixmap) NULL;
         }
      if ((long)fread(s,1,6,ftemp) < (long)6) {
	 fclose(ftemp);
	 return (Pixmap) NULL;
         }
      fclose(ftemp);
      /* check s for XPM string */
      isxbm = 1;         /* default to xbm */
      for (i = 0; i <= 3; i++)
	 if (!strncmp(&s[i], "XPM", 3))
	    isxbm = 0;
      }

   if (isxbm) {    /* isxbm = 1 => .xbm file */
      if (XReadBitmapFile(stddpy, DefaultRootWindow(stddpy), filename,
			  width, height, &p1, &xhot, &yhot) != BitmapSuccess)
	 return (Pixmap) NULL;
      else *status = 0;
      p2 = XCreatePixmap(stddpy, DefaultRootWindow(stddpy), *width, *height,
			 DefaultDepth(stddpy,DefaultScreen(stddpy)));
      }
   else {				/* isxbm == 0 => .xpm file */
#ifdef HAVE_LIBXPM
      XpmAttributes a;
      XColor color;
      LinearColor clr;
      Pixmap dummy;
      a.npixels = 0;
      a.colormap = wd->cmap;
      a.valuemask = XpmReturnPixels | XpmColormap;
      
      *status = XpmReadFileToPixmap(stddpy, DefaultRootWindow(stddpy),
			    filename, &p2, &dummy, &a);

      if (*status == XpmColorFailed && go_virtual(w)) {
	 /* try again with a virtual colormap */
	 a.npixels = 0;
	 a.colormap = wd->cmap;
	 a.valuemask = XpmReturnPixels | XpmColormap;
         *status = XpmReadFileToPixmap(stddpy, DefaultRootWindow(stddpy),
			               filename, &p2, &dummy, &a);
	 }

      if (*status != XpmSuccess) {
         if (*status == XpmColorFailed)
	    *status = 1;
	 else
	    return (Pixmap) NULL;
         }
      else *status = 0;
      *height = a.height;
      *width = a.width;

      /*
       * if the loaded image is to cover an entire window, free up colors
       * currently in use by the window
       */
      if (atorigin && *width >= ws->pixwidth && *height >= ws->pixheight
	 && wc->clipw < 0) {
            free_xcolors(w, 0);
	    }

      /*
       * OK, now register all the allocated colors with the display
       * and window in which we are residing.
       */
      for (i = 0; i < a.npixels; i++) {
	 for (j = 2; j < DMAXCOLORS; j++)
	    if (wd->colors[j].refcount == 0) break;
	 if (j == DMAXCOLORS) {
	    return (Pixmap) NULL;
	    }
	 if (j == wd->numColors) wd->numColors++;
         else if (j > wd->numColors) {
	    wd->numColors = j+1;
	    }
	 wd->colors[j].refcount = 1;
	 /*
	  * Store their allocated pixel (r,g,b) values.
	  */
	 color.pixel = wd->colors[j].c = a.pixels[i];
	 XQueryColor(stddpy, wd->cmap, &color);
	 wd->colors[j].r = color.red;
	 wd->colors[j].g = color.green;
	 wd->colors[j].b = color.blue;
         clr = lcolor(w, color);
         sprintf(wd->colors[j].name,"%ld,%ld,%ld",clr.red,clr.green,clr.blue);
	 if (ws->numColors == WMAXCOLORS)
	    ;
	 else {
	    if (ws->theColors == NULL) {
	       ws->theColors = (short *)calloc(WMAXCOLORS, sizeof(short));
	       if (ws->theColors == NULL)
		  return (Pixmap) NULL;
	       }
	    ws->theColors[ws->numColors++] = j;
	    }
         }
#else					/* HAVE_LIBXPM */
      return NULL;
#endif					/* HAVE_LIBXPM */
      }

   if (p2 == (Pixmap) NULL) {
      return (Pixmap) NULL;
      }

   if (stdgc == NULL) {
      gcv.foreground = wd->colors[wc->fg].c;
      gcv.background = wd->colors[wc->bg].c;
      gcv.font       = wc->font->fsp->fid;
      wc->gc = XCreateGC(stddpy, p2, gcmask, &gcv);
      stdgc = wc->gc;
      }

   if (isxbm) {
      XCopyPlane(stddpy, p1, p2, stdgc, 0, 0, *width, *height, 0, 0, 1);
      XSync(stddpy, False);
      XFreePixmap(stddpy, p1);
      }
   return p2;
   }

/*
 * Interpret a platform-specific color name s.
 * Under X, we can do this only if there is a window.
 */
int nativecolor(w, s, r, g, b)
wbp w;
char *s;
long *r, *g, *b;
   {
   XColor colorcell;
   LinearColor clr;
   wsp ws;
   wdp wd;

   if (!w)				/* if no window, give up */
      return 0;
   ws = w->window;
   wd = ws->display;
   if (!XParseColor(wd->display, wd->cmap, s, &colorcell))
      return 0;				/* if unknown to X */
   clr = lcolor(w, colorcell);
   *r = clr.red;
   *g = clr.green;
   *b = clr.blue;
   return 1;
   }

/*
 * Convert an X color into an Icon linear color.
 */
LinearColor lcolor(w, colorcell)
wbp w;
XColor colorcell;
   {
   LinearColor l;
   double gamma = w->context->gamma;

   l.red   = 65535 * pow((int)colorcell.red   / 65535.0, gamma);
   l.green = 65535 * pow((int)colorcell.green / 65535.0, gamma);
   l.blue  = 65535 * pow((int)colorcell.blue  / 65535.0, gamma);
   return l;
   }

/*
 * Convert an Icon linear color into an X colorcell.
 */
XColor xcolor(w, c)
wbp w;
LinearColor c;
   {
   XColor x;
   double invgamma = 1.0 / w->context->gamma;

   x.red   = 65535 * pow(c.red   / 65535.0, invgamma);
   x.green = 65535 * pow(c.green / 65535.0, invgamma);
   x.blue  = 65535 * pow(c.blue  / 65535.0, invgamma);
   x.flags = DoRed | DoGreen | DoBlue;
   return x;
   }


int raiseWindow(w)
wbp w;
   {
   wsp ws = w->window;
   if (ws->win) {
      XRaiseWindow(ws->display->display, ws->win);
      XSetInputFocus(ws->display->display, ws->win, RevertToParent, CurrentTime);
      }
   return Succeeded;
   }

int lowerWindow(w)
wbp w;
   {
   if (w->window->win)
      XLowerWindow(w->window->display->display, w->window->win);
   return Succeeded;
   }

int walert(w, volume) 
wbp w;
int volume;
{
  XBell(w->window->display->display, volume); 
  XFlush(w->window->display->display);
  return Succeeded;
  }

int children_close(w)
wbp w;
   {
   wbp tmp_wb;
   struct wbind_list *wbl;
   wsp ws = w->window;
   Display *stddpy = ws->display->display;

   XSync(stddpy, False);
   if (pollevent() == -1) return -1;

   /*
    * Force window to close (turn into a pixmap)
    */

        while (ws->children) {
                tmp_wb = ws->children->child;
                wbl = ws->children;
                ws->children = ws->children->next;
                children_close(tmp_wb);
                ws->refcount--;
                wbl->next=NULL;
                free(wbl);
        }

   SETCLOSED(w);
   if (ws->win && ws->refcount > 1) {
      SETZOMBIE(w);
#ifdef GraphicsGL
      if (ws->is_gl) {
         ws->busy_flag = 1; /* set so pollevent won't redraw */
         UnbindCurrent(ws->display);

         if (ws->win != (Window) NULL)
            XDestroyWindow(stddpy, ws->win);
         XFlush(stddpy);
         ws->refcount--;
         while (ws->win)
   	    if (pollevent() == -1) return -1;
         ws->win = (Window) NULL; 
         ws->busy_flag = 0;
         }
      else
#endif						/* GraphicsGL */
      {
      XDestroyWindow(stddpy, ws->win);
      XFlush(stddpy);
      ws->refcount--;
      while (ws->win)
	 if (pollevent() == -1) return -1;
      }
      }
   /*
    * Entire canvas terminates
    */
   else {
      free_xcolors(w, 2);
      free_xcolors(w, 1);
/*      free_window(ws);  */
      w->window->display->refcount--;
      w->window->display->refcount--;
      free_binding(w);
      }

   return 0;
   }

int setglXVisual(wdp wd){
#ifdef GraphicsGL
   int query;
   int visualparms[] = {GLX_RGBA, GLX_DOUBLEBUFFER, GLX_DEPTH_SIZE, 16, GLX_STENCIL_SIZE, 2, None}; 
   if (!glXQueryExtension(wd->display, &query, &query)) {
      return 0;
      }
   wd->vis = glXChooseVisual(wd->display, wd->screen, visualparms);
   if (wd->vis == NULL) {
      return 0;
      }
  return 1;
#endif					/* GraphicsGL */
  return 0;      
}

/*
 * initialize child window w from parent window wp
 */
char child_window_stuff(wbp w, wbp wp, int child_window)
{
   if (child_window_generic(w, wp, child_window) == 0)
      return 0;
#ifdef GraphicsGL 
   if (!w->window->is_gl)      
#endif					/* GraphicsGL */
   w->window->vis = DefaultVisual(w->window->display->display, w->window->display->screen);
   return 1;
}

char my_wmap(wbp w)
{
   XWindowAttributes attrs;
   XGCValues gcv;
   unsigned long gcmask =
      GCFont | GCForeground | GCBackground | GCFillStyle | GCCapStyle;
   struct imgdata *imd=NULL;
   int i, r;
   int new_pixmap = 0;
   XWMHints wmhints;
   XSizeHints size_hints;
   wsp ws = w->window;
   wcp wc = w->context;
   wdp wd = w->window->display;
   wbp wp;
   int child_window=CHILD_WIN2D;

#ifdef Graphics3D
   if (ws->is_3D) {
       child_window = CHILD_WIN3D;
       if (setglXVisual(wd) == 0)
         return 0;      
       }
       else
       if (ws->type >= CHILD_WIN3D)
       	  child_window = CHILD_WIN3D;
#endif					/* Graphics3D */
    wp = ws->parent;
   /*
    *  Create a pixmap for this canvas if there isn't one already.
    */
   if (ws->pix == (Pixmap) NULL) {
      if (ws->initialPix) {
	 ws->pix = ws->initialPix;
	 ws->initialPix = (Pixmap) NULL;
	 ws->pixwidth = ws->width;
	 ws->pixheight = ws->height;
	 }
      else {
	 ws->pix = XCreatePixmap(wd->display, /* RootWindow(wd->display, wd->vis->screen) */
                                 wp->window->win ? wp->window->win : wp->window->pix,
				 ws->width, ws->height,
				 DefaultDepth(wd->display, wd->screen));
	 ws->pixwidth = ws->width;
	 ws->pixheight = ws->height;
	 new_pixmap = 1;
	 }
/*      stdpix = ws->pix; */
      }


   /*
    * create the X window (or use the DefaultRootWindow if requested)
    */
   if (ws->iconic != HiddenState && wp->window->iconic != HiddenState) {

      XSetWindowAttributes attr;
      attr.background_pixmap = None;
      attr.background_pixel = wd->colors[wc->bg].c;
      attr.border_pixel = wd->colors[wc->fg].c;
	attr.event_mask = StructureNotifyMask | ExposureMask;
 
#ifdef Graphics3D 
      if (ws->is_3D) {
         attr.colormap = 
	    XCreateColormap(wd->display,
			    wp->window->win?wp->window->win:wp->window->pix,
			    wd->vis->visual, AllocNone);
         ws->win = ((ws->iconic == RootState) ? DefaultRootWindow(wd->display):
		    XCreateWindow (wd->display, (wp->window->win?wp->window->win:wp->window->pix), /*DefaultRootWindow(wd->display), */
                                  ws->posx < 0 ? 0 : ws->posx, 
				            ws->posy < 0 ? 0 : ws->posy, 
                                  ws->width,  ws->height, 0, 
				           wd->vis->depth, InputOutput, wd->vis->visual, 
				           CWBackPixel|CWBorderPixel|CWColormap|CWEventMask, &attr)); 
	}
	else
#endif					/* Graphics3D */     
           ws->win = ((ws->iconic == RootState) ? DefaultRootWindow(wd->display) :

		       XCreateSimpleWindow(wd->display, (wp->window->win?wp->window->win:wp->window->pix), /*DefaultRootWindow(stddpy), */
				     ws->posx < 0 ? 0 : ws->posx,
				     ws->posy < 0 ? 0 : ws->posy, ws->width,
				     ws->height, 1,
					   wd->colors[wc->fg].c,
					   wd->colors[wc->bg].c));

    if (ws->win == (Window) NULL)
	 return 0;
/*      stdwin = ws->win; */
      XClearWindow(wd->display, ws->win);

      }

   /*
    * before creating the graphics context, construct a description
    * of any non-default initial graphics context values.
    */
   gcv.foreground = wd->colors[wc->fg].c ^ (ISXORREVERSE(w) ? wd->colors[wc->bg].c : 0);
   gcv.background = wd->colors[wc->bg].c;
   gcv.font       = wc->font->fsp->fid;
   if (wc->fillstyle)
      gcv.fill_style = wc->fillstyle;
   else
      gcv.fill_style = wc->fillstyle = FillSolid;
   if (wc->linestyle || wc->linewidth) {
      gcmask |= (GCLineWidth | GCLineStyle);
      gcv.line_width = wc->linewidth;
      gcv.line_style = wc->linestyle;
      if (wc->linewidth > 1) {
         gcv.dashes = 3 * wc->linewidth;
         gcmask |= GCDashList;
         }
      }
   else
      wc->linestyle = LineSolid;
   gcv.cap_style = CapProjecting;

   /*
    * Create a graphics context (or change an existing one to conform
    * with initial values).
    */
   if (wc->gc == NULL) {
      wc->gc = XCreateGC(wd->display, ws->pix, gcmask, &gcv);
      if (wc->gc == NULL) return 0;
      }
   else
      XChangeGC(wd->display, wc->gc, gcmask, &gcv);

#ifdef Graphics3D
   if (ws->is_3D) {
#if HAVE_LIBGL
      ws->ctx = glXCreateContext(wd->display, wd->vis, None, GL_TRUE);
      if (ws->ctx == NULL) 
	 return 0;
      if (w->window->win)
	 glXMakeCurrent(wd->display, w->window->win, ws->ctx);
#endif					/* HAVE_LIBGL */
      }
#endif					/* Graphics3D */

   if (wc->clipw >= 0)
      setclip(w);

   if (new_pixmap) {
      XSetForeground(wd->display, wc->gc, wd->colors[wc->bg].c);
      XFillRectangle(wd->display, ws->pix, wc->gc, 0, 0, ws->width, ws->height);
      XSetForeground(wd->display, wc->gc,
		     wd->colors[wc->fg].c ^(ISXORREVERSE(w)?wd->colors[wc->bg].c:0));
      }

   imd = &ws->initimage;
   if (imd->width) {
      r = strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
         imd->data, (word)imd->width * (word)imd->height, 0);
      free((pointer)imd->paltbl);
      free((pointer)imd->data);
      imd->width = 0;
      if (r < 0)
         return 0;
      }

   imd = &ws->initicon;
   if (imd->width) {
      r = strimage(w, 0, 0, imd->width, imd->height, imd->paltbl,
         imd->data, (word)imd->width * (word)imd->height, 1);
      free((pointer)imd->paltbl);
      free((pointer)imd->data);
      imd->width = 0;
      if (r < 0)
         return 0;
      wmhints.icon_window = ws->iconwin;
      ws->wmhintflags |= IconWindowHint;
      }

   if (wc->patternname != NULL) {
      if (SetPattern(w, wc->patternname, strlen(wc->patternname)) != Succeeded)
	 return 0;
      }

   /*
    *  if we are opening a pixmap, we are done at this point.
    */
   if (ws->win == (Window) NULL) return 1;

   if (ws->iconic != RootState) {
      size_hints.flags = PSize | PMinSize | PMaxSize;
      size_hints.width = ws->width;
      size_hints.height= ws->height;
      if (ws->posx == -(MaxInt)) ws->posx = 0;
      else size_hints.flags |= USPosition;
      if (ws->posy == -(MaxInt)) ws->posy = 0;
      else size_hints.flags |= USPosition;
      size_hints.x = ws->posx;
      size_hints.y = ws->posy;
      if (ISRESIZABLE(w)) {
	 size_hints.min_width = 0;
	 size_hints.min_height = 0;
	 size_hints.max_width = DisplayWidth(wd->display, wd->screen);
	 size_hints.max_height = DisplayHeight(wd->display, wd->screen);
	 }
      else {
	 size_hints.min_width = size_hints.max_width = ws->width;
	 size_hints.min_height = size_hints.max_height = ws->height;
	 }
/*
      if (ws->iconlabel == NULL) {
	 if ((ws->iconlabel = salloc(ws->windowlabel)) == NULL)
	    ReturnErrNum(305, RunError);
	 }
*/
      XSetStandardProperties(wd->display, ws->win, ws->windowlabel, ws->iconlabel,
			     0,0,0, &size_hints);
      XSelectInput(wd->display, ws->win, XMasks(ws->inputmask));
      }

   wmhints.input = True;
   wmhints.flags = InputHint;
/*
   if (ws->iconic != RootState) {
      if (ws->iconimage != NULL) {
	 makeIcon(w, ws->posx < 0 ? 0 : ws->posx, ws->posy < 0 ? 0 : ws->posy);
	 wmhints.icon_window = ws->iconwin;
	 ws->wmhintflags |= IconWindowHint;
         }
      wmhints.flags |= (ws->wmhintflags | StateHint);
      wmhints.initial_state = ws->iconic;
      wmhints.icon_x = ws->iconx;
      wmhints.icon_y = ws->icony;
      }
*/
   XSetWMHints(wd->display, ws->win, &wmhints);

   setclasshints(w);

/*
   if (wd->cmap != DefaultColormap(wd->display,wd->screen)) {
      XSetWindowColormap(wd->display, ws->win, wd->cmap);
   }
*/

   XSync(wd->display, False);
 
   if (ws->iconic != RootState) {
      CLREXPOSED(w);
      XMapWindow(wd->display, ws->win);
      }

   XGetWindowAttributes(wd->display, ws->win, &attrs);
   ws->width = attrs.width;
   ws->height = attrs.height;
   if (!resizePixmap(w, ws->width, ws->height)) return 0;

   if (ws->win) {
      i = ws->theCursor;
      if (!(wd->cursors[i]))
         wd->cursors[i] = XCreateFontCursor(wd->display, 2 * i);
      XDefineCursor(wd->display, ws->win, wd->cursors[i]);
      }

   /*
    * busy loop for an expose event, unless of course we are starting out
    *  in an iconic state
    */
   CLRZOMBIE(w);

   if (ws->win != (Window) NULL) {
      int hm;
      while (!ISEXPOSED(w) && (ws->iconic != IconicState || ws->iconwin)) {
	 if ((hm = handle_misc(wd, w)) < 1) {
	    if (hm == -1) return 0;
	    else if (hm == 0) {
	       /* how to handle failure? */
	       }
	    }
         }
      }

   XSetFunction(wd->display, wc->gc, wc->drawop);
   XSync(wd->display, False);

   if (ws->win) {
     Atom WMDeleteWindow = XInternAtom(ws->display->display, "WM_DELETE_WINDOW", True);
     XSetWMProtocols(ws->display->display, ws->win, &WMDeleteWindow, 1);
   }

#ifdef Graphics3D
   /* set up the appropriate opengl states */
   if (child_window == CHILD_WIN3D){
      if (init_3dcanvas(w) == Failed)
      	 return 0;
      }
#endif					/* Graphics3D */
   return 1;
}

#ifdef Graphics3D

/* could be macro? */
void makecurrent(wbp w)
{
   wsp ws = w->window;
#ifdef GraphicsGL
   /* Avoid redundant state changes for efficiency */
   if (glXGetCurrentContext() != ws->ctx) {
      glXMakeCurrent(ws->display->display, ws->win, ws->ctx);
      }
#endif					/* GraphicsGL */
}

void mkfont(char *s, char is_3D)
{
   int flags, size, tp;
   char family[MAXFONTWORD+1], fn[80];
   char *stdfam = NULL;

   if (parsefont(s, family, &flags, &size, &tp)) {
      /*
       * This is a legal Icon font spec.
       * Check first for special "standard" family names.
       */
      if (!strcmp(family, "mono")) {
	 stdfam = "Lucida Console";
	 flags |= FONTFLAG_MONO + FONTFLAG_SANS;
	 }
      else if ( !strcmp(family, "fixed")) {
	 stdfam = "Lucida Sans";
	 flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SANS;
	 }
      else if (!strcmp(family, "typewriter")) {
	 stdfam = "Courier New"; /* was "courier" */
	 flags |= FONTFLAG_MONO + FONTFLAG_SERIF;
	 }
      else if (!strcmp(family, "sans")) {
	 stdfam = "Arial"; /* was "swiss" */
	 flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SANS;
	 }
      else if (!strcmp(family, "serif")) {
	 stdfam = "Times New Roman";
	 flags |= FONTFLAG_PROPORTIONAL + FONTFLAG_SERIF;
	 }
      else stdfam = NULL;
      if (is_3D) {
	if (stdfam) {
	      if (strcmp(stdfam, "Arial")==0) { 
	      strcpy(fn,"nimbu" /* "arial" */);
	      if ((flags & FONTFLAG_BOLD) && (flags & (FONTFLAG_ITALIC)))
		strcat(fn, "17" /* "b"*/);
	      else if ((flags & FONTFLAG_BOLD) && (flags & (FONTFLAG_NORMAL)))
		strcat(fn,"15" /* "b" */);
	      else if (flags & FONTFLAG_BOLD) strcat(fn, "15" /* "bd" */);
	      else if (flags & FONTFLAG_ITALIC) strcat(fn, "16" /* "i" */);
	      else strcat(fn, "14");
	      }
	   else if (strcmp(stdfam, "Times New Roman")==0) { 
	      strcpy(fn,"nimbu" /* "times" */);
 	      if ((flags & FONTFLAG_BOLD) && (flags & (FONTFLAG_ITALIC)))
		strcat(fn, "25" /* "b" */);
	      else if (flags & FONTFLAG_BOLD) strcat(fn, "23" /*"bd"*/);
	      else if (flags & FONTFLAG_ITALIC) strcat(fn, "24"/*"i"*/);
	      else strcat(fn, "22");
              }
	   else if ((strcmp(stdfam, "Courier New")==0) ||
		    (strcmp(stdfam, "Lucida Sans")==0)
		    ) {
	      strcpy(fn,"nimbu" /* "cour" */);
 	      if ((flags & FONTFLAG_BOLD) && (flags & (FONTFLAG_ITALIC)))
		strcat(fn, "29" /* "b" */);
	      else if (flags & FONTFLAG_BOLD) strcat(fn, "27" /* "bd" */);
	      else if (flags & FONTFLAG_ITALIC) strcat(fn, "28" /* "i" */);
	      else strcat(fn, "26");
              }
	   strcat(fn, ".ttf");
	   }
	else {
	   strcpy(fn,family);
	   if (flags & (FONTFLAG_BOLD+FONTFLAG_ITALIC)) strcat(fn, "BI");
	   else if (flags & FONTFLAG_BOLD) strcat(fn, "BD");
	   else if (flags & FONTFLAG_ITALIC) strcat(fn, "I");
	   strcat(fn, ".TTF");
           }
        curr_font = srch_3dfont(fn, size, tp);
	if (!curr_font) {
	  add_3dfont(fn, size, tp);
	  curr_font = end_font;
          }
      }
    }
}
#endif					/* Graphics3D */

#passthru #undef drawlines
void drawlines(wbp w, XPoint *points, int npoints)
{
   STDLOCALS_RENDER(w);
   {
   RENDER3(XDrawLines,points,npoints,CoordModeOrigin);
   }
}

#passthru #undef fillpolygon
void fillpolygon(wbp w, XPoint *points, int npoints)
{
   STDLOCALS_RENDER(w);
   {
   RENDER4(XFillPolygon,points,npoints,Complex,CoordModeOrigin);
   }
}

#else					/* Graphics */
/* static char junk;		/* avoid empty module */
#endif					/* Graphics */

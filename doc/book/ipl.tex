\chapter{The Icon Program Library}

The \index{Icon Program Library}Icon Program Library (IPL) contains
hundreds of complete programs ranging from simple demonstrations to
complex applications. More importantly, it provides hundreds of
library modules with thousands of procedures that can save you a lot
of effort. To use these procedures, add \index{link}\texttt{link}
declarations to the modules in which they are declared. On standard
installations, Unicon knows the location of the directory IPL
hierarchy relative to the Unicon binaries. To move these binaries or
add your own directories of reusable code modules, you must set the
\index{environment variable!IPATH}IPATH (and often LPATH)
\index{environment variable!LPATH}environment variables so they know
where to find the IPL directories, in addition to any of your own you
wish to add. Both IPATH and LPATH are semicolon-separated lists of
directories. The names IPATH and LPATH can be confusing; IPATH
directories are searched for .u code modules to be linked,
while LPATH directories are searched for .icn
\index{source code}source code files that you wish to \$include.

The Icon Program Library's 20 directories of code, data, and
supporting documentation is included in Unicon
distributions. This reference appendix presents
only the most useful components of the IPL, emphasizing those of
potential value to other programmers.  Many modules were written by
Ralph Griswold; if he was not the author of a given
module, the initials of authors are included in the module
description. A list of authors' names appears at the end of the
appendix. This appendix no doubt overlooks some excellent library
modules and programs.  The entries in this appendix loosely follow
this template:

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filename}}

Each module has a general description, ending
with the authors' initials in parentheses. For some modules,
the external interface of the module is then summarized.
The number and type of procedures' parameters and
return values are given. Library procedures return a
null value unless otherwise noted. The filename at the beginning is
\index{link}linked in in order to use these procedures in a
program. After the external interface, related modules
are listed.

record types(fields) with summary descriptions\\
functions(parameters) : return types with summary descriptions

Links: other library modules (author's initials)

\section{Procedure Library Modules}

These files appear in the \texttt{ipl/procs/} directory. Each library
module in this directory is a collection of one or more procedures.
Some modules also introduce record types or use global variables that
are of interest to programmers that use the module.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{adlutils}}

This module processes address lists; addresses are
represented using a record type \texttt{label}. Procedures for
extracting the city, state, and ZIP code work for U.S. addresses only.

%\texttt{record label(header, text, comments)} holds one address\\
%\texttt{nextadd() : label} produces the next address from standard
%input\\
%\texttt{writeadd(label)} writes an address to standard output\\
%\texttt{get\_country(label) : string} produces the country from an
%address\\
%\texttt{get\_state(label) : string} produces the state,
%or \texttt{"XX"} if no state is found\\
%\texttt{get\_city(label) : string} produces the city from an address\\
%\texttt{get\_zipcode(label) : string} produces the city from an address\\
%\texttt{get\_lastname(label) : string} get last name\\
%\texttt{get\_namepfx(label) : string} get name prefix\\
%\texttt{get\_title(label) : string} get name title\\
%\texttt{format\_country(string) : string} format country name using
%initial capital letters.

Links: \texttt{lastname}, \texttt{io}, \texttt{namepfx}, \texttt{title}

% {\sffamily\bfseries ansi }
% 
% This module implements a subset of the \index{ANSI terminal}ANSI
% terminal control sequences. The procedures' names are
% taken directly from the ANSI names. To use these routines with non-ANSI
% devices, link in \texttt{iolib} and (optionally) \texttt{iscreen}. Not
% all ANSI terminals support even the limited subset of control sequences
% included in this file. (REG, RLG)
% 
% \texttt{CUB(i:integer)} moves the cursor left i columns\\
% \texttt{CUD(i:integer)} moves the cursor down i rows\\
% \texttt{CUF(i:integer)}\ \ moves the cursor right i columns\\
% \texttt{CUP(i:integer,j:integer)} moves the cursor to row i, column
% j\\
% \texttt{CUU(i:integer)} moves the cursor up i rows\\
% \texttt{ED(i:integer:2)} erases \index{screen}screen: i = 0: \ to end; i
% = 1: from beginning; i = 2, all\\
% \texttt{EL(i:integer:0)} erases current row: i = 0: to end; i = 1: from
% beginning; i = 2, all\\
% \texttt{SGR(i:integer:0)} sets \index{attribute!video}video attributes:
% 0:off; 1:bold; 4:underline; 5:blink; 7:reverse 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{apply}}

\index{apply()}\texttt{apply(L:list, argument):any} applies a list of
functions to an argument. An example is
\texttt{apply([integer,log],10)} which is equivalent to
\texttt{integer(log(10))}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{argparse}}

\texttt{argparse(s:string):list} parses \texttt{s} as a
command line and returns a list of arguments. At
present, it does not accept any escape conventions. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{array}}

This module provides a \index{multidimensional array}multidimensional
array abstraction with programmer-supplied base indices.
\texttt{create\_array(lbs:list, ubs:list, value):array} creates an
n-dimensional array with specified lower bounds, upper bounds, and with
each array element having the given initial value.
\texttt{ref\_array(A, i1, i2, ...)} references the i1-th i2-th ...
element of A. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{asciinam} \hfill (RJA)}

\texttt{asciiname(s:string):string} returns the name of
unprintable ASCII character \texttt{s}.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{base64} \hfill (DAG)}

This module provides base64 encodings for \index{MIME}MIME (RFC 2045).
Among other things, this facilitates the writing of programs that read
e-mail messages.

\texttt{base64encode(string) : string} returns the base64 encoding of
its argument.\\
\texttt{base64decode(string) : string?} returns a base64 decoding of its
argument. It fails if the string is not base64 encoded.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{basename} \hfill (REG, CAS)}

\index{basename}\texttt{basename}\texttt{(name, suffix) : string} removes
any path information as well as the specified suffix, if present.
If no suffix is given, the whole filename (sans path) is returned.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{binary} \hfill (RJA)}

These procedures support conversion of Icon data elements
to and from binary data formats. The control procedures \texttt{pack()}
and \texttt{unpack()} take a format string that controls conversions of
several values, similar to the \texttt{printf()} C library function.

\texttt{pack(template,
}\texttt{\textit{value}}\texttt{\textit{\textsubscript{1}}}\texttt{,
...) : packed\_binary\_string}\texttt{ }packs the \textit{value}
arguments into a binary structure, returning a string containing the
structure. The elements of any lists in the \textit{value} parameters
are processed individually as if they were spliced into the
\textit{value} parameter list. The \texttt{template} characters give
the order and type of values, as follows:

\begin{flushleft}
\begin{xtabular}{|m{0.12in}|m{2.69in}|m{0.12in}|m{2.69in}|}
\hline
a & ASCII, null padded & A & ASCII, space padded\\
b & bitstring, low-to-high order & B & bitstring, high-to-low order\\
h & hexadecimal string, low-nibble-first &
H & hexadecimal string, high-nibble-first\\
c & signed char & C & unsigned char\\
s & signed short & S & unsigned short\\
i & signed integer & I & unsigned integer\\
l & signed long & L & unsigned long\\
n & short in "network" order
(big-endian) &
N & long in "network" order
(big-endian)\\
v & short in VAX order (little endian) &
V & long in VAX order (little endian)\\
f & single-precision float in IEEE Motorola format &
d & double precision floats in IEEE Motorola format\\
e & extended-precision float in IEEE Motorola format 80-bit &
E & extended-precision float in IEEE Motorola format 96-bit\\
x & skip forward a byte (null-fill for pack()) &
X & back up a byte\\
@ & go to absolute position (null-fill if necessary for
pack()) &
u & uuencoded/uudecoded string \\
\hline
\end{xtabular}
\end{flushleft}

\noindent
Each letter may be followed by a numeric count.
Together the letter and the count make a field specifier. Letters and
numbers can be separated by white space that is ignored. Types in 
[AaBbHh] consume one value from the
``value'' list and produce a string of the
length given as the field-specifier-count. The other types consume
``field-specifier-count'' values from the
``value'' list and append the appropriate
data to the packed string.

\texttt{unpack(template, string) : value\_list} does the reverse of
\texttt{pack()}: it takes a string representing a structure and expands
it out into a list of values. The template has mostly the same format
as for \texttt{pack()}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bincvt} \hfill (RJA)}

These procedures are for processing of \index{binary data}binary data
read from a file.

\texttt{unsigned(s:string) : integer} converts a binary byte string into
an unsigned integer.

\texttt{raw(s:string) : integer} puts raw bits of characters of string
\texttt{s} into an integer. If the size of \texttt{s} is less than the
size of an integer, the bytes are put into the low order part of the
integer, with the remaining high order bytes filled with zero. If the
string is too large, the most significant bytes will be lost -{}- no
overflow detection.

\texttt{rawstring(i:integer, size) : string} creates a string consisting
of the raw bits in the low order \texttt{size} bytes of integer
\texttt{i}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bitint}}

\texttt{int2bit(i) : string} produces a string with the bit
representation of \texttt{i}.

\texttt{bit2int(s) : integer} produces an integer corresponding to the
bit representation \texttt{i}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bitstr,bitstrm}}

These two modules operate on numeric values represented by
arbitrarily long strings of bits, stored without regard to character
boundaries. In conjunction with arbitrary precision integers, this
facility can deal with bit strings of arbitrary size.
\texttt{record \index{BitString}BitString(s, buffer, bufferBits)} represents bit
strings internally.
See the header comments atop the source code for the public API and examples
for these modules.

% \texttt{BitStringPut(bitString, nbits, value:0)} is called with three
% arguments to put bits into a \texttt{BitString}, and called with a
% single argument to obtain the resulting string value. An example
% illustrates how \texttt{BitStringPut()} is used:

% \iconcode{
% record bit\_value(value, nbits) \\
% ... \\
% bitString := BitString("") \\
% while value := get\_new\_value() do \# loop to append to string \\
% \>   BitStringPut(bitString, value.nbits, value.value) \\
% resultString := BitStringPut(bitString) \# output any buffered bits
% }

% \texttt{BitStringPut(bitString)}, as well as producing the complete
% string, pads the buffered string to an even character boundary. This
% can be done during construction of a bit string if the effect is
% desired. The "value" argument defaults to
% zero.

% \texttt{BitStringGet(bitString, n:integer):integer} extracts n bits from
% a BitString and returns them as an integer. An example is the best way
% to show how \texttt{BitStringGet()} is used:

% \iconcode{
% record bit\_value(value, nbits) \\
% ... \\
% bitString := BitString(string\_of\_bits) \\
% while value := BitStringGet(bitString, nbits) do \\
% \>   \# do something with value
% }

% \texttt{BitStringGet()} fails when too few bits remain to satisfy a
% request. However, if bits remain in the string, subsequent calls with
% fewer bits requested may succeed. A negative \textit{nbits} value gets
% the value of the entire remainder of the string, to the byte boundary
% at its end.

% Module \texttt{bitstrm} provides procedures for reading and writing
% integer values made up of an arbitrary number of bits, stored without
% regard to character boundaries. An example is the best way to show how
% \texttt{BitStreamWrite()} is used:

% \iconcode{
% record bit\_value(value, nbits) \\
% ... \\
% BitStreamWrite() \#initialize \\
% while value := get\_new\_value() do \# loop to output values \\
% BitStreamWrite(outfile, value.nbits, value.value) \\
% BitStreamWrite(outfile) \# output any buffered bits
% }

% \texttt{BitStreamWrite(outproc)} outputs the complete string and pads
% the output to an even character boundary. This can be done during
% construction of a bit string if the effect is desired. The
% \textit{value} argument defaults to zero. \texttt{BitStreamRead()} is
% illustrated by the following example:

% \iconcode{
% BitStreamRead() \\
% while value := BitStreamRead(infile, nbits) do \\
% \>   \# do something with value
% }

% \texttt{BitStringRead()} fails when too few bits remain to satisfy a
% request. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bufread} \hfill (CAS)}

These procedures provide lookahead within an open file. The procedures
\texttt{bufopen()}, \texttt{bufread()}, and \texttt{bufclose()} mirror
the built-in \texttt{open()}, \texttt{read()}, and \texttt{close()}.

\texttt{bufopen(s:\&input): file?} opens a file name \texttt{s} for
buffered read and lookahead.

\texttt{bufread(f:\&input): string} reads the next line from file
\texttt{f}. You cannot \texttt{bufread()} \texttt{\&input} unless you
have previously called \texttt{bufopen()} on it.

\texttt{bufnext(f:\&input, n:1): string} returns the next \texttt{n}th
line from file \texttt{f} without changing the next record to be read
by \texttt{bufread()}.

\texttt{bufclose(f:\&input): file} close file f.

In addition to processing the current line, one may process subsequent
lines \textbf{before} they are logically read. % Example:

%\begin{flushleft}
%\begin{xtabular}{|m{3.4in}|m{2.65in}|}
%\hline
%\texttt{file := bufopen("name","r"){\textbar}stop("open failed")} & \texttt{line := bufnext(file,2) \# 2nd next line} \\
%\texttt{while line := bufread(file) do \{} &   ...process 2nd next line... ...etc... \\
%\ \ \ ...process current line... &  \texttt{\}} \\
%\ \ \ \texttt{line := bufnext(file,1) \# next line} & \texttt{bufclose(file)} \\
%\ \ \  ...process next line... & \texttt{\}} \\
%\hline
%\end{xtabular}
%\end{flushleft}

%In the code above, calls to \texttt{bufnext()} do not affect subsequent
%\texttt{bufread()}'s.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{calls}}

Procedures to deal with \index{procedure invocation}procedure
invocations encapsulated in records.

\texttt{record call(proc, args)} encapsulates a procedure
and its argument list.\\
\texttt{invoke(call) : any*} invokes a procedure with an argument from a
call record.\\
\texttt{call\_image(call) : string} produces a string image of a
call.\\
\texttt{make\_call(string) : call} makes a call record from a string
image of an invocation.\\
\texttt{make\_args(string) : list} makes an argument list from a
comma-separated string.\\
\texttt{call\_code(string) : string} produces a string of Icon code to
construct a call record.\\
\texttt{write\_calltable(T:table, p:procedure, f:file):null} writes a
table of calls (all to procedure p) out to a file. The format is
\texttt{name=proc:arg1,arg2,?,argn,}\\
\texttt{read\_calltable(f:file) : table} reads a call table file into a
table.

Links: \texttt{ivalue}, \texttt{procname}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{capture} \hfill (DAG)}

\texttt{capture(f:file)} replaces \texttt{write()}, \texttt{writes()},
and \texttt{stop()} with procedures that echo those elements that are
sent to \texttt{\&output} to the file \texttt{f}.

\texttt{uncaptured\_write(s:string...)},
\texttt{uncaptured\_writes(s:string...)} and \linebreak
\texttt{uncaptured\_stop(s:string...)} allow output to be directed to
\texttt{\&output} without echoing to the capture file. These are handy
for placing progress messages and other comforting information on the
screen.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{caseless} \hfill (NJL)}

These procedures are analogous to the standard string-analysis functions
except that uppercase letters are considered equivalent to lowercase
letters. They observe the string scanning function conventions for
defaulting of the last three parameters.

\texttt{anycl(c, s, i1, i2)} succeeds and produces \texttt{i1 + 1},
provided \texttt{map(s[i1])} is in \texttt{cset(map(c))} and
\texttt{i2} is greater than \texttt{i1}. It fails otherwise.

\texttt{balcl(c1, c2:'(',
c3:')', s, i1, i2)} generates the
sequence of integer positions in \texttt{s} preceding a character of
\texttt{cset(map(c1))} in \texttt{map(s[i1:i2])} that is balanced with
respect to characters in \texttt{cset(map(c2))} and
\texttt{cset(map(c3))}, but fails if there is no such position.

\texttt{findcl(s1, s2, i1, i2)} generates the sequence of integer
positions in \texttt{s2} at which \texttt{map(s1)} occurs as a
substring in \texttt{map(s2[i1:i2])}, but fails if there is no such
position.

\texttt{manycl(c,s,i1,i2)} produces the position in \texttt{s} after the
longest initial sequence of characters in \texttt{cset(map(c))} within
\texttt{map(s[i1:i2])}. It fails if \texttt{map(s[i1])} is not in
\texttt{cset(map(c))}.

\texttt{matchcl(s1, s2, i1, i2) : integer?} produces i1 + *s1 if map(s1)
== map(s2[i1+:=*s1]).

\texttt{uptocl(c, s, i1, i2)} generates the sequence of integer
positions in \texttt{s} preceding a character of \texttt{cset(map(c))}
in \texttt{map(s[i1:i2])}. It fails if there is no such position.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{cgi} \hfill (JvM, CLJ)}

The cgi library provides support for development of Common Gateway
Interface server side web based applications, commonly called
\index{CGI}CGI scripts.

\texttt{global cgi : table} contains keys that are
the names of input fields in the invoking HTML page's
form, and values are whatever the user typed in those input fields. 

\texttt{cgiInput(type, name, values)} writes \index{HTML}HTML INPUT tags
with the given type and name for each of a list of
values. The first value's input tag is CHECKED. 

\texttt{cgiSelect(name, values)} writes an HTML SELECT with a
given name and OPTION tags for a list of
values. The first value's OPTION tag is SELECTED. 

\texttt{cgiXYCoord(hlst) : string} is used with an ISMAP.
If the x and y coordinates are between certain boundaries, it returns
the value of the list element that was entered. 

\texttt{cgiMyURL() : string} returns the URL for the current script, as
obtained from the SERVER\_NAME and SCRIPT\_NAME environment variables. 

\texttt{cgiPrintVariables(T)} prints a Unicon table
using simple HTML formatting. 

\texttt{cgiError(L)} generates an error message consisting of the
strings in list \texttt{L}, with \texttt{L[1]} as the title and
subsequent list elements as paragraphs.

\texttt{cgiHexVal(c)} produces a value from 0 to 15 corresponding to
hex chars 0 to F. 

\texttt{cgiHexChar(c1,c2)} produces a char corresponding to
two char-encoded hex digits. 

\texttt{cgiColorToHex(s) : string} produces a 24-bit hex color value
corresponding to a string color name. At present, only the colors
black, gray, white, pink, violet, brown, red, orange, yellow, green,
cyan, blue, purple, and magenta are supported. 

\texttt{cgiPrePro(filename, def)} copies out parts of a
named HTML file, writing out anything between pairs of \texttt{$<!--$ ALL}
or \texttt{$<!--$ {\em def\/}} comments.

\texttt{cgiRndImg(L, s)} writes an HTML IMG tag for a random element of
L, which should be a list of image filenames. The tag has ALT text
given in string s. 

\texttt{cgiOptwindow(opts, args...) : window?} attempts to open an Icon
window, either on the X server or else on display :0 of the
client's machine (as defined by the IP address in
REMOTE\_ADDR). The Icon window is typically used to generate a .GIF
image to which a \index{link!HTML}link is embedded in the CGI
program's output. 

\texttt{main(args)} is included in the CGI library; you do not write
your own. The CGI \texttt{main()} procedure generates an HTML header,
parses the CGI input fields into a global table cgi, generates a
background by calling the user's
\texttt{cgiBBuilder()} function, if any, and calls the
user's \texttt{cgimain()} function. 

\texttt{cgiBBuilder(args...) : table} is an optional procedure that a
CGI program can use to define the general appearance of its
generated web page output. If the user application defines this
function, it should return a table which contains keys
"background",
"bgcolor",
"text", "link",
"vlink", and
"bgproperties" with appropriate values to
go into the BODY tag and define background color and texture for the
CGI page. 

\texttt{cgimain(args)} is the entry point for CGI programs. \ When you
use the CGI library, its \texttt{main()} initializes things and then
calls your \texttt{cgimain()} to generate the HTML content body for the
client's web page. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{codeobj}}

This module provides a way of storing Icon values as strings and
retrieving them.

\texttt{encode(x:any) : string} converts x to a string s.\\
\texttt{decode(s:string): any} converts a string in \texttt{encode()}
format back to x.

These procedures handle all Unicon values, including structures of
arbitrary complexity. For scalar types (null,
integer, real, cset, and string), \texttt{decode(encode(x)) === x}.
For structures (list, set, table, and record types)
\texttt{decode(encode(x))} is not identical to \texttt{x}, but it has
the same "shape" and its elements bear the
same relation to the original as if they were encoded and decode
individually. Not much can be done with files, functions and
procedures, and co-expressions except to preserve type and
identification. The encoding of strings and csets handles
characters in a way that is safe to write to a file and read it back.

Links: \texttt{escape}, \texttt{gener}, \texttt{procname},
\texttt{typecode}. See also: \texttt{object.icn}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{colmize}\hfill (RJA)}

\texttt{colmize(L:list,mx:80,sp:2,mi:0,tag,tagsp:2,tagmi:0,roww,dist) :
string*} arranges data items (from list of strings
\texttt{L}) into multiple columns. \texttt{mx} is the maximum width of
output lines. \texttt{sp} is the minimum number of spaces between
columns. \texttt{mi} is the minimum column width. \texttt{tag} is a
label to be placed on the first line of output. Items are arranged
column-wise unless \texttt{roww} is nonnull; by default the sequence runs
down the first column, then down the second, etc. \texttt{colmize()}
prints the items in as few vertical lines as possible.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{complete}\hfill (RLG)}

\index{complete()}\texttt{complete(s:string,st) : string*} takes
a partial string, \texttt{s}, and generates those strings in
\texttt{st} that begin with \texttt{s}. \ \texttt{st} must be a list or
set of strings. % Example:

%\iconcode{
%commands :=
%["run","stop","quit","save","load","continue"] \\
%while line := read(\&input) do \{ \\
%\>   cmds := [: complete(line, commands) :] \\
%\>   case *cmds of \{ \\
%\>   \ \ \ 0 : input\_error(line) \\
%\>   \ \ \ 1 : do\_command(cmds[1]) \\
%\>   \ \ \ default : display\_possible\_completions(cmds) \\
%\>   \ \ \ \} \\
%\>   \}
%}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{complex}}

The following procedures perform operations on \index{complex
numbers}complex numbers. 

\noindent \texttt{record complex(r,i)} creates a complex number with real part r
and imaginary part i\\
\texttt{cpxadd(x1,x2) : complex} add complex numbers \texttt{x1} and
\texttt{x2}\\
\texttt{cpxdiv(x1,x2) : complex} divide complex number \texttt{x1} by
complex number \texttt{x2}\\
\texttt{cpxmul(x1,x2) : complex} multiply complex number \texttt{x1} by
complex number \texttt{x2}\\
\texttt{cpxsub(x1,x2) : complex} subtract complex numbers \texttt{x2}
from \ \texttt{x1}\\
\texttt{cpxstr(x) : complex} convert complex number \texttt{x} to string
representation\\
\texttt{strcpx(s) : complex} convert string to complex number 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{conffile}\hfill (DAG)}

This module parses ``configuration files'' into Icon
structures for easy access. The service is similar to 
command-line option handling, except that configuration files can
contain structured data such as lists or tables. A configuration file
supplies values for a set of named \textit{directives}. The directives
and their values are read in to a table, usually during program
initialization. The types of all allowed directives are specified
% as follows,
before the configuration file is accessed.

%\texttt{Directive(classproc,editproc,minargs,maxargs):DirectivesRec}
%produces records (whose field names match the parameter names) that
%populate a table used to control configuration file processing.
%\texttt{classproc} is a procedure that indicates what kind of value is
%associated with a given directive in the configuration file:.
%\texttt{editproc} is an optional type conversion procedure to apply to
%values. \texttt{minargs} and \texttt{maxargs} are the minimum and
%maximum number of arguments to a directive; their defaults depend on
%the \texttt{classproc}.

%\begin{xtabular}{m{2.0in} m{0.9in} m{2.0in} m{0.9in}}
%classproc & min, max & classproc & min, max \\
%Directive\_value & 1, 1 & Directive\_list & 1, inf \\
%Directive\_table & 2, inf & Directive\_set & 1, inf\\
%Directive\_table\_of\_sets & 2, inf & Directive\_ignore & 0, inf\\
%Directive\_warning\ \ \ \ 0, inf \\
%\end{xtabular}

%The following code creates a table of specifications for a
%case-insensitive label and a list of exactly three color components.
%The default value for tables passed into \texttt{ReadDirectives()}
%should be a \texttt{Directive} for \texttt{Directive\_ignore} or
%\texttt{Directive\_warning}.

%\iconcode{
%tos := table(Directive(Directive\_ignore)) \\
%tos["mylabel"] := Directive(Directive\_value, map) \\
%tos["fgrgb"] := Directive(Directive\_list, 3, 3)
%}

%\texttt{ReadDirectives(L:list,T:table,s1:"\#",s2:'-',c1:'{\textbackslash}{\textbackslash}',
%c2:'
%{\textbackslash}b{\textbackslash}t{\textbackslash}v{\textbackslash}f{\textbackslash}r',p)
%: table} returns a table containing directives parsed and extracted
%from a file. \texttt{L} is a list of string filenames or open files;
%the procedure uses the first one that it is able to read. \texttt{T} is
%a table of specifications for parsing and handling directives.
%\texttt{s1} is the comment character. \texttt{s2} is the continuation
%character. \texttt{c1} are escape characters. \texttt{c2} are white
%space. The following code reads directives using the previously-defined
%specification table, and creates a window whose title is taken from the
%specified \texttt{mylabel} directive if it is present. Links: lastc.

%\iconcode{
%cfg := ReadDirectives([".mycfg", "my.cfg", \&input], tos) \\
%WOpen("label=" {\textbar}{\textbar} (
%{\textbackslash} (cfg["mylabel"])
%{\textbar} "untitled"))
%}


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{convert}}

This module contains numeric conversions between
\index{convert!base}bases. There are several other procedures related
to conversion that are not yet part of this module. 

\texttt{exbase10(i, j) : string} converts base-10 integer i to base
j.\\
\texttt{inbase10(s, i) : integer} converts base-i integer s to base
10.\\
\texttt{radcon(s, i, j) : integer} converts base-i integer s to base j.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{created}}

\texttt{created(string) : integer} returns (approximately) the number of
structures of a given type that have been created. Links: \texttt{serial}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{currency}\hfill (RJA)}

\texttt{currency(amt, wid:0, neg:"-",
frac:2, whole:1, sign:"\$",
decimal:".",
comma:",") : string} formats \texttt{amt}
in a currency format that defaults to U.S. currency. \texttt{amt} can
be a real, integer, or numeric string. \texttt{wid} is the output field
width; its amount is right-adjusted. The returned string will
be longer than \texttt{width} if necessary to preserve significance.
\texttt{neg} is the character string to be used for negative amounts,
and is placed to the right of the amount. \texttt{frac} and
\texttt{whole} are the exact number of digits to use right of the
decimal, and the minimum number of digits to appear left of the
decimal, respectively. The currency \texttt{sign} prefixes the returned
string. The characters used for decimal point and comma may also be
supplied.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{datecomp}\hfill (CSM)}

These procedures do simple \index{date comparison}date comparisons. The
parameters are strings of the form mm/dd/yyyy or
\texttt{\&date}{}-compatible yyyy/mm/dd.

\texttt{dgt(date1:string, date2:string) : ?}\ \ succeeds if date1 is later than
date2.\\
\texttt{dlt(date1:string, date2:string) : ?}\ \ succeeds if date1 is earlier than
date2.\\
\texttt{deq(date1:string, date2:string) : ?}\ \ succeeds if date1 is equal to
date2.\\
\texttt{futuredate(date:string) : ?}\ \ \ \ succeeds if date is in the
future.\\
\texttt{pastdate(date:string) : ?}\ \ \ \ succeeds if date is in the
past.\\
\texttt{getmonth(date:string) : string}\ \ \ \ returns the month portion of a
date.\\
\texttt{getday(date:string) : string}\ \ \ \ returns the day portion of a
date.\\
\texttt{getyear(date:string) : string}\ \ \ \ returns the year portion of a date.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{datefns}\hfill (CH)}

Date and calendar adaptations of C functions from
"The C Programming Language" (Kernighan and
Ritchie, Prentice-Hall) and "Numerical Recipes in
C" (Press et al, Cambridge). They represent dates using
the record type below.

\texttt{record date\_rec(year, month, day, yearday, monthname,
dayname)}\\
\texttt{initdate()} initializes the global data before using the other
functions.\\
\texttt{today() : date\_rec} produces a computationally useful value for
today's date\\
\index{julian}\texttt{julian}\texttt{(date) : integer} converts a
date\_rec to a Julian day number\\
\texttt{unjulian(julianday) : date\_rec} produces a date from the Julian
day number\\
\texttt{doy(year, month, day) : integer} returns the day-of-year from
(year, month, day)\\
\texttt{wrdate(leadin, date)} writes a
basic date string preceded by a leadin to \texttt{\&output}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{datetime}\hfill (RJA, REG)}

Miscellaneous date and time operations. See also: \texttt{datefns.icn}.

\texttt{global DateBaseYear : 1970} is a time origin for several
functions. An \index{environment variable!DateBaseYear}environment
variable by the same name overrides the default value.

\texttt{ClockToSec(string) : integer} converts
\texttt{\&clock} format to seconds past midnight.

\texttt{DateLineToSec(dateline,hoursFromGmt) : integer} converts
\texttt{\&dateline} format to seconds past \texttt{DateBaseYear}.
\texttt{DateToSec(string) : integer} converts
\texttt{\&date} format (yyyy/mm/dd) to seconds past
\texttt{DateBaseYear}.

\texttt{SecToClock(integer) : string} converts a number of seconds past
midnight to a string in the format of \texttt{\&clock}.
\texttt{SecToDate(integer) : string} converts a number of seconds past
\texttt{DateBaseYear} to a string in Icon \texttt{\&date} format
(yyyy/mm/dd).

\texttt{SecToDateLine(sec,hoursFromGmt) : string} yields a date in
\texttt{\&dateline} format.

\texttt{SecToUnixDate(sec,hoursFromGmt) : string} returns a date and
time in typical UNIX format: Jan 14 10:24 1991.

\texttt{calendat(j) : date1} returns a record with the month, day, and
year corresponding to the Julian Date Number \texttt{j}.

\texttt{date() : string} produces the natural date in English.

\texttt{dayoweek(day, month, year) : string} yields the day of the
week for a given date.

\texttt{full13th(year1, year2)} generates records giving the days on
which a full moon occurs on Friday the 13th in the range from
\texttt{year1} through \texttt{year2}.

\texttt{julian(m,d,y)} yields the Julian Day Number for the given
month, day, and year.

\texttt{pom(n, phase)} returns record with the Julian Day number of
fractional part of the day for which the nth such phase since January,
1900. Phases are encoded as:\\
\ \ 0 = new moon \ \ \ \ 1 = first quarter \ \ \ \ 2 = full moon
\ \ \ \ 3 = last quarter\\
GMT is assumed.

\texttt{saytime()} computes the time in natural English. If an argument
is supplied it is used as a test value to check the operation the
program.

\texttt{walltime() : integer} produces the number of seconds since
midnight. Beware wrap-around when used in programs that span midnight.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{db}}

These procedures provide an interface to the ODBC database facilities
that does not require knowledge of SQL. It also provides compatibility
procedures for an earlier version of the ODBC interface.

\texttt{dbdelete(db, filter...):integer} deletes rows from db that satisfy
filters. Warning: if the filter criteria are omitted, the
\index{database}database will be emptied by this operation!

\texttt{dbinsert(db, row:record)} inserts a record as a tuple (row) into db.

\texttt{dbselect(db,columns,condition,ordering):integer} selects columns from db.
columns defaults to "all", condition
defaults to unconditionally, and ordering defaults to unordered.

\texttt{dbupdate(db:database,row:record)} updates the \texttt{db} tuple
corresponding to \texttt{row}.

\texttt{dbopen(dsn, tabl, user, password):f} is an alias for
\texttt{open(dsn,"o",...)}. \texttt{tabl} is optional.\\
\texttt{dbclose(db)} is an alias for \texttt{close()}\\
\texttt{dbfetch(db)} is an alias for \texttt{fetch()}\\
\texttt{dbsql(db, query)} is an alias for \texttt{sql()}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{dif} \hfill (RJA)}

\texttt{dif(strm:list,compare:"===",eof,group:groupfactor):list*}
generates \index{diff}differences between input streams. 
Returns a list of records, one for each input stream, with each
record containing a list of items that differ and their positions in
the input stream. The record type is as: \texttt{record
diff\_rec(pos,diffs)}. \texttt{dif()} fails if there are no
differences.

\texttt{strm} is a list of input streams from which \texttt{dif()} will
extract its input "records". The elements
can be any of the following types, with corresponding actions:

\begin{xtabular}{m{1.0in} m{4.8in}}
Type & Action \\

file &  file is "read" to get records\\
co-expression & co-expression is activated to get records\\
list & records are "gotten"
(\texttt{get()}) from the list\\
diff\_proc & a record type that has two fields, a procedure
to call and the argument to pass to it. Its definition is:
 \texttt{record diff\_proc(proc,arg)}. It allows
procedures supplied by \texttt{dif}'s
 caller to be called to get records.
\\
\end{xtabular}

\texttt{compare} is a procedure that succeeds if two records are
"equal", and fails otherwise. The
comparison must allow for the fact that the EOF object might be an
argument, and a pair of EOFs must compare equal.

\texttt{eof} is an object that is distinguishable from other objects in
the stream.

\texttt{group} is a procedure that is called with the current number of
unmatched items as its argument. It must return the number of matching
items required for file synchronization to occur. The default
(procedure \texttt{groupfactor()}) is the formula Trunc((2.0 * Log(M))
+ 2.0) where M is the number of unmatched items.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{digitcnt}}

\texttt{digitcnt(file:\&input) : list} counts the number of each digit
in a file and returns a ten-element list with the counts. 

% \vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ebcdic}}

% These procedures assist in use of the \index{ASCII}ASCII and
% \index{EBCDIC}EBCDIC character sets, regardless of the native character
% set of the host. For example, \texttt{Ascii128()} returns a 128-byte
% string of ASCII characters in numerical order, replacing
% \texttt{\&ascii} for applications which might run on an EBCDIC host.
% (AB)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{equiv}}

\texttt{equiv(x,y) : any?} tests the equivalence of two values. For
non-structures, it returns \texttt{x1 === x2}. For structures, the test
is for \index{shape equivalence}\textit{shape}. For example,
\texttt{equiv([],[])} succeeds. It handles loops, but does not
recognize them as such. The concept of equivalence for tables and sets
is weak if their elements are themselves structures. There
is no concept of order for tables and sets, yet it is impractical to
test for equivalence of their elements without imposing an order. Since
structures sort by "age", there may be a
mismatch between equivalent structures in two tables or sets. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{escapesq} \hfill (RJA)}

These procedures manipulate \index{escape sequence}escape sequences in
Icon string format.

\texttt{escapeseq() : string} is a matching procedure for Icon string
escape sequences\\
\texttt{escchar(string) : string} produces the character value of an
Icon escape sequence\\
\texttt{escape()} converts a string with escape sequences to the string it
represents. For example,
\texttt{escape("{\textbackslash}{\textbackslash}143{\textbackslash}{\textbackslash}141{\textbackslash}{\textbackslash}164")}
produces the string \texttt{"cat"}.\\
\texttt{quotedstring()} matches a complete quoted string.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{eval}}

\index{eval()}\texttt{eval(string) : any*} analyzes a string
representing an Icon function or procedure call and evaluates the
result. Operators can be used in functional form, as in
\texttt{"*(2,3)"}. This procedure cannot
handle nested expressions or control structures. It assumes the string
is well formed. The arguments can only be Icon literals. Escapes,
commas, and parentheses in string literals are not handled. In the case
of operators that are both unary and binary, the binary form is used.
Links: \texttt{ivalue}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{evallist}}

\texttt{evallist(expr, n, ucode, ...) : list} 
returns a list of the results written by a program consisting of expression
\texttt{expr} (normally a
generator); \texttt{n} is the maximum size of the list, and the
trailing arguments are ucode files to link with the expression.
Requires: \texttt{system()}, \texttt{/tmp}, pipes. Links:
\texttt{exprfile}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{everycat}}

\texttt{everycat(x1, x2, ...) : string*} generates the concatenation of
every string from !x1, !x2, ... For example, if first :=
["Mary", 'Joe',
"Sandra"] and last :=
["Smith",
"Roberts"] then \texttt{every
write(everycat(first, " ", last))} writes
Mary Smith, Mary Roberts, Joe Smith, Joe Roberts, Sandra Smith, Sandra
Roberts. x1, x2, ... can be any values for which !x1, !x2, ... are
convertible to strings. In the example, the second
argument is a one-character string \texttt{"
"}, so that \texttt{!" '}
generates a single blank. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{exprfile}}

\texttt{exprfile(exp, link, ...) : file} produces a pipe to a program
that writes all the results generated by \texttt{exp}. The trailing
arguments name link files needed for the expression.
\texttt{exprfile()} closes any previous pipe it opened and deletes its
temporary file. Therefore, \texttt{exprfile()} cannot be used for
multiple expression pipes. If the expression fails to compile, the
global \texttt{expr\_error} is set to 1; otherwise 0. 

\texttt{exec\_expr(expr\_list, links[]) : string*} generates the results
of executing the expression contained in the lists \texttt{expr\_list}
with the specified links.

Requires: \texttt{system()}, pipes, \texttt{/tmp}. Links: \texttt{io}.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{factors}\hfill (REG, GMT)}

This file contains procedures related to factorization and prime
numbers.

\index{factorial(n)}\texttt{factorial(n)} returns n!. It fails if n is
less than 0.\\
\texttt{factors(i, j)} returns a list containing the factors of i, up to
maximum j; by default\\
 \ \ \ \ \ there is no limit.\\
\texttt{gfactorial(n, i)} generalized factorial; n x (n - i) x (n - 2i)
x ...\\
\texttt{ispower(i, j)} succeeds and returns root if i is k\^{}j\\
\texttt{is}\index{prime number}\texttt{prime(n)} succeeds if n is a
prime.\\
\texttt{nxtprime(n)} returns the next prime number beyond n.\\
\texttt{pfactors(i)} returns a list containing the primes that divide
i.\\
\texttt{prdecomp(i)} returns a list of exponents for the prime
decomposition of i.\\
\texttt{prime()} generates the primes.\\
\texttt{primel()} generates the primes from a precompiled list.\\
\texttt{primorial(i,j)} product of primes j {\textless}= i; j defaults
to 1.\\
\texttt{sfactors(i, j)} is the same as \texttt{factors(i, j)}, except
output is in string form\\
 \ \ \ \ \ with exponents for repeated factors

Requires: Large-integer arithmetic and prime.lst for
\texttt{primel()}. Links: \texttt{io}, \texttt{numbers}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fastfncs}}

These procedures implement integer-values using a best known method.

\begin{tabular}{m{1in}m{5in}}
\texttt{acker(i, j)} & Ackermann's function\\
\texttt{fib(i)}      & Fibonacci sequence\\
\texttt{g(k, i)}     & Generalized Hofstader nested recurrence\\
\texttt{q(i)}        & "Chaotic" sequence\\
\texttt{robbins(i)}  & Robbins numbers
\end{tabular}
See also: \texttt{iterfncs.icn},
\texttt{recrfncs.icn}. Links: \texttt{factors}, \texttt{memrfncs}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filedim}}

\texttt{filedim(s, p) : textdim} computes the number of rows and maximum
column width of the file named \texttt{s}. The procedure \texttt{p},
which defaults to \texttt{detab}, is applied to each line. For example,
to have lines left as is, use \texttt{filedim(s, 1)}. The return value
is a record that uses the declaration \texttt{record textdim(cols,
rows)}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filenseq}\hfill (DAG)}

\texttt{nextseqfilename(dir, pre, ext) : string?} creates the next
filename in a series of files (such as successive
log files). Usage: \texttt{fn :=
nextseqfilename(".", ".", "log")}
returns the (non-existent) filename next in the sequence
\texttt{.{\textbackslash}.*.log} (\texttt{*} represents 1, 2, 3, ...)
or fails.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{findre}\hfill (RLG)}

\texttt{findre(s1,s2,i,j) : integer*} is like the built-in function
\texttt{find()}, except its first argument is a \index{regular
expression}regular expression similar to the ones the Unix
e\index{grep}grep command uses. A no argument invocation wipes out all
static structures utilized by \index{findre()}\texttt{findre()}, and
then forces a \index{garbage collection}garbage collection.
%\texttt{findre()} offers a simple and compact wildcard-based search
%system. If you do many searches through text files, or write programs
%which do searches based on user input, then \texttt{findre()} is a
%utility you might want to look over. \texttt{findre()} leaves the user
%with no easy way to tab past a matched substring, as with \texttt{s ?
%write(tab(find("hello")+5))}. In order to
%remedy this intrinsic deficiency, \texttt{findre()} sets the global
%variable \texttt{\_\_endpoint} to the first position after any given
%match occurs. \texttt{findre()} utilizes the same basic language as
%egrep, but uses intrinsic Icon data structures and escaping conventions
%rather than those of any particular Unix variant.
\texttt{findre()} takes a shortest-possible-match approach to regular
expressions. If you look for \texttt{"a*"},
\texttt{findre()} will not even bother looking for an
\texttt{"a"}\texttt{.} It will just match
the empty string.

%\texttt{\^{}} - matches if what follows is at the beginning of a line\\
%\texttt{\$} - matches if the preceding pattern is at the end of a line\\
%\texttt{.} - matches any single character\\
%\texttt{+} - matches 1 or more occurrences of the previous expression (i.e. \\
% \ \ \ \ \ a character, or set of parenthesized/bracketed characters)\\
%\texttt{*} - matches from 0 to any number of occurrences of the previous
%expression\\
%{\textbackslash} \ {}- removes the special meaning of any special characters\\
% \ \ \ \ (i.e. if you want to match lines beginning with a
%\texttt{"["}, write
%\texttt{\^{}{\textbackslash}[}, and not \texttt{\^{}[})\\
%\texttt{{\textbar}} - matches either the pattern before it, or the one
%after it\\
%\texttt{[]} - matches any member of the enclosed character set, or, if
%\texttt{\^{}} is the first character,\\
% \ \ \ \ \ \ \ any nonmember of the enclosed character set \\
%\texttt{()} - used for grouping (e.g. \texttt{\^{}(abc{\textbar}cde)\$} matches
%lines consisting of either \texttt{"abc"} or \texttt{"cde",}\\
% \ \ \ \ \ \ while \texttt{\^{}abc{\textbar}cde}\$ matches lines either
%beginning with \texttt{"abc"} or ending in
%\texttt{"cde"})

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gauss} \hfill (SBW)}

\texttt{gauss\_random(x, f)} produces a \index{Gaussian
distribution}Gaussian distribution about the value \texttt{x}.
Parameter \texttt{f} can be used to alter the shape of the Gaussian
distribution (larger values flatten the curve...) Produce a random
value within a Gaussian distribution about 0.0. (Sum 12 random numbers
between 0 and 1, (expected mean is 6.0) and subtract 6 to center on 0.0.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gdl, gdl2} \hfill (RLG)}

\texttt{gdl(dir:string) : list} returns a list containing everything in
a directory. You\\
 \ \ \ \ can use this file as a template, modifying the procedures
according to the needs\\
 \ \ \ \ of the program in which they are used.\\
\texttt{gdlrec(dir, findflag) : list} does same thing as gdl except it
recursively\\
 \ \ \ \ descends through subdirectories. If \texttt{findflag} is
nonnull, the UNIX "find"\\
 \ \ \ \ program is used; otherwise the "ls" program
is used.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gener}}

These procedures generate sequences of results. 

\texttt{days() : string*} produces the \index{days of the week}days of
the week, starting with
\texttt{"Sunday"}.\\
\texttt{hex() : string*} is the sequence of
\index{hexadecimal}hexadecimal codes for numbers from 0 to 255\\
\texttt{label(s,i) : string*} produces labels with prefix \texttt{s}
starting at \texttt{i}\\
\texttt{multii(i, j) : integer*} produces \texttt{i * j}
\texttt{i}'s\\
\texttt{months() : string*} produces the \index{months of the
year}months of the year\\
\texttt{octal() : string*} produces the \index{octal}octal codes for
numbers from 0 to 255\\
\texttt{star(s) : string*} produces the \index{closure,
star(s)}\index{string!closure}closure of \texttt{s} starting with the
empty string and\\
 \ \ \ \ continuing in lexical order as given in \texttt{s} 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{genrfncs}}

These procedures generate various mathematical
\index{sequences}sequences of results. Too many are included to list
them all here; consult the source code for a complete listing.

\texttt{arithseq(i, j) : string*} arithmetic sequence starting at i with
increment j.\\
\texttt{chaosseq()} chaotic sequence\\
\texttt{factseq()} factorial sequence\\
\texttt{fibseq(i, j, k)} generalized Fibonacci (Lucas) sequence with
additive constant k\\
\texttt{figurseq(i)} series of i'th figurate
number\\
\texttt{fileseq(s, i)} generate lines (if i is null) or characters
(except line terminators)\\
 \ \ \ \ from file s.\\
\texttt{geomseq(i, j)} geometric sequence starting at i with multiplier
j\\
\texttt{irepl(i, j)} j instances of i\\
\texttt{multiseq(i, j, k)} sequence of (i * j + k)
i's\\
\texttt{ngonalseq(i)} sequence of the i polygonal number\\
\texttt{primeseq()} the sequence of prime numbers\\
\texttt{powerseq(i, j)} sequence i \^{} j, starting at j = 0\\
\texttt{spectseq(r)} spectral sequence integer(i * r), i - 1, 2, 3,
...\\
\texttt{starseq(s)} sequence consisting of the closure of s starting
with the empty string\\
 \ \ \ \ and continuing in lexical order as given in s

Requires: co-expressions. Links: \texttt{io}, \texttt{fastfncs},
\texttt{partit}, \texttt{numbers}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{getmail}\hfill (CS)}

\texttt{getmail(x):message\_rec*} reads an Internet \index{mail folder,
read}mail folder and generates a sequence of records, one per message,
failing when end-of-file is reached. Each record contains the message
header and message text components parsed into fields. The argument x
is either the name or the file handle. If getmail() is resumed after
the last message is generated, it closes the mail folder and returns
failure. If \texttt{getmail()} generates an incomplete sequence (does
not close the folder and return failure) and is then restarted (not
resumed) on the same or a different mail folder, the previous folder
file handle remains open and inaccessible. If message\_records are
stored in a list, the records may be sorted by individual components
(like sender, \_date, \_subject) using the \texttt{sortf()} function.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{getpaths}\hfill (RLG)}

\texttt{getpaths(args[]) : string*} generates the paths supplied as
arguments followed by those paths in the PATH \index{environment
variable!PATH}environment variable, if one is available. A typical
invocation might look like:

\ \texttt{open(getpaths("/usr/local/lib/icon/procs")
{\textbar}{\textbar} filename)}

\texttt{getpaths()} will be resumed in the above context until open
succeeds in finding an existing, readable file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{graphpak}}

The procedures here use sets to represent directed \index{graph}graphs.
See "The Icon Programming Language", third
edition, pp. 233-236. A graph has two components: a list of nodes and a
two-way lookup table. The nodes in turn are sets of
\index{pointer}pointers to other nodes. The two-way table maps a node
to its name and vice-versa. Graph specifications are given in files in
which the first line is a white-space separated list of node names and
subsequent lines give the arcs, with \texttt{-\textgreater} between
source and destination. %, as in

%Tucson Phoenix Bisbee Douglas Flagstaff\\
%Tucson-{\textgreater}Phoenix\\
%Tucson-{\textgreater}Bisbee\\
%Bisbee-{\textgreater}Bisbee\\
%Bisbee-{\textgreater}Douglas\\
%Douglas-{\textgreater}Phoenix\\
%Douglas-{\textgreater}Tucson

\texttt{record graph(nodes:list, lookup:table)} represents a graph\\
\texttt{read\_graph(f:file) : graph} reads a graph from a file\\
\texttt{write\_graph(g:graph, f:file) : null} writes a graph to a file\\
\texttt{closure(node) : set} computes the transitive closure of a node.
\ \ \ \ \ \ 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{hexcvt}\hfill (RJA)}

\texttt{hex(s) : integer} converts a string of hex digits into an
integer.\\
\texttt{hexstring(i,n,lc) : string} produces the
\index{hexadecimal}hexadecimal representation of the argument. If \texttt{n} is
supplied, a minimum of \texttt{n} digits appears in the result; otherwise there
is no minimum, and negative values are indicated by a minus sign. If \texttt{lc}
is non-null, lowercase characters are used instead of uppercase.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{html}\hfill (GMT)}

These procedures assist in processing HTML files:

\texttt{htchunks(file) : string*} generates \index{HTML}HTML chunks in a
file. Results beginning with\\
 \ \ \ \ {\textless}!-{}- are unclosed comments
(legal comments are deleted); {\textless} begins tags;\\
 \ \ \ \ others are untagged text.\\
\texttt{htrefs(f) : string*} generates the tagname/keyword/value
combinations that\\
 \ \ \ \ \index{reference!HTML}reference other files. Tags and
keywords are returned in upper case.\\
\texttt{httag(string) : string} produces the name of a tag contained
within a tag string.\\
\texttt{htvals(s) : string*} generates the keyword/value pairs from a
tag.\\
\texttt{urlmerge(base,new) : string} interprets a new URL in the context
of a base URL.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ichartp}\hfill (RLG)}

\texttt{ichartp} implements a simple \index{chart parser}chart
\index{parse}parser - a slow but easy-to-implement strategy for parsing
context free grammars (it has a cubic worst-case time factor). Chart
parsers are flexible enough to handle a variety of natural language
constructs, and lack many of the troubles associated with empty and
left-recursive derivations.
% To obtain a parse, create a \index{BNF}BNF
%file, obtain a line of input, and then invoke
%\texttt{parse\_sentence(sentence,
%bnf\_filename, start-symbol)}. \texttt{parse\_sentence()} suspends successive
%edge structures corresponding to possible parses of the input sentence.
%BNF grammars are specified using the same notation used in Griswold \&
%Griswold, and as described in the IPL program
%"pargen.icn" later in this appendix with
%the following difference: All metacharacters (space, tab, vertical
%slash, right/left parentheses, brackets and angle brackets) are
%converted to literals by prepending a backslash. %Comments can be
%included along with BNF rules using the same notation as for Icon code
%(i.e. \#-sign).

Links: \texttt{trees, rewrap, scan, strip, stripcom, strings}. Requires:
co-expressions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iftrace}\hfill (SBW, REG)}

These procedures \index{trace}trace Icon functions by using procedure
wrappers to call the functions. \texttt{iftrace(fncs[])} sets tracing for a list
of function names. Links: \texttt{ifncs}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{image}\hfill (MG, REG, DY)}

\texttt{Image(x, style:1) : string} generalizes
\texttt{image(x)}, providing detailed information about structures. The
\texttt{style} determines the formatting and order of
processing. Style 1 is indented, with ] and ) at end of last item.
Style 2 is also indented, with ] and ) on new line. Style 3 puts the
whole image on one line. Style 4 is like style 3, with structures
expanded breadthfirst instead of depthfirst as for other styles.

Structures are identified by a letter identifying the type followed by
an integer. The tag letters are \texttt{"L"} for lists,
\texttt{"R"} for records, \texttt{"S"} for sets, and
\texttt{"T"} for tables. The first time a structure
is seen, it is imaged as the tag followed by a colon, followed
by a representation of the structure. If the structure is
encountered again, only the tag is given.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{inbits}\hfill (RLG)}

\texttt{inbits(file,len:integer) : integer} re-imports data converted
into writable form by \texttt{outbits()}. See also:
\texttt{outbits.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{indices}}

\texttt{indices(spec:list, last) : list} produces a list of the integers
given by the specification \texttt{spec}, which is a comma separated
list of positive integers or integer spans, as in
\texttt{"1,3-10,..."} If \texttt{last} is
specified, it is used for a span of the form
\texttt{"10-"}. In a span, the low and high
values need not be in order. For example,
\texttt{"1-10"} and
\texttt{"10-1"} are equivalent. Similarly,
indices need not be in order, as in \texttt{"3-10,
1,..."}. Empty values, as in
\texttt{"10,,12"} are ignored.
\texttt{indices()} fails if the specification is syntactically
erroneous or if it contains a value less than 1. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{inserts}}

\texttt{inserts(table,key,value) : table} inserts values into a table in
which the same key can have more than one value (i.e.,
\index{key!duplicate}duplicate keys). The value of each element is a
list of inserted values. The table must be created with default value
\texttt{\&null}. (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{intstr}\hfill (RJA)}

\texttt{intstr(i:integer,size:integer) : string} produces a string
consisting of the raw bits in the low order \texttt{size} bytes of
integer \texttt{i}. This procedure is used for processing of
\index{binary data}binary data to be written to a file. Note that if
large integers are supported, this procedure still will not work for
integers larger than the implementation defined word size due to the
shifting in of zero-bits from the left in the right shift operation.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{io}}

These procedures provide facilities for handling \index{input}input,
\index{output}output, and \index{file}files. Some require
\texttt{loadfunc()}. Links: \texttt{random}, \texttt{strings}.

\texttt{fcopy(fn1:string,fn2:string)} copies a file named \texttt{fn1}
to file named \texttt{fn2}.

\texttt{exists(name:string) : file?} succeeds if \texttt{name} exists as
a file but fails otherwise.

\texttt{filelist(s,x) : list} returns a list of the file names that
match the specification \texttt{s}. If \texttt{x} is nonnull, any
directory is stripped off. At present it only works for UNIX.

\texttt{filetext(f) : list} reads the lines of f into a list and returns
that list

\texttt{readline(file) : string?} assembles backslash-continued lines
from the specified file into a single line. If the last line in a file
ends in a backslash, that character is included in the last line read.

\texttt{splitline(file, line, limit)} splits \texttt{line} into pieces
at first blank after the limit, appending a backslash to identify split
lines (if a line ends in a backslash already, that's
too bad). The pieces are written to the specified file.

\paragraph{Buffered input and output:}
\texttt{ClearOut()} remove contents of output buffer without
writing\\
\texttt{Flush()} flush output buffer\\
\texttt{GetBack()} get back line written\\
\texttt{LookAhead()} look ahead at next line\\
\texttt{PutBack(s)} put back a line\\
\texttt{Read()} read a line\\
\texttt{ReadAhead(n)} read ahead n lines\\
\texttt{Write(s)} write a line

See also module \texttt{bufread} for a multi-file implementation of
buffered input.

\paragraph{Path searching:}
\texttt{dopen(s) : file?} opens and returns the file \texttt{s} on
DPATH.

\texttt{dpath(s) : string?} returns the path to \texttt{s} on DPATH.

\texttt{pathfind(fname,
path:getenv("DPATH")) : string?} returns
the full path of fname if found along the space-separated list of
directories "path". As is customary in Icon
path searching, "." is prepended to the
path.

\texttt{pathload(fname,entry)} calls \texttt{loadfunc()} to load
\texttt{entry} from the file \texttt{fname} found on the function path.
If the file or entry point cannot be found, the program is aborted. The
function path consists of the current directory, then
\texttt{getenv("FPATH")}, and finally any
additional directories configured in the code.

\paragraph[Parsing file names:]{Parsing file names:}
\texttt{suffix() : list} parses a hierarchical file name, returning a
2-element list: [prefix,suffix]. For example,
\texttt{suffix("/a/b/c.d")} produces
\texttt{["/a/b/c","d"]}

\texttt{tail() : list} parses a hierarchical file name, returning a
2-element list: [head,tail]. For example,
\texttt{tail("/a/b/c.d")} produces
\texttt{["/a/b","c.d"]}.

\texttt{components() : list} parses a hierarchical file name, returning
a list of all directory names in the file path, with the file name
(tail) as the last element. For example,
\texttt{components("/a/b/c.d")} produces
\texttt{["/","a","b","c.d"]}.

\paragraph{Temporary files:}
\texttt{tempfile(prefix:"",suffix:"",path:".",len:8)}
produces a temporary file that can be written. The name is chosen so as
not to overwrite an existing file. The \texttt{prefix} and
\texttt{suffix} are prepended and appended, respectively, to a randomly
chosen number. The \texttt{path} is prepended to the file name. The
randomly chosen number is fit into a field of \texttt{len} characters
by truncation or right filling with zeros as necessary. It is the
user's responsibility to remove the file when it is no
longer needed.

\texttt{tempname(prefix:"",
suffix:"",
path:".", len:8)} returns a
temporary file name.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iolib}\hfill
(RLG, NA)}

This library provides control functions for text terminals, based on
legacy ANSI and VT-100 devices. The TERM and TERMCAP \index{environment
variable!TERMCAP}environment variables must be set in order to use
this library. TERM tells iolib what driver you are using,
e.g. TERM=ansi-color. The TERMCAP variable
gives the location of the termcap database file, as provided on your
UNIX system.

%Some useful termcap codes are "cl" (clear screen), "ce" (clear to end of line),
%"ho" (go to the top left square on the screen), "so" (begin standout mode), and
%"se" (end standout mode). The termcap
%database holds both string- and numeric-valued sequences. The value
%of "li" tells how many lines the terminal has; "co" tells how
%many columns. To go to the beginning of the second-to-last line on the
%screen: iputs(igoto(getval("cm"), 1, getval("li")-1)). The
%"cm" capability is a special capability,
%and needs to be output via igoto(cm,x,y), where cm is the sequence
%telling your computer to move the cursor to a specified spot, x is the
%column, and y is the row.

%\texttt{setname(term)} initializes the terminal. Overrides
%TERM environment variable.

%\texttt{getval(id)} returns the terminal code for the capability named
%id. Integer valued capabilities are returned as integers, strings as
%strings, and flags as records (if a flag is set, then
%\texttt{type(flag)} will return \texttt{"true"}). Absence of a capability
%is signaled by failure.

%\texttt{igoto(cm,column,row)} returns a terminal code string that causes
%the cursor to move to the designated column and row. cm is the cursor
%movement command for the current terminal, as obtained via
%getval("cm"). column and row count down and
%to the right starting from the location (1,1).

%\texttt{iputs(s)} sends s out to the console. For example, to clear the
%screen, \texttt{iputs(getval("cl"))}

Requires: UNIX, co-expressions. See also: iscreen.icn.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iscreen}\hfill (RLG)}

This file contains some rudimentary screen functions for use with
\texttt{iolib.icn}.

\texttt{clear()} clears the screen (tries several methods)\\
\texttt{clear\_emphasize()} clears the screen to all-emphasize
mode.\\
\texttt{emphasize()} initiates emphasized (usually reverse video dark on
light) mode\\
\texttt{boldface()} initiates bold mode\\
\texttt{blink()} initiates blinking mode\\
\texttt{normal()} resets to normal mode\\
\texttt{message(s)} displays message \texttt{s} on 2nd-to-last
line\\
\texttt{underline()} initiates underline mode\\
\texttt{status\_line(s,s2,p)} draws status line \texttt{s} on the
3rd-to-last screen line; if \texttt{s} is too short for the terminal,
\texttt{s2} is used; if \texttt{p} is nonnull then it either centers,
left-, or right-justifies, depending on the value,
\texttt{"c"},
\texttt{"l"}, or
\texttt{"r"}.

Requires: UNIX. Links: \texttt{iolib}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{isort}\hfill (RJA)}

\texttt{i}\index{sort}\texttt{sort}\texttt{(x,keyproc,y) : list} is a
customizable sort procedure. \texttt{x} can be any Icon data type that
supports the unary element generation (!) operator. The result is a
sorted list of objects. The sort keys are obtained by calling
keyproc() on each element of strucure \texttt{x} to obtain the sort
key for that element. If
\texttt{keyproc} is a procedure, the first argument to each call to
keyproc() is the element for which the key is to be computed,
and the second argument is isort's argument
\texttt{y}, passed unchanged. The \texttt{keyproc} must produce the
extracted key. Alternatively, \texttt{keyproc} can be an integer, in
which case it is a subscript applied uniformly to each element to select
a sort key. If \texttt{keyproc} is omitted, sorting uses
the standard Icon sort order.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itokens}\hfill (RLG)}

\texttt{itokens(file, nostrip) : TOK*} breaks Icon source files up into
tokens for use in things like pretty printers, preprocessors, code
obfuscators, and so forth. itokens() suspends values of type
\texttt{record TOK(sym:string, str:string). sym} contains the name of
the next token, such as \texttt{"CSET"}, or
\texttt{"STRING". str} gives that
token's literal value. For example, the \texttt{TOK}
for a literal semicolon is
\texttt{TOK("SEMICOL",
";")}. For a mandatory newline,
\texttt{itokens()} would suspend
\texttt{TOK("SEMICOL",
"{\textbackslash}n"). itokens()} fails on
end-of-file. It returns syntactically meaningless newlines if the
second argument is nonnull. These meaningless newlines are returned as
TOK records with a null sym field (i.e. \texttt{TOK(\&null,
"{\textbackslash}n")}). If new reserved
words or operators are added to a given implementation, the tables in
this module have to be altered. Note: keywords are implemented at the
syntactic level; they are not tokens. A keyword like
\texttt{\&features} is suspended as an \texttt{\&} token followed by an
identifier token.
Links: \texttt{scan}. Requires: co-expressions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ivalue}}

\texttt{ivalue(s):any} turns a string from \texttt{image()} into the
corresponding Icon value. It handles integers, real numbers,
strings, csets, keywords, structures, and procedures. For the image of
a structure, it produces a result of the correct type and size, but
values in the structure are not correct, since they are not encoded in
the image. For procedures, the procedure must be present in the
environment in which \texttt{ivalue()} is evaluated. This generally is
true for built-in procedures (functions). All keywords are supported.
The values produced for non-constant keywords are the
values they have in the environment in which \texttt{ivalue()} is
evaluated. \texttt{ivalue()} handles non-local variables
(\texttt{image()} does not produce these), but they must be present in
the environment in which \texttt{ivalue()} is evaluated. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{jumpque}}

\texttt{jumpque(}\index{queue}\texttt{queue}\texttt{:list,y):list} moves
\texttt{y} to the head if it is in the queue; otherwise it adds
\texttt{y} to the head of the queue. A copy of the queue is returned.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{kmap}}

\texttt{kmap(string) : string} maps uppercase and control
characters into the corresponding
lowercase letters. It is for graphic applications in which the modifier
keys for shift and control are encoded in \index{keyboard}keyboard
events. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lastc}}

These string scanning functions follow standard conventions for
defaulting the last three parameters to the current scanning
environment. (DAG)

\texttt{lastc(c:cset, s:string, i1:integer, i2:integer) : integer}
succeeds and produces \texttt{i1}, provided either that \texttt{i1} is
\texttt{1}, or that \texttt{s[i1 - 1]} is in \texttt{c} and \texttt{i2}
is greater than \texttt{i1}.

\texttt{findp(c:cset, s1:string, s2:string, i1:integer, i2:integer) :
integer*} generates the sequence of positions in \texttt{s2} at which
\texttt{s1} occurs provided that \texttt{s2} is preceded by a character
in \texttt{c}, or is found at the beginning of the string.

\texttt{findw(c1:cset, s1:string, c2:cset, s2:string, i1:integer,
i2:integer) : integer*} generates the sequence of positions in
\texttt{s2} at which \texttt{s1} occurs provided that \texttt{s2} is
preceded and followed by the empty string or a member of \texttt{c1}
and \texttt{c2, respectively}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lastname}}

\texttt{lastname(s:string) : string} produces the last name in string
\texttt{s}, which must be a name in conventional form. Obviously, it
doesn't work for every possibility. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{list2tab}}

\texttt{list2tab(list) : null} writes a list as a tab-separated string
to \texttt{\&output}. Carriage returns in files are converted to
vertical tabs.
See also: tab2list, tab2rec, rec2tab. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lists}\hfill (REG, RLG)}

These procedures implement \index{list functions}list functions
similar to string functions, including an implementation of
\index{scanning!list}list scanning, similar to the
string scanning functions.

\texttt{lcomb(L,i):L*} produces all sublist combinations of \texttt{L}
that have \texttt{i} elements.\\
\texttt{ldelete(L,spec:string):L} deletes values of \texttt{L} at
indices given in \texttt{spec}; see \texttt{indices}.\\
\texttt{lequiv(L1,L2):L?} tests if acyclic lists \texttt{L1} and \texttt{L2} are
structurally equivalent.\\
\texttt{lextend(L,i,x):L} extends \texttt{L} to at least size
\texttt{i}, using initial value \texttt{x}.\\
\texttt{limage(L):string} list image function that shows
elements' images, one level deep.\\
\texttt{linterl(L1,L2):L} interleaves elements of \texttt{L1} and
\texttt{L2}. If \texttt{L1} and \texttt{L2} are unequal size,\\
 \ \ \ \ the shorter list is extended with null values to the
size of the larger list.\\
\texttt{llpad(L,i,x):L} produces a new list that extends \texttt{L} on
its front (left) side.\\
\texttt{lltrim(L,S):L} produces a copy of \texttt{L} with elements of
\texttt{S} trimmed on the left.\\
\texttt{lmap(L1,L2,L3):L} maps elements of \texttt{L1} according to
\texttt{L2} and \texttt{L3}, similar to function\\
 \ \ \ \ \texttt{map(s1, s2,s3)}.
%Elements in \texttt{L1} that are the same as
% \ \ \ \  elements in \texttt{L2} are mapped into the corresponding
% elements of \texttt{L3}.  % For example,\\
%The lists can \\
% \ \ \ \ given the lists\\
% \ \ \ \ \ \ \ \texttt{L1 := [1,2,3,4]; L2 := [4,3,2,1]; L3 :=
%["a","b","c","d"]}\\
% \ \ \ \ \texttt{lmap(L1, L2,L3)} produces a new list
%\texttt{["d","c","b","a"]}.
%have any kinds of elements.
The operation \texttt{x === y} is used to determine if elements\\
 \ \ \ \  \texttt{x} and \texttt{y} are equivalent.
No defaults are provided for omitted arguments. \\ % As with\\
% \ \ \ \ \texttt{map(), lmap()}, can be used for transposition as well as substitution.\\
% \ \ \ \ \textbf{Warning: }If \texttt{lmap()} is called with
% the same lists \texttt{L2} and \texttt{L3} as in the
%immedi-\\
% \ \ \ \ ately preceding call, the same mapping is performed, even if
% the values in \texttt{L2} \\
% \ \ \ \ and \texttt{L3} have been changed. This improves performance,
% but it may cause \\
% \ \ \ \ unexpected effects. \\
\texttt{lpalin(L):L} produces a list palindrome of \texttt{L}
concatenated with its reverse.\\
\texttt{lpermute(L):L*} produces all the permutations of list
\texttt{L}.\\
\texttt{lreflect(L,i:0):L} returns \texttt{L} concatenated with its
reversal to produce a palindrome.\\
 \ \ \ \ Parameter \texttt{i} specifies
end conditions: 0 = omit first and last elements,\\
 \ \ \ \ 1 = omit first element, 2 = omit last element,
 3 = don't omit element.\\
\texttt{lremvals(L, x1, x2, ...) : list} produces a copy of L with
x1, x2, ... removed\\
\texttt{lrepl(L,i):L} \index{replicate list}\index{replicate list}replicates L i
times.\\
\texttt{lrotate(L,i):L} produces a list with the elements of L, rotated i
positions.\\
\texttt{lrpad(L,i,x):L} is like lextend(), but produces a new list instead of
changing L.\\
\texttt{lrtrim(L,S:set):L} produces a copy of L with elements of S trimmed on
 the left.\\
\texttt{lswap(L):L} produces a copy of L with odd elements swapped with even
elements.\\
\texttt{lunique(L):L} produces a list containing only unique list elements.

\subsection*{List Scanning}

List scanning depends on the following underlying state mechanisms.

\texttt{global l\_POS, l\_SUBJ} are the current list scanning
environment\\
\texttt{record l\_ScanEnvir(subject,pos)} represents (nested) list
scanning environments\\
\texttt{l\_Bscan(e1) : l\_ScanEnvir} enter (possibly nested) list
scanning environment\\
\texttt{l\_Escan(l\_OuterEnvir, e2) : any} exit list scanning environment \\

\noindent Within a list scanning environment, the following procedures
are equivalent to their string scanning counterparts.

\begin{tabular}{m{3in}m{3in}}
\texttt{l\_any(L1, L2,i,j) : integer?} & \texttt{l\_move(i) : list}\\
\texttt{l\_bal(L1,L2,L3,l,i,j) : integer*} & \texttt{l\_pos(i) : integer}\\
\texttt{l\_find(L1,L2,i,j) : integer*} & \texttt{l\_tab(i) : list}\\
\texttt{l\_many(L1,L2,i,j) : integer?} &  \texttt{l\_upto(L1,L2,i,j) : integer}\\
\texttt{l\_match(L1,L2,i,j) : integer?} & \ \\
\end{tabular}

\noindent \texttt{l\_any()}, \texttt{l\_many()}, and \texttt{l\_upto()} take
either sets of lists or lists of lists. \texttt{l\_bal()} has no
defaults for the first four arguments, since there is no list
analogue to \texttt{\&cset}, etc. List scanning environments are not
maintained implicitly as for string scanning. You must use a set of
nested procedure calls \texttt{l\_Bscan()} and \texttt{l\_Escan()}, as
explained in the \textit{Icon Analyst} 1:6 (June, 1991), p. 1-2.
You cannot suspend, return, or otherwise break out of the
nested procedure calls; they can only be exited via failure. Here is an
example of how list scanning might be invoked:

\iconcode{
suspend l\_Escan(l\_Bscan(some\_list\_or\_other), \{ \\
\>   l\_tab(10 to *l\_SUBJ) \& \{ \\
\>   if l\_any(l1) {\textbar} l\_match(l2) then old\_l\_POS +
(l\_POS-1) \\
\>   \} \\
\>   \})
}

%List scanning environments may be nested, and may be used to generate a
%series of results as well. Here's an example of nested
%list scanning:

%\iconcode{
%procedure main() \\
%\ \ \ l :=
%["h","e","l","l","o"," ","t","t","t","h","e","r","e"] \\
%\>   l\_Escan(l\_Bscan(l), \{ \\
%\>   \ \ \ hello\_list :=
%l\_tab(l\_match(["h","e","l","l","o"])) \\
%\>   \ \ \ every writes(!hello\_list) \\
%\>   \ \ \ write() \# Note the nested list-scanning expressions. \\
%\>   \ \ \ l\_Escan(l\_Bscan(l\_tab(0)), \{ \\
%\>   \ \ \ \ \ \ l\_tab(l\_many([[" "],["t"]]) - 1) \\
%\>   \ \ \ \ \ \ every writes(!l\_tab(0)) \\
%\>   \ \ \ \ \ \ write() \\
%\>   \ \ \ \ \ \ \}) \\
%\>   \ \ \ \}) \\
%end
%}

%\noindent This program writes "hello" and
%"there" on successive lines to the standard
%output.

The functions compare lists, not strings, so
\texttt{l\_find("h", l)}, for instance,
will yield an error message: use
\texttt{l\_find(["h"], l)} instead. This
becomes confusing when looking for lists within lists. Suppose
\texttt{l1 := ["junk",
[["hello"]," ",["there"]],"!","m","o","r","e","junk"]}
and you wish to find the position in \texttt{l1} at which the list
\texttt{[["hello"],'
",["there']]} occurs. If you
assign \texttt{L2 :=
[["hello"]," ",["there"]]}, then the
\texttt{l\_find()} call needs to look like \texttt{l\_find([l2],l1)}.
Links: \texttt{indices}. See also: \texttt{structs.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{loadfile}}

\texttt{loadfile(exp, link,...)} creates and loads a program that
generates the results of exp. The trailing arguments name link files
needed for the expression. \texttt{loadfile()} returns a procedure that
generates the results.
Requires: \texttt{system()}, pipes, \texttt{/tmp}. Links:
\texttt{io}. 

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{longstr}\hfill
 (JN,SBW,KW,RJA,RLG)}

String scanning function \texttt{longstr(l,s,i,j) : integer?} works like
\texttt{any()}, except that instead of taking a cset as its first
argument, it takes instead a list or set of strings (\texttt{l}).
Returns \texttt{i + *x}, where \texttt{x} is the \index{longest
match}longest string in \texttt{l} for which \texttt{match(x,s,i,j)}
succeeds, if there is such an \texttt{x}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lrgapprx}}

\texttt{lrgapprx(i) : string} produces an approximate of an integer
value in the form \texttt{i.jx10\^{}k}. It is primarily useful for
large integers. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lu}}

\texttt{lu\_decomp(M, I) : real?} performs \index{LU decomposition}LU
decomposition on the square matrix \texttt{M} using the vector
\texttt{I}. Both \texttt{M} and \texttt{I} are modified. The value
returned is +1.0 or -1.0 depending on whether the number of row
interchanges is even or odd. \texttt{lu\_decomp()} is used in
combination with \texttt{lu\_back\_sub()} to solve linear equations or
invert matrices. \texttt{lu\_decomp()} fails if the matrix is singular.

\texttt{lu\_back\_sub(M, I, B)} solves the set of linear equations
\textit{M x X = B}. \texttt{M} is the matrix as modified by
\texttt{lu\_decomp()}. \texttt{I} is the index vector produced by
\texttt{lu\_decomp()}. \texttt{B} is the right-hand side vector and
return with the solution vector. \texttt{M} and \texttt{I} are not
modified and can be used in successive
calls of \texttt{lu\_back\_sub()} with different \texttt{B}s.
These procedures are based on algorithms given in
``Numerical Recipes; The Art of Scientific
Computing'' by Press, Flannery,
Teukolsky, and Vetterling; Cambridge University Press, 1986.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mapbit}}

\texttt{mapbit(s:string) : string} produces a string of zeros and ones
corresponding to the bit patterns for the characters of \texttt{s}.
For example, \texttt{mapbit("Axe")} produces the string \linebreak
\texttt{"010000010111100001100101"}. Links:
\texttt{strings}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mapstr}\hfill (RLG)}

\texttt{mapstrs(string, l1:list, l2:list) : string} works like
\texttt{map()}, except that instead of taking ordered character
sequences (strings) as arguments 2 and 3, it takes ordered string
sequences (lists). Suppose, for example, you wanted to
\index{bowdlerize}bowdlerize a string by replacing the words
"hell" and
"shit" with
"heck" and
"shoot." You would call mapstrs as
follows:\\
\texttt{mapstrs(s, ["hell",
"shit"],
["heck",
"shoot"])}. If you want to replace one
string with another, just use the IPL \texttt{replace()} routine (in
\texttt{strings.icn}). If \texttt{l2} is longer than \texttt{l1}, extra
members in \texttt{l2} are ignored. If \texttt{l1} is longer, however,
strings in \texttt{l1} that have no correspondent in \texttt{l2} are
simply deleted. \texttt{mapstr()} uses a longest-possible-match
approach, so that replacing
\texttt{["hellish",
"hell"]} with
\texttt{["heckish",
"heck"]} will work as one would expect.
Links: \texttt{longstr}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{math}}

\texttt{binocoef(n:integer, k:integer) : integer?} produces the
\index{binomial coefficient}binomial coefficient \texttt{n} over
\texttt{k}. It fails unless 0 {\textless}= \texttt{k} {\textless}=
\texttt{n}.\\
\texttt{cosh(r:real) : real} produces the \index{hyperbolic
functions}hyperbolic cosine of \texttt{r}.\\
\texttt{sinh(r:real) : real} produces the hyperbolic sine of
\texttt{r}.\\
\texttt{tanh(r:real) : real} produces the hyperbolic tangent of
\texttt{r}.

Links: \texttt{factors}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{matrix}\hfill  (SBW, REG)}

This file contains procedures for \index{matrix manipulation}matrix
manipulation. Matrices (arguments beginning with M) are represented as
lists of lists. Links: \texttt{lu}.

\texttt{matrix\_width(M) : integer} produces the number of columns in a
\ matrix.\\
\texttt{matrix\_height(M) : integer} produces the number of rows in a
matrix.\\
\texttt{write\_matrix(file, M, x)} outputs a matrix to a file, one row
per line. If \texttt{x} is nonnull,\\
 \ \ \ \ \ elements are comma-separated and rows are enclosed
in square brackets.\\
\texttt{copy\_matrix(M) : list} produces a copy of a matrix.\\
\texttt{create\_matrix(n,m,x) : list} creates an \texttt{n} by
\texttt{m} matrix with initial value \texttt{x}.\\
\texttt{identity\_matrix(n,m) : list} produces an identity matrix of
size \texttt{n} by \texttt{m}\textsubscript{.}\\
\texttt{add\_matrix(M1,M2) : list} produces the matrix addition of
\texttt{M1} and \texttt{M2.}\\
\texttt{mult\_matrix(M1,M2) : list} produces the matrix multiplication
of \texttt{M1} and \texttt{M2.}\\
\texttt{invert\_matrix(M) : list} produces the matrix inversion of
\texttt{M}.\\
\texttt{determinant(M) : real} produces the determinant of \texttt{M}.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{memlog}\hfill (GMT)}

\texttt{memlog(f:\&output) : integer} writes a message to file
\texttt{f} recording the current memory amount in use, amount
reserved, and number of collections in the string and block regions.
%\texttt{memlog()} does not perturb the figures: it allocates nothing itself.
\texttt{memlog()} returns the total current usage.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{morse}\hfill (REG, RM)}

\texttt{morse(s:string) : string} converts \texttt{s} to its
\index{Morse code}International Morse Code (a.k.a. Continental Code)
equivalent, as used by radio amateurs (hams).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mset}\hfill (JPR)}

\texttt{same\_value(d1,d2) : ? \ }\ \ \ compares \texttt{d1} and
\texttt{d2} for structural equivalence.\\
\texttt{insert2(S:set, el) : set} inserts \texttt{el} into \texttt{S}
\\
\texttt{member2(S:set, el) : ?} \ \ \ \ \ tests whether \texttt{el} (or
its structural equivalent) is in \texttt{S}.\\
\texttt{delete2(S:set, el) : set} deletes \texttt{el} (or its structural
equivalent) from \texttt{S}.

This module implements set operations in which no two identical
(structurally equivalent) values can be present in a set.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{namepfx}}

\texttt{namepfx(s:string) : string} produces the "name
prefix" from a name in standard form -{}- omitting any
title, but picking up the first name and any initials.
\texttt{namepfx()} only knows how to omit common titles found in module
\texttt{titleset}. Obviously, it can't always produce
the ``correct'' result. Links:
\texttt{lastname}, \texttt{titleset}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ngrams}}

\texttt{ngrams(file,n,c:\&letters,t) : string*} generates a tabulation
of the n-grams in the specified file. If \texttt{c} is non-null, it is
the set of characters from which \index{n-grams}n-grams are
taken (other characters break n-grams). If \texttt{t} is non-null, the
tabulation is given in order of frequency; otherwise in alphabetical
order of n-grams. % Note: This procedure is unsuitable if there are very
%many different n-grams. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{numbers}\hfill (REG, RJA, RLG, TK)}

These procedures format numbers in various ways:

\texttt{amean(L) : real} returns arithmetic \index{mean values}mean of
numbers in L.\\
\index{ceil(r)}\texttt{ceil(r) : integer} returns nearest integer to
\texttt{r} away from 0.\\
\texttt{commas(s) : string} inserts commas in s to separate digits into
groups of three.\\
\texttt{decipos(r,i:3,j:5):string?} position decimal point at \texttt{i}
in \texttt{r} in field width \texttt{j}.\\
\texttt{digred(i) : integer} reduces a number by adding digits until one
digit is reached.\\
\texttt{div(i:number,j:number) : real} produces the result of real
\index{division}division of \texttt{i} by \texttt{j}.\\
\texttt{fix(i, j:1, w:8, d:3) : string?} formats \texttt{i / j} as a
real (floating-point) number in a\\
 \ \ \ \ field of width \texttt{w} with \texttt{d} digits to
the right of the decimal point, if possible.\\
 \ \ \ \ If \texttt{w} is less than 3 it is set to 3. If \texttt{d} is
less than 1, it is set to 1. The function\\
 \ \ \ \  fails if \texttt{j}
is 0 or if the number cannot be formatted.\\
\index{floor(r)}\texttt{floor(r)}\texttt{ : integer} nearest integer to
\texttt{r} toward 0.\\
\texttt{gcd(i,j):integer?} returns greatest common divisor of i and j.
It fails if both are 0.\\
\texttt{gcdl(L:list): integer} returns the greatest common division of a
list of integers.\\
\texttt{gmean(args?) : real?} returns the geometric mean of
numbers.\\
\texttt{hmean(args?) : real?} returns the harmonic mean of
numbers.\\
\texttt{large(i) : integer?} succeeds if \texttt{i} is a large integer
but fails otherwise.\\
\texttt{lcm(i, j) : integer?} returns the least common multiple of i and
j.\\
\texttt{lcml(L): integer?} returns the least common multiple of the
integers in the list L.\\
\index{mceil(r)}\texttt{mceil(r) : integer} returns the least integer
greater than or equal to \texttt{r}.\\
\index{mfloor(r)}\texttt{mfloor(r)}\texttt{ : integer} returns the
greatest integer less than or equal to \texttt{r}.\\
\texttt{npalins(n) : string*} generates palindromic n-digit
numbers\\
\texttt{roman(i) : string?} converts \texttt{i} to \index{Roman
numerals}Roman numerals.\\
\texttt{round(r:real) : integer} returns nearest integer to
\texttt{r}.\\
\texttt{sign(r) : integer} returns sign of \texttt{r}.\\
\texttt{spell(i : integer) : string?} spells out \texttt{i} in
English.\\
\texttt{trunc(r:real) : integer} returns nearest integer less than
\texttt{r}.\\
\texttt{unroman(string) : integer} converts Roman numerals to integers.

Note that \texttt{ceil()} and \texttt{floor()} are the traditional Icon
definitions of the ceiling and floor functions; \texttt{mceil()} and
\texttt{mfloor()} implement the more commonly used mathematical definitions.

Links: \texttt{strings}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{openchk}\hfill (DAG)}

\texttt{OpenCheck()} causes subsequent opens and closes to write
diagnostic information to \texttt{\&errout}. Useful for diagnosing
situations where many files are opened and closed and there is a
possibility that some files are not always being closed.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{options}\hfill (RJA, GMT)}

\texttt{options(args:list, opt:string, err:stop) : table} separates,
interprets, and removes UNIX-style \index{options, command-line}command
options from a list of strings,
returning a table of option values. Options are
introduced by a \texttt{"-"} character. An
option name is either a single printable character, as in
\texttt{"-n"} or
\texttt{"-?"}, or a string of letters, as
in \texttt{"-geometry"}. Valueless
single-character options may be combined, for example as
\texttt{"-qtv"}. Some options require
values. Generally, the option name is one argument and the value
appears as the next argument, for example: {\ttfamily "-F file.txt"}

\noindent With a single-character argument name,
the value may be concatenated, as in
\texttt{"-Ffile.txt"}.
Options may be interspersed with non-option
arguments. An argument of \texttt{"-"} is
treated as a non-option. The special argument
\texttt{"-{}-"} terminates option
processing. Non-option arguments are left in \texttt{args}
for use by the caller. \texttt{options()} replaces arguments of the form
\texttt{@filename} with arguments retrieved from the file
"filename". Each line of the file is taken
as a separate argument, exactly as it appears in the file.

The options string is a concatenation, with optional spaces between, of
one or more option specs of the form
\texttt{{}-}\texttt{\textit{name}}\texttt{\%} where \texttt{{}-}
introduces the option.
\texttt{\textit{name}} is either a string of letters or any single
printable character
\texttt{\%} is one of the following flag characters:

\begin{tabular}{m{0.15in}m{2.85in}m{0.15in}m{2.85in}}
\texttt{!} & No value is required or allowed &
\texttt{:} & A string value is required\\
\texttt{+} & An integer value is required &
\texttt{.} & A real value is required
\end{tabular}

The leading \texttt{"-"} may be omitted for
a single-character option. The \texttt{"!"}
flag may be omitted except when needed to terminate a multi-character
name. % Thus, the optstring
%\texttt{"-n+ -t -v -q -F: -geometry: -silent"} is equivalent to
%\texttt{"n+tvqF:-geometry:-silent"} or
%\texttt{"-silent!n+tvqF:-geometry"}.
If the options string is omitted, any single letter is assumed to be valid and
require no data.

The \texttt{err} procedure will be called if an error is detected in the
command line options. The procedure is called with one argument: a
string describing the error that occurred. After \texttt{err()} is
called, \texttt{options()} immediately returns the outcome of
\texttt{errproc()}, without processing further arguments.
Processed arguments will have been removed from args.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{outbits}\hfill (RLG)}

\texttt{outbits(i:integer, len:integer) string*} fits variable,
non-byte-sized blocks into 8-bit bytes,
suspending byte-sized chunks of \texttt{i} converted to characters
(most significant bits first) until there is not enough left of
\texttt{i} to fill up an 8-bit character. The remainder is
stored in a buffer until \texttt{outbits()} is called again, at which
point the buffer is combined with the new \texttt{i} and output in
the same manner as before. The buffer is flushed by calling
\texttt{outbits()} with a null \texttt{i} argument. 
\texttt{len} gives the number of bits in \texttt{i} to preserve;
bits that are discarded are the most significant ones. A trivial
example of how \texttt{outbits()} might be used:

\iconcode{
outtext :=
open("some.file.name","w") \\
L := [1,2,3,4] \\
every writes(outtext, outbits(!L,3)) \\
writes(outtext, outbits(\&null,3)) \# flush buffer
}

\noindent List L may be reconstructed with \texttt{inbits()}:

\iconcode{
intext := open("some.file.name") \\
L := [] \\
while put(L, inbits(intext, 3))
}

\noindent Note that \texttt{outbits()} is a \index{generator}generator, while
\texttt{inbits()} is not.
See also: \texttt{inbits.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{packunpk}\hfill (CT, RLG)}

\texttt{pack(num:i,width:i):string} produces a binary-coded decimal
representation of \texttt{num}\\
 \ \ \ \  in which each character contains two decimal
digits stored in four bits each.\\
\texttt{unpack(val:s,width:i):string} converts a binary-coded decimal
back to a\\
 \ \ \ \ string representation \ \texttt{width} characters long of the
original source integer.\\
\texttt{unpack2(val:string) : integer} converts a binary-coded decimal
back into its\\
 \ \ \ \ original source integer.

Links: \texttt{convert.}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{partit}}

\texttt{partit(i,min:i,max:i):L*} generates the partitions of
\texttt{i}; that is the ways that \texttt{i} can be\\
 \ \ \ \ represented as a sum of positive integers with minimum
and maximum values.\\
\texttt{partcount(i,min:i,max:i):integer} returns the number of
partitions.\\
\texttt{fibpart(i):L} returns a list of Fibonacci numbers that is a
partition of \texttt{i}.

Links: \texttt{fastfncs}, \texttt{numbers}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{patterns}}

This module provides string scanning procedure equivalents for most
\index{SNOBOL4}SNOBOL4 \index{patterns, SNOBOL4}patterns and some
extensions. % Procedures and their pattern equivalents are:
It is largely subsumed by Unicon's pattern type.

%\begin{xtabular}{m{1.2in} m{1.7in} m{1.2in} m{1.7in}}

%Procedure & Equivalent SNOBOL & Procedure & Equivalent SNOBOL \\

%\texttt{Any(s)} & ANY(S) & \texttt{Arb()} & ARB\\
%\texttt{Arbno(p)} & ARBNO(P) & \texttt{Arbx(i)} & ARB(I)\\
%\texttt{Bal()} & BAL & \texttt{Break(s)} & BREAK(S)\\
%\texttt{Breakx(s)} & BREAKX(S) & \texttt{Cat(p1,p2)} & P1 P2\\
%\texttt{Discard(p)} & /P & \texttt{Exog(s)} & {\textbackslash}S\\
%\texttt{Find(s)} & FIND(S) & \texttt{Len(i)} & LEN(I)\\
%\texttt{Limit(p,i)} & P {\textbackslash} I & \texttt{Locate(p)} & LOCATE(P)\\
%\texttt{Marb()} & longest-first ARB & \texttt{Notany(s)} & NOTANY(S)\\
%\texttt{Pos(i)} & POS(I) & \texttt{Replace(p,s)} & P = S\\
%\texttt{Rpos(i)} & RPOS(I) & \texttt{Rtab(i)} & RTAB(I)\\
%\texttt{Span(s)} & SPAN(S) & \texttt{String(s)} & S\\
%\texttt{Succeed()} & SUCCEED & \texttt{Tab(i)} & TAB(I)\\
%\texttt{Xform(f,p)} & F(P) \\
%\end{xtabular}

%The following procedures relate to the application and control of
%\index{pattern matching}pattern matching:

%\texttt{Apply(s,p)}\ \ S ? P\\
%\texttt{Mode()}\ \ anchored or unanchored matching (see Anchor() and
%\texttt{Float()})\\
%\texttt{Anchor()}\ \ \&ANCHOR = 1 if Mode := Anchor\\
%\texttt{Float()}\ \ \ \ \&ANCHOR = 0 if Mode := Float

%In addition to the procedures above, the following expressions can be
%used:

%\texttt{p1() {\textbar} p2()}\ \ \ P1 {\textbar} P2\\
%\texttt{v {\textless}- p()}\ \ \ \ \ \ P . V (approximate)\\
%\texttt{v := p()}\ \ \ \ \ \ P . V (approximate)\\
%\texttt{fail}\ \ \ \ \ \ \ \ \ \ \ \ FAIL\\
%\texttt{=s}\ \ \ \ \ \ \ \ \ \ \ \ \ S (in place of String(s))\\
%\texttt{p1() {\textbar}{\textbar} p2()}\ \ \ \ \ \ P1 P2 (in place of Cat(p1,p2))

%Using this system, most SNOBOL4 patterns can be satisfactorily
%transliterated into Icon procedures and expressions. For example, the
%pattern

%\iconcode{
%SPAN("0123456789") . N
%"H" LEN(*N) . LIT}

%can be transliterated into

%\iconcode{
%(n {\textless}- Span('0123456789'))
%{\textbar}{\textbar} ="H"
%{\textbar}{\textbar} (lit {\textless}- Len(n))}

%Concatenation of components is necessary to preserve the
%pattern-matching properties of SNOBOL4. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{patword}\hfill (KW)}

\texttt{patword(s:string) : string} returns a letter pattern in which
each different character in \texttt{s} is assigned a letter. For
example, \texttt{patword("structural")}
returns \texttt{"abcdebdcfg"}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{phoname}\hfill (TRH)}

\texttt{phoname(telno:string) : string*} generates the letter
combinations corresponding to the digits in a telephone number. The
number of possibilities is very large. This procedure should be used in
a context that limits or filters its output.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{plural}}

\texttt{plural(word:string) : string} produces the \index{plural
form}plural form of a singular English noun. The procedure here is
rudimentary and is not correct in all cases. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{polystuf}}

These procedures are for creating and performing operations on
single-variable \index{polynomials}polynomials (like ax\^{}2 + bx + c).
A polynomial is represented as a table in which the keys are exponents
and the values are coefficients. (EE)

\texttt{poly(c1, e1, c2, e2, ...) : poly} creates a polynomial from
the\\
 \ \ \ \ \ parameters given as coefficient-exponent pairs:
\texttt{c1x\^{}e1 + c2x\^{}e2 + ...}\\
\texttt{is\_zero(n) : ?
\ }\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ determines if n = 0\\
\texttt{is\_zero\_poly(p) : ?} \ \ \ \ \ \ \ \ \ \ determines if a given
polynomial is 0x\^{}0\\
\texttt{poly\_add(p1, p2) : poly} returns the sum of two
polynomials\\
\texttt{poly\_sub(p1, p2) : poly} returns the difference of p1 -
p2\\
\texttt{poly\_mul(p1, p2) : poly} returns the product of two
polynomials\\
\texttt{poly\_eval(p, x) : poly} finds the value of polynomial p
evaluated at the given x.\\
\texttt{term2string (c, e) : string} converts one coefficient-exponent
pair into a string.\\
\texttt{poly\_string(p) : string} returns the string representation of
an entire polynomial. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{printcol}\hfill (RJA)}

\texttt{printcol(items, fields, title:"",
pagelength:30000, linelength:80, auxdata)} deals with the problem of
printing tabular data where the total width of items to be printed is
wider than the page. Simply allowing the data to wrap to additional
lines often produces marginally readable output. This procedure
facilitates printing such groups of data as vertical columns down the
page length, instead of as horizontal rows across the page. That way
many, many fields can be printed neatly.% The programming of such a
transformation can be a nuisance.% This procedure does much of the work
%for you, like deciding how many items can fit across the page width and
%ensuring that entire items will be printed on the same page without
%page breaks (if that service is requested).

%For example, suppose you have a list of records to print. The record is
%defined as:\\
%\texttt{record rec(item1,item2,item3,...)} Also suppose that lines such
%as

%\iconcode{
%Field 1 Field 2 Field 3 ... \\
%{}-{}-{}-{}-{}-{}-{}- -{}-{}-{}-{}-{}-{}- -{}-{}-{}-{}-{}-{}- -{}-{}- \\
%Record 1 item1 item2 item3 ... \\
%Record 2 item1 item2 item3 ...
%}

%are too long to print across the page. This procedure will print them
%as:

%\iconcode{
%TITLE \\
%===== \\
%Record 1 Record 2 ... \\
%{}-{}-{}-{}-{}-{}-{}-{}- -{}-{}-{}-{}-{}-{}-{}- -{}-{}- \\
%Field 1 item1 item1 ... \\
%Field 2 item2 item2 ... \\
%Field 3 item3 item3 ...
%}

The arguments are:

\texttt{items}: a co-expression that produces a sequence of items
(usually structured data, but not necessarily) for which data
is to be printed.

\texttt{fields}: a list of procedures to produce the
field's data. Each procedure takes two arguments. The
procedure's action depends upon what is passed in the
first argument:

\texttt{header} produces the row heading string to be used for that
field (the field name).

\texttt{width} produces the maximum field width (including the column
header).

\texttt{other} produces the field value string for the item passed as
the argument.

The second argument is arbitrary data from the procedures with each
invocation. The data returned by the first function on the list is used
as a column heading (the item name).

\texttt{auxdata}: arbitrary auxiliary data to be passed to the \texttt{fields}
procedures (see above).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{printf}\hfill (WHM, CW, PLT)}

This module provides formatted output functions
modeled on those in the C language.

\texttt{printf(fmt:string, args[])} formats and writes arguments to
\texttt{\&output}.\\
\texttt{fprintf(f:file,fmt:string,args[])} formats and writes arguments
to \texttt{f}.\\
\texttt{sprintf(fmt:string, args[]) : string} formats arguments and
produces a string result.

The format string \texttt{fmt} is modified by substituting arguments
in place of the ``format specifiers'' within it, consisting of a
percent sign followed by a specifier code:

\begin{xtabular}{m{0.5in} m{2.55in}m{0.5in}m{2.55in}}
code & argument printed in the form &
code & argument printed in the form \\
 \texttt{\%d}  & decimal integer        & \texttt{\%r}    & real number \\
 \texttt{\%e}  & scientific (exponential) notation & \texttt{\%s}    & string \\
 \texttt{\%i}  & image &          \texttt{\%x}    & hexadecimal \\
 \texttt{\%o}  & octal &           & \\
\end{xtabular}

Specifier code \texttt{\%r} uses scientific notation if the integer
portion is inexact.
An hyphen after the percent sign indicates left justification,
otherwise right justification is used. A number of digits after the
percent sign may specify the minimum width of the field to use, or after
a period they specify a number of digits of precision. For example,
\texttt{printf("\%-5.2r", x)} specifies that real number x be
formatted as a string of at least 5 characters, left justified,
with two digits after the decimal point.

\pagebreak


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{prockind}}

\texttt{prockind(p:procedure) : string?} produces a code for the kind of
the procedure p as follows: \texttt{"p"}
(declared) procedure \texttt{"f"}
(built-in) function, \texttt{"o"} operator,
\texttt{"c"} record
\index{constructor}constructor. It fails if \texttt{p} is not of type
procedure. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{procname}}

\texttt{procname(p:procedure, x) : string?} produces the name of a
procedure (including functions, operators, and record
\index{constructor!record}constructors) value. If \texttt{x} is null,
the result is derived from \texttt{image()} in a relatively
straightforward way. In the case of operators, the number of arguments
is appended to the operator symbol. If \texttt{x} is nonnull, the
result is put in a form that resembles an Icon expression.
\texttt{procname()} fails if \texttt{p} is not of type procedure. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pscript}\hfill (GMT)}

\texttt{epsheader(f, x, y, w, h, flags)} writes an Encapsulated
PostScript file header and initializes the PostScript coordinate
system. This procedure is for writing PostScript output
explicitly.
% An EPS file can either be incorporated as part of a larger document or sent
%directly to a PostScript printer.
% \texttt{epsheader()} writes the first
%portion of the PostScript output to file \texttt{f}.
% The calling program then generates the rest.
 It is the caller's
responsibility to ensure that the rest of the file conforms to the
requirements for EPS files as documented in the PostScript Reference
Manual, second edition. (x,y,w,h) specify the range of coordinates that
are to be used in the generated PostScript code. \texttt{epsheader()}
generates \index{PostScript}PostScript commands that center this region
on the page and clip anything outside it. If the flags string contains
the letter \texttt{"r"} and \texttt{abs(w)
{\textgreater} abs(h)}, the coordinate system is rotated to place the
region in "landscape" mode. The generated
header also defines an "inch" operator that
can be used for absolute measurements as shown in the example below.

\iconcode{
f := open(filename, "w") {\textbar}
stop("can't open
",filename) \\
epsheader(f, x, y, w, h) \\
write(f, ".07 inch setlinewidth") \\
write(f,x1, " ", y1, " moveto ", x2, " ", y2,
" lineto stroke") ... write(f,
"showpage")
}

See also: \texttt{psrecord.icn} contains procedures that
write PostScript as a side effect of normal graphics calls.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{random}\hfill (REG, GMT)}

This file contains procedures related to pseudo-random numbers.

\texttt{rand\_num() : integer} is a linear congruential pseudo-random
number \index{generator}generator. Each call produces
another number in the sequence and assigns it to the global
variable \texttt{random}. With no arguments, \texttt{rand\_num()}
produces the same sequence(s) as the built-in
random-number \index{generator, random number}generator. Arguments can
be used to get different sequences. The global variable \texttt{random}
plays the same role that \texttt{\&random} does for
the built-in \index{random!number generator}random
number generator.

\texttt{rand\_int(i) : integer} produces a random integer in the range 1
to i.\\
\index{randomize()}\texttt{randomize()} sets \texttt{\&random}, based on the
date and time of day. \\
\texttt{randrange(min, max) : integer} produces a random number from
\texttt{min {\textless}= i {\textless}= max}.\\
\texttt{randrangeseq(i, j) : integer*} generates the integers from
\texttt{i} to \texttt{j} in random order.\\
\texttt{randseq(seed) : integer*} generates the values of \&random,
starting at \texttt{seed},\\
 \ \ \ \ \ that occur as the result of using \texttt{?x}.

\texttt{shuffle(x):x} shuffles the elements of string, list, or record
\texttt{x}. \ If \texttt{x} is a list or record\\
 \ \ \ \ \ it is altered in place instead of creating a new structure for
the shuffled result.

Links: \texttt{factors}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{rational}}

These procedures perform arithmetic on \index{rational numbers}rational
numbers (\index{fractions}fractions):

\texttt{record rational(numer, denom, sign)} is used to represent
rational values.\\
\texttt{str2rat(string):rational?} converts a string such as
\texttt{"3/2"} to a rational
number.\\
\texttt{rat2str(r:rational):string} converts rational number \texttt{r}
to its string representation.\\
\texttt{addrat(r1:rational,r2:rational) : rational} adds rational
numbers \texttt{r1} and \texttt{r2}.\\
\texttt{subrat(r1:rational,r2:rational) : rational} subtracts rational
numbers \texttt{r1} and \texttt{r2}.\\
\texttt{mpyrat(r1:rational,r2:rational) : rational} multiplies rational
numbers \texttt{r1} and \texttt{r2}.\\
\texttt{divrat(r1:rational,r2:rational) : rational} divides rational
number \texttt{r1} by \texttt{r2}.\\
\texttt{negrat(r) : rational} produces the negative of rational number
\texttt{r}.\\
\texttt{reciprat(r:rational) : rational} produces the reciprocal of
rational number \texttt{r}.

Links: \texttt{numbers}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{readtbl}\hfill (RLG)}

\texttt{readtbl(f:file) : table} reads \index{SGML}SGML mapping
information from a file. This module is part of the \texttt{strpsgml}
package. The file specifies how each SGML tag in a given input text
should be translated. Each line has the form:

\ \ \ SGML-designator\ \ start\_code\ \ end\_code

where the SGML designator is something like
"quote" (without the quotation marks), and
the start and end codes are the way in which you want the beginning and
end of a
\texttt{{\textless}quote{\textgreater}...{\textless}/quote{\textgreater}}
sequence to be translated. Presumably, in this instance, your codes
would indicate some set level of indentation, and perhaps a font
change. If you don't have an end code for a particular
SGML designator, just leave it blank.
Links: \texttt{stripunb.}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{rec2tab}}

\texttt{rec2tab(x) : null} writes fields of a record as tab-separated
string. Carriage returns in files are converted to vertical tabs.
(Works for lists too.) \ 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{records}}

\texttt{field(R, i) : string?} returns the name of the \texttt{i}th
field of \texttt{R}. Other record processing procedures may be added to
this module in future editions. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{recurmap}}

\texttt{recurmap(recur:list) : string} maps a recurrence declaration of
the form
\iconcode{
 \ \ \texttt{\ f(i):}\\
 \ \ if expr11 then expr12\\
 \ \ if expr21 then expr22\\
 \ \ \ \ \ \ \ \ \ \ ...\\
 \ \ else expr
}

The declaration is a list of strings. The result string is a
declaration for an Icon procedure that computes corresponding values.
At present there is no error checking and the most naive form of code
is generated. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{reduce}}

\index{reduce()}\texttt{reduce(op, init, args[])} applies the binary
operation \texttt{op} to the values in \texttt{args}, using
\texttt{init} as the initial value. For example,
\texttt{reduce("+", 1, ...)} produces
the sum of the values in \texttt{...}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{regexp}\hfill (RJA)}

This module implements UNIX-like \index{regular expression}regular
expression patterns. % These procedures are interesting partly because of
%the "recursive suspension" (or
%"suspensive \index{recursion}recursion":)
%technique used to simulate conjunction of an arbitrary number of
%computed expressions.
String scanning function default conventions are followed.

\texttt{ReMatch(pattern,s,i1,i2) : integer*} produces the sequence of
positions in \texttt{s} past a substring starting at \texttt{i1} that
matches \texttt{pattern}, but fails if there is no such position.
%Similar to \texttt{match()}, but is capable of generating multiple
%positions.

\texttt{ReFind(pattern,s,i1,i2) : integer*} produces the sequence of
positions in \texttt{s} where substrings begin that match
\texttt{pattern}, but fails if there is no such position.
% Similar to \texttt{find()}.
Each position is produced only once. %, even if several
%possible matches are possible at that position.
\texttt{pattern} can be
either a string or a pattern list -{}- see \texttt{RePat()}.

\texttt{RePat(s) : list?} creates a ``pattern element list'' from pattern
string \texttt{s}, but fails if the pattern string is not syntactically
correct. \texttt{ReMatch()} and \texttt{ReFind()} will automatically
convert a pattern string to a pattern list, but it is faster to do the
conversion explicitly if multiple operations are done using the same
pattern. % An additional advantage to compiling the pattern separately is
%avoiding ambiguity of failure caused by an incorrect pattern and
%failure to match a correct pattern.

\texttt{ReCaseIndependent() : null, ReCaseDependent() : null} set the
mode for case-independent or case-dependent matching. The initial mode
is case-dependent.

\paragraph{Accessible Global Variables}
After a match, the strings matched by parenthesized regular expressions
are left in list \texttt{Re\_ParenGroups}, and can be accessed by
subscript.
% using the same number as the {\textbackslash}N construct.
%If it is desired that regular expression format be similar
%to UNIX filename generation patterns but still retain the power of full
%regular expressions, make the following assignments prior to compiling
%the pattern string:

%\iconcode{
%\>   Re\_ArbString := "*" \# Defaults to
%".*" }

%The csets that define a word, digits, and white space can be modified.
% The following assignments can be made before
%compiling the pattern string. The character sets are captured when the
%pattern is compiled, so changing them after pattern compilation will
%not alter the behavior of matches unless the pattern string is
%recompiled.

%\iconcode{
%\>   Re\_WordChars := 'whatever' \#
%default: \&letters++\&digits++'\_' \\
%\>   Re\_Digits := \&digits ++
%'ABCDEFabcdef' \# Defaults to
%\&digits \\
%\>   Re\_Space := 'whatever' \#
%Defaults to '
%{\textbackslash}t{\textbackslash}v{\textbackslash}n{\textbackslash}r{\textbackslash}f'
%}

%These globals are initialized in the first call to \texttt{RePat()} if
%they are null. They can be explicitly initialized to their defaults (if
%they are null) by calling \texttt{Re\_Default()}.

%Characters compiled into patterns can be passed through a user-supplied
%filter procedure, provided in global variable \texttt{Re\_Filter}.
%Filtering is done as the pattern is compiled, before the characters are
%bound into the pattern. The filter is passed one argument, the string
%to filter, and it must return the filtered string as its result. If the
%filter procedure fails, the string will be used unfiltered. The filter
%is called with an argument of either type string (for characters in the
%pattern) or cset (for character classes [...]). By default, individual
%pattern elements are matched in a "leftmost-
%longest-first" sequence, which is the order observed by
%\index{Perl}Perl, e\index{grep}grep, and most other regular expression
%matchers. %The following global variable setting causes the matcher to
%operate in leftmost-shortest- first order.

%\iconcode{
%\>   Re\_LeftmostShortest := 1}

%In the case of patterns containing alternation, \texttt{ReFind()} will
%generally not produce positions in increasing order, but will produce
%all positions from the first term of the alternation (in increasing
%order) followed by all positions from the second (in increasing order).
%If it is necessary that the positions be generated in strictly
%increasing order, with no duplicates, assign a non-null value to
%\texttt{Re\_Ordered}:

%\iconcode{
%\>   Re\_Ordered := 1}

%The \texttt{Re\_Ordered} option imposes a small performance penalty in
%some cases, and the co-expression facility is required in your Icon
%implementation.

\paragraph{Regular Expression Characters and Features Supported}
The regular expression format supported by procedures in this file model
very closely those supported by the UNIX
"egrep" program, with modifications as
described in the Perl programming language definition. Following is a
brief description of the special characters used in regular
expressions. The abbreviation RE means regular expression.

\texttt{c} An ordinary character (not one of the special characters
discussed below) is a one-character RE that matches that character.

\texttt{{\textbackslash}c} A backslash followed by any special character
is a one-character RE that matches the special character itself. % Note
%that backslash escape sequences representing non-graphic characters are
%not supported directly by these procedures. Of course, strings coded in
%an Icon program will have such escapes handled by the Icon translator.
%If such escapes must be supported in strings read from the run-time
%environment (e.g. files), they will have to be converted by other
%means, such as the Icon Program Library procedure \texttt{escape()}.

\texttt{.} A period is a one-character RE that matches any character.

\texttt{[string]} A non-empty string enclosed in square brackets
%is a one-character RE that
matches any one character in that string. If the
first character is \texttt{"\^{}"}
(circumflex), any character {\em not\/} in the remaining
characters of the string is matched. The \texttt{"-"}
(minus), when between two other characters, indicates a
range of consecutive \index{ASCII}ASCII characters (e.g. \texttt{[0-9]}
is equivalent to \texttt{[0123456789]}). Other special characters stand
for themselves in a bracketed string.

\texttt{*} Matches zero or more occurrences of the RE to its
left.\\
\texttt{+} Matches one or more occurrences of the RE to its
left.\\
\texttt{?} Matches zero or one occurrences of the RE to its
left.\\
\texttt{\{N\}} Matches exactly \texttt{N} occurrences of the RE to its
left.\\
\texttt{\{N,\}} Matches at least \texttt{N} occurrences of the RE to its
left.\\
\texttt{\{N,M\}} Matches from \texttt{N} to
\texttt{M} occurrences of the RE to its left.\\
\texttt{\^{}} A caret at the beginning of an entire RE constrains that
RE to match an initial\\
 \ \ \ \ substring of the subject string.\\
\texttt{\$} A currency symbol at the end of an entire RE constrains that
RE to match a\\
 \ \ \ \ final substring of the subject string.\\
\texttt{{\textbar}} \index{alternation operator ( {\textbar}
)}Alternation: two regular expressions separated by
\texttt{"{\textbar}"} match either a match
for\\
 \ \ \ \ the first or a match for the second.\\
\texttt{()} A RE enclosed in parentheses matches a match for the regular
expression\\
 \ \ \ \ (parenthesized groups are used for grouping, and for accessing
the matched\\
 \ \ \ \ string subsequently in the match using the {\textbackslash}N
expression).\\
\texttt{{\textbackslash}N} where \texttt{N} is a digit in the range 1-9,
matches a string of characters that was\\
 \ \ \ \ matched by a parenthesized RE to the left in the same RE. The
sub-expression\\
 \ \ \ \ specified is that beginning with the \texttt{N}th occurrence of
\texttt{"("} counting from the
\\
 \ \ \ \ left. e.g., \^{}(.*){\textbackslash}1. matches a string consisting of
two consecutive occurrences\\
 \ \ \ \ of the same string.

\paragraph{Extensions beyond UNIX egrep}
The following extensions to UNIX regular expressions, as specified in
the Perl programming language, are supported.

\texttt{{\textbackslash}w} matches any alphanumeric (including
\texttt{"\_"}).\\
\texttt{{\textbackslash}W} Matches any non-alphanumeric.\\
\texttt{{\textbackslash}b} matches at a word-boundary (a word is
a string of alphanumerics, as in \texttt{{\textbackslash}w}).\\
\texttt{{\textbackslash}B} matches only non-word-boundaries.\\
\texttt{{\textbackslash}s} matches any white-space character.\\
\texttt{{\textbackslash}S} matches any non-white-space
character.\\
\texttt{{\textbackslash}d} matches any digit \texttt{[0-9]}.\\
\texttt{{\textbackslash}D} matches any non-digit.\\
\texttt{{\textbackslash}w}, \texttt{{\textbackslash}W},
\texttt{{\textbackslash}s}, \texttt{{\textbackslash}S},
\texttt{{\textbackslash}d}, \texttt{{\textbackslash}D} can be used
within \texttt{[string]} regular expressions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{repetit}}

\texttt{repetit(L:list) : integer} returns the length of the smallest
range of values that repeat in a list. For example, if L := [1, 2, 3,
1, 2, 3, 1, 2, 3] , \texttt{repetit(L)} returns \texttt{3}. If there is
no repetition, \texttt{repetit()} returns the length of the list. 

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{re\index{wrap}wrap}
\hfill (RLG)}

\texttt{rewrap(s:string,i:70) : string?} reformats text fed to it into
strings \texttt{{\textless}i} in length. \texttt{rewrap()} utilizes a
static buffer, so it can be called repeatedly with different string
arguments, and still produce homogeneous output. This buffer is flushed
by calling \texttt{rewrap()} with a null first argument.
Here's a simple example of how \texttt{rewrap()} could
be used. The following program reads the standard input, producing
fully rewrapped output.

\iconcode{
procedure main() \\
\>   every write(rewrap(!\&input)) \\
\>   write(rewrap()) \\
end
}

\noindent Naturally, in practice you would want to do things like check for
indentation or blank lines in order to wrap only on a paragraph by
paragraph basis. %, as in

%\iconcode{
%procedure main() \\
%\>   while line := read(\&input) do \{ \\
%\>   \ \ \ if line == "" then \{ \\
%\>   \ \ \ \ \ \ write("" \~{}==rewrap()) \\
%\>   \ \ \ \ \ \ write(line) \\
%\>   \ \ \ \ \ \ \} \\
%\>   \ \ \ else \{ \\
%\>   \ \ \ \ \ \ if match("{\textbackslash}t", line) then \{ \\
%\>   \ \ \ \ \ \ \ \ \ write(rewrap()) \\
%\>   \ \ \ \ \ \ \ \ \ write(rewrap(line)) \\
%\>   \ \ \ \ \ \ \ \ \ \} \\
%\>   \ \ \ \ \ \ else \\
%\>   \ \ \ \ \ \ \ \ \ write(rewrap(line)) \\
%\>   \ \ \ \ \ \ \} \\
%\>   \ \ \ \} \\
%end
%}

%\noindent Fill-prefixes can be implemented simply by prepending them
%to the output of rewrap:

%\iconcode{
%i := 70; fill\_prefix := " {\textgreater} " \\
%while line := read(input\_file) do \{ \\
%\>   line ?:= (f\_bit := tab(many('{\textgreater}')) {\textbar} "",
%tab(0)) \\
%\>   write(fill\_prefix {\textbar}{\textbar} f\_bit
%{\textbar}{\textbar} rewrap(line, i - *fill\_prefix)) \\
%\>   etc.
%}

%Obviously, these examples are fairly simplistic. Putting them to actual
%use would certainly require a few environment-specific modifications
%and/or extensions. Still, they offer some indication of the kinds of
%applications \texttt{rewrap()} might be used in.
Note: If you want
leading and trailing tabs removed, map them to spaces first.
\texttt{rewrap()} only fools with spaces, leaving tabs intact. This can
be changed easily enough, by running its input through the
\texttt{detab()} function.
See also: \texttt{wrap.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{scan}\hfill (RLG, DAG, REG, RLS, CW)}

This module contains procedures related to \index{string!scanning}string
scanning: Where indicated by parameter names, they follow the string
scanning conventions for parameter defaults.

\texttt{balq(c1,c2,c3,c4:'{\textbackslash}'"',c5:'{\textbackslash}',s,i1,i2):integer*}
generates integer positions in \texttt{s} preceding a character of
\texttt{c1} in \texttt{s[i1:i2]} that are (a) balanced with respect to
characters in \texttt{c2} and \texttt{c3} and (b) not
"quoted" by characters in \texttt{c4} with
"escape" sequences in
\texttt{c5}.

\texttt{balqc(c1,c2,c3,c4:'{\textbackslash}'"',c5,s1:"/*",s2:"*/",s3,i1,i2):integer*}
is like \texttt{balq()} with the addition that balanced characters
within "comments", as delimited by the
strings \texttt{s1} and \texttt{s2}, are also excluded from balancing.
In addition, if \texttt{s1} is given and \texttt{s2} is null then the
\index{comment}comment terminates at the end of string.

\texttt{limatch(L:list, c:cset) : integer?} matches items in L delimited
by characters in c. Returns the last cursor position scanned to, or
fails 

\texttt{slashbal(c1,c2,c3,s,i,j) : integer*} behaves like
\texttt{bal()}, except that it ignores, for purposes of balancing, any
\texttt{c2} or \texttt{c3} char which is preceded by a backslash.

\texttt{slashupto(c, s, i, j) : integer?} works just like
\texttt{upto()}, except that it ignores backslash escaped characters.

\texttt{snapshot(title:string, len:integer)} writes a snapshot of the
state of string scanning, showing the value of \texttt{\&subject} and
\texttt{\&pos}. Two optional arguments specify a title written at the
top of the snapshot, and a width (in characters) at which to wrap
output. % For example,

%\iconcode{
%"((a+b)-delta)/(c*d))" ?
%\{tab(bal('+-/*'));
%snapshot("example")\}}

%\noindent produces

%\iconcode{
%{}-{}-{}-example-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-\\
%{\textbar}
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}
%\\
%{\textbar}
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}
%\\
%{\textbar} \&subject =
%"((a+b)-delta)/(c*d))" {\textbar}
%\\
%{\textbar} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}
%\ \ \ \ \ \ \ {\textbar}
%\\
%{\textbar}
%\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\textbar}
%\\
%{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-}

A bar showing \texttt{\&pos} is positioned under the
\texttt{\&pos'}th character (actual positions are
between characters). If \texttt{\&pos} is at the end of
\texttt{\&subject}, the bar is positioned under the quotation mark
delimiting the subject. Escape sequences are handled properly. 



\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{scanset}}

\texttt{scan\_setup(s, i1, i2) : scan\_setup\_result?} sets things up
for user-written string-scanning procedures that are in the spirit of
the built-ins. The values passed are the last three
arguments to all scanning functions (such as
\texttt{upto(c,s,i1,i2)}). \texttt{scan\_setup()} supplies any
appropriate defaults and returns needed values. The value returned is a
\texttt{record scan\_setup\_result(ss, offset)}
where \texttt{ss} is the substring of \texttt{s} to be scanned, and
offset is the size of the substring of \texttt{s} that precedes the
substring to be scanned. \texttt{scan\_setup()} fails if \texttt{i1} or
\texttt{i2} is out of range with respect to \texttt{s}. The
user-written procedure can then match in the string \texttt{ss} to
compute the position within \texttt{ss} appropriate to the scan
(\texttt{p}). The value returned (or suspended) to the caller is
\texttt{p + offset} (the position within the original string,
\texttt{s}). For example, the following function finds two words
separated by spaces:

\iconcode{
procedure two\_words(s,i1,i2) \\
\>   local p, x := scan\_setup(s,i1,i2) {\textbar} fail \# fail if out of range \\
\>   x.ss ? suspend \{ \\
\>   \ \ \ tab(upto(\&letters)) \& \\
\>   \ \ \ pos(1) {\textbar} (move(-1) \& tab(any(\~{}\&letters))) \& \\
\>   \ \ \ p := \&pos \& \# remember starting position \\
\>   \ \ \ tab(many(\&letters)) \& tab(many('
')) \& \\
\>   \ \ \ tab(many(\&letters)) \& \\
\>   \ \ \ p + x.offset \# return position in original s \\
\>   \ \ \ \} \\
end
}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{segment}\hfill (WHM)}

These procedures segment a string \texttt{s} into consecutive substrings
consisting of characters that respectively do/do not occur in
\texttt{c}.

\index{segment(s,c)}\texttt{segment(s,c)}\texttt{ : string*} generates
the substrings, while \texttt{seglist(s,c) : list} produces a list of
the segments. For example, \texttt{segment("Not a
sentence.",\&letters)} generates six string results:
"Not" " "
"a" " "
"sentence" "."
while \texttt{seglist("Not a
sentence.",\&letters)} produces a list of size six:
["Not"," ","a","sentence","."]


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sentence, senten1}
\hfill (RLG, PAB)}

Two alternative modules provide a function \texttt{sentence(f) :string*}
that \index{generate sentences}generates sentences from file
\texttt{f}. Many grammatical and stylistic analysis programs are
predicated on the notion of a sentence. Some programs
count the number of words in each sentence; others count the number and
length of clauses. Still others pedantically check for sentence-final
particles and prepositions. Neither module's
definition of a sentence will handle all possible inputs properly; you
may wish to try both of them to see which one works better on your
inputs.

Module \texttt{sentence} requires co-expressions, while module
\texttt{senten1} does not. Module \texttt{senten1} uses a definition of
a "sentence" detailed in the source code.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{seqimage}}

\texttt{Seqimage\{e,i,j\}: string} produces a string image of the result
sequence for the expression \texttt{e}.  The first \texttt{i}
results are printed. If \texttt{i} is omitted, there is no limit. If
there are more than \texttt{i} results for \texttt{e}, ellipses are
provided in the image after the first \texttt{i}. If \texttt{j} is
specified, at most \texttt{j} results from the end of the sequence are
printed after the ellipses. If \texttt{j} is omitted, only the first
\texttt{i} results are produced. For example, the expressions 

\iconcode{
\>   Seqimage\{1 to 12\} \\
\>   Seqimage\{1 to 12,10\}  \\
\>   Seqimage\{1 to 12,6,3\}
}

\noindent produce, respectively, 

\iconcode{
\>   \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\} \\
\>   \{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...\} \\
\>   \{1, 2, 3, 4, 5, 6, ..., 10, 11, 12\}
}

\noindent If \texttt{j} is given and \texttt{e} has an infinite result
sequence, \texttt{Seqimage\{\}} does not terminate.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sername}}

\texttt{sername(p:"file",
s:"", n:3, i:0) : string} produces a series
of names of the form p{\textless}nnn{\textgreater}s. If \texttt{n} is
given it determines the number of digits in
{\textless}nnn{\textgreater}. If \texttt{i} is given it resets the
sequence to start with \texttt{i}. {\textless}nnn{\textgreater} is a
right-adjusted integer padded with zeros. Ordinarily, the arguments
only are given on the first call. Subsequent calls without arguments
give the next name. For example,
\texttt{sername("image",
".gif", 3, 0)} produces
\texttt{"image000.gif"}, and subsequently,
\texttt{sername()} produces
\texttt{"image001.gif"},
\texttt{"image002.gif"}, and so on. If any
argument changes on subsequent calls, all non-null arguments are reset.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sets}\hfill (AB, REG)}

\texttt{cset2set(c:cset): set} returns a set that contains the
individual characters in \texttt{c}.\\
\texttt{domain(T:table)} returns the domain (set of keys) of the
function defined by \texttt{T}.

\texttt{inverse(T:table, x) : table} returns the inverse of the function
defined by \texttt{T}. \texttt{x} values\\
 \ \ \ \ \ specify: \texttt{\&null} (functional inverse), empty list
 (relational inverse), empty set:\\
 \ \ \ \ \ (relational inverse, but with each table member as a set instead of a list).

\texttt{pairset(T:table) : set} converts \texttt{T} to an equivalent set
of ordered pairs.

\texttt{range(T:table):set} returns the range (set of values) of the
function defined by \texttt{T}.\\
\texttt{seteq(S1, S2) : set?} tests \index{equivalence!set}equivalence
of sets \texttt{S1} and \texttt{S2}.

\texttt{setlt(S1, S2) : set?} tests inclusion (strict subset) of set
\texttt{S1} in \texttt{S2}. 


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{showtbl}}

\texttt{showtbl(title:"", T, mode, limit,
order, posit, w1:10, w2:10, gutter:3, f1:left, f2:right)} displays
table \texttt{T} according to the arguments given. The remaining arguments are:

\texttt{mode} indicates the type of sorting, one of:
\texttt{"ref"{\textbar}"val"}
(by key or decreasing value)\\
\texttt{limit} specifies the maximum lines of table output, if
any\\
\texttt{order} gives the sort order, one of:
\texttt{"incr"{\textbar}"decr"}
(not implemented yet)\\
\texttt{posit} is the first column position, one of:
\texttt{"ref"{\textbar}"val"}
(not implemented yet)\\
\texttt{w1} is the width of 1\textsuperscript{st} column\\
\texttt{w2} is the width of 2\textsuperscript{nd} column\\
\texttt{gutter} is the width between columns\\
\texttt{f1} supplies the formatting function used on the 1st
column\\
\texttt{f2} supplies the formatting function used on the 2nd column

\noindent \texttt{showtbl()} returns a record with the first element being a count
of the size of the table and the second element the number of lines
written. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shquote} \hfill (RJA)}

This module is useful for writing programs that generate
\index{shell commands}shell commands. Certain characters cannot appear
in the open in strings that are to be interpreted as
"words" by command shells. This family of
procedures assists in quoting such strings so that they will be
interpreted as single words. Quoting characters are applied only if
necessary -{}- if strings need no quoting they are returned unchanged.


\texttt{shquote(s1, s2,..., sN) : string} \ produces a string of words
\texttt{s1, s2, ..., sN} that are properly separated and quoted for the
Bourne Shell (sh).

\texttt{cshquote(s1, s2,..., sN) : string} produces a string of words
\texttt{s1, s2,..., sN} that are properly separated and quoted for the
C-Shell (csh).

\texttt{mpwquote(s1, s2,..., sN) : string} produces a string of words
\texttt{s1, s2,..., sN} that are properly separated and quoted for the
Macintosh Programmer's Workshop shell.

\texttt{dequote(s1,s2:"{\textbackslash}{\textbackslash}")
: string} produces the UNIX-style command line word \texttt{s1} with
any quoting characters removed. \texttt{s2} is the escape character
required by the shell.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{signed}\hfill (RJA)}

\texttt{signed(s) : integer} puts raw bits of characters of string
\texttt{s} into an integer. The value is taken as signed. This
procedure is used for processing of binary data read from a file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sort}\hfill (RJA,RLG,REG)}

\index{sort}\texttt{sort}\texttt{ff(L, fields[])} is like
\texttt{sortf()}, except it takes an unlimited number of \index{sort by
field}field arguments. \texttt{sortgen(T, m) : any*} generates sorted
output in a manner given by \texttt{m}:

\begin{tabular}{m{0.3in}m{2.5in}m{0.3in}m{2.7in}}
\texttt{"k+"} & sort by key in ascending order &
\texttt{"k-"} & sort by key in descending order\\
\texttt{"v+"} & sort by value in ascending order &
\texttt{"v-"} & sort by value in descending order
\end{tabular}

\index{sortt}\texttt{sortt}\texttt{(T, i)} is like \texttt{sort(T, i)}
but produces a list of two-element records instead of a list of
two-element lists.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{\index{soundex}soundex,
soundex1} \hfill (CW, JDS)}

\texttt{soundex(name:string) : string} produces a code for a name that
tends to bring together variant spellings from Knuth, The Art
of Computer Programming, Vol.3.
Module \texttt{soundex1} employs an approach proposed by M. K.
Odell and R. C. Russell.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{statemap}}

\texttt{statemap() : table} produces a
``two-way'' table to map \index{state names,
U.S.}state names (in the postal sense) to their postal abbreviations
and vice-versa.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{str2toks}\hfill (RLG)}

Scanning procedure \texttt{str2toks(c:\~{}(\&letters++\&digits),
s, i1, i2) : string*} suspends portions of \texttt{s[i1:i2]} delimited
by characters in \texttt{c}. \texttt{str2toks()} is not a primitive
scanning function in the sense that it suspends strings, and not
integer positions. The code:

\iconcode{
\>   "hello, how are ya?" ? every
write(str2toks()) }

\noindent writes to \texttt{\&output}, on successive lines, the words
\texttt{"hello"},
\texttt{"how"},
\texttt{"are"}, and finally
\texttt{"ya"} (skipping the punctuation).
The beginning and end of the line count as delimiters. Note
that if \texttt{i {\textgreater} 1} or \texttt{j {\textless} *s+1} some
tokens may end up appearing truncated.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{strings}}

These procedures perform operations on \index{string}strings. 

\texttt{cat(s1, s2,...) : string} concatenates an arbitrary number of
strings.\\
\texttt{charcnt(s, c) : integer} returns the number of instances of
characters in \texttt{c} in \texttt{s}.

\texttt{collate(s1, s2) : string} \index{collate}collates the characters
of \texttt{s1} and \texttt{s2}. For example,\\
 \ \ \ \ \ \texttt{collate("abc", "def")} produces \texttt{"adbecf"}.

\texttt{comb(s, i) : string*} generates \index{combinations,
string}combinations of characters of \texttt{s} taken \texttt{i} at a time.\\
\texttt{compress(s, c:\&cset) : string} collapses consecutive
occurrences of members of \texttt{c} in \texttt{s}.

\texttt{csort(s) : string} produces the characters of \texttt{s} in
lexical order.\\
\texttt{decollate(s, i:1) : string} produces a string consisting of
every other\\
 \ \ \ \ \ character of \texttt{s}. If \texttt{i} is odd, the
odd-numbered characters are selected, while if\\
 \ \ \ \ \ \texttt{i} is even, the even-numbered characters are selected.

\texttt{deletec(s, c) : string} deletes occurrences of characters in
\texttt{c} from \texttt{s}.\\
\texttt{deletep(s, L) : string} deletes all characters at positions
specified in \texttt{L}.\\
\texttt{deletes(s1, s2) : string} deletes occurrences of \texttt{s2} in
\texttt{s1}.\\
\texttt{diffcnt(s) : integer} returns count of the number of different
characters in \texttt{s}.\\
\texttt{extend(s, n) : string} replicates \texttt{s} to length
\texttt{n}.\\
\texttt{interleave(s1, s2) : string} interleaves characters \texttt{s2}
extended to the length of \texttt{s1}\\
 \ \ \ \ \  with \texttt{s1}.
\texttt{ispal(s) : string?} succeeds and returns \texttt{s} if
\texttt{s} is a palindrome

\texttt{maxlen(L, p:proc("*",1)) : integer}
returns the length of the longest\\
 \ \ \ \ \ string in \texttt{L}. \texttt{p} is applied to each string as
a "length" procedure.

\texttt{meander(s, n) : string} produces a
"meandering" string that contains
all\\
 \ \ \ \ \ n-tuples of characters of \texttt{s}.\\
\texttt{minlen(L, p: proc("*", 1)) :
integer} returns the length of the shortest\\
 \ \ \ \ \ string in \texttt{L}. \texttt{p} is applied to each string as
a "length" procedure.

\texttt{ochars(s) : string} produces unique characters in the order that
they appear in \texttt{s}.\\
\texttt{palins(s, n) : string*} generates the \texttt{n}{}-character
\index{palindrome}palindromes from characters in \texttt{s}.\\
\texttt{permute(s) : string*} generates all the permutations of the
string \texttt{s}.\\
\texttt{pretrim(s, c:' ') : string}
trims characters from beginning of \texttt{s}.\\
\texttt{reflect(s1, i, s2:"") : string}
returns \texttt{s1} concatenated with \texttt{s2} and the reversal of \texttt{s1} to\\
 \ \ \ \ \ produce a partial palindrome. The
values of \texttt{i} determine end conditions for the\\
 \ \ \ \ \ reversal: 0 = omit first
and last characters, 1 = omit first character,\\
 \ \ \ \ \ 2 = omit last character, 3 =
don't omit character.

\texttt{replace(s1, s2, s3) : string} replaces all occurrences of
\texttt{s2} in \texttt{s1} by \texttt{s3}.\\
\texttt{replacem(s,...) : string} performs multiple \index{replacement,
string}replacements in the style of \texttt{replace()},\\
 \ \ \ \ where multiple
argument pairs may be given, as in\\
 \ \ \ \ \ \texttt{replacem(s, "a",
"bc", "d",
"cd")} which replaces all
a's by
\texttt{"bc"}\\
\ \ \ \ and all d's by
\texttt{"cd"}. Replacements are performed
sequentially, not in parallel.

\texttt{replc(s, L) : string} replicates characters of \texttt{s} by
amounts given by the values in \texttt{L}.\\
\texttt{rotate(s, i:1) : string} rotates \texttt{s} \texttt{i}
characters left (negative \texttt{i} rotates to the
right).\\
\texttt{schars(s) : string} produces the unique characters of \texttt{s}
in lexical order.\\
\texttt{scramble(s) : string} scrambles (shuffles) the characters of
\texttt{s} randomly.\\
\texttt{selectp(s, L) : string} selects characters of \texttt{s} that
are at positions given in \texttt{L}.\\
\texttt{transpose(s1, s2, s3) : string} transposes \texttt{s1} using
label \texttt{s2} and transposition \texttt{s3}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{stripcom}\hfill (RLG)}

\texttt{stripcom(s) : string?} strips comments from a
line of code. Fails on lines which, either stripped or otherwise,
come out as an empty string. \texttt{stripcom()} can't
handle lines ending in an underscore as part of a broken string
literal, since \texttt{stripcom()} is not intended to be used on
sequentially-read files. It just removes \index{comment}comments from
individual lines.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{stripunb}\hfill (RLG)}

\texttt{stripunb(c1,c2,s,i,j,t:table) : string} strips material from a
line which is unbalanced with respect to the characters defined in
arguments 1 and 2 (unbalanced being defined as \texttt{bal()} defines
it, except that characters preceded by a backslash are counted as
regular characters, and are not taken into account by the balancing
algorithm). If you call \texttt{stripunb()} with a table argument as
follows,
\texttt{stripunb('{\textless}','{\textgreater}',s,\&null,\&null,t)}
and if \texttt{t} is a table having the form

\iconcode{
key: "bold" value:
outstr("{\textbackslash}e[2m",
"{\textbackslash}e1m") \\
key: "underline" value:
outstr("{\textbackslash}e[4m",
"{\textbackslash}e1m") etc.}

\noindent then every instance of
\texttt{"{\textless}bold{\textgreater}"} in
string s will be mapped to
\texttt{"{\textbackslash}e2m,"} and every
instance of
\texttt{"{\textless}/bold{\textgreater}"}
will be mapped to
\texttt{"{\textbackslash}e[1m."} Values in
table t must be records of type \texttt{outstr(on, off)}. When
\texttt{"{\textless}/{\textgreater}"} is
encountered, \texttt{stripunb()} will output the \texttt{.off} value
for the preceding \texttt{.on} string encountered.
Links: \texttt{scan}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tab2list, tab2rec}}

\texttt{tab2list(string):list} takes tab-separated strings and inserts
them into a list.\\
 \ \ \ \ \ Vertical tabs in strings are converted to carriage returns.

\texttt{tab2rec(s, x) : null} takes tab-separated strings and assigns
them into fields of\\
 \ \ \ \ \ a record or list \texttt{x}. Vertical tabs in strings are
converted to carriage returns.

See also: list2tab.icn, rec2tab.icn. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tables}\hfill (REG, AB)}

\texttt{keylist(T) : list} produces a list of keys in table
\texttt{T}.\\
\texttt{kvallist(T) : list} produces values in \texttt{T} ordered by
sorted order of keys.\\
\texttt{tbleq(T1, T2) : table?} tests the equivalence of tables
\texttt{T1 and T2}.\\
\texttt{tblunion(T1, T2) : table} approximates \texttt{T1 ++
T2}.\\
\texttt{tblinter(T1, T2) : table} approximates \texttt{T1 **
T2}.\\
\texttt{tbldiff(T1, T2) : table} approximates \texttt{T1 -{}-
T2}.\\
\texttt{tblinvrt(T) : table} produces a table with the keys and values
of \texttt{T} swapped.\\
\texttt{tbldflt(T) : any} produces the default value for
\texttt{T}.\\
\texttt{twt(T) : table} produces a \index{two-way table}two-way table
based on \texttt{T}.\\
\texttt{vallist(T) : list} produces list of values in table \texttt{T}.

For the operations on tables that mimic set operations, the
correspondences are only approximate and do not have the mathematical
properties of the corresponding operations on sets. For example, table
"union" is not symmetric or transitive.
Where there is potential asymmetry, the procedures
"favor" their first argument. The
procedures that return tables return new tables and do not modify their
arguments.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tclass}}

\texttt{tclass(x) : string} returns "atomic"
or "composite" depending on the type of
\texttt{x}. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{title, titleset}}

\texttt{title(name:string) : string} produces the title of a name, such
as "Mr." from\\
 \ \ \ \ \ "Mr. John Doe". The process is
imperfect. Links \texttt{titleset}.

\texttt{titleset() : set} produces a set of strings that commonly appear
as titles in\\
 \ \ \ \ \ names. This set is (necessarily) incomplete. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{trees}}

\texttt{depth(t) : integer} compute maximum depth of \index{tree}tree
\texttt{t}\\
\texttt{ldag(s) : list} construct a \index{DAG}DAG from the string
\texttt{s}\\
\texttt{ltree(s) : list} construct a tree from the string
\texttt{s}\\
\texttt{stree(t) : string} construct a string from the tree
\texttt{t}\\
\texttt{tcopy(t) : list} deep copy tree \texttt{t}.\\
\texttt{teq(t1,t2) : list?} compare trees \texttt{t1} and
\texttt{t2}\\
\texttt{visit(t) : any*} visit, in preorder, the nodes of the tree
\texttt{t} by suspending them all 

This module provides tree operations using a list representation of
trees and directed acyclic graphs (DAGs). The procedures do not
protect themselves from cycles. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tuple}\hfill (WHM)}

\texttt{tuple(tl:list) : list} implements a
"tuple" feature that produces the effect of
multiple keys. A tuple is created by an expression of the form
\texttt{tuple([exrp1, expr2,..., exprn])}. The result can be used in a
\index{case expression}case expression or as a table subscript. Lookup
is successful provided the values of expr1, expr2,..., exprn are the
same (even if the lists containing them are not). For example, consider
selecting an operation based on the types of two operands. The
following expression uses \texttt{tuple()} to drive a case expression
using value pairs.

\iconcode{
case tuple([type(op1), type(op2)]) of \{ \\
\>   tuple(["integer",
"integer"]): op1 + op2 \\
\>   tuple(["string",
"integer"]) : op1 {\textbar}{\textbar}
"+" {\textbar}{\textbar} op2 \\
\>   tuple(["integer",
"string"]) : op1 {\textbar}{\textbar}
"+" {\textbar}{\textbar} op2 \\
\>   tuple(["string",
"string"]) : op1 {\textbar}{\textbar}
"+" {\textbar}{\textbar} op2 \\
\>   \}
}

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{typecode}}

\texttt{typecode(x) : string} produces a one-letter string identifying
the type of its argument. In most cases, the code is the first
(lowercase) letter of the type, as in
\texttt{"i"} for the integer type.
Structure types are in uppercase, as in
\texttt{"L"} for the list type. All records
have the code \texttt{"R"}. The code
\texttt{"C"} is used for the co-expression
type to avoid conflict for the \texttt{"c"}
for the cset type. The code \texttt{"w"} is
produced for windows. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{unsigned}\hfill (RJA)}

\texttt{unsigned(s) : integer} puts raw bits of characters of string
\texttt{s} into an integer. The value is taken as unsigned. This
procedure is used for processing of binary data read from a
file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{usage}}

These procedures provide various common services: 

\index{Usage(s)}\texttt{Usage(s)} stops execution with a message
indicating how to use a program.\\
\texttt{Error(args?)} writes arguments to \texttt{\&errout} on a single
line, preceded by \texttt{"*** "}.\\
\texttt{ErrorCheck(l,f) : null} reports to \texttt{\&output} an error
that was converted to failure.\\
\index{Feature(s)}\texttt{Feature(s)}\texttt{ : ?} \ succeeds if feature
\texttt{s} is available in this implementation.\\
\texttt{Requires(s)} terminates execution is feature \texttt{s} is not
available.\\
\texttt{Signature()} writes the version, host, and features support in
the running\\
 \ \ \ \ \ implementation of Icon. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{varsub}}

\texttt{varsub(s, varProc:getenv)} obtains a variable value from the
procedure, \texttt{varProc}. As with the UNIX Bourne shell and C shell,
variable names are preceded by \$. Optionally, the variable name can
additionally be surrounded by curly braces \{\}, which is usually done
when necessary to isolate the variable name from surrounding text. As
with the C-shell, the special symbol
\texttt{\~{}{\textless}username{\textgreater}} is handled. Username can
be omitted; in which case the value of the variable \texttt{HOME} is
substituted. If username is supplied, the \texttt{/etc/passwd} file is
searched to supply the home directory of username (this action is
obviously not portable to non-UNIX environments). (RJA)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{version}}

\index{version}\texttt{version}\texttt{() : string?} produces the
version number of Icon on which a program is running. It only works if
the \texttt{\&version} is in the standard form. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{vrml, vrml1lib, vrml2lib}}

These modules contain procedures for producing \index{VRML}VRML files.

\texttt{point\_field(L)} create VRML point field from point list
\texttt{L\\
u\_crd\_idx(i)} create VRML coordinate index for 0 through i - 1\\
\texttt{render(x)} render node x\\
\texttt{vrml1(x)} produces VRML 1.0 file for node \texttt{x\\
vrml2(x)} produces VRML 2.0 file for node \texttt{x\\
vrml\_color(s)} converts Icon color specification to vrml form

Not all node types have been tested. Where field values are
complex, as in vectors, these must be built separately as strings to go
in the appropriate fields. There is no error checking. Fields must be
given in the order they appear in the node record declarations and
field values must be of the correct type and form.% The introduction of
%record types other than for nodes will cause bogus output. A structural
%loop will produce output until the evaluation \index{stack}stack
%overflows.

\texttt{vrml1lib.icn} contains declarations for VRML 1.0 nodes;
\texttt{vrml2lib.icn} is for VRML 2.0 nodes.
Although VRML 1.0 and 2.0 allow node fields to be given in any order,
these modules require that
they be specified in the order given in the record declarations.
In VRML 1.0, omitted (null-valued) fields are ignored on
output; group nodes require list arguments for lists of nodes.
In VRML 2.0, group nodes require list arguments for lists of nodes. 
Links: \texttt{records}. Requires: graphics facilities, for color
conversion. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{wdiag}}

\texttt{wdiag(s1, s2,...) : null} writes the values of global
variables \texttt{s1, s2, ...} with \texttt{s1, s2, ...} as
identifying labels. It writes a diagnostic message to standard error
if an argument is not the name of a global variable.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{weighted}\hfill (EE)}

\texttt{WeightedShuffle(sample, percentage) : list} returns the list
\texttt{sample} with a portion of the elements switched. Examples:

\texttt{WeightedShuffle(X, 100)} - returns a fully shuffled list\\
\texttt{WeightedShuffle(X, 50)} - every other element is eligible to be
switched\\
\texttt{WeightedShuffle(X, 25)} - every fourth element is
shuffled\\
\texttt{WeightedShuffle(X, 0)} - nothing is changed

The procedure will fail if the given percentage is not between 0 and
100, inclusive, or if it is not a numeric value.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{wildcard}\hfill (RJA)}

These procedures deal with UNIX-like filename
\index{wild-card patterns}wild-card patterns containing *, ?, and
[...], as found in
the UNIX shells csh and sh; they are described briefly in the
\texttt{wild\_pat()} procedure. 
Recursive suspension is used to simulate conjunction of an arbitrary number of
computed expressions.
Default values of \texttt{s}, \texttt{i1}, and \texttt{i2} are the same
as for Icon's built-in string scanning procedures such
as \texttt{match()}.
The public procedures are:

\texttt{wild\_match(pattern,s,i1,i2) : integer*} produces the sequence
of positions in \texttt{s} past a substring starting at \texttt{i1}
that matches \texttt{pattern}, but fails if there is no such position.
Similar to \texttt{match()}, but is capable of generating multiple
positions.

\texttt{wild\_find(pattern,s,i1,i2) : integer*} produces the sequence of
positions in \texttt{s} where substrings begin that match
\texttt{pattern}, but fails if there is no such position. Similar to
\texttt{find()}. \texttt{pattern} can be either a string or a pattern
list, see \texttt{wild\_pat()}, below.

\texttt{wild\_pat(s) : L} creates a pattern element list from pattern
string \texttt{s}. A pattern element is needed by
\texttt{wild\_match()} and \texttt{wild\_find()}.
\texttt{wild\_match()} and \texttt{wild\_find()} will automatically
convert a pattern string to a pattern list, but it is faster to do the
conversion explicitly if multiple operations are done using the same
pattern.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{word}\hfill (RJA)}

String scanning function \texttt{word(s, i1, i2) : integer?} produces
the position past a UNIX-style command line word, including quoted and
escaped characters.

\texttt{word\_dequote(s) : string} produces the UNIX-style command line
word \texttt{s} with any quoting characters removed.
Links: \texttt{scanset}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{wrap}\hfill (RJA)}

\index{wrap}\texttt{wrap}\texttt{(s:"",i:0)
: string?} accumulates small strings into longer ones,
writing when the accumulated string would exceed a
specified length.
\texttt{s} is the string to accumulate, \texttt{i} is the width of
desired output string. \texttt{wrap()} fails if the string \texttt{s}
did not necessitate output of the buffered output string; otherwise the
output string is returned (which never includes \texttt{s}). Calling
\texttt{wrap()} with no arguments produces the buffer (if it is not
empty) and clears it. \texttt{wrap()} does no output to files.
Here's how \texttt{wrap()} is normally used:

\iconcode{
wrap() \# Initialize; not needed unless there was a previous use. \\
every i := 1 to 100 do \# Loop to process strings to output -{}-  \\
\>   write(wrap(x[i],80)) \# only writes when 80-char line filled. \\
write(wrap()) \# Output what's in buffer, if something
to write.
}

\texttt{wraps(s,i) : string?} is similar to \texttt{wrap()}, but
intended for use with \texttt{writes()}. If the string \texttt{s} did
not necessitate a line-wrap, \texttt{s} is returned. If a line-wrap is
needed, \texttt{s}, preceded by a new-line character
(\texttt{"{\textbackslash}n"}), is
returned.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xcodes}\hfill (RJA, REG)}

The \index{xcodes}\texttt{xcodes} module provides procedures to save
and restore structures to disk. Records are encoded
using canonical names: record0, record1, ... This allows
programs to decode files by providing declarations for these names when
the original declarations are not available. \texttt{xcodes} also
provides for procedures and files present in the encoded file that are
not in the decoding program.

\texttt{xencode(x,f)} stores \texttt{x} in file
\texttt{f} such that it can be converted back to \texttt{x} by
\texttt{xdecode(f)}. The procedures handle most kinds of values,
including structures of arbitrary complexity including cycles. The
following sequence will output \texttt{x} and recreate it as
\texttt{y}:

\begin{tabular}{m{3.0in}m{3.0in}}
\texttt{f := open("xstore","w")} & \texttt{f := open("xstore")} \\
\texttt{xencode(x,f)}            & \texttt{y := xdecode(f)} \\
\texttt{close(f)}                & \texttt{close(f)} \\
\end{tabular}

\noindent For scalar types (null, integer,
real, cset, and string), this sequence results in the relationship
\texttt{x === y}. For structured types (list, set, table, record and object),
\texttt{y} has the same
shape as \texttt{x} and its elements bear the same
relation to the original as if they were encoded and decoded
individually. Files, co-expressions, and windows are not handled;
they decode as empty lists, with the exception of the special files
\texttt{\&input}, \texttt{\&output}, and \texttt{\&errout}.
Functions and procedures only
preserve type and identification. \texttt{xdecode()} fails if given a file
that is not in xcode format or if the encoded file contains a record
for which there is no declaration in the program in which the decoding
is done. If a record is declared differently in the encoding
and decoding programs, the decoding may be bogus.

\texttt{xencoden()} and \texttt{xdecoden()} perform the same operations,
except they take the name of a file to open, not an already-open file.

\texttt{xencodet()} and \texttt{xdecodet()} are like \texttt{xencode()}
and \texttt{xdecode()} except that the trailing argument is a type
name. If the encoded decoded value is not of that type, they fail.
\texttt{xencodet()} does not take an opt argument. 

\texttt{xencode(x, f:\&output, p:write) : f} encodes \texttt{x} writing
to file \texttt{f} using procedure \texttt{p}. \texttt{p} uses
the same interface as \texttt{write()} (the first
parameter is always the value passed as \texttt{f}).

\texttt{xdecode(f:\&input, p:read) : x} returns the restored object
where \texttt{f} is the file to read, and \texttt{p} is a procedure
that reads a line from f using the same interface as \texttt{read()}.

If \texttt{p} is provided to \texttt{xencode()}, then \texttt{f} can be any
arbitrary data object -{}- it need not be a file. For example, to
``write'' \texttt{x} to a string:

\iconcode{
record StringFile(s) \\
procedure main() ... \\
\>   encodeString := xencode(x,StringFile(""),WriteString).s \\
\>   ... \\
end \\
procedure WriteString(f,s[]) \\
\>   (every f.s {\textbar}{\textbar}:= !s);
       f.s {\textbar}{\textbar}:= "{\textbackslash}n" \\
\>   return \\
end
}

Links: \texttt{escape}. See also: \texttt{object.icn},
\texttt{codeobj.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xforms}}

These procedures produce matrices for affine transformation in two
dimensions and transform point lists. A point list is a list of
\texttt{Point()} records.

\texttt{transform(p:list, M) : list} transforms a point list by
matrix\\
\texttt{transform\_points(pl:list,M)} transforms point list\\
\texttt{set\_scale(x, y) : matrix} produces a matrix for scaling\\
\texttt{set\_trans(x, y) : matrix} produces a matrix for
translation\\
\texttt{set\_xshear(x) : matrix} produces a matrix for x shear\\
\texttt{set\_yshear(y) : matrix} produces a matrix for y shear\\
\texttt{set\_rotate(x) : matrix} produces a matrix for rotation

Links: \texttt{gobject}. See also: \texttt{matrix}. (SBW, REG)

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ximage}\hfill (RJA)}

\texttt{ximage(x) : s} produces a string image of \texttt{x}.
\texttt{ximage()} differs from \texttt{image()} in that it outputs all
elements of \index{structure types}structured data types. The output
resembles Icon code and is thus familiar to Icon programmers.
Additionally, it indents successive structural levels in such a way
that it is easy to visualize the data's structure.
Note that the additional arguments in the \texttt{ximage()} procedure
declaration are used for passing data among recursive levels. 

\texttt{xdump(x1,x2,...,xn) : xn} uses \texttt{ximage()} to
write \texttt{x1, x2, ..., xn} to \texttt{\&errout}.
% For example, the code

%\iconcode{
%\>   t := table() ; t["one"] := 1 ; t["two"] := 2 \\
%\>   xdump("A table",t) \\
%\>   xdump("A list",[3,1,3,[2,4,6],3,4,3,5])
%}

%\noindent
%writes the following output (note that \texttt{ximage()} infers the
%predominant list element value and avoids excessive output):

%\iconcode{
%"A table" \\
%T18 := table(\&null) \\
%T18["one"] := 1 \\
%T18["two"] := 2 \\
%"A list" \\
%L25 := list(8,3) \\
%L25[2] := 1 \\
%L25[4] := L24 := list(3) \\
%L24[1] := 2 \\
%L24[2] := 4 \\
%L24[3] := 6 \\
%L25[6] := 4 \\
%L25[8] := 5
%}


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xrotate}}

\texttt{xrotate(X, i)} rotates the values in \texttt{X} right by one
position. It works for lists and records. This procedure is mainly
interesting as a recursive version of\\
 \ \ \ \ \ \texttt{x1 :=: x2 :=: x3 :=: ... xn}\\
\noindent since a better method for lists is \texttt{push(L, pull(L))}. 


\section{Application Programs, Examples, and Tools}

The Icon Program Library \texttt{progs} directory contains 200+ programs that
are useful for demonstration, entertainment, and/or practical utility.
Highlights of usage information is presented with [optional] and repeated*
command-line arguments.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{adlcheck,
 adlcount, adlfilter, adlfirst, adllist, adlsort}

This suite of address-list tools works on ``address list files'' and
includes a correctness checker, a counter, a filterer, a lister, and
a sorter.  Read the source code for a description of these programs'
many command line options. See also: address.doc, labels.icn.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{animal \hfill (RJA)}}

\texttt{animal} is the familiar "animal
game". The program asks the user
a series of questions in an attempt to guess what animal he or
she is thinking of. This expert system gets smarter as it plays.
Typing "list" at any yes/no
prompt will show an inventory of animals known, and there are some
other commands too. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{banner \hfill (CT)}}

\texttt{banner} is a utility that outputs enlarged letters (5x6 matrix) in
portrait mode.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{bj \hfill (CT, RLG)}}

\texttt{bj} is a simple but fun blackjack game. The original version was
for an ANSI screen. This version has been modified to work with the
UNIX termcap database file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{blnk2tab}}

\texttt{blnk2tab} is a UNIX-style filter that converts strings of two or
more blanks to tabs.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{c2icn \hfill (RJA)}}

The \texttt{c2icn} filter does easy work involved in porting a C
program to Icon. It reformats \index{comment}comments, moves embedded
comments to end of line, removes ";"
from ends of lines, reformats line-continued strings, changes
\texttt{=} to \texttt{:=}, and changes \texttt{{}-{\textgreater}} to
\texttt{.} 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{calc}}

\texttt{calc} is a simple Polish "desk calculator". It accepts as values
integers, reals, csets, and strings, as well as
an empty line for the null value. Other lines of input are operations,
either binary operators, functions, or one of:
\texttt{clear} (remove all values from the
calculator's \index{stack}stack), \texttt{dump} (write out the contents of the stack), or \texttt{quit} (exits from the calculator).
Failure and most errors are detected; arguments are consumed and not
left on the stack.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{chkhtml \hfill (RJA)}}

This program checks an \index{HTML}HTML file and detects the following
errors: Reference to undefined anchor name; duplicated anchor name;
warning for unreferenced anchor name; unknown tag; badly formed tag;
improper tag nesting; unescaped {\textless}, {\textgreater}, ", or \&;
bad escape string; improper embedding of attributes; and
bad (non-\index{ASCII}ASCII) characters.
The program also advises on the use of
\texttt{{\textless}HTML{\textgreater}},
\texttt{{\textless}HEAD{\textgreater}}, and
\texttt{{\textless}BODY{\textgreater}} tags. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{
colm \ \textrm{\textmd{[-w linewidth] [-s space] [-m min\_width] [-t
tab\_width] [-x] [-d] file*}} \hfill (RJA)}}

\texttt{colm} arranges a number of data items, one per line, into
multiple columns. Items are arranged in column-wise order, that is, the
sequence runs down the first column, then down the second, etc. If a
null line appears in the input stream, it signifies a break in the
list, and the following line is taken as a title for the following data
items. No title precedes the initial sequence of items.  See the program
source code for command line options interpretation.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{comfiles}}

\texttt{comfiles} lists common file names in two directories given as
command-line arguments. Requires: UNIX 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{concord}}

\texttt{concord} produces a simple concordance from standard input to
standard output. Words less than three characters long are ignored.
Option \texttt{{}-l n} sets maximum line length to
n (default 72), after which \texttt{concord} starts a new line. Option
\texttt{{}-w n} sets the maximum width for word to \texttt{n}
(default 15), after which words are truncated.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{conman \hfill (WED)}}

\texttt{conman} responds to queries like "? Volume of the
earth in tbsp". The commands (which are
not reserved) are: \texttt{load, save, print, ?} (same as print),
\texttt{list, is, are} (same as is).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{countlst}}

\texttt{countlst} counts how many times each line of input occurs and
writes a summary. By default, the output is sorted first by
decreasing count and within each count, alphabetically. Option
\texttt{{}-a} causes output to be sorted alphabetically;
\texttt{{}-t} prints a total at the end.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{cross \hfill (WPM)}}

\texttt{cross} takes a list of words and tries to arrange them in
crossword format so that they intersect. Uppercase letters are mapped
into lowercase letters on input. The program objects if the input
contains a nonalphabetic character. It produces only one % possible
intersection.
%and it does not attempt to produce the most compact result. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{crypt \ \ \textrm{\textmd{[key] {\textless}infile
{\textgreater}outfile \hfill (PB, PLT)}}}}

\texttt{crypt} is an example \index{encryption}encryption program. Do
\textit{not} use this in the face of competent cryptanalysis. Helen
Gaines' book (Gaines, 1939) is a classical
introduction to the field.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{csgen}}

\texttt{csgen} takes a context-sensitive production grammar and
generates random sentences from the corresponding language.
Uppercase letters are nonterminal symbols and
\texttt{{}-{\textgreater}} indicates the left-hand side can be
rewritten by the right-hand side. Other characters are considered to be
terminal symbols. Lines beginning with \texttt{\#} are
ignored. A line with a nonterminal symbol \texttt{S} followed by a colon
and an integer \texttt{i} specifies generation of \texttt{i}
sentences for the language with start symbol \texttt{S}.
See the source code for details and explanation.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{cstrings \hfill (RJA)}

\texttt{cstrings} prints all strings (enclosed in double quotes) in C
source files. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{daystil \hfill (NL)}

\texttt{daystil} calculates the number of days between the
current date and the date given on the command line, which may
be specified in many ways. For example,
August 12 can be specified as "August 12", "Aug 12", "12 August", or
"12 aUGuS", among others.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{deal}}

\texttt{deal [-h n:1]} shuffles, deals, and displays \texttt{n}
hands in the game of bridge.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{declchck}}

\texttt{declchck} examines ucode files and reports declared identifiers
that may conflict with function names. Requires: UNIX. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{delamc \hfill (TRH)}

\texttt{delamc} delaminates standard input into several output files
according to the separator characters specified by the string following
the -t option (default: tab). All output files contain the same number
of lines as the input file.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{detex \hfill (CLJ)}

\texttt{detex} reads in documents written in the \index{LaTeX}LaTeX
typesetting language, and removes some of the common LaTeX commands to
produce plain \index{ASCII}ASCII. Output must typically be further
edited by hand to produce an acceptable result.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffn \ \ \textrm{\textmd{file*}} \hfill (RJA)}}

\texttt{diffn} shows the \index{diff}differences between n files.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffsum \ \ \textrm{\textmd{[file]}} \hfill (GMT)}}

\texttt{diffsum} reads output from the Unix
\texttt{diff(1)} utility, either normal diffs or
context diffs. For each pair of files compared, diffsum reports two
numbers: The number of lines added or changed, and the net change in
file size. The first of these indicates the magnitude of the changes
and the second the net effect on file size. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffu \ \
\textrm{\textmd{f1 f2}} \hfill (RM)}}

\texttt{diffu} uses \texttt{dif()} to generate file
differences like the UNIX \texttt{diff(1)} command.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diffword}}

\texttt{diffword} lists the different words in the input. The
definition of "word" is naive. 

% \vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{diskpack}}

% \texttt{diskpack} is designed to produce a list of files to fit onto
% \index{diskettes}diskettes. It can be adapted to other uses. This
% program uses a straightforward, first-fit algorithm. The options
% supported are:\\
% \ \ \texttt{{}-s i}\ \ diskette capacity, default 360000\\
% \ \ \texttt{{}-r i}\ \ space to reserve on first diskettes, default
% 0\\
% \ \ \texttt{{}-n s}\texttt{\ \ }UNIX-style file name specification for
% files to be packed, default "*.lzh"

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{duplfile}}

\texttt{duplfile} lists the file names that occur in more than one
subdirectory and the subdirectories in which the names occur. This
program runs slow on large directory structures.

% \vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{duplproc \hfill (RLG)}}

% Use \texttt{duplproc} if you plan on posting utility procedures suitable
% for inclusion in someone's Icon library directories.
% duplproc.icn compiles into a program that will search through every
% directory in your ILIBS \index{environment variable!ILIBS}environment
% variable (and/or in the directories supplied as arguments to the
% program). If it finds any duplicate procedure or record identifiers, it
% will report this on the standard output. It is important to try to use
% unique procedure names in programs you write, especially if you intend
% to link in some of the routines contained in the IPL. BUG: duplproc
% thinks that differently written names for the same directory are in
% fact different directories. Use absolute path names, and
% you'll be fine.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{envelope \ \texttt{\textmd{[options] {\textless}
address(es) \hfill (RF)}}}}

\texttt{envelope} addresses envelopes on a \index{PostScript}PostScript
or HP-LJ printer, including barcodes for the zip code. A line beginning
with \texttt{\#} or an optional alternate separator can be used to
separate multiple addresses. The parser will strip the formatting
commands from an address in a troff or LaTeX letter. Typically,
\texttt{envelope} is used from inside an \index{editor}editor. In
Emacs, mark the region of the address and do \texttt{M-{\textbar}
envelope}. In vi, put the cursor on the first line of the address and
do \texttt{:,+N w !envelope} where N = number-of-lines-in-address.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{farb, farb2}}

Dave \index{Farber, Dave}Farber, co-author of the original SNOBOL
programming language, is noted for his creative use of the English
language. Hence the terms "farberisms" and
"to farberate". This program produces a randomly selected farberism.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filecnvt \ \textrm{\textmd{[\texttt{-i} s1] [\texttt{-o} s2]}} infile
outfile \hfill (BW)}}

\texttt{filecnvt} copies a text file, converting line terminators.
Option \texttt{{}-i s1} indicates the
input file line termination system (default \texttt{"u"}). Option
\texttt{{}-o s2} directs output to use line terminators for
system \texttt{s2} (default \texttt{"u"}).
The designations are {\tt d} (DOS/Windows
\texttt{"{\textbackslash}n{\textbackslash}r"}), {\tt m} (Macintosh
\texttt{"{\textbackslash}r"}), and {\tt u} (UNIX \text{"{\textbackslash}n"}).

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fileprnt}}

\texttt{fileprnt} reads the file specified as a command-line argument
and writes out a representation of each character in several forms:
hex, octal, decimal, symbolic, and \index{ASCII}ASCII.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filesect}}

\texttt{filesect \emph{start nlines}}
writes the section of the input file starting at a
line number and extending some number of lines. If the
specifications are out of range, the file is truncated.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{filtskel \hfill (RJA)}

\texttt{filtskel} is a skeleton/template for
creation of filter programs. Command line options, file names, and
tabbing are handled; you need only provide the filtering code.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{findstr \hfill (RJA)}}

\texttt{findstr} is a utility filter to list character strings embedded
in data files such as object files. The option
\texttt{{}-l length} gives the minimum string size to be printed (default
3); option
\texttt{{}-c chars} specifies a string of characters (besides the standard
ASCII printable characters) to be considered part of a string.  String
escape sequences can be used.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{findtext \hfill (PLT)}}

\texttt{findtext} retrieves multiline text from a
\index{database}database indexed by idxtext. Each section of text lines
follows a line declaring the index terms.
Each index line begins with "::".

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fixpath \ \textrm{\textmd{filename oldpath
newpath}} \hfill (GMT)}

\texttt{fixpath} changes file paths or other strings in a binary file by
modifying the file in place. Each null-terminated occurrence of
\texttt{oldpath} is replaced by \texttt{newpath}. If the new path is
longer than the old one, a warning is given and the old path is
extended by null characters, which must be matched in the file for
replacement to take place. % This is dangerous in general but allows
% repairing an errant fixpath command. 


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{format \hfill (RJA)}

\texttt{format} is a filter program that word-\index{wrap}wraps a range
of text. Options include full justification.
All lines that have the same indentation as the first line (or same
comment leading character format if \texttt{-c} option) are wrapped. Other lines
are left as is. This program is useful in conjunction with editors that
can invoke filters on a range of selected text.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{former}}

\texttt{former} takes a single line of input and outputs it in lines no
greater than the number given on the command line (default 80). 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fract \hfill (REG, GMT)}}

\texttt{fract} produces successive rational approximations to a real
number. The option \texttt{{}-n r} specifies the real number to be
approximated, default .6180339887498948482. Option
\texttt{{}-l i} gives the limit on number of approximations, default 100.
%This program was based on a calculator algorithm posted by: Joseph D.
%Rudmin, Duke Univ. Physics Dept., 1987.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{fuzz \hfill (AC)}

\texttt{fuzz} does "fuzzy" string
\index{pattern matching}pattern matching. The result of matching {\tt s} and
{\tt t} is a number between 0 and 1, based on counting matching pairs of
characters in increasing substrings of {\tt s} and {\tt t}. Characters
may be weighted differently.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gcomp \hfill (WHM, REG)}

\texttt{gcomp} produces a list of the files in the current directory that do not
appear among the arguments. For example, \texttt{gcomp *.c} produces a list of
files in the current directory that do not end in \texttt{.c}. Requires: UNIX.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{genqueen \hfill (PAB)}

\texttt{genqueen \emph{n}} solves the non-attacking \index{n-queens}n-queens
problem for (square) boards of arbitrary size. The problem consists of
placing chess queens on an n-by-n grid such that no queen is in the
same row, column, or diagonal as any other queen. The output is each of
the solution boards; rotations not considered equal.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{gftrace \hfill (GMT)}}

\texttt{gftrace} writes a set of procedures to standard output. Those
procedures can be linked with an Icon program to enable the
\index{tracing}tracing of calls to built-in functions. See the comments
in the generated code for details. The set of generated functions
reflects the built-in functions of the version of Icon under which this
\index{generator}generator is run. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{graphdem \hfill (MH)}

\texttt{graphdem} is a simple bar graphics package with two
demonstration applications. The first displays the 4 most frequently
used characters in a string; the second displays the Fibonacci numbers.
Requires: ANSI terminal support.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{grpsort \hfill (TRH)}

\texttt{grpsort} sorts input containing
"records" defined to be groups of
consecutive lines. One or more
repetitions of a demarcation line beginning with the separator
string separate each input record. The first line of each record is
used as the key. The separator string defaults to
the empty string; empty lines are default
demarcation lines.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{headicon}}

\texttt{headicon} prepends a standard header to an Icon program. It does
not check to see if the program already has a header. The first
command-line argument is taken as the base name of the file; default
"foo". The second command-line argument is
taken as the author; the default is \texttt{"Ralph E.
Griswold"} -{}- but you can personalize it for your own
use. The new file is brought up in the vi \index{editor}editor. The
file \texttt{skeleton.icn} must be accessible via \texttt{dopen()}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{hebcalen,hcal4unx
\hfill (ADC, RLG)}

The Jewish year harmonizes the solar and lunar cycle, using the 19-year
cycle of Meton (c. 432 BCE).
Startup syntax is \texttt{hebcalen [date]}, where
\texttt{date} is a year specification of the form 5750 for a Jewish
year, +1990 or 1990AD or 1990CE or -1990 or 1990BC or 1990BCE for a
civil year. \ Requires: \index{keyboard}keyboard functions,
\texttt{hebcalen.dat}, \texttt{hebcalen.hlp}.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{hr \hfill (CT)}

\texttt{hr} implements a horse-race game.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ibar}}

\texttt{ibar} replaces \index{comment}comment bars by
bars 76 characters long, the IPL standard. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ibrow \hfill (RJA)}

\texttt{ibrow} browses Icon files for declarations, defaulting to browse
all \texttt{*.icn} files in the current directory.
The user interface is self-explanatory -{}- use "?" for help if
you're confused.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icalc \hfill (SBW)}

\texttt{icalc} is an infix calculator with control structures and
compound statements.
% It illustrates a technique that can greatly reduce the performance cost of
%recursive-descent parsing with \index{backtracking}backtracking.
Features include: integer and real value arithmetic; variables;
function calls to built-in functions; strings allowed as function arguments;
unary operators + (absolute value) and - (negation); assignment := ;
binary operators: +, -, *, /, \%, and \^{};
relational operators: =, !=, {\textless}, {\textless}=,
{\textgreater}, {\textgreater}= (use 1 for true and 0 for false);
compound statements in curly braces with semicolon separators;
if-then and if-then-else; while-do; and limited multiline input.
The input is processed one line
at a time, in calculator fashion, but compound statements can be
continued across line boundaries.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icalls}}

\texttt{icalls} processes trace output and tabulates calls of
procedures.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icn2c \hfill (RJA)}

\texttt{icn2c} partially converts Icon to C. It
reformats comments, line-continued strings and procedure declarations,
changes \texttt{:=} to \texttt{=,} and changes \texttt{end} to
\texttt{"\}"}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icontent \ \textmd{{\textless}options{\textgreater}
{\textless}Icon source file{\textgreater}...} \hfill (RJA)}}

\texttt{icontent} builds a list, in Icon comment format, of procedures
and records in an Icon source file. \ Multiple files can be specified
as arguments, and are processed in sequence. Option
\texttt{{}-s} specifies to sort names alphabetically (default is in order of
occurrence); option
\texttt{{}-l} lists in single column (default is to list in multiple
columns).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{icvt \hfill (CW, REG)}

\texttt{icvt} converts Icon programs from \index{ASCII}ASCII syntax to
\index{EBCDIC}EBCDIC syntax or vice versa. The option \texttt{{}-a}
converts to ASCII, while the option \texttt{{}-e} converts to EBCDIC.
The program given in standard input is written in converted form to
standard output. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{idepth}}

\texttt{idepth} processes trace output and reports the maximum depth of
\index{recursion}recursion. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{idxtext \
\texttt{\textmd{[-a] file1 [file2 [...]]}} \hfill (RLG, PLT)}}

\texttt{idxtext} turns a file associated with the \texttt{gettext()}
routine into an indexed text-base. Though \texttt{gettext()} will work
fine with files that haven't been indexed via
\texttt{idxtext()}, access is faster if the indexing is done if the
file is, say, over 5k or 10k.
\texttt{file1, file2}, etc. are the names of \texttt{gettext}{}-format
files that are to be (re-)indexed. The \texttt{{}-a} flag tells
\texttt{idxtext} to abort if an index file already exists. Indexed
files have the format: \\
\ \ \ 
\texttt{keyname delimiter offset [delimiter offset [etc.]]{\textbackslash}n.}


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ifilter} op}

\texttt{ifilter} applies the operation given on the command-line
to each line of standard input, writing the results. For example,
\texttt{ifilter reverse {\textless}foo} writes the lines of foo
reversed end-for-end, while
\texttt{ifilter right 10 0 {\textless}foo}
calls {\tt right(line, "10", "0")} for each line of foo.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{igrep \hfill (RJA)}}

\texttt{i}\index{grep}\texttt{grep} emulates UNIX egrep using the
enhanced regular expressions supported by \texttt{regexp.icn}. Options
are nearly identical to those supported by egrep (no -b:
print disk block number). The option \texttt{-E} allows Icon-type
(hence C-type) string escape sequences in the pattern string. Beware:
when \texttt{-E} is used, backslashes that are meant to be processed in the
regular expression context must be doubled.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iheader}}

\texttt{iheader} lists the headers of Icon files whose names are given
on the command line.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ihelp \ \textrm{\textmd{[-f helpfile] [item] [keyword
...]}}\hfill (RJA)}}

\texttt{ihelp} displays help information. The optional item name
specifies the section of the help file that is to be displayed. If no
item name is specified a default section will be displayed, which
usually lists the help items that are available.


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iidecode \ \textrm{\textmd{[infile] [-x]}}, iiencode
\ \textrm{\textmd{[infile] [-x] remotefile [-o outfile]}} \hfill (RLG, FJL)}}

These are Icon ports of the UNIX/C uudecode/\index{uuencode,
uudecode}uuencode utilities, based on freely distributable BSD code.
File modes are always encoded with 0644 permissions. An option
specifies xxencoded files (like uuencoding, but passes
unscathed through \index{EBCDIC}EBCDIC sites).


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ilnkxref \ \textrm{\textmd{[-options] {\textless}icon source
file{\textgreater}... \hfill }}(RJA)}

\texttt{ilnkxref} is a utility to create
\index{cross-reference}cross-reference of library files used in Icon
programs (i.e., those files named in \index{link}link declarations).
Requires: UNIX. Option \texttt{{}-p} specifies to sort by
"popularity"; option \texttt{{}-v} tells the program to
report progress information

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ilump}}

\texttt{ilump} copies Icon source files, incorporating
recursively the \index{source code}source code for files named by link
directives. This produces a whole source program in one file,
useful with certain profiling and visualization tools.
If a linked file is not found in the current directory,
directories specified by the LPATH \index{environment
variable!LPATH}environment variable are tried.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{imagetyp}}

\texttt{imagetyp} accepts file names from standard input and writes
their image type to standard output. It relies on a procedure
\texttt{imagetyp(s)} that attempts to determine the type of image file
named \texttt{s}. Corrupted or fake files
easily fool it. Examples of some image file types were not
available for testing. % The types presently recognized are:

%\vspace{0.15in}
%\begin{xtabular}{m{0.5in} m{1.2in} m{0.9in} m{3.1in}}
%Value & Image file type & Value & Image file type\\
%xpm &  XPM image & ps & \index{PostScript}PostScript document\\
%pgm &  PGM image & cgm char & Computer Graphics Metafil, character\\

% ?  & unknown & cgm text & Computer Graphics Metafil, text \\
%iris &  Iris image &
%sundraw & SunDraw document \\

%pbm &  PBM image &
%cgm binary & Computer Graphics Metafil, binary \\
%ppm &  PPM image & xwd &  X Window dump \\
%bmp &  BMP image & gif &  Compuserv GIF image \\
%xmp &  XMP image & ras & UNIX raster image \\
%pcx &  PCX image &rle &  UNIX RLE image \\
%tiff &  TIFF image & iff &  IFF/ILBM image \\
%\end{xtabular}

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ineeds \hfill (RJA)}}

\texttt{ineeds} determines Icon modules required by an Icon module. It
expects environment variable LPATH to be set properly as for the Icon
Compiler.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{inter}}

\texttt{inter} lists lines common to two files. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{interpe, interpp\hfill (REG, JN)}}

\texttt{interpe} is a crude but effective interpreter for Icon
expressions.
% Each line entered from standard input must be an Icon expression.
If the expression is a \index{generator}generator, all its results are
produced. If option \texttt{-e} is given, the expression is echoed.

\texttt{interpp} takes expressions prefixed with line numbers.
You can resequence, list, and execute lines in order.
Retype a line to change it. Use "?" to list the other commands. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipatch \ \textrm{\textmd{file
path\hfill }(GMT)}}}

\texttt{ipatch} changes the path to iconx, the Icon interpreter, which
is embedded in an Icon executable file under Unix. Because the headers
of such files are not designed to expand, a different form of header is
written to accommodate a possibly longer path.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipldoc}}

\texttt{ipldoc} collects selected information from documentation headers
for Icon procedure files named on the command line.
Option \texttt{{}-s} skips file headers; option
\texttt{{}-f} sorts the procedure list by file, instead of the default sort by
procedure name.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iplindex \
\textrm{[-k i:16] [-p i:12]}\hfill (REG, SBW)}}

\texttt{iplindex} produces an indexed listing of the Icon Program
Library. Option \texttt{{}-k i} gives the width keyword field;
option \texttt{{}-p i} specifies the width of field for program name.
If a file \texttt{except.wrd} is readable in the current directory,
the words in it are used instead. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iplkwic\hfill (SBW, REG)}}

\texttt{iplkwic} is a specialized version of \texttt{kwic.icn} used for
producing kwic listings for the Icon program library. This is a simple
keyword-in-context (\index{KWIC}KWIC) program. The
"key" words are aligned at a specified
column, with the text shifted as necessary. Text shifted left is
truncated at the left. Tabs and other special characters
may not be handled properly.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iplweb \ \textrm{\textmd{[-ipl source] [dest]}}\hfill (JK)}}

\index{iplweb}\texttt{iplweb} generates web pages from IPL header
\index{comment}comments. \index{environment
variable!IPL}Environment variable \texttt{IPL} locates the Icon
Program Library if \texttt{{}-ipl} is not specified;
\texttt{dest} defaults to the current directory.
\texttt{iplweb} generates an \index{HTML}HTML subdirectory in
\texttt{dest} and makes an index to \texttt{gprogs}, \texttt{gprocs},
\texttt{procs}, and \texttt{progs} directories under HTML.
These directories contain an \texttt{.html} file for each
\texttt{.icn} file in the referenced directory. An index to all
files is also generated. The \texttt{.html} files
contain the IPL standard comment header info inside.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iprint \hfill (RJA)}}

\texttt{iprint} formats Icon programs, trying to keep whole
procedures on the same page. It identifies the end of a
print group (e.g. procedure) by looking for the string
(defaulting to "end") at the beginning of a line.
Comments and declarations prior to the procedure are
grouped with the procedure.
Page creases are skipped over, and form-feeds (\^{}L) embedded in the
file are handled properly. Page headings (file
name, date, time, page number) are printed unless suppressed by the
\texttt{{}-h} option.  See the program source code for details.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipsort}}

\texttt{ipsort} reads an Icon program and writes an equivalent program
with the procedures \index{sort source file procedures} reordered.
Global, link, and record declarations come first and aren't reordered.
The \texttt{main()} procedure comes
next followed by the remaining procedures in alphabetical order.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipsplit}}

\texttt{ipsplit} reads an Icon program and writes each procedure to a
separate file. The output file names consist of the procedure name with
\texttt{.icn} appended. If \texttt{{}-g} is specified, any global,
link, and record declarations are written to that file. Otherwise they
are written in the file for the procedure that immediately follows
them.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ipxref [file] \hfill (AJA)}}

\texttt{ipxref} \index{cross-reference}cross-references Icon programs.
It lists the occurrences of each variable by line number. Variables are
listed by procedure or separately as globals. % The options specify the
%formatting of the output and whether or not to cross-reference quoted
%strings and non-alphanumerics.
Variables that are followed by a left
parenthesis are listed with an asterisk following the name. If a file
is not specified, then standard input is used. The
following options change the defaults:\\
\ \ \texttt{{}-c n}\ \ The column width (default:4) per line
number.\\
\ \ \texttt{{}-l n}\ \ The left margin or starting column (default: 40)
of the line numbers.\\
\ \ \texttt{{}-w n}\ \ The column width (default: 80) of the whole
output line.\\
\noindent Normally only alphanumerics are cross-referenced. Two options broaden
it:\\
\ \ \texttt{{}-q}\ \ Include quoted strings.\\
\ \ \texttt{{}-x}\ \ Include all non-alphanumerics.\\
\noindent This program assumes the subject file is a valid Icon program.
% For example, it expects quotes be matched.
%Bugs: In some situations, the output is not properly formatted.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{isrcline}}

\texttt{isrcline} counts the number of lines in an Icon program that
actually contain code, as opposed to being comments or blank lines.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{istrip}}

\texttt{istrip} removes comments, empty lines, and leading spaces
from an Icon program.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itab \ \textrm{\textmd{[options]
[source-program...]}}\hfill (RJA)}}

\texttt{itab} entabs an Icon program, leaving quoted strings alone. The
options are:\\
\texttt{{}-i}\ \ Input tab spacing (default 8)\\
\texttt{{}-o}\ \ Output tab spacing (default 8).\\
\texttt{itab} observes Icon conventions for escapes and continuations in
string constants. If no source-program names are given, standard input
is "itabbed" to standard output.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itags \ \textrm{\textmd{[-aBFtvwx] [-f tagsfile]
file...}} \hfill (RJA)}}

\texttt{itags} creates a tags file for an Icon program. The options
are:\\
\ \ \texttt{{}-a}\ \ append output to an existing tags file.\\
\ \ \texttt{{}-B}\ \ use backward searching patterns (?...?).\\
\ \ \texttt{{}-F}\ \ use forward searching patterns (/.../)
(default).\\
\ \ \texttt{{}-x}\ \ produce object names, the line number and
file name on which each is\\
\ \ \ \ defined, as well as the text of that line and prints this on the
standard output.\\
%\ \ \ \ This simple index can be printed out as an off-line readable
%function index.\\
\ \ \texttt{{}-t}\ \ create tags for records.\\
\ \ \texttt{{}-v}\ \ produce on the standard output an index of the form
expected by vgrind(1).\\
\ \ \ \ This listing contains the function name, file name, and page number
(assuming\\
\ \ \ \ 64 line pages). Since the output will be sorted into lexicographic
order,\\
\ \ \ \ it may be desired to run the output through \texttt{sort -f}. \\
% Sample use:\\
%\ \ \ \  \ \ \ \texttt{itags -v files {\textbar} sort -f {\textgreater}
%index vgrind -x index}\texttt{\\
\ \ \texttt{{}-w}\ \ suppress warning diagnostics.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itrbksum}}

\texttt{itrbksum} summarizes traceback information produced on error
termination by filtering out the bulk of the procedure traceback
information.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itrcfltr [procs]}}

\texttt{itrcfilter} filters trace output. Command-line
arguments are procedure names, and only lines with
those names are written.
The names of procedures to pass through can be given
in a "response" file as accepted by
\texttt{options()}, as in\\
\ \ \texttt{itrcfltr @names {\textless}trace\_file}\\
\noindent
where \texttt{names} is a file containing the names to be passed
through. The option \texttt{{}-a} lists all
trace messages; it overrides any procedure names given.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{itrcsum}}

\texttt{itrcsum} provides a summary of Icon trace output.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iundecl [files]\hfill (RJA, REG)}}

\texttt{iundecl} invokes {\tt icont} to find undeclared variables in an Icon
program. The output is in the form of a
\texttt{local} declaration, preceded by a comment
line that identifies the procedure and file name from whence it arose.
Undeclared variables aren't necessarily
local; any intended to be global must be removed from the
generated list.
The program works only if
the reserved words \texttt{procedure} and \texttt{end} are the first
words on their respective lines.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{iwriter}}

\texttt{iwriter} reads \texttt{\&input} and writes code
that when compiled and executed, writes out the original input. This is
handy for incorporating message text in programs.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{knapsack\hfill (AVH)}}

\texttt{knapsack} is a filter that solves a knapsack problem - how to
fill a container to capacity by inserting items of various volumes. Its
input consists of a string of newline-separated volumes. Its output is
a single solution. knapsack demonstrates an underlying
algorithm that might be useful in a variety of real-world applications.
Knapsack may be tested conveniently by supplying its
standard input with any sequence of random numbers. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{krieg\hfill (DJS)}}

Kriegspiel ("war game") implements a variation of chess
which has the same rules and goal as ordinary chess except that neither
player sees the other's moves or pieces. %Kriegspiel combines the
%intricacies and flavor of chess with elements of uncertainty that
%characterize games of imperfect information such as bridge or poker.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{kross\hfill}}

\texttt{kross} accepts pairs of strings on successive lines. It diagrams
all the intersections of the two strings in a common character. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{kwic, kwicprep\hfill (SBW, REG)}}

\texttt{kwic} is a simple keyword-in-context \index{KWIC} program. The
"key" words are aligned in column 40, with
the text shifted as necessary. Text shifted left is truncated.
Tabs and other characters whose "print
width" is less than one may not be handled properly. If
an integer is given on the command line, it overrides the default 40.
Some noise words are omitted (see "exceptions" in the program text). If a
file named \texttt{except.wrd} is open and readable in the current
directory, the words in it are used instead. 
\texttt{kwicprep} prepares information to create keyword-in-context
listings of the Icon program library. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{labels}}

\texttt{labels} produces mailing labels using coded information taken
from the input file. In the input file, a line beginning with \# is a
label header. Subsequent lines up to the next header or end-of-file are
accumulated and written out centered horizontally and vertically on
label forms. Lines beginning with * are treated as comments and are
ignored. See the source code for options.
See also: address.doc, adl*.icn, zipsort.icn. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lam} files\hfill \texttt{(TRH)}}

\texttt{lam} laminates files named on the command line,
producing a concatenation of corresponding lines from each file
named. If files are different lengths, empty lines are substituted
for missing lines in the shorter files. Argument
\texttt{{}-s} causes string \texttt{s} to be inserted between
the concatenated file lines. Each command line argument is placed in
the output line at the point that it appears in the argument list. For
example, lines from file1 and file2 can be laminated with a colon
between each line from file1 and the corresponding line from file2 by
\texttt{lam file1 -: file2}.
% File names and strings may appear in any order in the argument list.
If a file is named more than once, its
lines are duplicated on the output, but if standard
input is named more than once, its lines will be read alternately.
% For example, pairs of lines from standard input can be joined onto one
%line with a space between them by the command \texttt{lam - "-" -}
%while \texttt{lam file1 "- " file1} replicates each line from
%\texttt{file1}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{latexidx\hfill (DSC)}}

\texttt{latexidx} processes \index{LaTeX}LaTeX idx files. Input: A latex
.idx file containing the {\textbackslash}indexentry lines. Output:
{\textbackslash}item lines sorted in order by entry value, pagerefs
\index{reference!page} in sorted order. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lc}}

\texttt{lc} simply counts the number of lines in standard input and
writes the result to standard output. Assumes UNIX-style line
terminators, and uses lots of memory. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lindcode}}

\texttt{lindcode} reads a file of L-system specifications and build Icon
code that creates a table of records containing the specifications. If
the option -e is given, symbols for which there is no definition are
included in the table with themselves as replacement. See also:
\texttt{lindrec.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lineseq}}

\texttt{lineseq} reads values on separate lines and strings them
together on a single line. The separating strings is specified by
the \texttt{{}-s} option (default: \texttt{" "}).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lisp\hfill (SBW, PLT)}}

\texttt{lisp} is a simple interpreter for pure \index{Lisp}Lisp. It
takes the name of the Lisp program as a command-line argument. The
syntax and semantics are based on EV-LISP, as described in L.
Siklossy's "Let's Talk
LISP" (Prentice-Hall, 1976). Functions that have been
predefined match those described in Chapters 1-4 of the book.
The language is case-insensitive. % It only reads enough
%input lines at one time to produce at least one lisp-expression, but
%continues to read input until a valid lisp-expression is found.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{literat\hfill (MH)}}

\texttt{literat} manages
information concerning \index{literature}literature. The program uses
files \texttt{literat.fil}, \texttt{literat2.fil} and
\texttt{adress.fil} to store its data. It has a predefined
structure of the items and field labels. Requires: ANSI terminal support.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{loadmap\hfill (SBW)}

\texttt{loadmap} produces a listing of selected symbol classes
from a compiled object file. The listing is by class, and gives the name,
starting address, and length of the region for each symbol.
%If the address of
%a symbol cannot be determined, ???? is given in its place.
The size of the last region in a symbol class is suspect

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{longest}}

\texttt{longest} writes the (last) longest line in the input file. If
the command-line option -\# is given, the number of the longest line is
written first. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{lower}}

\texttt{lower} maps the names of all files in the current directory to
lowercase.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{makepuzz
 \ \textrm{\textmd{[-f}}\textmd{
}\textrm{\textmd{infil]}}\textmd{ }\textrm{\textmd{[-o}}\textmd{
}\textrm{\textmd{outfil]}}\textmd{ }\textrm{\textmd{[-h}}\textmd{
}\textrm{\textmd{ht]}}\textmd{ }\textrm{\textmd{[-w}}\textmd{
}\textrm{\textmd{wd]}}\textmd{ }\textrm{\textmd{[-t}}\textmd{
}\textrm{\textmd{sec]}}\textmd{ }\textrm{\textmd{[-r}}\textmd{
}\textrm{\textmd{reject]}}\textmd{ }\textrm{\textmd{[-s]}}\textmd{
}\textrm{\textmd{[-d]}}}\hfill (RLG)}

\texttt{makepuzz} takes a list of words, and constructs out of them one
of those square find-the-word puzzles that some people like to bend
their minds over. infile is a file containing words, one to a line,
and outfile is the file to write the puzzle. \texttt{ht}
(height) and \texttt{wd} (width) are the basic dimensions you want to
try to fit your word game into (default 20x20). If the \texttt{{}-s}
argument is present, \texttt{makepuzz} will scramble its output.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{missile\hfill (CT)}}

\texttt{missile} is a text-based Missile Command game. It runs
on systems that support the \texttt{delay()} function, and uses ANSI
escape sequences for screen output. To play use 7, 8, and 9 to launch a
missile. 7 is leftward, 8 is straight, and 9 is right. q quits the
game.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{miu\hfill (CAC, REG)}}

\texttt{miu} generates strings from the MIU string system. The number of
generations is determined by the command-line argument; default is 7.
Reference: Godel, Escher, and Bach: an Eternal Golden Braid, D. R.
Hofstadter, Basic Books, 1979. pp. 33-36. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mkpasswd\hfill (JK)}}

\texttt{mkpasswd} creates a list of randomly generated
\index{password}passwords consisting of eight random characters in the
range [A-Z0-9]. Number of passwords to generate is the first argument.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{monkeys\hfill (SBW, REG, AB)}}

The old monkeys at the typewriters anecdote... \texttt{monkeys} uses
ngram analysis to randomly generate text in the same
'style' as the input text.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{morse\hfill (REG, RJA)}}

If \texttt{morse} is invoked without arguments, a \index{Morse
code}Morse code table is printed. If arguments are given, the Morse
code conversion is printed in dots and dashes. If the first
argument's first character is a dot or dash, the
arguments are Morse code and converted to a string.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{mr \ \textrm{\textmd{[recipient] [-u user] [-f spool]}}\hfill(RF)}}

With no arguments, \texttt{mr} reads the default UNIX \index{mail spool}mail
spool. Another user, a spool file, or the recipient for outgoing mail
can be given as a command line argument. Help is available with the H
command.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{newicon\hfill}}

\texttt{newicon} creates a new file with a standard Icon program header
and a skeleton mail procedure. The first command-line argument is taken
as the base name of the file; default
"foo". The second command-line argument is
taken as the author. The default is "Ralph E.
Griswold"; personalize it for your own use. The same
\index{comment}comment applies to the skeleton file mentioned below.
The new file is brought up in the vi \index{editor}editor. The options
are:\\
\ \ \texttt{{}-f}\ \ overwrite an existing file\\
\ \ \texttt{{}-p}\ \ produce a procedure file instead of a
program\\
\ \ \texttt{{}-o}\ \ provide program skeleton with
\texttt{options()}\\
\noindent The files \texttt{skeleton.icn}, \texttt{skelproc.icn}, and
\texttt{skelopt.icn} must be accessible via \texttt{dopen()}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{newsrc\hfill (ADC)}}

\index{news}\texttt{news}\texttt{rc} takes the \texttt{.newsrc} file,
moves active groups to the beginning, and then appends inactive groups
with the numbers omitted, % followed by anything else.% The groups are
%alphabetized. The user may retain a set of groups at the top of the
%file by specifying how many groups on the command line. If not
%specified, it will be prompted for.
and writes out a new file called \texttt{newnewsrc}.
%The user can replace .newsrc with it if it is satisfactory. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{nim} show{\textbar}save \hfill \texttt{(JN)}}

The game of \texttt{nim} is played with a pile of 15 sticks. Each player can
select 1, 2, or 3 sticks from the pile on
their turn. The player to pick up the last
stick(s) wins. % The loser of the previous game always gets to go first.
There are two versions of nim here. The default version uses
an algorithm that will never lose if it gets the first
turn. The second version learns from each game. % After a while it will
% also never lose if it gets the first turn, if you know how to play.
To invoke the learning version, pass an argument to the program.
\texttt{show} displays the
program's game memory after each game.
\texttt{save} writes a file
called ".nimdump" in the current directory
with a dump of the program's game memory when you
quit. When the game is played in learn mode it will initialize its game
memory from the dump. You can run this program with both
\texttt{show} and \texttt{save} at the same time.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{oldicon}}

\texttt{oldicon} updates the date line in a standard Icon program
header. The old file is saved with the suffix \texttt{.bak}. The file
then is brought up in the vi \index{editor}editor unless the
\texttt{{}-f} option is specified. Requires: \texttt{system()},
\texttt{vi(1)}, UNIX.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pack}}

\texttt{pack} packages a list of files named on the command line
into a single file, which is written to standard
output. Files are separated by a header, \#\#\#\#\#\#\#\#\#\#, followed
by the file name. This simple scheme does not work if a file contains
such a header itself, and it's problematical for files
of binary data. See also: \texttt{unpack.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{paginate\hfill (PA)}}

\texttt{paginate} processes a document text file, inserting \index{form
feed}form feeds at appropriate places. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{papply}}

\texttt{papply} applies the procedure given as a command-line argument
to each line of standard input, writing out the results. For example,
\texttt{papply reverse {\textless}foo} writes out the lines of foo
reversed end-for-end. There is no way to provide other
arguments. Except for use with (built-in) functions, this program must
be linked with procedures that are used with it. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{parens}}

\texttt{parens} produces parenthesis-balanced strings in which the
parentheses are randomly distributed. See the source code for options.
This program was motivated by the need for test data for error repair
schemes for block-structured programming languages. A useful extension
to this program would be a way to generate other text among the
parentheses.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pargen}}

\texttt{pargen} reads a context-free grammar and produces an Icon
program that parses the corresponding language. Nonterminal
symbols are enclosed in angle brackets. \texttt{::=} separates
the LHS and RHS of the production. Vertical bars separate
alternatives. Other characters are considered to be terminal
symbols. The nonterminal on the first line is the goal.

Parentheses group symbols, as in
\texttt{{\textless}term{\textgreater}::={\textless}element{\textgreater}({\textbar}*{\textless}term{\textgreater})}
Empty alternatives are allowable. The terminals
\texttt{{\textless}}, \texttt{{\textgreater}},
\texttt{(}, \texttt{)}, and \texttt{{\textbar}} are accessible through
the built-in symbols \texttt{{\textless}lb{\textgreater}},
\texttt{{\textless}rb{\textgreater}},
\texttt{{\textless}lp{\textgreater}},
\texttt{{\textless}rp{\textgreater}}, and
\texttt{{\textless}vb{\textgreater}}, respectively. Two other
built-in symbols, \texttt{{\textless}empty{\textgreater}} and
\texttt{{\textless}nl{\textgreater}} match the empty string and a
newline, respectively.
Lines beginning with \texttt{=} are passed through unchanged,
allowing Icon declarations to be placed in the parser. Lines beginning
with a \# are ignored.
If the name of a ucode file is given on the command line, a
\index{link}link declaration for it is provided in the output.
Limitations:
Left \index{recursion}recursion in the grammar may cause the parser to
loop. See also: \texttt{recog.icn}, \texttt{matchlib.icn},
and \texttt{parscond.icn}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{parse, parsex\hfill (KW, CW)}}

\index{parse}\texttt{parse} parses simple statements.
%It provides an interesting example of the use of co-expressions.
\texttt{parsex} is
another expression parser, adapted from C code written by Allen I.
Holub (Dr. Dobb's Journal, Feb 1987). This program can evaluate any expression
consisting of numbers and the following operators (listed according to
precedence level):\\
\texttt{\ \ () - !
'str'str' * / \& + -
{\textless} {\textless}= {\textgreater} {\textgreater}= == != \&\&
{\textbar}{\textbar}} \\
\noindent All operators associate left to right unless () are present. The top -
is a unary minus. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{patchu\hfill (RM)}

\index{patch}\texttt{patch}\texttt{u} reads a source file and a diff
file, producing an updated file. The diff file may be generated by the
UNIX \texttt{diff(1)} utility, or by \texttt{diffu.icn}, which uses
\texttt{dif.icn}. The original \texttt{patch(1)}
utility, written by Larry Wall, is widely used in the UNIX community.
See \texttt{diff(1)} in a UNIX manual for more details. Requires:
co-expressions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{pdecomp}}

\texttt{pdecomp} lists the prime factors of integers given in standard
input.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{polydemo\hfill (EE)}}

\texttt{polydemo} demonstrates the \texttt{polystuf}
module. The user can create, output,
delete, or operate up to 26 polynomials, indexed by letter.
%Available commands: (R)ead - allows input of a polynomial by giving
%pairs of coefficients and exponents. For example, entering 5, 6, 2, and
%3 will create 5x\^{}6 + 2x\^{}3. This polynomial will be stored by an
%index that is a lower-case letter. (W)rite - outputs to the screen a
%chosen polynomial. (A)dd - adds two polynomials and defines the sum as
%a third (S)ubtract - subtracts two polynomials and defines the
%difference as a third. (M)ultiply - multiplies two polynomials and
%defines the product as a third. (E)valuate - gives the result of
%setting x in a polynomial to a value (C)lear - deletes one polynomial
%(H)elp - lists all commands (Q)uit - end the demonstration.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{
post \ \textrm{\textmd{[-n groups] [-s subj] [-d dist] [-f followup] [-p
prefix] [file]}} \hfill (RF)}

\texttt{post} posts a \index{news}news article to Usenet. Given the name
of a file
containing a news article, \texttt{post} creates a follow-up article,
with an attribution and quoted text.
On systems posting via \texttt{inews},
\texttt{post} validates newsgroups and distributions in the
\texttt{active} and \texttt{distributions} files in the news library
directory. Newsgroup validation assumes the active file is
sorted.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{press\hfill (RJA)}}

\texttt{press} is a file archiving utility that  contains
extensive \index{tracing}tracing facilities that illustrate the LZW
compression process in detail.
% Compression can be turned off if faster archiving is desired.
The LZW compression procedures in this program are general
purpose and suitable for reuse in other programs.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{procprep}}

\texttt{procprep} is used to produce the data needed to index the
"\#:" comments on procedure declarations
that is needed to produces a permuted index to procedures. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{procwrap}}

\texttt{procwrap} takes procedure names from standard input and writes
minimal procedure declarations for them. For example, the input line
wrapper produces: \\
\texttt{\ \ \ procedure wrapper() \\
\ \ \ end} \\
\noindent This program is useful when you have a lot of procedures to write. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{psrsplit
\ \textrm{\textmd{file}}\hfill (GMT)}}

\index{PostScript}\texttt{psrsplit} separates \texttt{psrecord.icn}
output pages. If a file produced by the procedures in
\texttt{psrecord.icn} contains multiple pages, it cannot be easily
incorporated into another document. \texttt{psrsplit} reads such a file
and breaks it into individual pages.
For an input file named \texttt{xxxx} or \texttt{xxxx.yyy}, the
output files are named \texttt{xxxx.p01}, \texttt{xxxx.p01}, etc. for
as many pages as are available. It is assumed that the input file was
written by \texttt{psrecord.icn}; the likelihood of correctly
processing anything else is small. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{puzz}} \hfill (CT)}

\texttt{puzz} creates word search puzzles. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{qei\hfill (WHM, REG)}}

\texttt{qei} evaluates expressions interactively.
A semicolon is required to complete an expression; without one
the subsequent line is added to what already has been
entered. \texttt{qei} accumulates
expressions and evaluates all previously entered expressions before it
evaluates a new one. A line beginning with a colon is a command. The
commands are: {\tt :clear} clears the accumulated expressions;
{\tt :every} generates all the results from the expression, otherwise,
at most one is produced; {\tt :exit} or {\tt quit} terminates the session;
{\tt :list} lists the accumulated expressions; and
{\tt :type} toggles the switch that displays the type of the result.
%(default: on).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{qt
\ \textrm{\textmd{[-a]}}\hfill (RJA)}}

\texttt{qt} writes out the time in English. If \texttt{{}-a} is present,
only the time is printed: \texttt{just after a quarter to three.}
Otherwise, time is printed as a sentence: \texttt{It's
just after a quarter to three}.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{queens\hfill (SBW)}}

\texttt{queens} displays the solutions to the non-attacking
\index{n-queens}n-queens problem: the ways in which n queens can be
placed on an n-by-n chessboard so that no queen can attack another. An
integer command line argument specifies the
number of queens (default: 6). For example, \texttt{queens -n8} displays the
solutions for 8 queens on an 8-by-8 chessboard.
% This program is worth reading for its programming techniques.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ranstars\hfill (SBW)}}

\texttt{ranstars} displays a random field of
"stars" on an ANSI terminal
at randomly chosen positions on the \index{screen}screen until
a specified maximum number is reached. It then extinguishes existing
stars and creates new ones for a specified steady-state time.
% , after which the stars disappear, one by one.
% The programming technique is worth noting.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{reply \ \texttt{\textmd{[prefix] {\textless}
}}\texttt{\textmd{\textit{news-article}}}\texttt{\textmd{ or
}}\texttt{\textmd{\textit{mail-item}}} \hfill (RF)}}

\texttt{reply} creates the appropriate headers and attribution, quotes a
news or mail message, and uses \texttt{system()} to put the user
in an \index{editor}editor and then mails the reply. The default
quote prefix is \texttt{{\textquotedblleft}{\textgreater}
{\textquotedblleft}}. % If a smarthost is defined, Internet addresses are
% converted to bang paths (\texttt{name@site.domain} becomes
% \texttt{site.domain!name}). The mail is routed to a domained smarthost
% as \texttt{address@smarthost.domain}, otherwise to
% \texttt{smarthost!address}.
The editor can be specified with
the EDITOR \index{environment variable!EDITOR}environment variable. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{repro\hfill (KW)}}

\texttt{repro} is the shortest known self-reproducing Icon program. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{revsort\hfill}}

\texttt{revsort} sorts strings with characters in reverse order. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{roffcmds}}

\texttt{roffcmds} processes standard input and writes a tabulation of
nroff/troff commands and defined strings to standard output.
Limitations: the program only recognizes commands that appear at the
beginning of lines and does not attempt to unravel conditional
constructions. Similarly, defined strings buried in disguised form in
definitions are not recognized.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{rsg}}

\texttt{rsg} generates random strings from a
grammar. Grammars are context-free 
extended BNF similar to that of \texttt{pargen}.
This interactive program allows the user to build, test, modify, and save
grammars. Input consists of various
specifications, which can be intermixed: Productions define nonterminal
symbols in syntax similar to BNF % with various
%alternatives consisting of the concatenation of nonterminal and
%terminal symbols.
Generation specifications cause the generation of a
specified number of sentences from the language defined by a given
nonterminal symbol. Grammar output specifications cause the definition
of a specified nonterminal or the entire current grammar to be written
to a given file. Source specifications cause subsequent input to be
read from a specified file. Any line beginning with = causes the
rest of that line to be used as a prompt to the user
whenever \texttt{rsg} is ready for input (there normally is no prompt).
A line with a single = stops prompting.

Specifying a new production for
a nonterminal symbol changes its definition. There are a number of
special devices to facilitate the definition of grammars, including:
{\textless}lb{\textgreater} for {\textless},
{\textless}rb{\textgreater} for {\textgreater},
{\textless}vb{\textgreater} for {\textbar},
{\textless}nl{\textgreater} for newline,
{\textless}{\textgreater} for the empty string,
{\textless}\&lcase{\textgreater} denoting any single lowercase letter,
{\textless}\&ucase{\textgreater} for any single uppercase letter, and
{\textless}\&digit{\textgreater} representing any single digit (Note: \&digit,
not \&digits).
In addition, if the string between a {\textless} and a {\textgreater}
begins and ends with a single quotation mark, it stands for any single
character between the quotation marks. For example,
{\textless}'xyz'{\textgreater} is
equivalent to x{\textbar}y{\textbar}z


\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ruler [length:80]
[\#lines]\hfill (RJA)}}

\texttt{ruler} writes a character ruler to standard output. Arguments give
the length of the ruler in characters and
the number of lines to write, with a line number on each line.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{scramble\hfill (CT)}}

\texttt{scramble} takes a document and re-outputs it in a cleverly
scrambled fashion. It uses the next two most likely words to follow.
% The concept was found in a recent Scientific American and Icon seemed
% to offer the best implementation.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{setmerge \ \texttt{\textmd{file [[op]
file]...}} \hfill (GMT)}}

\texttt{setmerge} combines sets of items according to the specified
operators. Sets are read from files, one entry per line. Operation is
from left to right without any precedence rules. After all operations
are complete the resulting set is sorted and written to standard
output.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shar
\ \texttt{\textmd{text\_file...}}\hfill (RJA)}}

\texttt{shar} creates a Bourne shell archive of text files. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shortest}}

\texttt{shortest} writes the (last) shortest line in the input file. If
the command-line option -\# is given, the number of the shortest line
is written first. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{shuffile}}

\texttt{shuffile} writes a version of the input file with the lines
shuffled.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sing \hfill (FJL)}}

\texttt{sing} is an adaptation of a SNOBOL program by Mike Shapiro
in (Griswold71). It writes the lyrics to the
song, "The Twelve Days of Christmas" to a
parameter that can be any file open for output. % It would be especially
% nice to send the lyrics to a speech synthesizer (perhaps via a pipe).
The algorithm used can be adapted to other popular songs.
%, such as "Old McDonald had a Farm".

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{snake
\ \texttt{\textmd{[character:o]}} \hfill (RLG)}}

While away the idle moments watching the snake eat blank squares on your
screen. % \texttt{character} represents a single character to be used in
%drawing the snake.
To run \texttt{snake}, your terminal must have cursor movement and
able to do reverse video.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{solit} \hfill (JN, PLT, REG)}}

\texttt{solit} was inspired by a solitaire game that was written
by Allyn Wade in 1985. This program supports several common terminals and
PC's. Note: The command-line argument, which defaults to support for
the VT100, determines the screen driver.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{sortname}}

\texttt{sortname} sorts a list of person's names by the
last names. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{splitlit}}

\texttt{splitlit} creates a string literal with continuations in case
it's too long. Option \texttt{{}-w i} specifies the width of piece on
line, default 50. Option \texttt{{}-i i} specifies the indent, default 3.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{streamer}}

\texttt{streamer} outputs one long line obtained by concatenating the
lines of the input file. Option
\texttt{{}-l i} stops when line reaches or exceeds i; default no
limit. Option \texttt{{}-s s} inserts separator s after each line; default no
separator.
Separators are counted in the length limit.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{strpsgml \ \textrm{\textmd{[-f}}\textmd{
}\textrm{\textmd{translation-file]}}\textmd{
}\textrm{\textmd{[left-delimiter}}\textmd{
}\textrm{\textmd{[right-delimiter]]}}} \hfill (RLG)}

\texttt{strpsgml} strips or translates
\index{SGML}SGML \texttt{{\textless}{\textgreater}}{}-style tags. The
default left-delimiter is \texttt{{\textless}}, the default right
delimiter is \texttt{{\textgreater}}. If no translation file is
specified, the program strips material
between the delimiters. The format of the translation file is: \\
\texttt{\ \ \ code\ \ \ \ initialization\ \ completion}\\
\noindent A tab or colon separates the fields. If you want to use a tab or colon
as part of the text (and not as a separator), place a backslash before
it. The completion field is optional.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tablc}}

\texttt{tablc} tabulates characters and lists each character and the
number of times it occurs. % Characters are written using escapes.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{tablw}}

\texttt{tablw} tabulates words and lists number of times each word
occurs. A word is a string of consecutive letters with at most one
interior occurrence of a dash or apostrophe.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{textcnt}}

\texttt{textcnt} tabulates the number of characters,
"words", and lines in standard input and
gives the maximum and minimum line length. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{textcvt\hfill (RJA)}}

\texttt{textcvt} converts text file(s) among various
platforms' formats. The supported text file types are
UNIX, MS-DOS, and Macintosh. The files
are either converted in-place by converting to a temporary file and
copying the result back to the original, or are copied to a separate
new file, depending on the command line options.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{toktab}}

\texttt{toktab} reads the token files given on the command line and
summarizes them in a single file. Option \texttt{{}-n} sorts
tokens by category in decreasing \textit{numerical} order;
default is alphabetical. Option \texttt{{}-l i} limits output
in any category to \texttt{i} items; default no limit

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{trim} [n]}

\texttt{trim} copies lines from standard input to standard output,
truncating the lines at n characters and removing trailing blanks.
The default for n is 80.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{ttt\hfill (CT)}}

\texttt{ttt} plays the game of tic-tac-toe.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{turing\hfill (GMT)}}

\texttt{turing} simulates the operation of an n-state \index{Turing
machine}Turing machine. The machine starts in
state 1 with an empty tape. A description of the Turing machine is read
from the file given as a command-line argument, or from standard input
if none is specified.
% Comment lines beginning with '\#' are allowed, as are empty lines.
% The program states must be numbered from 1 and must appear in order.
% Each appears on a single line in this form: \\
%\texttt{\ \ \ sss. wdnnn wdnnn}\\
%\noindent
%\texttt{sss} is the state number in decimal. The \texttt{wdnnn} fields
%specify the action to be taken on reading a 0 or 1 respectively:
%\texttt{w} is the digit to write (0 or 1), \texttt{d} is the direction
%to move (L/l/R/r, or H/h to halt), \texttt{nnn} is the next state
%number (0 if halting).

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{unique\hfill (AVH, RJA)}}

\texttt{unique} filters out (deletes) identical adjacent lines in a
file. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{unpack}}

\texttt{unpack} unpackages files produced by \texttt{pack.icn}. See that
program for limitations. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{upper}}

\texttt{upper} maps the names of all files in the current directory to
uppercase.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{verse
[vocabularyfile:verse.dat \hfill (CT)}}

This \index{verse}verse maker was initially published in a 1980s
Byte magazine in TRS80 Basic. % It fetches the vocabulary from a
%vocabulary file specified on the command line; it looks for
%\texttt{verse.dat} by default. See that file for examples of form. 

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{versum}}

\texttt{versum} writes the versum sequence for an integer to a file of a
specified name. If such a file exists, it picks up where it left off,
appending new values to the file.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{webimage}}

\texttt{webimage} takes image filename arguments and
writes a Web page that embeds each image.
Option \texttt{{}-a s} specifies alignment, default "bottom". Option
\texttt{{}-t s} supplies a title for the page; default "untitled".
Option \texttt{{}-n} directs to include file names.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{what \hfill (PLT)}}

\texttt{what} writes all strings beginning with
"@" followed by
"(\#)" and ending with null, newline,
quotes, greater-than or backslash. Follows UNIX \texttt{what(1)}
conventions.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{when\hfill (CT)}}

\texttt{when} is a date based \texttt{ls} command. UNIX \texttt{find} is a bit
arcane, so \texttt{when} provides a simpler alternative.
%Many options and clauses are supported. Look at the code for clues.
This program only works in the current directory. Requires: UNIX.

\pagebreak

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{xtable\hfill (RJA, AB)}}

\texttt{xtable} prints tables for ASCII, EBCDIC
and their decimal and octal values.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{yahtz\hfill (CT, RLG, PLT)}}

A classic "dice poker" game.

\vspace{0.25cm}\hrule\vspace{0.1cm}{\noindent\texttt{zipsort}}

\texttt{zipsort} sorts labels produced by {\tt labels} in ascending order
of their postal zip codes. Option \texttt{{}-d n} sets the
number of lines per label to n (default 9). % This value must agree
% with that used to format the labels. The zip code must
% be the last nonblank string at the end of the label. It must consist of
% digits but may have an embedded dash.
See also: \texttt{labels.icn}.

\section{Selected IPL Authors and Contributors}

This Appendix presents the work of the following authors and contributors of
Icon Program Library modules and programs. Ralph Griswold
initiated and maintained the collection. The
various authors' code is described in their own words, from the
public domain documentation they have written about it. We
acknowledge their contribution to the Icon community and to this book.
Errors in this Appendix are solely our responsibility.

\begin{xtabular}{m{1.8in} m{1.8in} m{1.8in}}

Paul Abrahams & Robert J. Alexander & Allan J. Anderson \\
Norman Azadian & Alan Beale & Phil Bewig \\
Peter A. Bigot & David S. Cargo & Alex Cecil \\
Alan D. Corre & Cary A. Coutant & William E. Drissel \\
Erik Eid & Ronald Florence & David A. Gamey \\
Michael Glass & Richard L. Goerwitz & Ralph E. Griswold \\
Matthias Heesch & Charles Hethcoat & Anthony V. Hewitt \\
Thomas R. Hicks & Clinton L. Jeffery & Jere K?pyaho \\
Justin Kolb & Tim Korb & Frank J. Lhota \\
Nevin J. Liber & William P. Malloy & C. Scott McArthur \\
Will Menagarini & Joe van Meter & William H. Mitchell \\
Rich Morin & Jerry Nowlin & Mark Otto \\
Robert Parlett & Jan P. de Ruiter & Randal L. Schwartz \\
Charles Shartsis & David J. Slate & John D. Stone \\
Chris Tenaglia & Phillip L. Thomas & Gregg M. Townsend \\
Kenneth Walker & Stephen B. Wampler & Beth Weiss \\
Robert C. Wieland & Cheyenne Wills & David Yost\\
\end{xtabular}

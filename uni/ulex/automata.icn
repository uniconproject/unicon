#
# based on automata.c by Katie Ray, Project: ulex, March 15, 2003
# contains the functions that allow the automata to operate.
#

record edge(symbol, destinations)
record edgelist(current, _next)
record anode(label, rulenum, edges, epsilon, dot, semaction)
record anodelist(current, _next)
record automata(start, states, accepting)

procedure alcedge(sym)
   return edge(sym)
end

procedure alcedgelist()
   return edgelist()
end

procedure alcanode(lab)
   return anode(lab)
end

procedure alcnodelist()
   return anodelist()
end

procedure alcautomata()
   return automata()
end

#
# label all states in an automaton with an increasing numeric sequence.
#
procedure labelaut(aut)
   local statelist := aut.states
   local lab := 0

   while \statelist do {
      statelist.current.label := lab
      statelist := statelist._next
      lab +:= 1
      }
end

procedure createicon(myautomata)
   local states, states2
   local edges
   local maxrulenum := 0, i, action

   if not (outfile := open(outfilename, "w")) then {
      fprintf(stderr, "Unable to open output file %s\n", outfilename)
      exit(1)
      }

   #
   # write out the standard skeleton automata code
   #
   ulexskel(outfile)

   if (begintext) then {
      fprintf(outfile, "%s\n", begintext)
      }

   fprintf(outfile,
	   "global semantic_action\n\n_
	   procedure yylex()\n_
	   static myautomata\n_
	   local currstate, state2, tempedge\n\n_
	      myautomata := automata()\n\n_
	      myautomata.states := []\n_
	      myautomata.accepting := []\n")

   states := myautomata.states
   while \states do {
      fprintf(outfile,
	 "   put(myautomata.states, currstate := anode(%d, %d, [], [], []))\n",
	      states.current.label, states.current.rulenum)

      if states.current.label == myautomata.start.label then
        fprintf(outfile, "   myautomata.start := currstate\n")

      if member(states.current.label, myautomata.accepting) == 1 then {
	 fprintf(outfile, "   put(myautomata.accepting, currstate)\n")
	 if states.current.rulenum > maxrulenum then
	    maxrulenum := states.current.rulenum
	 }

      fprintf(outfile, "\n")
      states := states._next
      }

   states := myautomata.states
   while \states do {
      fprintf(outfile,
	      "   currstate := pop(myautomata.states)\n_
	         put(myautomata.states, currstate)\n\n_
	         while currstate.label ~= %d do {\n_
	            currstate := pop(myautomata.states)\n_
	            put(myautomata.states, currstate)\n   }\n_
	         state2 := currstate\n\n",
	      states.current.label)

      states2 := states.current.epsilon
      while \states2 do {
	 fprintf(outfile,
		 "   currstate := pop(myautomata.states)\n_
		    put(myautomata.states, currstate)\n\n_
		    while currstate.label ~= %d do {\n_
		       currstate := pop(myautomata.states)\n_
		       put(myautomata.states, currstate)\n   }\n_
		    put(state2.epsilon, currstate)\n\n",
		 states2.current.label)
	 states2 := states2._next
	 }

      states2 := states.current.dot
      while \states2 do {
	 fprintf(outfile,
		 "   currstate := pop(myautomata.states)\n_
		    put(myautomata.states, currstate)\n\n_
		    while currstate.label ~= %d do {\n_
		       currstate := pop(myautomata.states)\n_
		       put(myautomata.states, currstate)\n   }\n_
		    put(state2.dot, currstate)\n\n",
		 states2.current.label)
	 states2 := states2._next
	 }

      edges := states.current.edges
      while \edges do {
	 fprintf(outfile, "   tempedge := edge()\n")

	 if edges.current.symbol == "\n" then
	    fprintf(outfile, "   tempedge.symbol := \"\\n\"\n")
	 else {
	    fprintf(outfile, "   tempedge.symbol := \"%s\"\n",
		    edges.current.symbol)
	    }

	 fprintf(outfile, "   tempedge.destinations := []\n")

	 states2 := edges.current.destinations
	 while \states2 do {
	    fprintf(outfile,		    "   currstate := pop(myautomata.states)\n_
		       put(myautomata.states, currstate)\n\n_
		       while currstate.label ~= %d do {\n_
		          currstate := pop(myautomata.states)\n_
		          put(myautomata.states, currstate)\n   }\n_
		       put(tempedge.destinations, currstate)\n\n_
		       put(state2.edges, tempedge)\n",
		    states2.current.label)
	    states2 := states2._next
	    }

	 edges := edges._next
	 }

      states := states._next
      }
 
   fprintf(outfile,
	   "   init_semantic_actions()\n\n_
	      return yyulex(myautomata)\n\n_
	   end\n\n_
	   procedure init_semantic_actions()\n\n_
	      semantic_action := table()\n")

   action := list(maxrulenum+1, 0)
   
   every i := 1 to maxrulenum do {
      fprintf(outfile, "   semantic_action[%d] := semantic_action_%d\n", i, i)
      }

   fprintf(outfile, "\nend\n\n")
   states := myautomata.accepting

   while \states do {
      if action[states.current.rulenum] == 0 then {
	 fprintf(outfile,
		 "procedure semantic_action_%d()\n_
		    %s\n_
		 end\n\n",
		 states.current.rulenum,
		 states.current.semaction)
	 action[states.current.rulenum] := 1
	 }
      states := states._next
      }
end

procedure member(nodelabel, nodelist)
   local traverse := nodelist

   while \traverse do {
      if traverse.current.label == nodelabel then
	 return 1
      traverse := traverse._next
      }
   return 0
end

################################################################################
#
#	File:     classbrowser.icn
#
#	Subject:  Class Browser
#
#	Author:   Nolan Clayton
#
#       Date:     September 22, 2003
#  
################################################################################
#
#  This program provides a simple graphical, not ASCII art as below,
#  class browser for icon/unicon programs.
#
#   ex.     -Files
#           |--foo.icn
#               |-+class blah
#               |--class whatever
#               |    |--method bees 
#               |--procedure good
#                 
#
#   result from--> classbrowser foo.icn 
#  	
################################################################################
#  Links:  graphics
################################################################################
import gui

#link "../ide/imgs"
#link "../ide/tree"

$include "guih.icn"

#
# class  ClassBrowser : is a subclass of Tree used  to overide the draw and
#                other methods.
#
class  ClassBrowser : Tree(
   last_selected,
   fileimgs,
   files_root)

   #
   # Draw Method: Each node depending on its type is drawn 
   # with a different image.
   #
   method draw_line(xp, yp, i, selection_cw, cursor_cw, highlight_cw)
      local N, dashed, lp, j, bmps, img, little, temp

      N := contents[i]
      dashed := Clone(self.cbwin, "pattern=gray", "fillstyle=textured")
      lp := xp
      every j := 1 to N.depth - 1 do {
         if N.draw_line[j] == ("f"|"d") then
            DrawLine(dashed, lp + col_w / 2, yp - self.line_height / 2,
                     lp + col_w / 2, yp + self.line_height / 2)
            lp +:= col_w
            }
      if N.depth > 0 then { 
         if N.draw_line[N.depth] == "d" then
            DrawLine(dashed, lp + col_w / 2, yp, lp + col_w / 2,
                     yp + self.line_height / 2)
         else if N.draw_line[N.depth] == "f" then
            DrawLine(dashed, lp + col_w / 2, yp - self.line_height / 2,
                     lp + col_w / 2, yp + self.line_height / 2)
         else if N.draw_line[N.depth] == "u" then
            DrawLine(dashed, lp + col_w / 2, yp - self.line_height / 2,
                     lp + col_w / 2, yp)
         DrawLine(dashed, lp + col_w / 2, yp, lp + col_w + col_w / 2, yp)
         lp +:= col_w
         }

      bmps := \N.bmps | default_bmps

      if (*N.subnodes = 0) & /N.always_expandable_flag then
         img := bmps[3]
      else {
         if N.is_expanded() then {
            img := bmps[2]
            little := minus
            if *N.subnodes > 0 then
               DrawLine(dashed, lp + col_w / 2, yp, lp + col_w / 2,
                        yp + self.line_height / 2)
            }
         else {
            img := bmps[1]
            little := plus
            }
         if not(N.type == ("class" |"editor"|"file") ) then
            little := editorimgs("elbow")

         temp := editorimgs(N.type)
         if \temp then img := temp

         EraseArea(self.cbwin, lp - col_w / 2 - little_w / 2, 
                   yp - little_h / 2, little_w, little_h)
         DrawImageEx(self.cbwin, lp - col_w / 2 - little_w / 2, 
                    yp - little_h/2, little)
         }
      DrawImageEx(self.cbwin, lp + col_w / 2 - bmp_w / 2, yp - bmp_h / 2, img)
      left_string(self.cbwin, lp + col_w + HIGHLIGHT_TEXT_SPACING, yp, N.label)

      if \selection_cw then
         FillRectangle(selection_cw, lp + col_w,
            yp - self.line_height / 2, TextWidth(self.cbwin,
            N.label) + 2 * HIGHLIGHT_TEXT_SPACING, self.line_height)
      if \cursor_cw then {
         Rectangle(cursor_cw, lp + col_w, yp - self.line_height / 2, 
                   TextWidth(self.cbwin, N.label) + 2 * HIGHLIGHT_TEXT_SPACING,
                   self.line_height)
         }

      if \highlight_cw then {
         Rectangle(highlight_cw, lp + col_w,
            yp - self.line_height / 2, TextWidth(self.cbwin,
             N.label) + 2 * HIGHLIGHT_TEXT_SPACING, self.line_height)
         }
      Uncouple(dashed)
   end

   #
   # Handle Press Method:  If a node in the class browser is clicked
   # then goto the node's line in it's parent's file.
   #
   method handle_press(e)
      local l, lno, N, curr_sel, yp, xp
      if (self.view.x <= &x < self.view.x + self.view.w) &
         (self.view.y  <= &y < self.view.y + self.view.h) then {
         lno := (&y - self.view.y) / self.line_height
         l := lno + self.get_first_line()

         if l <= self.get_last_line() then {
            N := self.contents[l]

            if (N.depth > 0) & (*N.subnodes > 0) |
	       \N.always_expandable_flag then {
               #
               # Check for click on little +/- icon.
               #
               yp := self.view.y + self.line_height / 2 +
	             self.line_height * lno - little_h / 2
               xp := self.get_left_pos() + 
	             (N.depth - 1) * col_w + little_w / 2
               if (xp <= &x < xp + little_w) & (yp <= &y < yp + little_h) then {
                  #
                  # Clicking on the little icon ends the sequence, and sets
                  #the selection to the given node.
                  #
                  start_handle(e)
                  curr_sel := object_get_selections()
                  N.toggle_expanded()
                  self.last_expanded := N
                  tree_structure_changed()
                  is_held := &null
                  if not lang::equals(object_get_selections(), curr_sel) then
                     selchange := 1
                  fire(TREE_NODE_EXPANSION_EVENT, e)
                  end_handle(e)
                  }

            }
            if find(".icn",N.label) then {
               c:= uidlog.FileTabSet.get_tabitem(N.label)
               uidlog.FileTabSet.set_which_one(\c)
               }

               # Normal click down
#               self.is_held := 1
#               self.checked := list(*self.contents)
#               self$refresh(1)

               last_selected := self.contents[1]
               ide.goto_line(N.lineno,1)
               ide.CurrentEditBox().highlight_line(N.lineno)

         }
      }
      self.SelectableScrollArea.handle_press(e)
   end
   #
   # Fill Tree Method: Used to initialize a tree (class browser).
   # Contents is a list of Tags (nodes).
   #
   method filltree(contents)
      local i
      if \contents then every  i :=  ! contents do files_root.add(i)
      self.set_root_node(files_root)
   end

   #
   # Add Replace Method:  Replace a Tag with an newer version of the that Tag.
   #                     Contents is a list of lines in a file.  Tab Label is
   #                     the Files Name on the TabSet.
   #
   method addreplace(contents, tab_label)
      local i, l, temp

      if not( find(".icn"|".cpp"|".c"|".java"|".h",tab_label) ) then fail

      nodereplace(tab_label)

      l := utags(contents, tab_label)  #l is a list of tags
      temp := Tag("file", tab_label,1, tab_label)

      every  i :=  ! l do temp.add(i)

      files_root.add(temp)
      self.set_root_node(files_root)
   end

   #
   # Node Replace Method: Remove a Node with the same label as Tab Label
   #                   from the tree (class browser).
   method nodereplace(tab_label)
      local i

      every i := 1 to  *files_root.subnodes do 
         if tab_label == files_root.subnodes[i].label then {
            files_root.subnodes := files_root.subnodes[1 : i] |||
			           files_root.subnodes[i + 1 : 0]
            return   }
      self.set_root_node(files_root)
   end
   #
   # Go To Method: A Node was clicked. Set the focus on Tab with the label
   # Tab Label and go to and highlight the line number Line.
   # 
   method goto(tab_label,line)
      local c
      if /tab_label | /line then fail
      c := ide.uidlog.FileTabSet.get_tabitem(tab_label)  
      if /c then fail
 
      ide.uidlog.FileTabSet.set_which_one(c)
      ide.CurrentEditBox().highlight_line( line )
      ide.set_focus(ide.CurrentEditBox())
   end

   method highlight_line(i)
      start_handle()
      end_handle()
   end

   initially()
      self$Tree.initially() 
      fileimgs := table()
      files_root := Tag("editor", "Editor",0, &null)
end

#
# class  Tag : is a subclass of Node used only to keep track of Node attribs
#
class Tag : Node (
   type,        # Type is what kind of node it is (method, $include, procedure).
   lineno,      # The line number on which the Node occurs.
   parentfile   # The label(Tab Item) of the file in which the Node is a member.
   )

   method settype( x )
      type := x
   end

   method setlineno( x )
      lineno := x
   end

   method gettype( )
      return type
   end

   method getlineno( )
      return lineno
   end

   method getparentfile()
      return parentfile
   end

   method setparentfile(x)
      return parentfile := x
   end

initially ( args[] )
   self$Node.initially()
   if *(\args) > 3 then {
      type    := args[1]
      self$set_label( args[2] )
      lineno := args[3] 
      parentfile := args[4]
      }
   self$set_always_expandable()
end

\chapter{The System Interface}

The \index{system interface}system interface is Unicon's connection to the
outside world, defining \index{input}input/\index{output}output interactions
with the operating system. This chapter shows how to
\begin{itemize}\itemsep0pt
  \item Manipulate \index{file}files, \index{directories}directories, and
    access \index{permissions, file access}permissions
  \item Launch and interact with other programs
  \item Handle abnormal events that would otherwise terminate your program
  \item Write \index{Internet}Internet \index{client}client and
    \index{server}server applications.
\end{itemize}

\section{The Role of the System Interface}

Unicon's predecessor Icon is highly portable; it runs on everything
from mainframes to Unix machines to Amigas and Macs. This platform
independence is both a virtue and a limitation. Icon takes a greatest
common denominator approach to the system interface. Icon programs run
with no source modifications across platforms, but with little access
to the underlying system. Icon historically could not be used easily
for many tasks such as system administration or client/server
programming. Both the Icon graphics facilities, and now the Unicon
system interface, "raise the bar" of what portable facilities
programmers can expect to be provided by their programming language,
at the cost of making it more difficult to port the language to new
platforms.

The interface described in this chapter relies on underlying standards
including ANSI C's standard library, and the IEEE Portable Application
Standards Committee's \index{POSIX}POSIX operating system standard
(http://www.pasc.org). Unicon relies on standards, but is simpler and
higher level. It is also less platform-specific than the POSIX
standard. The goal was to define facilities that can be implemented to
a great extent on all modern operating systems.  Non-POSIX Unicon
implementations may provide a subset of the functionality described in
this chapter, but important facilities such as TCP/IP Internet
communications are ubiquitous and warrant inclusion in the language
definition. So far the complete Unicon system interface is implemented
for Linux, Solaris, and Windows; the challenge to port these
facilities to all platforms on which they are relevant and useful now
rests with Unicon's user community.

\section{Files and Directories}

The file type is used for any connection between a program and an
external piece of hardware. In reality, a file is a
\index{reference!file}reference to resources allocated by the
operating system for the purpose of input or output. Different kinds
of files support different operations, but most files support the
basic functions given in this section.

Files are commonly used to manipulate named repositories of data on a
storage device. The contents of files exist independent of the program
that creates them, and persist after that program finishes.  To read
data from a file or save data to a file, the functions
\index{read()}\texttt{read()} and \index{write()}\texttt{write()} are
often used. These functions by default use special files denoted by
the keywords \index{input, standard \&input}\texttt{\&input} and
\index{output, standard \&output}\texttt{\&output},
respectively. There is a third file keyword, \index{error!standard,
\&errout}\texttt{\&errout}, that refers to the location to which the
program should write any error messages.  Unless the files were
redirected, they refer to the \index{keyboard}keyboard and the
\index{display}display. If you pass \texttt{read()} or
\texttt{write()} a value of type \textit{file} as an argument, the
operation is performed on that file. The function
\texttt{open()}\texttt{ }creates a value of type file:

\iconcode{
f := open("myfile.txt", "w") \\
write(f, "This is my text file.")
}

\noindent
The \index{open()}\texttt{open()} function takes two parameters: a file
name and a mode. The default mode is
\texttt{"r"} for reading; the example above
uses mode \texttt{"w"} for
writing. Other modes denote other kinds of system interfaces.
They are described in later sections.

The \texttt{read()} function reads and returns a line of text, removing the
line terminator(s). Function \texttt{write()}
similarly adds a line terminator after writing its arguments.
Another way to read lines is via the generate operator, unary
\texttt{!}. The expression \texttt{!f} generates the lines of file
\texttt{f}, so \texttt{every put(L, !f)} puts the lines of
\texttt{f} into list \texttt{L}.

On systems with multi-character line terminators, appending an
extra letter to the mode parameter of \texttt{open()} indicates whether
newlines are to be translated (mode
\texttt{"t"}) or untranslated (mode
\texttt{"u"}). Text files should
be translated, while binary files should not. The default is to translate
newlines to and from operating system format.

Besides \texttt{read()} and \texttt{write()}, which always process a
single line of text, the functions \texttt{reads(f, i)} and
\texttt{writes(f, s, ...)} read (up to \texttt{i} characters) and write
strings to a file. These functions are not line-oriented and do no
newline processing of their own, although they still observe the
translation mode on systems that use one.

When operations on a file are complete, close the file by calling
\index{close()}\texttt{close(f)}. The only exceptions are the standard
files, \texttt{\&input}, \texttt{\&output}, and \texttt{\&errout};
since you didn't open them, don't
close them. For the rest, most operating systems have a limit on the
number of files that they can have open at any one time, so not closing
your files can cause your program to fail in strange ways if you use a
lot of files.

\subsection*{Directories}

A \index{directory}directory is a special file that contains a
collection of named files. Directories can contain other directories to
form a hierarchical structure. The \index{chdir()}\texttt{chdir()}
function returns the current working directory as an absolute path
name. Called with a string argument, the
\texttt{chdir(}\texttt{\textit{dirname}}\texttt{)} function sets the
current working directory to \texttt{dirname}. The call
\texttt{open(}\texttt{\textit{dirname}}\texttt{)} opens a directory to
read its contents. Directories can only be opened for reading,
not for writing. Every \texttt{read()} from a directory returns
the name of one file. Directory entries are not guaranteed to be in any
order. The expression \texttt{every
write(!open("."))} writes the names of the
files in the current directory, one per line. It is not good practice
to call an \texttt{open()} that you don't
\texttt{close()}.

The \index{mkdir()}\texttt{mkdir(s)} function creates a directory. An
optional second parameter specifies access permissions for
the directory; controlling file ownership and access is discussed
below. Files or directories can be renamed with \texttt{rename(s1,s2)}.
Renaming does not physically move the file, so if \texttt{s1} and
\texttt{s2} denote locations on different hardware devices or file
systems then \index{rename()}\texttt{rename()} will fail, and you will
need to "copy and then delete"
the file. Individual files or directories are removed with
\index{remove(s)}\texttt{remove(s)}. Only empty directories may be
removed. To remove an entire directory including its contents:

\iconcode{
procedure deldir(s) \\
\>   f := open(s) \\
\>   every remove( s {\textbar}{\textbar}
"/" {\textbar}{\textbar}
("." \~{}==
(".." \~{}== !f))) \\
\>   close(f) \\
\>   remove(s) \\
end
}

How would you change this function to delete subdirectories? You might
be able to devise a brute force approach using what you know, but what
you really need is more information about a file, such as whether it is
a directory or not.

\subsection*{Obtaining file information}

\index{file!information}\textit{Metadata} is information about the file
itself, as opposed to information stored in the file. Metadata includes
the owner of the file, its size, user access rights,
and so forth. This information is produced by the
\index{stat(f)}\texttt{stat()} system call. Its argument is the name of
a file or (on UNIX systems only) an open file. The \texttt{stat()}
function returns a record with the information about the file. Here is
a subset of \texttt{ls}, a UNIX program that reads a directory and
lists information about its files. Keyword \index{errortext,
keyword}\texttt{\&errortext} contains information about the
most recent error that resulted in an expression
\index{fail!expression}failure; it is written if opening the directory
fails. This version of \texttt{ls} only works correctly if its
arguments are the names of directories. How would you modify it, using
\texttt{stat()}, to take either ordinary file names or directory names
as command line arguments?

\iconcode{
link printf \\
procedure main(args) \\
\>   every name := !args do \{ \\
\>   \ \ \ f := open(name) {\textbar} stop(\&errortext, name) \\
\>   \ \ \ L := list() \\
\>   \ \ \ while line := read(f) do \\
\>   \ \ \ \ \ \ push(L, line) \\
\>   \ \ \ every write(format(stat(n := !sort(L)), n)) \\
\>   \ \ \ \} \\
end \\
procedure format(p, name) \\
\ \ \ s := sprintf("\%-7d \%-5d \%s \%-4d \%-9d \%-9d
\%-8d \%s \%s",  \\

\ \ \ \ \ \ \ \ \ \ p.ino, p.blocks, p.mode, p.nlink, p.uid, p.gid,
p.size, \\

\ \ \ \ \ \ \ \ \ \ ctime(p.mtime)[5:17], name) \\
\>   if p.mode[1] == "l" then \\
\>   \ \ \ s {\textbar}{\textbar}:= " -{\textgreater}
" {\textbar}{\textbar} {\textbackslash}(p.symlink) \\
\>   return s \\
end
}

The record returned by \texttt{stat()} contains many fields. Not all file
systems support all of these fields. Two of the most important portable fields
are \texttt{size}, the \index{file size}file size in bytes, and \texttt{mtime},
the file's last \index{file!modified time}modified time, an integer that is
converted into a human readable string format by \texttt{ctime(i)}. Another
important field is \texttt{mode}, a string that indicates the file's type and
\index{access, file}access permissions. Its first letter (\texttt{mode[1]}) is
\texttt{"-"} for normal files, \texttt{"d"} for directories, and some file
systems support additional types. The other characters of the mode string are
platform dependent. On UNIX there are nine letters to encode read, write, and
execute permissions for user, group, and world, in the format:
\texttt{"rwxrwxrwx"}. On a classic Windows FAT file system, there is only
\texttt{"rwa"} to indicate the status of hidden, read-only, and archive bits (if
it is set, the system bit is indicated in \texttt{mode[1]}).

Some file systems support duplicate directory entries called
\textit{links} that refer to the same file. In the record returned by
\texttt{stat()}, a \index{link, file system}link is indicated by a
\texttt{mode[1]} value of \texttt{"l"}. In addition, field
\texttt{nlinks} ("number of links") will be \texttt{{\textgreater} 1}
and/or field \texttt{symlink} may be the string filename of which this
file is an alias. Appendix E includes information on each platform's
support for the \texttt{mode} field, as well as \texttt{stat()}'s
other fields.

\subsection*{Controlling file ownership and access}

\index{file ownership}The previous section shows how different
platforms' file systems vary in their support for the concepts of file
ownership and access. If the system supports ownership, the user and
group that own a file are changed by calling \texttt{chown(fname,
user, group)}. The \index{chown()}\texttt{chown()} function only
succeeds for certain users, such as the super user.  User and group
may be string names, or integer user identity codes on some platforms.

File access rights are changed with \texttt{chmod(fname, mode)}. The
\index{chmod()}\texttt{chmod()} function only succeeds for the owner of a given
file. The \texttt{mode} is a nine-letter string similar to \texttt{stat()}'s
mode field, or an octal encoding of that information (see Appendix E).

Another piece of information about files is called the
\index{umask}\textit{umask}. This is a variable that tells the system what
access rights any newly created files or directories should have.  The function
call \texttt{umask("rwxr-xr-x")} tells the system that newly created directories
should have a permission of \texttt{"rwxr-xr-x"} and files should have
permissions of \texttt{"rw-r-{}-r-{}-"}.  The \texttt{mkdir(s, mode)} function
takes an optional mode parameter, which can override the umask for for newly
created directories.  Ordinary files are never given execute permission by the
system, it must be set explicitly with \texttt{chmod()}.

\subsection*{File locks}

Files can be \index{file!lock}locked while a program is updating some
information. If the contents of the file are in an inconsistent state, other
programs may be prevented from reading (or especially writing) the
file. Programs can cooperate by using file locks:

\iconcode{
flock(filename, "x")}

\noindent
The first call to \texttt{flock()} creates a lock, and subsequent
calls by other programs will block, waiting till the
writing program releases its lock. The flag
\texttt{"x"} represents an
\textit{exclusive} lock, which should be used while writing; this means
no other process can be granted a lock. For reading,
\texttt{"s"} should be used to create a
shared lock so that other programs that are also just reading can do
so. In this way you can enforce the behavior that only one process may
open the file for writing, and all others will be locked out; but many
processes can concurrently open the file for reading.

\section{Programs and Process Control}

Unicon's system interface is similar but
higher level than the POSIX C interface. An include file
\texttt{posix.icn} defines constants used by some functions. Include
files are special code, consisting mainly of defined symbols, intended
to be textually copied into other code files. They are handled by the
preprocessor, described in Appendix A. To include \texttt{posix.icn} in
a program, add this line at the top of your program:

\iconcode{
\$include "posix.icn"}

When a system call \index{fail!system call}fails, the integer keyword
\texttt{\&errno} indicates the error that occurred. As seen earlier, a
human-readable string is also available in \index{errortext,
keyword}\texttt{\&errortext}. Error codes (such as \texttt{EPERM}, or
\texttt{EPIPE}) are defined in \texttt{posix.icn}; \index{errno,
keyword}\texttt{\&errno} can be compared against constants like
\texttt{ENOENT}. In general, however, human readers will prefer to
decipher \texttt{\&errortext}.

In the discussion to follow, a \textit{program} is the code, while
a \index{process}\textit{process} is such
a program in execution. This distinction is not usually important, but
for network applications it matters,
since the same program can run in multiple processes, and a process can
change the program that it is running.

\subsection*{Signals}

A \index{signal}signal is an asynchronous message sent to a process either by
the system (usually as a result of an illegal operation like a
\index{error!floating point}floating point error) or by another process. A
program has two options to deal with a signal: it can allow the system to handle
it in the default manner (which may include termination of the process) or it
can register a function, called a signal handler, to be run when that signal is
delivered.

Signals are trapped or ignored with the \texttt{trap(s, p)} function.  Argument
\texttt{s} is the string name of the signal. The signal names vary by platform;
see Appendix E. You can trap any signal on any machine; if it is not defined it
will be ignored. For example, Linux systems don't have a \texttt{SIGLOST.}
Trapping that signal has no effect when a program runs on Linux. The
\texttt{trap()} function's second argument is the procedure to call when the
signal is received. The previous signal handler is returned from
\index{trap()}\texttt{trap()} so it can be restored by a subsequent call to
\texttt{trap()}. The signal handler defaults to the default provided by the
system. For instance, \texttt{SIGHUP} is ignored by default but \texttt{SIGFPE}
will cause the program to terminate.

Here is an example that handles a \texttt{SIGFPE} (floating point exception) by
printing out a message and then runs the system default handler:

\iconcode{
global oldhandler \\
\>   ... \\
\>   trap("SIGFPE", sig\_ignore) \\
\>   oldhandler := signal("SIGSEGV",
handler) \\
\>   ... \\
\ \ \ \# restore the old handler \\
\>   trap("SIGSEGV", oldhandler) \\
end \\
\ \\
procedure sig\_ignore(s); end
\ \\
procedure handler(s) \\
\>   write(\&errout, "Got signal ", s) \\
\>   ({\textbackslash}oldhandler)(s) \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \# propagate the signal \\
end
}

\subsection*{Launching programs}

Many applications execute other programs and read their results. In many cases,
the best way to do this is to call \texttt{open()} with mode \texttt{"p"}
(\index{pipe}pipe) to launch a command. In mode \texttt{"p"} the string argument
to \texttt{open()} is not a filename, it is an entire command string. Piped
commands opened for reading (mode \texttt{"p"} or \texttt{"pr"}) let your
program read the command's standard output, while piped commands open for
writing (mode \texttt{"pw"}) allow your program to write to the command's
standard input.

The more general function \texttt{system(x,f1,f2,f3,mode)} runs an external
command (argument \texttt{x}) with several options. If \texttt{x} is a list,
\texttt{x[1]} is the command to execute and the remaining list elements are its
command line arguments. If \texttt{x} is a string, it is parsed into arguments
separated by spaces. Arguments with spaces in them may be escaped using double
quotes. A program that calls \index{system()}\texttt{system()} normally waits
for the launched program to complete before continuing, and \texttt{system()}
returns the integer status of the completed command. If \texttt{s} ends in an
ampersand (\texttt{\&}) or the optional \texttt{mode} argument is \texttt{1} or
\texttt{"nowait"}, \texttt{system()} does not wait for the command to complete,
but instead launches the command in the background and returns an integer
process id. The \texttt{system()} function takes three optional file arguments
that specify redirected standard input, output, and error files for the launched
program.

\subsection*{Using file redirection and pipes}

\index{file!redirection}One common scenario is for a program to run
another program but with the input and output redirected to files. On
command-line systems like the Unix shells or the MS-DOS command prompt,
you may have used redirection:

\iconcode{
\ \ \ prog {\textless} file1
}

\noindent
File redirection characters and other platform-dependent operations are
supported in the command string passed to \texttt{system()}, as
in the following \texttt{system()} call:

\iconcode{
\>   system("prog {\textless} file1")
}

Pipes to and from the current program are nicely handled by the
\texttt{open()} function, but sometimes the input of one program needs
to be connected to the output of another program. You may have seen
uses like this:

\iconcode{
prog1 {\textbar} prog2
}

The \texttt{pipe()} function returns a pair of open files in a list,
with the property that anything written to the second file will appear
on the first. Here's how to hook up a pipe between two
programs:

\iconcode{
\>   L := pipe() {\textbar}
stop("Couldn't get pipe: ", \&errortext) \\
\>   system("prog1 \&", , L[2]) \\
\>   system("prog2 \&", L[1]) \\
\>   close(L[1]) \\
\>   close(L[2])
}

\subsection*{Process information}

The integer process identity can be obtained with
\index{getpid()}\texttt{getpid()}. The user id of the process can be
obtained with \index{getuid()}\texttt{getuid()} if the platform
supports it. Calls to obtain additional information such as group
identity on some platforms are described in Appendix E.

A parent process may want to be notified when any of its children quit
(or change status). This status can be obtained with the function
\index{wait()}\texttt{wait()}. When a child process changes state from
``running'' to either
``exited'' or
``terminated'' (and optionally
``stopped''), \texttt{wait()} returns a
string of the form

\iconcode{
pid:status:arg:core}

The \texttt{":core"} will only be present if
the system created a core file for the process. The status can be any
of \texttt{``exited''},
\texttt{``terminated''} or
\texttt{``stopped''}. The \texttt{arg} field
is either: a) the exit status of the program if it exited; or b) the
signal name if it was terminated. Typically \texttt{wait()} will be
used in the handler for the \texttt{SIGCHLD} signal which is sent to a
process when any of its children changes state.

The arguments to \texttt{wait()} are the pid of the process to wait for
and any options. The default for pid is to wait for all children. The
options may be either \texttt{"n"}, meaning
\texttt{wait()} should not wait for children to block but should return
immediately with any status that's available, or
\texttt{"u"}, meaning that any processes
that stopped should also be reported. These options may be combined by
using \texttt{"nu"}.

\subsection*{The \texttt{select()} system call}

Some programs need to be able to read data from more than one source.
For example, a program may have to handle network traffic and also
respond to the \index{keyboard}keyboard. The problem with using
\texttt{read()} is that if no input is available, the program will
block and will not be able to handle the other stream that may in fact
have input waiting on it. To handle this situation, you can use the
function \texttt{select(x1,x2,...i)}. The
\index{select()}\texttt{select()} function tells the system which files
you are interested in reading from, and when input becomes available on
any of those sources, the program will be notified. The
\texttt{select()} function takes files or lists of files as its
arguments, and returns a list of all files on which input is waiting.
If an integer argument is supplied, it is a timeout that gives the
maximum milliseconds to wait before input is available. If the timeout
expires, an empty list is returned. If no timeout is given, the program
waits indefinitely for input on one of the files.

\iconcode{
while *(L := select(f1, f2, f3, timeout)) = 0 do \\
\> handle\_timeout() \\
(\&errno = 0) {\textbar} stop("Select
 \index{expression failure}failed: ", \&errortext) \\
every f := !L do \{ \\
\> \# Dispatch reads pending on f \\
\> ... \\
\> \}
}

When using \texttt{select()} to process input from multiple files, you
may need to pay some attention to avoid blocking on any one of your
files. For example the function \texttt{read()} waits until an entire
line has been typed and then returns the whole line. Consider this
code, which waits for input from either a file (or network connection)
or a window designated by keyword \texttt{\&window}:

\iconcode{
\ \ \ while L := select(f, \&window) do \\
\ \ \ \ \ \ if !L === f then c := read(f)
}

Just because \texttt{select()} has returned doesn't
mean an entire line is available; \texttt{select()} only guarantees
that at least one character is available. The command shell log
application in Chapter 14 shows the usage of \texttt{select()}. Another
primary application area for \texttt{select()} is network programming,
described later in this chapter. For network connections, the function
\texttt{reads(f, i)} will return as soon as it has some input
characters available, rather than waiting for its maximum string size
of \texttt{i}. But if no input is available, reads() blocks.

\subsection*{Non-blocking input and the \texttt{ready()} function}

The function \texttt{ready(f, i)} is like \texttt{reads(f, i)} except
that it is non-blocking, that is, it returns immediately with up to
\texttt{i} bytes if they are available, but it does not wait around. It
is ideal for use with \texttt{select()} and in situations where a
server or client needs to interact with multiple remote connections.

\section[Networking]{Networking}
\index{networking}Unicon provides a very high-level interface to
\index{Internet}Internet communications. Applications with custom
communications use one of the major Internet
applications protocols, \index{TCP}TCP and UDP. An higher level
interface to several popular Internet protocols such as HTTP and POP is
provided by means of Unicon's messaging facilities.

\subsection*{TCP}

A TCP connection is a lot like a phone call: to make a connection you
need to know the address of the other end, just like a phone number.
For TCP, you need to know the name of the machine to connect to, and an
address on that machine, called a \textit{port}. A server listens for
connections to a port; a client sends requests to a port. Also, there
are two kinds of ports, called "Internet
Domain" and "Unix Domain."
The distinction is beyond the scope of this book; we will just mention
that Internet Domain ports are numbers, and Unix Domain ports look like
files. Also, a connection to a Unix domain port can only be made from
the same machine, so we will not consider the Unix domain further here.

A call to \texttt{open()} with mode
\texttt{"n"} (network) requests a network
connection. The first argument to \texttt{open()} is the network
address, a host:port pair for Internet domain connections, and a
filename for Unix domain sockets. If the address contains no host name
and therefore starts with \texttt{":"}, the
socket is opened on the same machine. The value returned by
\texttt{open()} is a file that can be used in \texttt{select()} and
related system functions, as well as normal reading and writing. 

A \index{client}client uses mode
\texttt{"n"} with \texttt{open()} to open a
connection to a TCP server. Here is a simple version of the Internet
"finger" program:

\iconcode{
procedure main(argv) \\
\>   local fserv := getserv("finger")
{\textbar} \\
\>   \ \ \ stop("Couldn't get service:
", \&errortext) \\
\>   name := argv[1] \\
\>   host := "" \\
\>   argv[1] ? \{ \\
\>   \ \ \ name := tab(find("@")) \&
="@" \& host := tab(0) \\
\>   \ \ \ \} \\
\>   if *host {\textgreater} 0 then
write("[", host,
"]") \\
\>   f := open(host {\textbar}{\textbar}
":" {\textbar}{\textbar} fserv.port,
"n") {\textbar} \\
\>   \ \ \ stop("Couldn't open
connection: ", \&errortext) \\
\ \\
\>   write(f, name) {\textbar}
stop("Couldn't write: ",
\&errortext) \\
\>   while write(read(f)) \\
end
}

Notice the use of \index{getserv()}\texttt{getserv()}. The
\texttt{posix\_servent} record it returns includes fields for the name,
aliases, port, and protocol used by the Internet service indicated in
\texttt{getserv()}'s argument. The Internet protocols
specify the ports to be used for various services; for instance, email
uses port 25. Instead of having to remember port numbers or hard-coding
them in our program, we can just use the name of the service and have
\texttt{getserv()} translate that into the port number and protocol we
need to use.

To write a \index{server}server, all we need to do is add
\texttt{"a"} (accept) to the mode after the
\texttt{"n"} in \texttt{open()}. Here is a
simple TCP server that listens on port 1888:

\iconcode{
procedure main() \\
\>   while f := open(":1888",
"na") do \{ \\
\>   \ \ \ system("myserverd -servicerequest
\&", f, f) \\
\>   \ \ \ close(f) \\
\>   \ \ \ \} \\
\>   (\&errno = 0) {\textbar} stop("Open failed:
", \&errortext) \\
end
}

The call \texttt{open(":1888",
"na")} blocks until a client connects.
The returned value is a file that represents the network connection.
This example server
responds to requests by launching a separate process to handle each
request. The network connection is passed to \texttt{myserverd} as its
standard input and output, so that process had better be expecting a
socket on its standard I/O files, and handle it appropriately.
This works on UNIX; on other platforms a different approach is needed.

Launching a separate process to handle requests is standard operating
procedure for many Internet servers, but besides the portability
concerns, it uses a lot of memory and CPU time. Many servers can be
implemented in a single process. Chapter 15 includes an example of such
a server. \ Mode \texttt{"na"} is less than
ideal for one-process servers: it only supports one connection at a
time. When waiting for a new connection, the process is not doing any
computation, and when servicing a connection, the program is not
listening for any other connection requests. Unless each connection is
of short duration, the server will appear to be down, or appear to be
unacceptably slow, to anyone trying to connect while an existing
request is being processed.

\subsection*{Determining IP numbers}

Many programs need the IP number of the machine they are talking to. Given a
network connection {\texttt f}, \index{image()}\texttt{image(f)} will show the
IP address and port of the client machine that is connected (this is sometimes
called the \index{peername}\textit{peername}).

Some programs need to know their own IP number, but each machine can have
several IP numbers, one for each kind of physical network hardware in operation.
To obtain a list of local IP numbers, a program can read the output of
\texttt{/sbin/ifconfig} (UNIX) or \texttt{ipconfig} (Windows). To find the IP
number used for a particular network connection \texttt{n}, on some platforms
you can call \texttt{gethost(n)}, which returns a string with the IP number and
port used by the local machine for a given connection.

If you do determine your IP number in one of these ways, it is usually not the
number seen by the world, because most devices are connecting through some form
of network address translation.  To see the number that the world sees, you have
to connect to someone else and ask them to tell you what IP number they see you
at.

\iconcode{
procedure main(argv) \\
\>   n := open(argv[1],"n") | \\
\>\>      stop("can't connect to ", argv[1]|"missing host") \\
\>   write("connected to: ", image(n)[6:-1]) \\
\>   write("using: ", gethost(n)) \\
end
}

\subsection*{Non-blocking network \texttt{open}s}

Servers need to never block. The call
\texttt{open(":port","nl")}
creates a \textit{listener} on the specified port, without waiting around for
someone to actually connect to it. The network file returned from
\texttt{open()} is not open for reading or writing, so it is not good for
much...yet. About the only thing you can do with such a file is include it
(along with any other network connections you have going) as an argument in a
call to \texttt{select()}. If a listener matches a current connection request,
\texttt{select()} converts it into a regular network connection as per mode
\texttt{"na"}.

In addition to non-blocking servers' listener connections, in the real-world
clients need a way to do an almost non-blocking connection as well.
TCP connections over long distances take a highly variable amount of time,
but most clients do not want to ``freeze'' for a couple of minutes while
the connection attempt times out. The network client versions of \texttt{open()}
allows an optional third parameter to supply it with a timeout value,
in milliseconds.

\subsection*{UDP}

\index{UDP}UDP is another protocol used on the Internet. TCP is like a
phone call: all messages you send on the connection are guaranteed to
arrive in the same order they were sent. UDP on the other hand is more
like the postal service, where messages are not guaranteed to reach
their destination and may not arrive in the same order they were sent
in. Messages sent via UDP are called \textit{datagrams}.
It's a lot cheaper (faster) to send UDP messages than
TCP, though, especially if you are sending them across the Internet
rather than to a local machine. Sending a postcard is usually cheaper
than a long distance phone call!

UDP datagrams can be sent either with an \texttt{open()/writes()}
pair, or with \texttt{send()}. Typically a server sends/receives on the
same socket so it will use \texttt{open()} with \texttt{read()} and
\texttt{write()}. A client that only sends one or two datagrams uses
\index{send()}\texttt{send()}\texttt{/}\index{receive()}\texttt{receive()}.

The following example provides a service called
"rdate" that allows a program to ask a
remote host what time it has. The server waits for request datagrams
and replies with the date and time. The
\texttt{"u"} flag added to the mode in the
call to \texttt{open()} signifies that a UDP connection should be used.
The function \texttt{receive()} waits for a datagram to arrive, and
then it constructs a record having the address the message came from
and the message in it. The server uses the address to send the reply.

\iconcode{
\ \ \ f := open(":1025",
"nua") \\
 \ \ while r := receive(f) do \{ \\
\ \ \ \ \ \ \# Process the request in r.msg \\
\ \ \ \ \ \ ... \\
\ \ \ \ \ \ send(r.addr, reply) \\
\ \ \ \ \ \ \}
}

The record returned by \texttt{receive()} has two fields: the
\texttt{addr} field contains the address of the sender in
\texttt{"}\texttt{\textit{host}}\texttt{:}\texttt{\textit{port}}\texttt{"}
form, and the \texttt{msg} field contains the message.

To write a UDP client, use mode \texttt{"nu"}
Since UDP is not reliable, the \texttt{receive()} is guarded
with a \texttt{select()}; otherwise, the program might hang forever if
the reply is lost. The timeout of five seconds in the call to
\texttt{select()} is arbitrary and might not be long enough on a
congested network or to access a very remote host. Notice the second
argument to \texttt{getserv()}; it restricts the search for Internet
service information to a particular network protocol, in this case UDP.

\iconcode{
procedure main(args) \\
\>   (*args = 1) {\textbar} stop("Usage: rdate
host") \\
\>   host := args[1] \\
\>   s := getserv("daytime",
"udp") \\
\>   f :=
open(host{\textbar}{\textbar}":"{\textbar}{\textbar}s.port,
"nu") {\textbar} \\
\>   \ \ \ stop("Open failed: ",
\&errortext) \\
\>   writes(f, " ") \\
\>   if *select(f, 5000) = 0 then \\
\>   \ \ \ stop("Connection timed out.") \\
\>   r := receive(f) \\
\>   write("Time on ", host,
" is ", r.msg) \\
end
}

From these examples you can see that it is relatively easy to write
programs that use Internet communication. But TCP and UDP are very
general, somewhat low-level protocols; most programs employ a
higher-level communication protocol, either by defining their own, or
using a standard protocol. If you need to define your own Internet
protocol, you can do it on top of TCP or UDP; if your program needs to
use a standard Internet protocol, you should check first to see if the
protocol is built-in to the language as part of the messaging
facilities, described in the next section.

\subsection*{Secure Sockets}

Unicon offers secure sockets to encrypt data when using the TCP/UDP protocols.

Example server code:
\iconcode{
procedure main() \\
\>   sock := open("localhost:6600", "nae", "key=server.key",
\"cert=server.crt", "ca=ca.crt")  | \\
\>\>\>\>stop(\&errortext) \\
\>   select(sock) \# wait for input\\
\>   msg := ready(sock) \\
\>   write("Message from client:", msg) \\
\>   writes(sock, msg)  \# echo back the same message to the client\\
\>   close(sock) \\
end
}

Example client code:
\iconcode{
procedure main() \\
\>   sock := open("localhost:6600", "ne") | stop(\&errortext) \\
\>   writes(sock, "Hello SSL Socket") \\
\>   select(sock)  \# wait for input\\
\>   msg := ready(sock) \\
\>   write("Message from server:", msg) \\
\>   close(sock) \\
end
}

\section{Messaging Facilities}

Unicon's \index{messaging}messaging facilities provide
higher level access to many popular Internet protocols. A call to
\texttt{open()} using mode \texttt{"m"}
establishes a messaging connection. The filename argument to a
messaging connection is a URI (Uniform Resource Indicator) that
specifies the protocol, host machine, and resource to read or write.
The protocols implemented thusfar are HTTP, HTTPS, Finger, SMTP, and POP.
Extra arguments to open() are used to send headers defined by the
protocol. For example, the call

\iconcode{
open("mailto:unicon-group", "m", "Reply To: jeffery@cs.uidaho.edu")}

\noindent
supplies a Reply To field as a third parameter to \texttt{open()} on an
SMTP connection.

Header fields from the server's response to a
connection are read by subscripting the message connection value
with a string header name; an example is in the next section.

\subsection*{HTTP and HTTPS}

\index{HTTP}HTTP is used to read or write to Web servers; the content
read or written typically consists of \index{HTML}HTML text. The
following program, \texttt{httpget.icn}, fetches a remote file
specified by a URI on the command line, and saves it as a local file.
The Icon Program Library module \texttt{basename} is used to extract
the filename from the URI.

\iconcode{
link basename}

\iconcode{
procedure main(argv) \\
\>   f1 := open(argv[1],"m") \\
\>   f2 := open(basename(argv[1]),"w") \\
\>   while write(f2, read(f1)) \\
end
}

This example retrieves the actual data for a successful HTTP request;
for a failed request the connection returns no data, appearing to be an
empty file. Programs can check the HTTP status code in order to
determine the nature of the problem. Status codes and other metadata
from HTTP header lines are inspected by subscripting the connection
with the desired header. For example, in the previous program, checking
\texttt{f1["Status-Code"]} would allow us
to detect HTTP errors, and
\texttt{f1["Location"]} would allow us to
find the new location of the file, if the HTTP server had informed us
that the file had moved. You can retrieve this status information on a
remote file without retrieving the file itself. If you open a URI with
mode \texttt{"ms"} instead of
\texttt{"m"}, an HTTP request for header
information is made, but no data is retrieved.

\index{HTTPS}HTTPS is HTTP communicated over a secure-socket
encryption layer. The encryption requires the use of encryption keys
and certificates to validate the authenticity of the remote site.
Certificates are typically stored in a directory or a
database of some kind. Mode \texttt{"m-"} may be used in
\texttt{open()} to skip the validation of the certificate provided
by the remote site.

\subsection*{SMTP and POP}

\index{SMTP}SMTP is used to send a mail message. Mail is delivered via
an SMTP server machine on which the user must have a valid account.
These default to the current user on the current host machine. Two
environment variables UNICON\_SMTPSERVER and UNICON\_USERADDRESS can be
set to override the default behavior.

\index{POP}POP is used to read mail messages. POP is the least file-like
of these protocols. A POP connection feels like a list of strings, each
string containing an entire mail message, rather than a simple sequence
of bytes. Function \texttt{read()} and operator \texttt{!} produce
entire messages which in general contain many newline characters. POP
messages may be removed by either \index{delete()!from POP
mail}\texttt{delete()} or \index{pop()!from POP mail}\texttt{pop()};
messages are buffered in such a way that message removal on the server
occurs when the connection is explicitly and successfully closed.

Here's a simple program that illustrates the use of
messaging to get email from a POP server. It gets messages from the
server without deleting them and, for every message, prints out who the
message is from as well as the subject line.

\iconcode{
procedure main(argv) \\
\>   user := argv[1] {\textbar}
getenv("USER") {\textbar}
stop("no user") \\
\>   passwd := argv[2] {\textbar}
getenv("PASSWD") {\textbar}
stop("no password") \\
\>   server := argv[3] {\textbar}
getenv("MAILHOST") {\textbar}
"mailhost" \\
\>   conn :=
open("pop://"{\textbar}{\textbar}user{\textbar}{\textbar}":"{\textbar}{\textbar}passwd{\textbar}{\textbar}"@"{\textbar}{\textbar}server,
"m") {\textbar} \\
\>   \ \ \ stop("couldn't connect to
the POP server ", server) \\
\>   every msg := !conn do msg ? \\
\>   \ \ \ while line :=
tab(find("{\textbackslash}n")) do \\
\>   \ \ \ \ \ \ if =("From: "
{\textbar} "Subject: ") then
write(line) \\
\>   close(conn) \\
end
}

\noindent
You should improve the password handling in this program if you use it!
Chapter 14 includes another example use of
Unicon's POP messaging facilities: a spam filter.

\section{Tasks}

A {\em task\/} is an executing program within the Unicon virtual
machine.\index{task} A single task called the {\em root\/} is created
when the interpreter starts execution. Additional tasks are created
dynamically as needed.

The tasking facilities allow Unicon programs to load, execute,
communicate with, and control one another, all within a single
instantiation of the Unicon interpreter. 

Although Unicon programs can use the tasking facilities to load and
execute any number of other programs within the same interpreter space,
the tasking facilities do not introduce a concurrent programming
construct nor do they include special support for multiprocessor
hardware. Their domain is that of high-level language support for
programs that benefit from or require a tighter coupling than that
provided by inter-process communication; that is, programs that access
each other's state extensively.

Co-expressions provide the tasking facilities' program
execution model, and co-expression activation serves as the
communication mechanism. The extensions are general enough to be useful
in a wide variety of contexts. For example, programs that use the
multi-tasking interface can communicate directly without resorting to
external files or pipes.

At the language level, the tasking facilities include several
built-in functions and keywords, but no new types, declarations, or
control structures. Several existing functions have been extended to
offer additional support for the multi-tasking environment. 
Separate memory allocation regions are established for each task. 

\subsection*{Preliminary terminology}

Before describing the task model, a few definitions are needed. These
definitions pertain to regions of memory referenced by programs during
execution. 

A \textit{name space} is a mapping from a set of program source-code
identifiers to a set of associated memory locations [Abelson85]. Icon
programs have a global name space shared across the entire program and
various name spaces associated with procedures. Procedures each have a
static name space consisting of memory locations shared by all
invocations of the procedure and local name spaces private to each
individual invocation of the procedure.
When a co-expression is created, a new local name space is allocated for
the currently executing procedure, and the current values of the local
variables are copied into the new name space for subsequent use by the
co-expression. 

An Icon program has an associated \textit{program state} consisting of
the memory associated with global and static name spaces, keywords, and
dynamic memory regions. Similarly, a co-expression has an associated
\textit{co-expression state} consisting of an evaluation stack that
contains the memory used to implement one or more local name spaces.
Co-expressions in an Icon program share access to the program state and
can use it to communicate. 

\subsection*{Tasks as extended co-expressions}

A task consists of a main co-expression and zero or more child
co-expressions that share a {\em program state\/} \index{program state}
consisting of the global and static name
spaces, keywords, and dynamic memory regions. At the source-language
level, tasks are loaded, referenced, and activated solely in terms of
one of their member co-expressions; the task itself is implicit.
Co-expressions share access to the program state and can use it to
communicate.
Unicon provides the task model as a mechanism for multi-tasking, but does
not predefine the policy; matters such as the scheduling algorithm used and
whether multi-tasking is co-operative or pre-emptive are programmable at the
user level in terms of co-expression activations.


\subsection*{Task creation}

A task can create other tasks. The function 

\iconcode{
load(s, L, f1, f2, f3, i1, i2, i3)}

\noindent loads an icode file \cite{Gris86} specified by the file name
\textrm{s}, creates a task for it and returns a co-expression corresponding to
the invocation of the procedure {\textrm{main(L)}} in the
loaded icode file.  {\textrm{L}}{
}defaults to the empty list. Unlike conventional Icon command-line argument
lists, the argument list passed to{
}{\textrm{load()}} can contain values of any type, such as
procedures, lists, and tables in the calling task.

The task being loaded is termed the child task, while the task calling
{\textrm{load()}} is termed the parent. The
collection of all tasks forms a tree of parent-child
relationships.

{\texttt{f1}}, {\texttt{f2}},
and {\texttt{f3}}{ }are file
arguments to use as {\texttt{\&input}},
{\texttt{\&output}}, and
{\texttt{\&error}} in the loaded task;
{\texttt{\&input}},
{\texttt{\&output}}, and
{\texttt{\&error}}{\textrm{
}}default to those of the loading task.{\textrm{
}}{\texttt{i1,}} {\texttt{i2}},
and {\texttt{i3}} are three integer arguments that
supply initial region sizes for the task's block,
string, and stack memory areas, respectively.
{\texttt{i1}} and {\texttt{i2}}
default to 65000, while {\texttt{i3 }}defaults to
20000 (the defaults may be changed by the environment variables
{\texttt{BLKSIZE}},
{\texttt{STRSIZ}}\texttt{E}, and
{\texttt{MSTKSIZE}}). 

\subsection*{Running other programs}

\index{run!loaded program}
A co-expression created by {\texttt{load()}} is
activated like any other co-expression. When activated with the
{\texttt{@}} operator, the child task begins
executing its main procedure. Unless it suspends or activates
{\texttt{\&source}}, the child task runs to
completion, after which control is returned to the parent. Chapter 5
presents an alternative means of executing a child with which the
parent retains control over the child as it executes. 

This default behavior is illustrated by the program
\texttt{seqload}, which loads and executes each
of its arguments (string names of executable Unicon programs) in turn.
Each of the strings passed on the command line and extracted from the
list using the element-generation operator,
{\texttt{!}}) is passed in turn to
{\texttt{load()}}, which reads the code for each argument
and creates a task in which to execute the loaded program. The tasks
are then executed one-by-one by the co-expression activation operator,
{\texttt{@}}. There is
nothing special about this example except the semantics of the
{\texttt{load()}} function and the independent
execution environment (separate global variables, heaps, and so forth),
that {\texttt{load()}} provides to each task. 

\iconcode{
\# seqload.icn \\
procedure main(arguments) \\
\>   every @load(!arguments) \\
end
}

For example, if three Icon programs whose executable files are named
translate, assemble, and link are to be run in succession, the command 

\iconcode{
{\texttt{seqload translate assemble link}}}

\noindent
executes the three programs without reloading the interpreter for each
program. 

\subsection*{Data access}

Although tasks have separate program states, they reside in the same
address space and can share data; values can be transmitted from task
to task through {\texttt{main()}}'s argument list, through
co-expression activation, or by use of event monitoring facilities
described in Chapter 10. In the following pair of programs, the
parent receives a list value from the child and writes its elements
out in reverse order.

\iconcode{
\# parent.icn \\
procedure main() \\
\>   L := @ load("child") \\
\>   while write(pull(L)) \\
end \\
\ \\
\# child.icn \\
procedure main() \\
\>   L := [ ] \\
\>   while put(L, read()) \\
\>   return L \\
end
}


\subsection*{Access Through Task Argument Lists}

The following program takes its first argument to be an Icon program
to load and execute as a child, sorts its remaining arguments, and
supplies them to the child program as its command-line arguments
({\tt pop()} and {\tt sort()} are Icon built-in functions that extract
the first list element and sort elements, respectively):

\iconcode{
	procedure main(arguments) \\
\>	   @load(pop(arguments), sort(arguments)) \\
	end
}

Argument lists allow more sophisticated data transfers; the {\tt seqload} 
example presented earlier can be extended to transmit arbitrary
structures between programs using argument lists in the following
manner.  As in {\tt seqload}, each string naming an executable Icon
program is passed into {\tt load()}, and the resulting task is
activated to execute the program.  In this case, however, any result
that is returned by one of the programs is assigned to local variable
{\tt L} and passed to the next program in the list via the second
argument to {\tt load()}.

\iconcode{
     \# seqload2.icn \\
     procedure main(arguments) \\
\>	every program := !arguments do \\
\>\>	   L := @load(program, L) \\
     end
}

The net effect of {\tt seqload2.icn} is similar to a UNIX pipe, with
an important difference: Arbitrary Icon values can be passed from
program to program through the argument lists.
This capability is more interesting in substantial multipass tools
such as compilers, where full data structures can be passed along from
tool to tool instead of writing out text encodings of the structures
to a file.


\subsection*{Inter-task Access Functions}

Several built-in functions
\index{access!variable}\index{variable@{\tt variable()}}
provide inter-task access to program data.  These functions
are usable in any multi-task Unicon context, but are especially
useful in program execution monitoring, discussed in Chapter 9.

For example, the
{\tt variable()} function takes a co-expression value as an
optional second argument denoting the task from which to fetch the named
variable. {\tt variable(s, C)} is
useful for assigning to or reading from another task's
variables. In the following {\tt seqload} example, the
parent initializes each child's {\tt Parent} global
variable (if there is one) to refer to the parent's {\tt \&main}
co-expression.  A child task can then use {\tt Parent} to determine
whether it is being run standalone or under a parent task.
The {\tt variable()} function is
useful in inspecting values, especially at intermediate points during
the monitored execution of a TP.

\iconcode{
     \# seqload3.icn \\
     procedure main(arguments) \\
\>	every arg := !arguments do \{ \\
\>\>	   Task := load(arg) \\
\>\>	   variable(\"Parent\", Task) := \&main \\
\>\>	   @Task \\
\>\>	   \} \\
	end
}

In addition to extending existing functions for monitoring,
several new functions have been added.  The use of these monitoring functions
are illustrated in many example monitors in Unicon's
ipl/mprogs directory.  Some of the intertask access functions
are listed in Figure 5-1.  In these functions, parameter {\tt C}
refers to a co-expression that may be from a task other than the one being
executed.  Functions that {\em generate\/}
values can produce more than one result from a given call.
\index{function!execution monitoring}\index{generator!function}
\index{access!functions}

\begin{center}

\begin{tabular}{|ll|} \hline
{\bf\tt cofail(C)}      & transmit failure to {\tt C}. \\
{\bf\tt fieldnames(r)}  & generate fieldnames of record {\tt r}. \\
{\bf\tt globalnames(C)} & generate the names of {\tt C}'s global
variables. \\
{\bf\tt keyword(s, C)} & produces keyword {\tt s} in {\tt C}. \\
	& Keywords are special global variables that have \\
	& special semantics in certain language facilities.\\
{\bf\tt localnames(C,i)} & generates the names of {\tt C}'s local variables,\\
	& {\tt i} calls up from the current procedure call. \\
{\bf\tt paramnames(C,i)} & generates the names of {\tt C}'s parameters. \\
{\bf\tt staticnames(C,i)} & generates the names of {\tt C}'s static variables. \\
{\bf\tt structure(C)} & generates the values in {\tt C}'s block
region, or heap. \\
	 & The heap holds structure types such as lists and tables. \\
{\bf\tt variable(s,C,i)} & produces variable named {\tt s}, interpreted {\tt i} levels\\
	& up within {\tt C}'s procedure stack. \\
\hline
\end{tabular}
\end{center}

{\sffamily\bfseries Figure 5-1:}
{\sffamily Unicon interprogram access functions.}



\subsection*{Shared icode libraries}

Programs that are written to take advantage of the multi-tasking environment
gain in space efficiency and modularity. Code sharing is one natural way to
achieve space efficiency in a collection of programs. Since procedures are
first-class data values in Icon, code sharing can be implemented via data
sharing. Programs executing in a single invocation of the interpreter can share
code easily if the code is not required to produce side effects on global
variables in the calling task's program state. If side-effects to the calling
task's program state are required, the shared code must generally be written
with care to explicitly reference the calling task's state. Side effects in the
client task can also be achieved through the parameters passed in and results
obtained by calling the shared procedure.

\subsection*{Loading shared code}

Consider a collection of applications that make extensive use of
procedures found in the Icon program library (IPL) [Griswold90c]. If
those applications are run using MT Icon, the IPL routines need be
loaded only once, after which they may be shared.

In order to reference shared code from a loaded task, two additional
considerations must be satisfied: the shared code must be loaded, and
the client tasks must be able to dynamically link shared routines into
their generated code.

Both of these problems can be solved entirely at the source level: In
order to introduce a shared Icon procedure into the name space, a
global variable of the same name must be declared. Managing the
loading of shared libraries is itself a natural task to assign to an
Icon procedure that uses a table to map strings to the pointers to the
procedures in question.

\subsection*{Code sharing example}

The following collection of three programs illustrate one schema that allows
code sharing. Other conventions can certainly be devised, and much of the
sharing infrastructure presented here can be automatically generated. Program
calc.icn consists of a shared library procedure named {\texttt{calc()}} and a
main procedure that exports a reference to {\texttt{calc()}} for sharing:

\iconcode{
\# calc.icn \\
procedure calc(args...) \\
\>   \# code for calc \\
\>   \# (may call other routines in calc.icn if there are any) \\
end \\
\ \\
procedure main() \\
\>   \# initialization code, if any \\
\>   return calc \\
end
}

Note that a module exporting shared procedures can also have global
variables (possibly initialized from other command-line arguments).
Shared modules can export other values besides procedures using the
same mechanism.

The parent task that loads the various shared library clients implements
a procedural encapsulation ({\texttt{loadlib()}} in
this example) of an Icon table to store references to shared routines.
The parent passes this procedure to clients. Each client calls the
procedure for each shared routine. Routines that are already loaded are
returned to requesting tasks after a simple Icon table lookup. Whenever
a routine is requested that has not been loaded, the
{\texttt{load()}} function is called and the shared
library activated. 

\iconcode{
procedure main(arguments) \\
\>   @load("client",put(arguments,loadlib)) \\
end \\
\ \\
procedure loadlib(s, C) \\
\>   static sharedlib \\
\>   initial sharedlib := table() \\
\>   sharedlib[s] := @load(s) \\
\>   variable(s, C) := sharedlib[s] \\
end
}

A client of {\texttt{calc}} declares a global variable named {\textrm{calc}},
and assigns its value after inspecting its argument list to find the shared
library loader:

\iconcode{
global loadlib \\
global calc \\
procedure main(arguments) \\
\>   if /loadlib then stop("no shared libraries
present") \\
\>   loadlib("calc", \&current) \\
\>   \# ... remainder of program may call shared calc \\
end
}

\subsection*{Sharing procedure collections}

The primary deficiency of the previous example is that it requires one
shared library procedure per Icon module, that is, separate
compilation. In practice it is more convenient to have a collection of
related procedures in a given Icon compilation unit. Shared libraries
can employ such a mechanism by resorting to a simple database that
maps procedure names to load modules.

\section{Summary}

Unicon's system facilities provide a high-level interface to the
common features of modern operating systems, such as directories and
network connections. This interface is vital to most programs, and it
also presents the main portability challenges, since a Unicon design
goal is for applications to require no \index{source code}source code
changes and no conditional code needed to run on most operating
systems. Of course some application domains such as system
administration are inevitably platform dependent.

There are two major areas of the system interface that are whole application
domains extensive enough to warrant an entire chapter of their own:
\index{database}databases and graphics. Databases can be viewed as a hybrid of
the file and directory system interface with some of the data structures
described in Chapter 2. Since many databases are implemented using a
client/server architecture, the database interface also includes aspects of
networking. Databases are presented in the Chapter 6.

Graphics is another crucial component of the system interface, rich
enough to warrant special features built-in to the language, and deep
enough to warrant an entire book. Like databases, graphics can be
viewed as an extension of the file data type described in this
chapter.  Unicon's powerful 2D and 3D graphics facilities are
discussed in Chapter 7.


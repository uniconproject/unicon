\clearpage\section{Appendix A: Language Reference}

Unicon is expression-based. Nearly everything is an expression,
including the common \index{control structure}control structures such
as while loops. The only things that are not expressions are
declarations for procedures, methods, variables, records, classes, and
linked libraries.

In the reference, types are listed for parameters and results. If an
identifier is used, any type is allowed. For results,
\index{generator}generator expressions are further annotated with an
asterisk (\textsf{\textbf{*}}) and non-generators that can
\index{expression failure}fail are annotated with a question mark
(\textsf{?}). A question mark by itself is shorthand for \textsf{null?}
and denotes a predicate whose success or failure is what matters; the
predicate return value (\textsf{\&null}) is not significant.

\subsection{Immutable Types}

Unicon{\textquotesingle}s immutable types are integers, real numbers,
strings, and csets. Values of these types cannot change. Operators and
functions on immutable types produce new values rather than modify
existing ones. The simplest expressions are literal values, which occur
only for immutable types. A literal value evaluates to itself.

\subsubsection{Integer}

Integers are of arbitrary precision. Decimal \index{integer}integer
literals are contiguous sequences of the digits 0 through 9, optionally
preceded by a + or - sign. Radix integer literals use the format
\textit{radix}R\textit{digits}, where \textit{radix} is a base in the
range 2 through 36, and \textit{digits} consists of one or more
numerals in the supplied radix. After values 0-9, the letters A-Z are
used for values 10-35. Radix literals are case insensitive, unlike the
rest of the language, so the R may be upper or lower case, as may the
following alphabetic digits.

\subsubsection{Real}

\index{real number}Reals are double-precision floating-point values.
Real decimal literals are contiguous sequences of the digits 0 through
9, with a decimal point (a period) somewhere within or at either end of
the digits. Real exponent literals use the format
\textit{number}E\textit{integer}; E may be upper or lower case.

\subsubsection[String]{String}

\index{string}Strings are sequences of 0 or more characters, where a
character is a value with a platform-dependent size and symbolic
representation. On platforms with multi-byte character sets, multiple
Icon characters represent a single symbol using a platform-dependent
encoding.

String literals consist of 0 or more characters enclosed in double
quotes. A string literal may include escape sequences that use multiple
characters to encode special characters. The escape sequences are given
in Table 3-1. Incomplete \index{string!multi-line}string literals may
be continued on the next line if the last character on a line is an
underscore (\_). In that case, the underscore, the newline, and any
whitespace at the beginning of the next line are not part of the string
literal.

\subsubsection[Cset]{Cset}

\index{cset}Csets are sets of 0 or more characters. Cset literals
consist of 0 or more characters enclosed in single quotes. As with
strings, a \index{cset literal}cset literal may include escape
sequences that use multiple characters to encode special characters.

\subsection{Mutable Types}

Mutable types have values that may be altered. Changes to a
\index{mutable value}mutable value affect its allocated memory or its
associated persistent storage. Mutable types include lists, tables,
sets, records, objects, and files, including windows, network
connections and \index{database}databases. These types are described in
this Appendix in the entries for \index{constructor}constructors that
create mutable values. \index{structure types}Structure types hold
collections of elements that may be of arbitrary, mixed type.

\subsubsection{List}

\index{list}Lists are dynamically sized, ordered sequences of zero or
more values. \ They are constructed by function, by an explicit
operator, or implicitly by a call to a variable argument procedure.
They change size by \index{stack}stack and \index{queue}queue
functions.

\subsubsection{Table}

\index{table}Tables are dynamically sized, unordered mappings from keys
to elements. They are constructed by function. The keys may be of
arbitrary, mixed type.

\subsubsection{Set}

\index{set}Sets are unordered collections. They are constructed by
function.

\subsubsection{Record}

\index{record}Records are ordered, fixed length sequences of elements
that may be accessed via named fields.

\subsubsection{Object}

\index{object}Objects are ordered, fixed length sequences of elements
that may be accessed via named fields and methods. Field access to
object state is a widely deprecated practice.

\subsubsection[File]{File}

\index{file}Files are system interface values that correspond to data on
secondary storage, areas on users{\textquotesingle} displays, network
connections, or \index{database}databases. Operations on files are
input or output functions that cause side effects on the system outside
of the program execution.

\subsection{Variables}

Variables are names for locations in memory where values can be stored.
Values are stored in variables by \index{assignment}assignment
operators. A \index{variable}variable name begins with a letter or
underscore, followed by zero or more letters, underscores, or digits. A
variable name cannot be the same as one of Icon{\textquotesingle}s
reserved words, nor can it be the same as one of
Icon{\textquotesingle}s keywords if it follows an adjacent ampersand
character. Variables can hold values of any type, and may hold
different types of values at different times during program execution.

There are four kinds of variables: \index{global}global,
\index{local}local, \index{static, and class}static, and class. Global,
local, and static variables are declared by introducing one of the
reserved words (\textsf{global}, \textsf{local}, or \textsf{static})
followed by a comma-separated list of variable names. Global variables
are declared outside of any procedure or method body, while local and
static variables are declared at the beginning of procedure and method
bodies. Local and static variable names may optionally be followed by
an assignment operator and an initial value; otherwise all variables
other than procedure and class names begin with the null value,
\textsf{\&null}.

\index{aliasing}\textit{Aliasing} occurs when two or more variables
refer to the same value, such that operations on one variable might
affect the other. Aliasing is a common source of program bugs.
Variables holding integer, real, string, or cset values are never
aliased, because those types are immutable.

\subsubsection{Global}

Global variables are visible everywhere in the program, and exist at the
same location for the entire program execution. Declaring a procedure
declares a global variable and preinitializes it to the procedure value
that corresponds to the code for that procedure.

\subsubsection{Local}

Local variables are visible only within a single procedure or method,
and exist at any particular location only for the duration of a single
procedure invocation, including suspensions and resumptions, until the
procedure returns, fails, or is \textit{vanquished} by the return or
failure of one of its ancestor invocations. Variables that are
undeclared in any \index{scope}scope are implicitly local, but this
dangerous practice is deprecated and should be avoided in large
programs.

Variables that are declared as \textit{parameters} are local variables
that are preinitialized to the values of actual parameters at the time
of a procedure or method invocation. The semantics of parameter passing
are the same as those of assignment.

\subsubsection{Static}

Static variables are visible only within a single procedure or method,
but exist at the same location for the entire program execution. The
value stored in a static variable is preserved between multiple calls
to the procedure in which it is declared.

\subsubsection{Class}

Class variables are visible within the methods of a declared class. A
set of class variables is created for each
\index{instance!class}instance (object) of the class. The lifespan of
class variables is the same as the life span of the instance to which
they belong. The value stored in a class variable is preserved between
multiple calls to the methods of the class in which it is declared.

\subsection[Keywords]{Keywords}

Keywords are names with global \index{scope}scope and special semantics
within the language. They begin with an ampersand character. Some
keywords are names of common constant values, while others are names of
variables that play a special role in Icon{\textquotesingle}s
\index{control structure}control structures. The name of the keyword is
followed by a : if it is read-only, or a := if it is a variable,
followed by the type of value the keyword holds.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&allocated : integer* \hfill report memory use}

\noindent
\index{memory use}\textsf{\&allocated} generates the cumulative number
of bytes allocated in heap, static, string, and block regions during
the entire program execution.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&ascii : cset \hfill ASCII character set}

\noindent
\index{ASCII, \&ascii}\textsf{\&ascii} produces a cset corresponding to
the ASCII characters.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&clock : string \hfill time of day}

\noindent
\textsf{\&clock} produces a string consisting of the current \index{time
of day \&clock}time of day in hh:mm:ss format. See also keyword
\textsf{\&now}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&collections : integer* \hfill garbage collection activity}

\noindent
\index{garbage collection}\textsf{\&collections} generates the number of
times memory has been reclaimed in heap, static, string, and block
regions.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&column : integer \hfill source code column}

\noindent
\textsf{\&column} returns the \index{source code}source code
\index{column number}column number of the current execution point. This
is especially useful for execution monitoring.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&cset : cset \hfill universal character set}

\noindent
\index{cset, universal \&cset}\textsf{\&cset} produces a cset constant
corresponding to the universal set of all characters.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&current :co{}-expression \hfill current co{}-expression}

\noindent
\index{current co-expression}\textsf{\&current} produces the
co-expression that is currently executing.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&date : string \hfill today{\textquotesingle}s date}

\noindent
\index{today \&date}\textsf{\&date} produces the current
\index{date}date in yyyy/mm/dd format.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&dateline : string \hfill time stamp}

\noindent
\index{time stamp}\textsf{\&dateline} produces a human-readable time
stamp that includes the day of the week, the date, and the current
time, down to the minute.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&digits : cset \hfill digit characters}

\noindent
\index{digits, cset \&digits}\textsf{\&digits} produces a cset constant
corresponding to the set of digit characters 0-9.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&dump := integer \hfill termination dump}

\noindent
\textsf{\&dump} controls whether the program dumps information on
program termination or not. If \textsf{\&dump} is nonzero when the
program halts, a dump of local and global variables and their values is
produced.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&e : real \hfill natural log e}

\noindent
\index{natural log, \&e}\textsf{\&e} is the base of the natural
logarithms, 2.7182818...

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&error := integer \hfill fail on error}

\noindent
\index{error!convert to failure}\textsf{\&error} controls whether
runtime errors are converted into expression failure. By assigning to
this keyword, error conversion can be enabled or disabled for specific
sections of code. The integer \&error is decremented by one on each
error, and if it reaches zero, a runtime error is generated. Assigning
a value of -1 effectively disables runtime errors indefinitely. See
also \textsf{\&syserr}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&errornumber : integer? \hfill runtime error code}

\noindent
\textsf{\&errornumber} is the error number of the last runtime error
that was converted to failure, if there was one.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&errortext : string? \hfill runtime error message}

\noindent
\index{error!message, \&errortext}\textsf{\&errortext} is the error
message of the last error that was converted to failure.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&errorvalue : any? \hfill offending value}

\noindent
\textsf{\&errorvalue} is the erroneous value of the last error that was
converted to failure.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&errout : file \hfill standard error file}

\noindent
\index{error!standard file \&errout}\textsf{\&errout} is the standard
error file. It is the default destination to which runtime errors and
program termination messages are written.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&eventcode := integer \hfill program execution event}

\noindent
\index{event code!program execution}\textsf{\&eventcode} indicates the
kind of behavior that occurred in a monitored program at the time of
the most recent call to \textsf{EvGet()}. This keyword is only
supported under interpreters built with execution monitoring support.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&eventsource := co{}-expression \hfill
	source of program execution events}

\noindent
\textsf{\&eventsource} is the co-expression that transmitted the most
recent event to the current program. This keyword is null unless the
program is an execution monitor. See also \textsf{\&source}. Under a
monitor coordinator, \textsf{\&eventsource} is the coordinator and
global variable Monitored is the target program.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&eventvalue := any \hfill program execution value}

\noindent
\index{event value!program execution}\textsf{\&eventvalue} is a value
from the monitored program that was being processed at the time of the
last program event returned by \textsf{EvGet()}. This keyword is only
supported under interpreters built with execution monitoring support.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&fail : none \hfill expression failure}

\noindent
\index{expression failure!\&fail}\textsf{\&fail} never produces a
result. Evaluating it always fails.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&features : string* \hfill platform features}

\noindent
\index{features}\textsf{\&features} generates strings that indicate the
non-portable features supported on the current platform.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&file : string? \hfill current source file}

\noindent
\textsf{\&file} is the name of the \index{source file}source file for
the current execution point, if there is one. This is especially useful
for execution monitoring.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&host : string \hfill host machine name}

\noindent
\index{host machine name, \&host}\textsf{\&host} is a string that
identifies the host computer Icon is running on.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&input : file \hfill standard input file}

\noindent
\index{input!standard file \&input}\textsf{\&input} is a standard input
file. It is the default source for file input functions.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&lcase : cset \hfill lowercase letters}

\noindent
\index{lowercase, cset \&lcase}\textsf{\&lcase} is a cset consisting of
the lowercase letters from a to z.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&letters : cset \hfill letters}

\noindent
\index{letters, cset \&letters}\textsf{\&letters} is a cset consisting
of the upper and lowercase letters A-Z and a-z.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&level : integer \hfill call depth}

\noindent
\index{call depth}\textsf{\&level} gives the nesting level of the
currently active procedure call. This keyword is not supported under
the optimizing compiler, iconc.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&line : integer \hfill current source line number}

\noindent
\index{line number}\textsf{\&line} is the line number in the
\index{source code!line}source code that is currently executing.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&main : co{}-expression \hfill main task}

\noindent
\index{main task}\textsf{\&main} is the co-expression in which program
execution began.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&now : integer \hfill current time}

\noindent
\textsf{\&}\index{now}\textsf{now} produces the current time as the
number of seconds since the epoch beginning 00:00:00 GMT, January 1,
1970. See also \&clock

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&null : null \hfill null value}

\noindent
\index{null value}\textsf{\&null} produces the null value.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&output : file \hfill standard output file}

\noindent
\index{output!standard file \&output}\textsf{\&output} is the standard
output file. It is the default destination for file output.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&phi : real \hfill golden ratio}

\noindent
\index{phi, golden ratio \&phi}\index{golden ratio, \&phi}\textsf{\&phi}
is the golden ratio, 1.618033988...

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&pi : real \hfill pi}

\noindent
\index{pi, 3.14... \&pi}\textsf{\&pi} is the value of pi, 3.141592653...

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&pos := integer \hfill string scanning position}

\noindent
\index{position, string}\textsf{\&pos} is the position within the
current subject of string scanning. It is assigned implicitly by
entering a string scanning environment, moving or tabbing within the
environment, or assigning a new value to \textsf{\&subject}.
\textsf{\&pos} may not be assigned a value that is outside the range of
legal indices for the current \textsf{\&subject} string.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&progname := string \hfill program name}

\noindent
\index{program name}\textsf{\&progname} is the name of the current
executing program.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&random := integer \hfill random number seed}

\noindent
\index{random!number seed}\textsf{\&random} is the seed for random
numbers produced by the random operator, unary \textsf{?}. It is
assigned a different sequence for each execution but may be explicitly
set.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&regions : integer* \hfill region
sizes}

\noindent
\index{region sizes}\textsf{\&regions} produces the sizes of the static
region, the string region, and the block region. The first result is
always zero and is included for backward compatibility reasons.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&source : co{}-expression \hfill invoking co{}-expression}

\noindent
\textsf{\&source} is the co-expression that activated the current
co-expression.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&storage : integer* \hfill memory in use}

\noindent
\index{memory use}\textsf{\&storage} gives the amount of memory
currently used within the static region, the string region, and the
block region. The first result is always zero and is included for
backward compatibility reasons.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&subject := string \hfill string
scanning subject}

\noindent
\index{subject, string scanning}\textsf{\&subject} holds the default
value used in string scanning and analysis functions. Assigning to
\textsf{\&subject} implicitly assigns the value \textsf{1} to
\textsf{\&pos}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&syserr := integer \hfill halt on system error}

\noindent
\textsf{\&syserr} controls whether a system error causes execution to
halt with a runtime error. System errors cause expression failure by
default. If \textsf{\&syserr} is set to a non-zero value, system errors
are converted to runtime errors and halt execution with an error
traceback.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&time : integer \hfill elapsed time}

\noindent
\index{elapsed time}\textsf{\&}\index{time!since start}\textsf{time}
gives the number of milliseconds of CPU time that have elapsed since
the program execution began. For wall clock time see \textsf{\&now} or
\textsf{\&clock}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&trace := integer \hfill trace program}

\noindent
\textsf{\&trace} indicates the number of nesting levels to which the
program execution should be traced. 0 means no \index{tracing}tracing.
A negative value turns on tracing to an infinite depth.
\textsf{\&trace} is set outside the program using the \textsf{TRACE}
\index{environment variable!TRACE}environment variable or the
\textsf{{}-t} compiler option.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&ucase : cset \hfill upper case letters}

\noindent
\index{upper case}\textsf{\&ucase} is a cset consisting of all the upper
case letters from A to Z.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&version : string \hfill version}

\noindent
\index{version}\textsf{\&version} is a string that indicates which
version of Unicon or Icon is executing.

\subsubsection{Graphics Keywords}

Several of the graphics keywords are variables with assignment
restricted to value of a particular type or types. Graphics keywords
are more fully described in [Griswold98].

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&col : integer \hfill mouse location, text column}

\noindent
\textsf{\&col} is the mouse location in text columns during the most
recent \textsf{Event()}. \ If \textsf{\&col} is assigned, \textsf{\&x}
gets a corresponding pixel location in the current font on
\textsf{\&window}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&control : integer \hfill control modifier flag}

\noindent
\textsf{\&control} produces the null value if the control key was
pressed at the time of the most recently processed event, otherwise
\textsf{\&control} fails.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&interval : integer \hfill time since last event}

\noindent
\textsf{\&interval} produces the time between the most recently
processed event and the event that preceded it, in milliseconds.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&ldrag : integer \hfill left mouse button drag}

\noindent
\textsf{\&ldrag} produces the integer that indicates a left button drag
event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&lpress : integer \hfill left mouse button press}

\noindent
\textsf{\&lpress} produces the integer that indicates a left button
press event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&lrelease : integer \hfill left mouse button release}

\noindent
\textsf{\&lrelease} produces the integer that indicates a left button
release event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&mdrag : integer \hfill  middle mouse button drag}

\noindent
\textsf{\&mdrag} produces the integer that \textsf{Event()} returns to
indicate a middle button drag event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&meta : integer \hfill meta modifier flag}

\noindent
\textsf{\&meta} produces the null value if the meta (Alt) key was
pressed at the time of the most recently processed event, otherwise
\textsf{\&meta} fails.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&mpress : integer \hfill middle mouse button press}

\noindent
\textsf{\&mpress} produces the integer that indicates a middle button
press event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&mrelease : integer \hfill middle mouse button release}

\noindent
\textsf{\&mrelease} produces the integer that indicates a middle button
release event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&pick : string* \hfill pick 3D objects}

\noindent
\textsf{\&pick} generates the object IDs selected at point
(\textsf{\&x},\textsf{\&y}) at the most recent \textsf{Event()}, if it
was read from a 3D window with the attribute \textsf{pick=on} at the
time.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&rdrag : integer \hfill right mouse button drag}

\noindent
\textsf{\&rdrag} produces the integer that indicates a right button drag
event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&resize : integer \hfill window resize event}

\noindent
\textsf{\&resize} produces the integer that indicates a window resize
event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&row : integer \hfill mouse location, text row}

\noindent
\textsf{\&row} is the mouse location in text rows during the most recent
\textsf{Event()}. If \textsf{\&row} is assigned, \textsf{\&y} gets a
corresponding pixel location in the current font on \textsf{\&window}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&rpress : integer \hfill right mouse button press}

\noindent
\textsf{\&rpress} produces the integer that indicates a right button
press event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&rrelease : integer \hfill right mouse button release}

\noindent
\textsf{\&rrelease} produces the integer that indicates a right button
release event.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&shift : integer \hfill shift modifier flag}

\noindent
\textsf{\&shift} produces the null value if the shift key was pressed at
the time of the most recently processed event, otherwise
\textsf{\&shift} fails.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&window : window \hfill default window}

\noindent
\textsf{\&window} is the default window argument for all window
functions. \ \textsf{\&window} may be assigned any value of type
window.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&x : integer \hfill mouse location, horizontal}

\noindent
\textsf{\&x} is the horizontal mouse location in pixels during the most
recent \textsf{Event()}. If \textsf{\&x} is assigned, \textsf{\&col}
gets a corresponding text coordinate in the current font on
\textsf{\&window}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \&y : integer \hfill mouse location, vertical}

\noindent
\textsf{\&y} is the vertical mouse location in pixels during the most
recent \textsf{Event()}. If \textsf{\&y} is assigned, \textsf{\&row}
gets a corresponding text coordinate in the current font on
\textsf{\&window}.

\subsection[Control Structures and Reserved Words]{Control Structures
and Reserved Words}
Unicon has many \index{reserved word}reserved words. Some are used in
declarations, but most are used in \index{control structure}control
structures. This section summarizes the syntax and semantics introduced
by all the reserved words of the language. The reserved word under
discussion is written in a bold font. The surrounding syntax uses
square brackets for optional items and an asterisk for items that may
repeat.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf break expr \hfill exit loop}

\noindent
The \index{break expression}\textsf{break} expression exits the nearest
enclosing loop. \textit{expr} is evaluated and treated as the result of
the entire loop expression. \ If \textit{expr} is another
\textsf{break} expression, multiple loops will be exited.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf expr1 to expr2 by expr3 \hfill step increment}

\noindent
\index{by, to-by step}The \textsf{by} reserved word supplies a step
increment to a \textsf{to}{}-expression (the default is 1).

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf case expr of \{ ? \} \hfill select expression}

\noindent
The \index{case expression}\textsf{case} expression selects one of
several branches of code to be executed.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{class} name [: superclass]*
(fields) methods [initially] end \hfill class declaration}

\noindent
\index{class!declaration}The \textsf{class} declaration introduces a new
object type into the program. The \textsf{class} declaration may
include a list of superclasses, fields, methods, and an optional
initially section.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf create expr \hfill create co{}-expression}

\noindent
\index{create}The \textsf{create} expression produces a new
co-expression to evaluate \textit{expr}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf default : expr \hfill default case branch}

\noindent
\index{default!case branch}The \textsf{default} branch of a case
expression is taken if no other case branch is taken.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf do expr \hfill iteration expression}

\noindent
\index{do, iteration}The \textsf{do} reserved word specifies an
expression to be executed for each iteration of a preceding
\textsf{while}, \textsf{every}, or \textsf{suspend} loop (yes,
\textsf{suspend} is a looping construct).

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf if expr1 then expr2 else expr3 \hfill else branch}

\noindent
\index{else}The \textsf{else} expression is executed if \textit{expr1}
\index{expression failure}fails to produce a result.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf end \hfill end of declared body}

\noindent
\index{end}The reserved word \textsf{end} signifies the end of a
procedure, method, or class body.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{every} \textit{expr1} [do
\textit{expr2}] \hfill generate all results}

\noindent
\index{every}The \textsf{every} expression always fails, causing
\textit{expr1} to be resumed for all its results.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf fail \hfill produce no results}

\noindent
\index{fail}The \textsf{fail} reserved word causes the enclosing
procedure or method invocation to terminate immediately and produce no
results. The invocation may not be resumed. See also the keyword
\textsf{\&fail}, which produces a less drastic expression failure.
\ \textsf{fail} is equivalent to \textsf{return \&fail}

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{global} \textit{var} [,
\textit{var}]* \hfill declare global variables}

\noindent
\index{global}Reserved word \textsf{global} introduces one or more
global variables.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{if} \textit{expr} then
\textit{expr2} [else \textit{expr3}] \hfill conditional expression}

\noindent
\index{if}The \textsf{if} expression evaluates \textit{expr2} only if
\textit{expr1} produces a result.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{import} \textit{name} [,
\textit{name}]* \hfill import package}

\noindent
\index{import}The \textsf{import} declaration introduces the names from
package \textit{name} so that they may be used without prefixing them
with the package name.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf initial expr \hfill execute on first invocation}

\noindent
\index{initial}The \textsf{initial} expression is executed the first
time a procedure or method is invoked.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{initially} [(parameters)] \hfill initialize object}

\noindent
\index{initially}The \textsf{initially} section defines a special method
that is invoked automatically when an object is created. If the
\textsf{initially} section has declared parameters, they are used as
the parameters of the \index{constructor!class}constructor for objects
of that class.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{invocable} \textit{procedure} [, \textit{procedure}]* \hfill
allow string invocation}

\noindent
\index{invocable}
{\textbf{invocable all} \hfill allow string invocation}

\noindent
The \textsf{invocable} declaration indicates that procedures may be used
in string invocation.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{link} \textit{filename} [,
\textit{filename}]* \hfill link code module}

\noindent
The \index{link}\textsf{link} declaration directs that the code in
\textit{filename} will be added to the executable when this program is
linked. \textit{filename} may be an identifier or a string literal file
path.

\bigskip\hrule\vspace{0.1cm}
{\bf \textbf{local}
\textit{var} \textit{[ }:=\textit{ initialize} \textit{\ r} ]
\textit{[}, \textit{var }\ \textit{[}:=\textit{ initializer ]
]}* \hfill declare local variables}

\noindent
\index{local}The \textsf{local} declaration introduces one or more local
variables into the current procedure or method body.
\index{variable}Variable declarations must be at the beginning of a
procedure or method.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf method name (params) body end \hfill declare method}

\noindent
\index{method}The \textsf{method} declaration introduces a procedure
that is only invoked with respect to \index{instance!class}instances of
an enclosing class declaration. The \textit{params} and \textit{body}
are as in procedures, described below.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf next \hfill iterate loop}

\noindent
\index{next, iteration}The \textsf{next} expression causes a loop to
immediate skip to its next iteration.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf not expr \hfill negate expression
failure}

\noindent
\index{not}The \textsf{not} expression fails if \textit{expr} succeeds,
and succeeds (producing null) if \textit{expr} fails.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf case expr of \{ ? \}\ \hfill introduce case branches}

\noindent
\index{of}The \textsf{of} reserved word precedes a special compound
expression consisting if a sequence of case branches of the form
\textit{expr} : \textit{expr}. Case branches are evaluated in sequence
until one is found that matches the expression given between the word
\textsf{case} and the \textsf{of}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf package name \hfill declare package}

\noindent
\index{package}The \textsf{package} declaration segregates the global
names in the current source file. In order to refer to them, client
code must either import the package, or prepend \textsf{\textit{name
.}} (the package name followed by a period) onto the front of a name in
the package.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf procedure name (params) body end \hfill declare procedure}

\noindent
\index{procedure}The \textsf{procedure} declaration specifies a
procedure with the specified parameters and code body. The parameters
are a comma-separated list of zero or more variable names. The last
parameter may optionally be suffixed by [ ] indicating that any
following parameters will be supplied to the procedure in a list. The
body is an optional sequence of local and static variable declarations,
followed by a sequence of zero or more expressions.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf record name (fields) \hfill declare record}

\noindent
\index{record}The \textsf{record} declaration introduces a new record
type into the program.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf repeat expr \hfill infinite loop}

\noindent
\index{repeat loop}\index{infinite loop}The \textsf{repeat} expression
introduces an infinite loop that will reevaluate \textit{expr} forever.
Of course, \textit{expr} may exit the loop or terminate the program in
any number of ways.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf return expr \hfill return from invocation}

\noindent
\index{return}The \textsf{return} expression exits a procedure or method
invocation, producing \textit{expr} as its result. The invocation may
not be resumed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \textbf{static} \textit{var} [, \textit{var}]* \hfill
declare static variables}

\noindent
\index{static}The \textsf{static} declaration introduces one or more
local variables into the current procedure or method body. Variable
declarations must be at the beginning of a procedure or method.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \textbf{suspend} \textit{expr} [do
\textit{expr}] \hfill produce result from invocation}

\noindent
\index{suspend}The \textsf{suspend} expression produces one or more
results from an invocation for use by the calling expression. The
procedure or method may be resumed for additional results if the
calling expression needs them. Execution in the suspended invocation
resumes where it left off, in the \textsf{suspend} expression. A single
evaluation of a \textsf{suspend} expression may produce multiple
results for the caller if \textit{expr} is a
\index{generator}generator. An optional \textsf{do} expression is
evaluated each time the \textsf{suspend} is resumed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf if expr1 then expr2 \hfill conditional expression}

\noindent
\index{then}The \textit{expr2} following a \textsf{then} is evaluated
only if \textit{expr1} following an \textsf{if} succeeds. In that case,
the result of the whole expression is the result of \textit{expr2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf expr1 to expr2 \hfill generate arithmetic sequence}

\noindent
\index{to, generator}The \textsf{to} expression produces the integer
sequence from \textit{expr1} to \textit{expr2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \textbf{until} \textit{expr1} [do
\textit{expr2}] \hfill loop until success}

\noindent
\index{until}\index{success}The \textsf{until} expression loops as long
as \textit{expr1} fails.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \textbf{while} \textit{expr1} [do
\textit{expr2}] \hfill loop until failure}

\noindent
\index{while}The \textsf{while} expression loops as long as
\textit{expr1} succeeds.

\subsection{Operators and Built-in Functions}

Icon{\textquotesingle}s built-ins operators and functions utilize
automatic type conversion to provide flexibility and ease of
programming. Automatic \index{type conversion}type \index{conversion,
type}conversions are limited to integer, real, string, and cset data
types. Conversions to a {\textquotedbl}number{\textquotedbl} will
convert to either an integer or a real, depending whether the value to
be converted has a decimal. Conversions between numeric types and csets
go through an intermediate conversion to a string value and are not
generally useful.

Indexes start at 1. Index 0 is the position after the last element of a
string or list. Negative \index{index, subscript}indexes are positions
relative to the end. Subscripting operators and string analysis
functions can take two indices to specify a section of the string or
list. When two indices are supplied, they select the same string
section whether they are in ascending or descending order.

\subsubsection[Operators]{Operators}
\index{operators}The result types of operators are the same as the
operand types except as noted.

\subsubsection{Unary Operators}

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ! x : any* \hfill generate elements}

\noindent
\index{generate elements}The \index{generate operator "!x}generate
operator produces the elements of \textsf{x}. It is a generator. If
\textsf{x} is a string variable or refers to a structure value, the
generated elements are variables that may be assigned. \ \textsf{!i} is
equivalent to \textsf{(1 to i)} for integer \textsf{i}. List, record,
string, and file elements are generated in order, with string elements
consisting of one-letter substrings. Set and table elements are
generated in an undefined order. If \textsf{x} is a messaging
connection to a POP server, \textsf{!x} produces complete messages as
strings. Other types of files, including network connections, produce
elements consisting of text lines.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf / x \hfill null test}
\index{null test /x}

\noindent
{\bf {\textbackslash} x \hfill nonnull test}
\index{nonnull test {\textbackslash}x}

\noindent
The null and nonnull tests succeed
and produce their operand if it satisfies the test.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf {}- number \hfill negate}

\noindent {\bf + number \hfill numeric identity}

\noindent
Negation reverses the sign of its operand. Numeric identity does not
change its operand{\textquotesingle}s value other than to convert to a
required numeric type.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf = string \hfill tab/match}

\noindent
\index{tab/match ( =s )}The tab/match operator is equivalent to calling
\textsf{tab(match(s))} on its operand.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf * x : integer \hfill size}

\noindent
The \index{size operator}size operator returns the number of elements in
string, cset or structure \textsf{x}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf . x : x \hfill dereference}

\noindent
The \index{dereference}dereference operator returns the value
\textsf{x}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ? x : any \hfill random element}

\noindent
The \index{random!operator, ?x}random operator produces a random element
from \textsf{x}. If \textsf{x} is a string, \textsf{?x} produces a
random one-letter substring. The result is a variable that may be
assigned.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf {\textbar} x : x* \hfill repeated alternation}

\noindent
The repeated \index{alternation, repeated}alternation operator generates
results from evaluating its operand over and over again in an infinite
loop.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \~{} cset \hfill cset complement}

\noindent
The \index{complement, cset}complement operator produces a cset
consisting of all characters not in its operand.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \^{} co{}-expression \hfill refresh co{}-expression}

\noindent
\index{refresh, co-expression}The refresh operator restarts a
co-expression so the next time it is activated it will begin with its
first result.

\subsubsection[Binary Operators]{Binary Operators}

\index{binary operator}Most binary operators may be augmented with an
\index{assignment!augmented}assignment. If such an operator is followed
by a \textsf{:=} the left operand must be a variable, and the
expression \textsf{x }\textsf{\textit{op}}\textsf{:= y} is equivalent
to \textsf{x := x }\textsf{\textit{op}}\textsf{ y}. For example,
\textsf{x +:= 5} is equivalent but faster than the expression
\ \textsf{x := x+5.}

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \textit{number1} \^{} \textit{number2} \hfill power}
\index{power, exponent \^{}}

\noindent {\bf \textit{number1} * \textit{number2} \hfill multiply}

\noindent {\bf \textit{number1} / \textit{number2} \hfill divide}

\noindent {\bf \textit{number1} \% \textit{number2} \hfill modulo}
\index{modulo \%}

\noindent {\bf \textit{number1} + \textit{number2} \hfill add}

\noindent {\bf \textit{number1} - \textit{number2} \hfill subtract}

\noindent
The \index{arithmetic operator}arithmetic operators may be augmented.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf set1 ** set2 \hfill intersection}

\noindent {\bf set1 ++ set2 \hfill union}

\noindent {\bf set1 -{}- set2 \hfill difference}

\noindent
The set operators work on sets or csets. They may be augmented.

\bigskip\hrule\vspace{0.1cm}

\noindent {\bf x . name \hfill field}
\index{field, record or class}

\noindent {\bf \textit{object} . name (params) \hfill method invocation}
\index{method!invocation}

\noindent {\bf \textit{object} \$ superclass .name (params) \hfill
superclass method invocation}
\index{superclass}

\noindent
The field operator selects field name out of a record,
object, or package. For objects, \textit{name} may be a method, in
which case the field operator is being used as part of a method
invocation. Superclass method invocation consists of a dollar sign and
superclass name prior to the field operator.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf number1 = number2 \hfill equal}

\noindent
\index{equal!numeric =}
{\bf number1 \~{}= number2 \hfill not equal}

\noindent {\bf number1 {\textless} number2 \hfill less than}

\noindent {\bf number1 {\textless}= number2 \hfill less or equal}

\noindent {\bf number1 {\textgreater} number2 \hfill greater than}

\noindent {\bf number1 {\textgreater}= number2 \hfill greater or equal}

\noindent {\bf string1 == string2 \hfill string equal}
\index{string!comparison}\index{equal!string ==}

\noindent {\bf string1 \~{}== string2 \hfill string not equal}

\noindent
{\bf string1 {\textless}{\textless} string2 \hfill string less than}

\noindent {\bf string1 {\textless}{\textless}= string2 \hfill
string less or equal}

\noindent {\bf string1 {\textgreater}{\textgreater} string2 \hfill
string greater than}

\noindent {\bf string1 {\textgreater}{\textgreater}= string2 \hfill
string greater or equal}

\noindent {\bf x1 === x2 \hfill equivalence}
\index{equal!reference ===}

\noindent {\bf x1 \~{}=== x2 \hfill non equivalence}

\noindent
Relational operators produce their right operand if they succeed. They
may be augmented.

\bigskip\hrule\vspace{0.1cm}

\noindent {\bf var := expr \hfill assign}

\noindent {\bf var1 :=: var2 \hfill swap}
\index{swap}

\noindent {\bf var {\textless}- expr \hfill reversible assignment}
\index{assignment!reversible}\index{reversible assignment}

\noindent {\bf var1 {\textless}-{\textgreater} var2 \hfill reversible swap}
\index{reversible swap}

\noindent The several \index{assignment}assignment
operators all require variables for their left operands, and swap
operators also require variables for their right operands.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf string ? expr \hfill scan string}

\noindent
\index{scan string}The string scanning operator evaluates \textit{expr}
with \textsf{\&subject} equal to string and \textsf{\&pos} starting at
1. It may be augmented.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf [x] @ co-expression \hfill activate co-expression}
\index{activate co-expression}

\noindent The activate operator transfers execution
control from the current co-expression to its right operand
co-expression. The transmitted value is \textsf{x}, or \textsf{\&null}
if no left operand is supplied. Activation may be augmented.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf string1 {\textbar}{\textbar} string2 \hfill concatenation}

\noindent
{\bf list1 {\textbar}{\textbar}{\textbar} list2 \hfill list concatenation}

\noindent The \index{concatenation}concatenation operators produce new values
containing a copy of the left operand followed by a copy of the right
operand. They may be augmented.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf x1 \& x2 \hfill conjunction}

\noindent
{\bf expr1 {\textbar} expr2 \hfill alternation}

\noindent
The \index{conjunction \&}conjunction operator produces \textsf{x2} if
\textsf{x1} succeeds. The \index{alternation operator ( {\textbar}
)}alternation operator produces the results of \textsf{expr1} followed
by the results of \textsf{expr2}; it is a \index{generator}generator.
These operators may be augmented.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf x1 {\textbackslash} integer \hfill limitation}

\noindent
The \index{limitation {\textbackslash}}limitation operator fails if it
is resumed after its left operand has produced a number of results
equal to its right operand.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ( expr [, expr]* ) \hfill mutual evaluation}
\index{mutual evaluation}

\noindent {\bf p ( expr [, expr]* ) \hfill invocation}
\index{invocation}

\noindent
By themselves, \index{parentheses}parentheses are used
to override operator precedence in surrounding expressions. A
comma-separated list of expressions is evaluated left to right, and
fails if any operand fails. Its value is the right of the rightmost
operand.

When preceded by an operand, parentheses form an \index{call,
procedure}invocation. The operand may be a procedure, a method, a
string that is converted to a procedure name, or an integer that
selects the parameter to use as the result of the entire expression.

\bigskip\hrule\vspace{0.1cm}

\noindent {\bf \textbf{[} \textbf{]} \hfill empty list creation}
\index{empty list}

\noindent {\bf \textbf{[} expr [, expr]* \textbf{]} \hfill list creation}
\index{list creation}

\noindent {\bf expr1 \textbf{[} expr2 [, expr]* \textbf{]} \hfill subscript}
\index{subscript}

\noindent {\bf expr1 \textbf{[} expr2 : expr3 \textbf{]} \hfill subsection}
\index{slice}\index{subsection}

\noindent {\bf expr1 \textbf{[} expr2 +: expr3 \textbf{]} \hfill
forward relative subsection}

\noindent {\bf expr1 \textbf{[} expr2 -: expr3 \textbf{]} \hfill
backward relative subsection}

\noindent
With no preceding operand, square brackets create and initialize lists.
When preceded by an operand, square brackets form a subscript or
subsection. Multiple comma-separated subscript operands are equivalent
to separate subscript operations with repeating square brackets, so
\textsf{x[y,z]} is equivalent to \textsf{x[y][z]}.

Subscripting selects an element from a structure and allows that element
to be assigned or for its value to be used. Lists and strings are
subscripted using 1-based integer indices, tables are subscripted using
arbitrary keys, and records may be subscripted by either string
fieldname or 1-based integer index. Message connections may be
subscripted by string header to obtain server responses; POP
connections may also be subscripted by 1-based integer message numbers.

Subsectioning works on strings and lists. For strings, the subsection is
a variable if the string was a variable, and
\index{assignment!substring}assignment to the subsection modifies the
original \index{variable}variable. For lists, a subsection is a new
list that contains a copy of the elements from the original list.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf expr1 ; expr2 \hfill bound expression}

\noindent
A semicolon bounds \textsf{expr1}. Once \textsf{expr2} is entered,
\textsf{expr1} cannot be resumed for more results. The result of
\textsf{expr2} is the result of the entire expression. \index{semicolon
insertion}Semicolons are automatically inserted at ends of lines
wherever it is syntactically allowable to do so. This results in many
\textit{implicitly }\index{bounded expressions}\textit{bounded}
expressions.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \{ expr [; expr]* \} \hfill compound expression}
\index{compound expression}

\noindent {\bf p \{ expr [; expr]* \} \hfill
programmer defined control structure}
\index{programmer defined control structure}\index{control
structure!programmer defined}

\noindent
Curly brackets typically cause a sequence
of bounded expressions to be treated as a single expression. Preceded
by a procedure value, curly brackets introduce a programmer defined
control structure in which a co-expression is created for each
argument; the procedure is called with these co-expressions as its
parameters, and can determine for itself whether, and in what order, to
activate its parameters to obtain values.

\subsubsection{Built-in Functions}

Unicon{\textquotesingle}s \index{built-in functions}built-in functions
are a key element of its ease of learning and use. They provide
substantial functionality in a consistent and easily memorized manner.

In addition to automatic type conversion, built-in functions make
extensive use of optional parameters with default values. Default
values are indicated in the function descriptions, with the exception
of string scanning functions. \index{default parameters!string scanning
functions}String scanning functions end with three parameters that
default to the string \textsf{\&subject}, the integer \textsf{\&pos},
and the end of string (0) respectively. The position argument defaults
to 1 when the string argument is supplied rather than defaulted.

\bigskip

\hrule\vspace{0.1cm}
\noindent {\bf abs(N) : number \hfill absolute value}

\noindent \index{absolute value}\textsf{abs(N)} produces the maximum of
\textsf{N} or \textsf{{}-N}.

\bigskip

\hrule\vspace{0.1cm}
\noindent {\bf acos(r) : real \hfill arc cosine}

\noindent
\index{arc cosine}\textsf{acos(r)} produces the arc cosine of
\textsf{r}. The argument is given in radians.

\bigskip

\hrule\vspace{0.1cm}
\noindent {\bf any(c, s, i, i) : integer? \hfill cset membership}

\noindent
\index{any()}\index{cset membership}String scanning function
\textsf{any(c,s,i1,i2)} produces \textsf{i1+1} if \textsf{s[i1:i2][1]}
is in cset \textsf{c}, but fails otherwise.

\bigskip

\hrule\vspace{0.1cm}
\noindent {\bf args(x,i) : integer \hfill number of arguments}

\noindent
\index{args(p)}\textsf{args(p)} produces the number of arguments
expected by procedure \textsf{p}. If \textsf{p} takes a variable number
of arguments, \textsf{args(p)} returns a negative number to indicate
that the final argument is a list conversion of an arbitrary number of
arguments. For example, \textsf{args(p)} for a procedure \textsf{p}
with formal parameters \textsf{(x, y, z[ ])} returns a \textsf{{}-3}.
\textsf{args(C)} produces the number of arguments in the current
operation in co-expression \textsf{C}, and \textsf{args(C,i)} produces
argument number \textsf{i} within co-expression \textsf{C}.

\bigskip

\hrule\vspace{0.1cm}
\noindent {\bf asin(real) : real \hfill arc sine}

\noindent
\index{arc sine}\textsf{asin(r1)} produces the arc sine of \textsf{r1}.
The argument is given in radians.

\bigskip

\hrule\vspace{0.1cm}
\noindent {\bf atan(r, r:1.0) : real \hfill arc tangent}

\noindent
\index{arc tangent}\textsf{atan(r1)} produces the arc tangent of
\textsf{r1}. \textsf{atan(r1,r2)} produces the arc tangent of
\textsf{r1} and \textsf{r2}. Arguments are given in radians.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf atanh(r) : real \hfill inverse hyperbolic tangent}

\noindent
\index{inverse hyperbolic tangent}\textsf{atanh(r)} produces the inverse
hyperbolic tangent of \textsf{r}. Arguments are given in radians.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf bal(cs:\&cset, cs:{\textquotesingle}({\textquotesingle},
cs:{\textquotesingle}){\textquotesingle}, s, i, i) :
integer* \hfill balance string}

\noindent
\index{balance string}\index{string!balance}String scanning function
\textsf{bal(c1,c2,c3,s,i1,i2)} generates the integer positions in
\textsf{s} at which a member of \textsf{c1} in \textsf{s[i1:i2]} is
balanced with respect to characters in \textsf{c2} and \textsf{c3}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf center(s, i:1, s:{\textquotedbl} {\textquotedbl}) :
string \hfill center string}

\noindent
\index{center()}\index{string!center}\textsf{center(s1,i,s2)} produces a
string of \textsf{i} characters. If \textsf{i {\textgreater} *s1} then
\textsf{s1} is padded equally on the left and right with \textsf{s2} to
length \textsf{i}. If \textsf{i {\textless} *s1} then the center
\textsf{i} characters of \textsf{s1} are produced.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf char(i) : string \hfill encode character}

\noindent
\index{character}\textsf{char(i)} produces a string consisting of the
character encoded by integer \textsf{i}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf chdir(s) : string \hfill change directory}

\noindent
\index{directory}\index{chdir()}\textsf{chdir(s)} changes the current
working directory to \textsf{s}. \textsf{chdir()} returns the current
working directory.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf chmod(f, m) : ? \hfill file permissions}

\noindent
\index{permissions, file}\index{permissions,
file}\index{file!permissions}\index{file!permissions}\index{chmod()}\textsf{chmod(f,
m)} sets the access permissions ({\textquotedbl}mode{\textquotedbl}) of
a string filename (or on UNIX systems, an open file) \textsf{f} to a
string or integer mode \textsf{m}. The mode indicates the change to be
performed. The string is of the form

\iconcode{
\>   [ugoa]*[+-=][rwxRWXstugo]* }

The first group describes the set of mode bits to be changed: \textsf{u}
is the owner set, \textsf{g} is the group and \textsf{o} is the set of
all others. The character \textsf{a} designates all the fields. The
operator (\textsf{+-=}) describes the operation to be performed:
\textsf{+} adds a permission, \textsf{{}-} removes a permission, and
\textsf{=} sets a permission. The permissions themselves are: 

\ \ \ \ \ \textsf{r} \ \ \ \ \ \ \ \ read\\
 \ \ \ \ \textsf{w} \ \ \ \ \ \ \ write\\
 \ \ \ \ \textsf{x} \ \ \ \ \ \ \ \ execute\\
 \ \ \ \ \textsf{R} \ \ \ \ \ \ \ read if any other set already has
r\\
 \ \ \ \ \textsf{W} \ \ \ \ \ \ write if any other set already has
w\\
 \ \ \ \ \textsf{X} \ \ \ \ \ \ \ execute if any other set already has
x\\
 \ \ \ \ \textsf{s} \ \ \ \ \ \ \ \ setuid (if the first part contains u
and/or setgid if the first part contains g\\
 \ \ \ \ \textsf{t} \ \ \ \ \ \ \ \ sticky if the first part has
o\\
 \ \ \ \ \textsf{u} \ \ \ \ \ \ \ the u bits on the same file\\
 \ \ \ \ \textsf{g} \ \ \ \ \ \ \ the g bits on the same file\\
 \ \ \ \ \textsf{o} \ \ \ \ \ \ \ the o bits on the same file

If the first group is missing, then it is treated as
{\textquotedbl}all{\textquotedbl} except that any bits in the
user{\textquotesingle}s umask will not be modified in the mode. Not all
platforms make use of all mode bits described here; the mode bits that
are used is a property of the filesystem on which the file resides.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf classname(r) : string \hfill class name}

\noindent
\textsf{classname(r)} produces the name of \textsf{r}{\textquotesingle}s
class.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf close(f) : file {\textbar} integer \hfill close file}

\noindent
\index{file!close}\index{close file}\textsf{close(f)} closes file, pipe,
window, network or message connection, or \index{database}database f
and returns any resources associated with it to the operating system.
If f was a window, close(f) causes it to disappear, but the window can
still be written to and copied from until all open bindings are closed.
If f was a pipe or network connection, close() returns the integer exit
status of the connection, otherwise it returns the closed file.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf cofail(CE) : any \hfill transmit co-expression failure}

\noindent
\index{fail!co-expression}\index{co-expression}cofail(ce) activates
co-expression ce, transmitting failure instead of a result.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf collect(i:0, i:0) : null \hfill collect garbage}

\noindent
\index{collect garbage}collect(i1,i2) calls the \index{garbage
collector}garbage collector to ensure that i2 bytes are free in region
i1. i1 can be 0 (no region in particular) 1 (static region) 2 (string
region) or 3 (block region).

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf constructor(s, ...) : procedure \hfill record constructor}

\noindent
\index{record constructor}constructor(label, field, field, ...) creates
a new record type named \textsf{label} with fields named by its
subsequent arguments, and returns a constructor procedure for this
record type.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf copy(any) : any \hfill copy value}

\noindent
\index{copy(x)}copy(x) produces a copy of x. For immutable types
(numbers, strings, csets, procedures) this is a no-op. For mutable
types (lists, tables, sets, records, objects) a one-level deep copy of
the object is made.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf cos(r) : real \hfill cosine}

\noindent
\index{cosine}cos(r) produces the cosine of r. The argument is given in
radians.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf cset(any) : cset? \hfill convert to cset}

\noindent
\index{convert!to cset}cset(x) converts x to a cset, or fails if the
conversion cannot be performed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ctime(i) : string \hfill format a time value into local time }

\noindent
\index{local time}\index{ctime(i)}ctime(i) converts an integer time
given in seconds since the epoch, Jan 1, 1970 00:00:00 into a string in
the local timezone. See also keywords \&clock and \&dateline.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf dbcolumns(D,s) : list \hfill ODBC column information}

\noindent
\index{column!ODBC}dbcolumns(db, tablename) produces a list of record
(catalog, schema, tablename, colname, datatype, typename, colsize,
buflen, decdigits, numprecradix, nullable, remarks) entries. Fields
\textsf{datatype} and \textsf{typename} are SQL-dependent and data
source dependent, respectively. Field \textsf{colsize} gives the
maximum length in characters for SQL\_CHAR or SQL\_VARCHAR columns..
Field \textsf{decdigits} gives the number of significant digits right
of the decimal. Field \textsf{numprecradix} specifies whether
\textsf{colsize} and \textsf{decdigits} are specified in bits or
decimal digits. Field \textsf{nullable} is 0 if the column does not
accept null values, 1 if it does accept null values, and 2 if it is not
known whether the column accepts null values.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf dbdriver(D) : record \hfill ODBC driver information}

\noindent
\index{ODBC driver}dbdriver(db) produces a record driver(name, ver,
odbcver, connections, statements, dsn) that describes the details of
the \index{ODBC}ODBC driver used to connect to database db. Connections
and statements are the maximums the driver can support. Fields
\textsf{ver} and \textsf{odbcver} are the driver and ODBC version
numbers. Fields \textsf{name} and \textsf{dsn} are the driver filename
and Windows Data Source Name associated with the connection.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf dbkeys(D,string) : list \hfill ODBC key information}

\noindent
\index{key!ODBC}dbkeys(db,tablename) produces a list of record
(columnname, sequencenumber) pairs containing information about the
primary keys in tablename.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf dblimits(D) : record \hfill ODBC operation limits}

\noindent
dblimits(db) produces a record with fields \textsf{maxbinlitlen,
maxcharlitlen, maxcolnamelen, maxgroupbycols, maxorderbycols,
maxindexcols, maxselectcols, maxtblcols, maxcursnamelen, maxindexsize,
maxrownamelen, maxprocnamelen, maxqualnamelen, maxrowsize,
maxrowsizelong, maxstmtlen, maxtblnamelen, maxselecttbls,} and\textsf{
maxusernamelen} that contains the upper bounds of the database for many
parameters.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf dbproduct(D) : record \hfill database name}

\noindent
dbproduct(db) produces a record (name, ver) that gives the name and the
version of the DBMS product containing db.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf dbtables(D) : list \hfill ODBC table information}

\noindent
dbtables(db) returns a list of record (qualifier, owner, name, type,
remarks) entries that describe all of the tables in the database
associated with db.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf delay(i) : null \hfill delay for i milliseconds}

\noindent
\index{delay(i)}delay(i) pauses the program for at least i milliseconds.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf delete(x1, x2, ...) : x1 \hfill delete element}

\noindent
\index{delete element}delete(x1, x2) deletes elements denoted by the
2\textsuperscript{nd} and following parameters from set, table, list,
DBM database, or POP connection x1 if it is there. In any case, it
returns x1. If x1 is a table or set, elements x\textsubscript{i} denote
keys of arbitrary type. If x1 is a DBM database, indices must be
strings. If x1 is a list or a POP messaging connection, elements xi are
integer indices of the element to be deleted. POP messages are actually
deleted when the close() operation closes that connection.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf detab(string, integer:9,...) : string \hfill replace tabs}

\noindent
detab(s,i,...) replaces tabs with spaces, with stops at columns
indicated by the second and following parameters, which must all be
integers. Tab stops are extended infinitely using the interval between
the last two specified tab stops.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf display(i:\&level, f:\&errout, CE:\&current) :
null \hfill write variables}

\noindent
\index{display(i,f)}display(i,f) writes the local variables of i most
recent procedure activations, plus global variables, to file f.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf dtor(r) : real \hfill convert degrees to radians}

\noindent
\index{convert!degrees to radians}\index{dtor(r)}dtor(r) produces the
equivalent of r degrees, expressed in radians.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf entab(s, i:9,...) : string \hfill replace spaces}

\noindent
entab(s,i,...) replaces spaces with tabs, with stops at columns
indicated. Tab stops are extended infinitely using the interval between
the last two specified tab stops.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf errorclear() : null \hfill clear error condition}

\noindent
\index{errorclear()}errorclear() resets keywords \&errornumber,
\&errortext, and \&errorvalue to indicate that no error is present.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf eventmask(CE, cset) : cset {\textbar}
null \hfill \ \ \ \ \ \ \ \  get/set event mask}

\noindent
\index{eventmask(ce)}eventmask(ce) returns the event mask associated
with the program that created ce, or \&null if there is no event mask.
eventmask(ce,cs) sets that program{\textquotesingle}s event mask to cs.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf EvGet(c, flag) : string \hfill get event from monitored program}

\noindent
EvGet(c,flag) activates a program being monitored until an event in cset
mask c occurs. Under normal circumstances this is a one-character
string event code.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf EvSend(i, x, CE) : any \hfill transmit event}

\noindent
\index{EvSend(x, y, C)}EvSend(x, y, C) transmits an event with event
code x and event value y to a monitoring co-expression C.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf exit(i:normalexit) \hfill exit process}

\noindent
\index{exit(i)}exit(i) terminates the current program execution,
returning status code i. The default is the platform-dependent exit
code that indicates normal termination (0 on most systems).

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf exp(r) : real \hfill exponential}

\noindent
\index{exponential, exp(r)}exp(r) produces the result of \&e \^{} r.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf fetch(D, s?) : string {\textbar} row? \hfill fetch database value}

\noindent
\index{fetch(d, k)}fetch(d, k) fetches the value corresponding to key k
from a \index{DBM}DBM or \index{SQL!fetch}SQL database d. The result is
a string (for DBM databases) or a row (for SQL databases). For SQL
databases, when the string k is omitted, fetch(d) produces the next row
in the current selection, and advances the cursor to the next row. A
row is a record whose field names and types are determined by the
columns specified in the current query. fetch(d) fails if there are no
more rows to return from the current query. Typically a call to
dbselect() will be followed by a while{}-loop that calls fetch()
repeatedly until it fails.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf fieldnames(R) : string* \hfill get field names}

\noindent
\index{fieldnames(r)}fieldnames(r) produces the names of the fields in
record r.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf find(s, s, i, i) : integer* \hfill find string}

\noindent
\index{find string}String scanning function find(s1,s2,i1,i2) generates
the positions in s2 at which s1 occurs as a substring in s2[i1:i2].

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf flock(f, s) : ? \hfill apply or remove file lock}

\noindent
\index{file!lock}\index{flock(f,s)}flock(f,s) applies an advisory
\index{lock, file}lock to the file. Advisory locks enable processes to
cooperate when accessing a shared file, but do not enforce exclusive
access. The following characters can be used to make up the operation
string: 

\ \ \ \ \ s \ \ \ \ \ \ \ shared lock\\
 \ \ \ \ x \ \ \ \ \ \ \ exclusive lock\\
 \ \ \ \ b \ \ \ \ \ \ \ don{\textquotesingle}t block when
locking\\
 \ \ \ \ u \ \ \ \ \ \ \ unlock 

Locks cannot be applied to windows, directories or database files. A
file may not simultaneously have shared and exclusive locks.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf flush(f) : file \hfill flush file}

\noindent
\index{flush(f)}\textsf{flush(f)} flushes all pending or buffered output
to file \textsf{f}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf function() : string* \hfill name the functions}

\noindent
\textsf{function()} generates the names of the built-in functions.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf get(L,i:1) : any? \hfill get element from queue}

\noindent
\textsf{get(L)} returns an element which is removed from the head of the
\index{queue}queue \textsf{L}. \textsf{get(L, i)} removes \textsf{i}
elements, returning the last one removed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf getch() : string? \hfill get character from console}

\noindent
\textsf{getch()} waits for (if necessary) and returns a character typed
at the \index{keyboard}keyboard, even if standard input was redirected.
The character is not displayed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf getche() : string? \hfill get and echo character from console}

\noindent
\textsf{getche()} waits for (if necessary) and returns a character typed
at the console keyboard, even if standard input was redirected. The
character is echoed to the \index{screen}screen.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf getenv(s) : string? \hfill get environment variable}

\noindent
\textsf{getenv(s)} returns the value of \index{environment
variable}environment variable \textsf{s} from the operating system.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf gettimeofday() : record \hfill time of day}

\noindent
\index{time!of day}Returns the current time in seconds and microseconds
since the epoch, Jan 1, 1970 00:00:00. The \textsf{sec} value may be
converted to a date string with ctime or gtime. See also keywords
\textsf{\&now}, \textsf{\&clock}, and \textsf{\&dateline}. Return
value: \textsf{record posix\_timeval(sec, usec)} 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf globalnames(CE) : string* \hfill name the global variables}

\noindent
\index{global}\textsf{globalnames(ce)} generates the names of the global
variables in the program that created co-expression \textsf{ce}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf gtime(i) : string \hfill format a time value into UTC }

\noindent
Converts an integer time in seconds since the epoch, Jan 1, 1970
00:00:00 into a string in Coordinated Universal Time (UTC). 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf iand(i, i) : integer \hfill bitwise and}

\noindent
\index{bitwise and}\textsf{iand(i1, i2)} produces the bitwise AND of
\textsf{i1} and \textsf{i2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf icom(i) : integer \hfill bitwise complement}

\noindent
\textsf{icom(i)} produces the bitwise complement (one{\textquotesingle}s
complement) of \textsf{i}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf image(any) : integer \hfill string image}

\noindent
\index{image(x)}\textsf{image(x)} returns the string image of the value
\textsf{x}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf insert(x1, x2, x3:\&null) : x1 \hfill insert element}

\noindent
\textsf{insert(x1, x2, x3)} inserts element \textsf{x2} into set, table,
or list or DBM database \textsf{x1} if not already there. Unless
\textsf{x1} is a set, the assigned value for element \textsf{x2} is
\textsf{x3}. For lists, \textsf{x2} is an integer index; for other
types, it is a key. \index{insert()}\textsf{insert()} always succeeds
and returns \textsf{x1}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf integer(any) : integer? \hfill convert to integer}

\noindent
\index{convert!to integer}\textsf{integer(x)} converts value \textsf{x}
to an integer, or fails if the conversion cannot be performed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ior(i, i) : integer \hfill bitwise or}

\noindent
\index{bitwise or}\textsf{ior(i1, i2)} produces the bitwise OR of
\textsf{i1} and \textsf{i2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ishift(i, i) : integer \hfill bitwise shift}

\noindent
\index{shift}\textsf{ishift(i, j)} produces the value obtained by
shifting \textsf{i} by \textsf{j} bit positions. Shifting is to the
left if \textsf{j{\textless}0}, or to the right if
\textsf{j{\textgreater}0}. \textsf{j} zero bits are introduced at the
end opposite the shift direction.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf istate(CE, s) : integer \hfill interpreter state}

\noindent
\textsf{istate(ce, attrib)} reports selected virtual machine interpreter
state information. \textsf{attrib} must be one of:
\textsf{{\textquotedblleft}count{\textquotedblright}},
\textsf{{\textquotedblleft}ilevel{\textquotedblright}},
\textsf{{\textquotedblleft}ipc{\textquotedblright}},
\textsf{{\textquotedblleft}ipc\_offset{\textquotedblright}},
\textsf{{\textquotedblleft}sp{\textquotedblright}},
\textsf{{\textquotedblleft}efp{\textquotedblright}},
\textsf{{\textquotedblleft}gfp{\textquotedblright}}. Used by monitors.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ixor(i, i) : integer \hfill bitwise xor}

\noindent
\textsf{ixor(i1, i2)} produces the bitwise \index{exclusive or}exclusive
or of \textsf{i1} and \textsf{i2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf kbhit() : ? \hfill check for console input}

\noindent
\index{kbhit()}\textsf{kbhit()} checks to see if there is a
\index{keyboard}keyboard character waiting to be read.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf key(x) : any* \hfill table keys}

\noindent
\index{key(x)}\textsf{key(T)} generates the key (entry) values from
table \textsf{T}. \textsf{key(L)} generates the indices from 1 to
\textsf{*L} in list \textsf{L}. \textsf{key(R)} generates the string
field names of record R.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf keyword(s,CE:\&current,i:0) : any* \hfill produce keyword value}

\noindent
\index{keyword()}\textsf{keyword(s,ce,i)} produces the value of keyword
\textsf{s} in the context of \textsf{ce}{\textquotesingle}s execution,
\textsf{i} levels up in the stack from the current point of execution.
Used in execution monitors.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf left(s, i:1, s:{\textquotedbl} {\textquotedbl}) :
string \hfill left format string}

\noindent
\index{left()}\textsf{left(s1,i,s2)} formats \textsf{s1} to be a string
of length \textsf{i}. If \textsf{s1} is more than \textsf{i}
characters, it is truncated. If \textsf{s1} is fewer than \textsf{i}
characters it is padded on the right with as many copies of \textsf{s2}
as needed to increase it to length \textsf{i}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf list(integer:0, any:\&null) : list \hfill create list}

\noindent
\index{list(i, x)}\textsf{list(i, x)} creates a list of size \textsf{i},
in which all elements have the initial value \textsf{x}. If \textsf{x}
is a mutable value such as a list, all elements refer to the
\textit{same} value, not a separate copy of the value for each element.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf load(s,L,f:\&input,f:\&output,f:\&errout,i,i,i) :
co-expression \hfill load Unicon program}

\noindent
\index{load!Unicon
program}\index{load()}\textsf{load(s,arglist,input,output,error,blocksize,stringsize,stacksize)}
loads the icode file named \textsf{s} and returns that
program{\textquotesingle}s execution as a co-expression ready to start
its \textsf{main()} procedure with parameter \textsf{arglist} as its
command line arguments. The three file parameters are used as that
program{\textquotesingle}s \textsf{\&input}, \textsf{\&output}, and
\textsf{\&errout}. The three integers are used as its initial memory
region sizes.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf loadfunc(s, s) : procedure \hfill load C function}

\noindent
\index{load!C function}\textsf{loadfunc(filename,funcname)} dynamically
loads a compiled C function from the object library file given by
\textsf{filename}. \textsf{funcname} must be a specially written
interface function that handles Icon data representations and calling
conventions.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf localnames(CE, i) : string* \hfill local variable names}

\noindent
\index{local}\index{variable}\textsf{localnames(ce,i)} generates the
names of local variables in co-expression \textsf{ce}, \textsf{i}
levels up from the current procedure invocation.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf log(r, r:\&e) : real \hfill logarithm}

\noindent
\index{logarithm}\textsf{log(r1,r2)} produces the logarithm of
\textsf{r1} to base \textsf{r2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf many(c, s, i, i) : integer? \hfill many characters}

\noindent
\index{many()}String scanning function \textsf{many(c,s,i1,i2)} produces
the position in \textsf{s} after the longest initial sequence of
members of \textsf{c} within \textsf{s[i1:i2]}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf map(s, s:\&ucase, s:\&lcase) : string \hfill map string}

\noindent
\index{map string}\textsf{map(s1,s2,s3)} maps \textsf{s1}, using
\textsf{s2} and \textsf{s3}. The resulting string will be a copy of
\textsf{s1}, with the exception that any of
\textsf{s1}{\textquotesingle}s characters that appear in \textsf{s2}
are replaced by characters at the same position in \textsf{s3}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf match(s, s:\&subject, i:\&pos, i:0) : integer \hfill
match string}

\noindent
\index{match string}String scanning function \textsf{match(s1,s2,i1,i2)}
produces \textsf{i1+*s1} if \textsf{s1==s2[i1+:*s1]}, but fails
otherwise.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf max(n, ...) : number \hfill largest value}

\noindent
\index{max()}\textsf{max(x, ...)} returns the largest value among its
arguments, which must be numeric.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf member(x, ...) : x? \hfill test membership}

\noindent
\index{member()}\textsf{member(x, ...)} returns \textsf{x} if its second
and subsequent arguments are all members of set, cset, list or table
\textsf{x} but fails otherwise. \ If \textsf{x} is a cset, all of the
characters in subsequent string arguments must be present in \textsf{x}
in order to succeed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf membernames(x) : list \hfill class member names}

\noindent
\textsf{membernames(x)} produces a list containing the string names of
the fields of x, where x is either an object or a string name of a
class.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf methodnames(x) : list \hfill class method names}

\noindent
\textsf{methodnames(x)} produces a list containing the string names of
the methods defined in class \textsf{x}, where \textsf{x} is either an
object or a string name of a class.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf methods(x) : list \hfill class method list}

\noindent
\textsf{methods(x)} produces a list containing the procedure values of
the methods of x, where x is either an object or a string name of a
class.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf min(n, ...) : number \hfill smallest value}

\noindent
\index{min()}\textsf{min(x, ...)} returns the smallest value among its
arguments, which must be numeric.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf mkdir(s, s?) : ? \hfill create directory}

\noindent
\index{directory!create}\index{create!directory}\index{mkdir()}\textsf{mkdir(path,
mode)} creates a new directory named \textsf{path} with mode
\textsf{mode}. The optional \textsf{mode} parameter can be numeric or a
string of the form accepted by \textsf{chmod()}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf move(i:1) : string \hfill move scanning position}

\noindent
\index{move(i)}\textsf{move(i)} moves \textsf{\&pos} \textsf{i}
characters from the current position and returns the substring of
\textsf{\&subject} between the old and new positions. This function
reverses its effects by resetting the position to its old value if it
is resumed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf name(v, CE:\&current) : string \hfill variable name}

\noindent
\index{name(v)}\textsf{name(v)} returns the name of variable \textsf{v}
within the program that created co-expression \textsf{c}. Keyword
variables are recognized and named correctly. \textsf{name()} returns
the base type and subscript or field information for variables that are
elements within other values, but does not produce the source code
variable name for such variables. 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf numeric(any) : number \hfill convert to number}

\noindent
\index{convert!to number}\textsf{numeric(x)} produces an integer or real
number resulting from the type conversion of \textsf{x}, but fails if
the conversion is not possible.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf open(s, s:{\textquotedbl}rt{\textquotedbl}, ...) :
file? \hfill open file}

\noindent
\index{open file}\textsf{open(s1, s2, ...)} opens a file named
\textsf{s1} with mode \textsf{s2} and attributes given in trailing
arguments. The modes recognized by \textsf{open()} are: 

\ \ \ \ \ \textsf{{\textquotedbl}a{\textquotedbl}\ \ \ \ }append; write
after current contents\\
 \ \ \ \ \textsf{{\textquotedbl}b{\textquotedbl}\ \ \ \ }open for both
reading and writing (b does not mean binary mode!)\\
 \ \ \ \ \textsf{{\textquotedbl}c{\textquotedbl}\ \ \ \ }create a new
file and open it\\
 \ \ \ \ \textsf{{\textquotedbl}d{\textquotedbl}\ \ \ \ }open a
[NG]\index{DBM}DBM database\\
 \ \ \ \ \textsf{{\textquotedbl}g{\textquotedbl}\ \ \ \ }create a 2D
graphics window\\
 \ \ \ \ \textsf{{\textquotedbl}gl{\textquotedbl}\ \ \ \ }create a 3D
graphics window\\
 \ \ \ \ \textsf{{\textquotedbl}n{\textquotedbl}\ \ \ \ }connect to a
remote TCP network socket\\
 \ \ \ \ \textsf{{\textquotedbl}na{\textquotedbl}\ \ \ \ }accept a
connection from a TCP network socket \\
 \ \ \ \ \textsf{{\textquotedbl}nau{\textquotedbl}\ \ }accept a
connection from a UDP network socket\\
 \ \ \ \ \textsf{{\textquotedbl}nl{\textquotedbl}\ \ \ \ }listen on a
TCP network socket \\
 \ \ \ \ \textsf{{\textquotedbl}nu{\textquotedbl}\ \ \ \ }connect to a
UDP network socket\\
 \ \ \ \ \textsf{{\textquotedbl}m{\textquotedbl}\ \ \ \ }connect to a
messaging server (HTTP, SMTP, POP, ...)\\
 \ \ \ \ \textsf{{\textquotedbl}o{\textquotedbl}\ \ \ \ }open an
\index{ODBC}ODBC connection to a (typically \index{SQL}SQL)
database\\
 \ \ \ \ \textsf{{\textquotedbl}p{\textquotedbl}\ \ \ \ }execute a
program given by command line s1 and open a pipe to it\\
 \ \ \ \ \textsf{{\textquotedbl}r{\textquotedbl}\ \ \ \ }read\\
 \ \ \ \ \textsf{{\textquotedbl}t{\textquotedbl}\ \ \ \ }use text mode,
with newlines translated\\
 \ \ \ \ \textsf{{\textquotedbl}u{\textquotedbl}\ \ \ \ }use a binary
untranslated mode\\
 \ \ \ \ \textsf{{\textquotedbl}w{\textquotedbl}\ \ \ \ }write

Directories may only be opened for reading, and produce the names of all
files, one per line. Pipes may be opened for reading or writing, but
not both.

When opening a network socket: the first argument \textsf{s1} is the
name of the socket to connect. If \textsf{s1} is of the form
{\textquotedbl}s:i{\textquotedbl}, it is an Internet domain socket on
host s and port i; otherwise, it is the name of a Unix
domain socket. If the host name is null, it represents the current
host. Mode "n" allows an optional third parameter,
an integer timeout (in milliseconds) after which \textsf{open()} fails
if no connection has been established by that time.

For a UDP socket, there is not really a connection, but any writes to
that file will send a datagram to that address, so that the address
doesn{\textquotesingle}t have to be specified each time. Also,
\textsf{read()} or \textsf{reads()} cannot be performed on a UDP
socket; use receive. UDP sockets must be in the INET domain; the
address must have a colon. 

For a DBM database, only one modifier character may be used: if
\textsf{s1} is \textsf{{\textquotedbl}dr{\textquotedbl}} it indicates
that the database should be opened in read-only mode. 

The filename argument is a Uniform Resource Indicator (URI) when opening
a messaging connection. Arguments after the mode
{\textquotedbl}m{\textquotedbl} are sent as headers. The HTTP
User-Agent header defaults to {\textquotedbl}Unicon
Messaging/10.0{\textquotedbl} and Host defaults to the host and port
indicated in the URI. The SMTP From: header obtains its default from a
UNICON\_USERADDRESS environment variable if it is present.

For 2D and 3D windows, attribute values may be specified in the
following arguments to \textsf{open()}. \ \textsf{open()} fails if a
window cannot be opened or an attribute cannot be set to a requested
value.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf opmask(CE, c) : cset \hfill opcode mask}

\noindent
\textsf{opmask(ce)} gets \textsf{ce}{\textquotesingle}s
program{\textquotesingle}s opcode mask. The function returns
\textsf{\&null} if there is no opcode mask. \textsf{opmask(ce,cs)} sets
\textsf{ce}{\textquotesingle}s program{\textquotesingle}s opcode mask
to \textsf{cs}. This function is part of the execution monitoring
facilities.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf oprec(x) : record \hfill get methods vector}

\noindent
\textsf{oprec(r)} produces a variable reference for
\textsf{r}{\textquotesingle}s class{\textquotesingle} methods vector.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ord(s) : integer \hfill ordinal value}

\noindent
\index{ordinal value}\textsf{ord(s)} produces the integer ordinal
(value) of \textsf{s}, which must be of size 1.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf paramnames(CE, i:0) : string* \hfill parameter names}

\noindent
\index{parameter names}\textsf{paramnames(ce,i)} produces the names of
the parameters in the procedure activation \textsf{i} levels above the
current activation in \textsf{ce}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf parent(CE) : co{}-expression \hfill parent program}

\noindent
\textsf{parent(ce)} returns \textsf{\&main} for ce{\textquotesingle}s
parent program. This is interesting only when programs are dynamically
loaded using the \textsf{load()} function.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf pipe() : list \hfill create pipe}

\noindent
\index{pipe()}\textsf{pipe()} creates a pipe and returns a list of two
file objects. The first is for reading, the second is for writing. See
also function \textsf{filepair()}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf pop(L {\textbar} Message) : any? \hfill pop from stack}

\noindent
\index{pop(L)}\textsf{pop(L)} removes an element from the top of the
\index{stack}stack (\textsf{L[1]}) and returns it. \textsf{pop(M)}
removes and returns the first message in POP mailbox connection M; the
actual deletion occurs when the messaging connection is closed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf pos(i) : integer? \hfill test scanning position}

\noindent
\index{pos(i)}\textsf{pos(i)} tests whether \textsf{\&pos} is at
position \textsf{i} in \textsf{\&subject}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf proc(any, i:1, C) : procedure? \hfill convert to procedure}

\noindent
\index{proc(s,i)}\textsf{proc(s,i)} converts \textsf{s} to a procedure
if that is possible. Parameter \textsf{i} is used to resolve ambiguous
string names; it must be either 0, 1, 2, or 3. \ If \textsf{i} is 0, a
built-in function is returned if it is available, even if the global
identifier by that name has been assigned differently. If \textsf{i} is
1, 2, or 3, the procedure for an operator with that number of operands
is produced. For example,
\textsf{proc({\textquotedbl}-{\textquotedbl},2)} produces the procedure
for subtraction, while
\ \ \textsf{proc({\textquotedbl}-{\textquotedbl})} produces the
procedure for unary negation. \textsf{proc(C,i)} returns the procedure
activated \textsf{i} levels up with \textsf{C}. \textsf{proc(p, i, C)}
returns procedure \textsf{p} if it belongs to the program which created
co-expression \textsf{C}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf pull(L,i:1) : any? \hfill remove from list end}

\noindent
\index{pull(L)}\textsf{pull(L)} removes and produces an element from the
end of a nonempty list \textsf{L.} \textsf{pull(L, i)} removes
\textsf{i} elements, producing the last one removed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf push(L, any, ...) : list \hfill push on to stack}

\noindent
\textsf{push(L, x1, ..., xN)} pushes elements onto the beginning of list
\textsf{L}. The order of the elements added to the list is the reverse
of the order they are supplied as parameters to the call to
\index{push()}\textsf{push()}. \textsf{push()} returns the list that is
passed as its first parameter, with the new elements added.

\hrule\vspace{0.1cm}
\noindent {\bf put(L, x1, ..., xN) : list \hfill add to list end}

\noindent
\index{put()}\textsf{put(L, x1, ..., xN)} puts elements onto the end of
list \textsf{L}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf read(f:\&input) : string? \hfill read line}

\noindent
\index{read(f)}\textsf{read(f)} reads a line from file \textsf{f}. The
end of line marker is discarded.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf reads(f:\&input, i:1) : string? \hfill read characters}

\noindent
\index{reads(f,i)}\textsf{reads(f,i)} reads up to \textsf{i} characters
from file \textsf{f}. It fails on end of file. If \textsf{f} is a
network connection, \textsf{reads()} returns as soon as it has input
available, even if fewer than \textsf{i} characters were delivered. If
\textsf{i} is -1, \textsf{reads()} reads and produces the entire file
as a string. Care should be exercised when using this feature to read
very large files.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ready(f:\&input, i:0) : string? \hfill non{}-blocking read}

\noindent
\index{ready(f,i)}\textsf{ready(f,i)} reads up to \textsf{i} characters
from file \textsf{f}. It returns immediately with available data and
fails if no data is available. If \textsf{i} is 0, \textsf{ready()}
returns all available input. It is not currently implemented for window
values.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf real(any) : real? \hfill convert to real}

\noindent
\index{convert!to real}\textsf{real(x)} converts \textsf{x} to a real,
or fails if the conversion cannot be performed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf receive(f) : record \hfill receive datagram}

\noindent
\index{receive datagram}\textsf{receive(f)} reads a datagram addressed
to the port associated with \textsf{f}, waiting if necessary. The
returned value is a record of type \textsf{posix\_message(addr, msg)},
containing the address of the sender and the contents of the message
respectively. 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf remove(s) : ? \hfill remove file}

\noindent
\index{remove file}\index{file!remove}\textsf{remove(s)} removes the
file named \textsf{s}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf rename(s, s) : ? \hfill rename file}

\noindent
\index{file!rename}\textsf{rename(s1,s2)} renames the file named
\textsf{s1} to have the name \textsf{s2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf repl(x, i) : x \hfill replicate}

\noindent
\index{replicate string}\textsf{repl(x, i)} concatenates and returns
\textsf{i} copies of string or list \textsf{x}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf reverse(x) : x \hfill reverse sequence}

\noindent
\index{reverse(x)}\textsf{reverse(x)} returns a value that is the
reverse of string or list \textsf{x}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf right(s, i:1, s:{\textquotedbl} {\textquotedbl}) :
string \hfill right format string}

\noindent
\index{right()}\textsf{right(s1,i,s2)} produces a string of length
\textsf{i}. If \textsf{i{\textless}*s1}, \textsf{s1} is truncated.
Otherwise, the function pads \textsf{s1} on left with \textsf{s2} to
length \textsf{i}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf rmdir(s) : ? \hfill remove directory}

\noindent
\index{remove directory}\textsf{rmdir(d)} removes the directory named
\textsf{d}. \textsf{rmdir()} fails if \textsf{d} is not empty or does
not exist.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf rtod(r) : real \hfill convert radians to degrees}

\noindent
\index{convert!radians to degrees}\textsf{rtod(r)} produces the
equivalent of \textsf{r} radians, expressed in degrees.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf runerr(i, any) \hfill runtime error}

\noindent
\index{runtime error}\textsf{runerr(i,x)} produces runtime error
\textsf{i} with value \textsf{x}. Program execution is terminated.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf seek(f, any) : file? \hfill seek to file offset}

\noindent
\index{seek(f,i)}\textsf{seek(f,i)} seeks to offset \textsf{i} in file
\textsf{f}, if it is possible. If \textsf{f} is a regular file,
\textsf{i} must be an integer. If \textsf{f} is a database, \textsf{i}
seeks a position within the current set of selected rows. The position
is selected numerically if \textsf{i} is convertible to an integer;
otherwise \textsf{i} must be convertible to a string and the position
is selected associatively by the primary key.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf select(x1, x2, ?) : list \hfill files with available input}

\noindent
\textsf{select(files?, timeout)} waits for a input to become available
on any of several files, typically network connections or windows. Its
arguments may be files or lists of files, ending with an optional
integer timeout value in milliseconds. It returns a list of those files
among its arguments that have input waiting.

If the final argument to \index{select()}\textsf{select()} is an
integer, it is an upper bound on the time elapsed before select
returns. A timeout of 0 causes \textsf{select()} to return immediately
with a list of files on which input is currently pending. If no files
are given, \textsf{select()} waits for its timeout to expire. If no
timeout is given, \textsf{select()} waits forever for available input
on one of its file arguments. Directories and databases cannot be
arguments to \textsf{select()}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf send(s, s) : ? \hfill send datagram}

\noindent
\index{send datagram}\textsf{send(s1, s2)} sends a UDP datagram to the
address \textsf{s1} (in host:port format) with the contents
\textsf{s2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf seq(i:1, i:1) : integer* \hfill generate sequence}

\noindent
\index{sequence, generate numeric}\textsf{seq(i, j)} generates the
infinite sequence \textsf{i}, \textsf{i+j}, \textsf{i+2*j}, ... .
\textsf{j} may not be 0.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf serial(x) : integer? \hfill structure serial number}

\noindent
\index{serial(x)}\textsf{serial(x)} returns the serial number for
structure \textsf{x}, if it has one. Serial numbers uniquely identify
structure values.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf set(x, ...) : set \hfill create set}

\noindent
\index{create!set}\index{set()}\textsf{set()} creates a set. Arguments
are inserted into the new set, with the exception of lists.
\textsf{set(L)} creates a set whose members are the elements of list
\textsf{L}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf setenv(s) : ? \hfill set environment variable}

\noindent
\index{setenv()}\textsf{setenv()} sets an environment variable
\textsf{s} in the operating system.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf sin(r) : real \hfill sine}

\noindent
\index{sine}sin(r) produces the sine of r. The argument is given in
radians.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf sort(x, i:1) : list \hfill sort structure}

\noindent
\index{sort(x, i)}\textsf{sort(x, i)} sorts structure \textsf{x}. If
\textsf{x} is a table, parameter \textsf{i} is the sort method. If
\textsf{i} is 1 or 2, the table is sorted into a list of lists of the
form [key, value]. If \textsf{i} is 3 or 4, the table is sorted into a
list of alternating keys and values. Sorting is by keys for odd-values
of \textsf{i}, and by table element values for even-values of
\textsf{i}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf sortf(x, i:1) : list \hfill sort by field}

\noindent
\index{sort by field}\textsf{sortf(x,i)} sorts a list, record, or set
\textsf{x} using field \textsf{i} of each element that has one.
Elements that don{\textquotesingle}t have an
\textsf{i}{\textquotesingle}th field are sorted in standard order and
come before those that do have an \textsf{i}{\textquotesingle}th field.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf sql(D, s) : integer \hfill execute SQL statement}

\noindent
\index{sql()}\textsf{sql(db, query)} executes arbitrary SQL code on
\textsf{db}. This function allows the program to do vendor-specific SQL
and many SQL statements that cannot be expressed otherwise using the
Unicon database facilities. \textsf{sql()} can leave the database in an
arbitrary state and should be used with care.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf sqrt(r) : real \hfill square root}

\noindent
\index{square root}\textsf{sqrt(r)} produces the square root of
\textsf{r}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf stat(f) : record? \hfill get file information}

\noindent
\index{file!information}\index{stat(f)}\textsf{stat(f)} returns a record
with information about the file \textsf{f} which may be a path or a
file object. The return value is of \ type: \textsf{record
posix\_stat(dev, ino, mode, nlink, uid, gid, rdev, size, atime, mtime,
ctime, blksize, blocks, symlink)}. Many of these fields are POSIX
specific, but a number are supported across platforms, such as the
\index{file size}file size in bytes (the \textsf{size} field), access
permissions (the \textsf{mode} field), and the last modified time (the
\textsf{mtime} field).

The \textsf{atime}, \textsf{mtime}, and \textsf{ctime} fields are
integers that may be formatted with the \textsf{ctime()} and
\textsf{mtime()} functions. The mode is a string similar to the long
listing option of the UNIX \textsf{ls(1)} command. For example,
\textsf{{\textquotedbl}-rwxrwsr-x{\textquotedbl}} represents a plain
file with a mode of 2775 (octal). \textsf{stat(f)} fails if filename or
path \textsf{f} does not exist.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf staticnames(CE:\&current, i:0) : string* \hfill static variable names}

\noindent
\index{static}\textsf{staticnames(ce,i)} generates the names of static
variables in the procedure \textsf{i} levels above the current
activation in \textsf{ce}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf stop(s{\textbar}f, ...) : \hfill stop execution}

\noindent
\index{stop}\textsf{stop(args)} \index{halt}halts execution after
writing out its string arguments, followed by a newline, to
\textsf{\&errout}. If any argument is a file, subsequent string
arguments are written to that file instead of \textsf{\&errout}. The
program exit status indicates that an error has occurred.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf string(x) : string? \hfill convert to string}

\noindent
\index{convert!to string}\index{string(x)}\textsf{string(x)} converts x
to a string and returns the result, or fails if the value cannot be
converted.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf system(x, f:\&input, f:\&output, f:\&errout, s) : integer \hfill 
execute system command}

\noindent
\index{system command}\textsf{system(x, f1, f2, f3, waitflag)} launches
execution of a program in a separate process. \textsf{x} can be either
a string or a list of strings. In the former case, whitespace is used
to separate the arguments and the command is processed by the
platform{\textquotesingle}s command interpreter. In the second case,
each member of the list is an argument and the second and subsequent
list elements are passed unmodified to the program named in the first
element of the list.

The three file arguments are files that will be used for the new
process{\textquotesingle} standard input, standard output and standard
error. The return value is the exit status from the process. If the
\textsf{waitflag} argument is
\textsf{{\textquotedbl}nowait{\textquotedbl}}, \textsf{system()}
returns immediately after spasyswning the new process, and the return
value is then the process id of the new process.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf sys\_errstr(i) : string? \hfill system error string}

\noindent
\index{sys\_errstr(i)}\textsf{sys\_errstr(i)} produces the error string
corresponding to \textsf{i}, a value obtained from \textsf{\&errno}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf tab(i:0) : string? \hfill set scanning position}

\noindent
\index{tab(i)}\textsf{tab(i)} sets \textsf{\&pos} to \textsf{i} and
returns the substring of \textsf{\&subject} spanned by the former and
new positions. \textsf{tab(0)} moves the position to the end of the
string. This function reverses its effects by resetting the position to
its old value if it is resumed.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf table(k,v, ..., x) : table \hfill create table}

\noindent
\index{table(x)}\textsf{table(x)} creates a table with default value
\textsf{x}. If \textsf{x} is a mutable value such as a list, all
references to the default value refer to the \textit{same} value, not a
separate copy for each key. Given more than one argument,
\textsf{table(k,v,...x)} takes alternating keys and values and
populates the table with these initial contents.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf tan(r) : real \hfill tangent}

\noindent
\index{tangent}\textsf{tan(r)} produces the tangent of \textsf{r} in
radians.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf trap(s, p) : procedure \hfill trap or untrap signal}

\noindent
\index{trap signal}\textsf{trap(s, proc)} sets up a signal handler for
the signal \textsf{s} (the name of the signal). The old handler (if
any) is returned. If \textsf{proc} is null, the signal is reset to its
default value. 

Caveat: This is not supported by the optimizing
\index{compiler}compiler, iconc!

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf trim(s, c:{\textquotesingle} {\textquotesingle}, i:{}-1) :
string \hfill trim string}

\noindent
\index{trim(s,c,i)}\textsf{trim(s,c,i)} removes characters in \textsf{c}
from \textsf{s} at the back (\textsf{i}=-1, the default), at the front
(\textsf{i}=1), or at both ends (\textsf{i}=0).

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf truncate(f, i) : ? \hfill truncate file}

\noindent
\index{truncate file}\textsf{truncate(f, len)} changes the file
\textsf{f} (which may be a string filename, or an open file) to be no
longer than length \textsf{len}. \textsf{truncate()} does not work on
windows, network connections, pipes, or databases.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf type(x) : string \hfill type of value}

\noindent
\index{type(x)}\textsf{type(x)} returns a string that indicates the type
of \textsf{x}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf upto(c, s, i, i) : integer* \hfill find characters in set}

\noindent
String scanning function \index{upto(c)}\textsf{upto(c,s,i1,i2)}
generates the sequence of integer positions in \textsf{s} up to a
character in \textsf{c} in \textsf{s[i2:i2]}, but fails if there is no
such position.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf utime(s, i, i) : null \hfill file access/modification times}

\noindent
\textsf{utime(f, atime, mtime)} sets the \index{access time, set}access
time for a file named \textsf{f} to \textsf{atime} and the modification
time to \textsf{mtime}. The \textsf{ctime} is set to the current time.
The effects of this function are platform specific. Some file systems
support only a subset of these times.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf variable(s, CE:\&current, i:0) : any? \hfill get variable}

\noindent
\index{variable(s,c,i)}\textsf{variable(s, c, i)} finds the variable
with name \textsf{s} and returns a variable descriptor that refers to
its value. The name \textsf{s} is searched for within co-expression
\textsf{c}, starting with local variables \textsf{i} levels above the
current procedure frame, and then among the global variables in the
program that created \textsf{c}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf where(f) : integer? \hfill file
position}

\noindent
\index{file!position}\index{where(f)}\textsf{where(f)} returns the
current offset position in file \textsf{f}. It fails on windows and
networks. The beginning of the file is offset 1.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf write(s{\textbar}f, ...) :
string{\textbar}file \hfill write text line}

\noindent
\textsf{write(args)} outputs strings, followed by a newline, to a file
or files. Strings are written in order to their nearest preceding file,
defaulting to \textsf{\&output}. A newline is output to the preceding
file after the last argument, as well as whenever a non-initial file
argument directs output to a different file.
\index{write()}\textsf{write()} returns its last argument.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf writes(s{\textbar}f, ...) :
string{\textbar}file \hfill write strings}

\noindent
\textsf{writes(args)} outputs strings to one or more files. Each string
argument is written to the nearest preceding file argument, defaulting
to \textsf{\&output}. \index{writes()}\textsf{writes()} returns its
last argument.

\subsubsection{Graphics Functions}

The names of built-in graphics functions begin with upper case. The
built-in graphics functions are listed here. These functions are more
thoroughly described in [Griswold98]. Extensive procedure and class
libraries for graphics are described in [Griswold98] and in Appendix B.
In 2D, arguments named \textsf{x} and \textsf{y} are pixel locations in
zero-based integer coordinates. \ In 3D windows coordinates are given
using real numbers, and functions by default take three coordinates
(\textsf{x,y,z}) per vertex. Attribute \textsf{dim} can be set to 2 or
4, changing most 3D functions to take vertices in a (\textsf{x,y}) or
(\textsf{x,y,z,w}) format. Arguments named \textsf{row} and
\textsf{col} are cursor locations in one-based integer text
coordinates. Most functions{\textquotesingle} first parameter named
\textsf{w} defaults to \textsf{\&window} and the window argument can be
omitted in the default case.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Active() : window \hfill produce active window}

\noindent
\textsf{Active()} returns a window that has one or more events pending.
If no window has an event pending, \textsf{Active()} blocks and waits
for an event to occur. \ \textsf{Active()} starts with a different
window on each call in order to avoid window
{\textquotedbl}starvation{\textquotedbl}. \ \textsf{Active()} fails if
no windows are open.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Alert() : window \hfill alert the user}

\noindent
\textsf{Alert()} produces a visual flash or audible beep that signifies
to the user the occurrence of some notable event in the application.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Bg(w,s) : string \hfill background color}

\noindent
\textsf{Bg(w)} retrieves the background color. \textsf{Bg(w,s)} sets the
background color by name, rgb, or mutable color value. \textsf{Bg()}
fails if the background cannot be set to the requested color.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf Clip(w,x:0,y:0,width:0,height:0) : window \hfill clip to rectangle}

\noindent
\textsf{Clip(w,x,y,width,height)} clips output to a rectangular area
within the window. \ If \textsf{width} is 0, the clip region extends
from \textsf{x} to the right side of the window. \ If \textsf{height}
is 0, the clip region extends from \textsf{y} to the bottom of the
window.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Clone(w,s,...) : window \hfill clone context}

\noindent
\textsf{Clone(w)} produces a new window binding in which a new graphics
context is copied from \textsf{w} and bound to
\textsf{w}{\textquotesingle}s canvas. Additional string arguments
specify attributes of the new binding, as in \textsf{WAttrib()}. If the
first string argument is
\textsf{{\textquotedblleft}g{\textquotedblright}} or
\textsf{{\textquotedblleft}gl{\textquotedblright}}, \textsf{Clone()}
binds the new context to a subwindow with separate canvas and input
queue inside of and relative to \textsf{w}. \textsf{Clone()} fails if
an attribute cannot be set to a requested value.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Color(w, i, s,...) : window \hfill set mutable color}

\noindent
\textsf{Color(w,i)} produces the current setting of mutable color
\textsf{i}. \textsf{Color(w,i,s,...)} sets the color map entries
identified by \textsf{i[j]} to the corresponding colors \textsf{s[j]}.
\ See [Griswold98].

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ColorValue(w, s) : string \hfill convert color name to rgb}

\noindent
\textsf{ColorValue(w,s)} converts the string color \textsf{s} into a
string with three comma-separated 16-bit integer values denoting the
color{\textquotesingle}s RGB components. \textsf{ColorValue()} fails if
string \textsf{s} is not a valid name or recognized decimal or hex
encoding of a color.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf CopyArea(w1, w2,x:0,y:0,width:0,height:0,x2:0,y2:0) :
window \hfill copy area}

\noindent
\textsf{CopyArea(w1,w2,x,y,width,height,x2,y2)} copies a rectangular
region within \textsf{w1} defined by
\textsf{x},\textsf{y},\textsf{width},\textsf{height} to window
\textsf{w2} at offset \textsf{x2},\textsf{y2}. \ \textsf{CopyArea()}
returns \textsf{w1}. \textsf{\&window} is not a default for this
function. The default copies all of \textsf{w1}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Couple(w1, w2) : window \hfill couple window to context}

\noindent
\textsf{Couple(w1,w2)} produces a new value that binds the window
associated with \textsf{w1} to the graphics context associated with
\textsf{w2}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawArc(w, x, y, width, height:width, a1:0.0, a2:2*\&pi, ...)
: window \hfill draw arc}

\noindent
\textsf{DrawArc(w,x,y,width,height,a1,a2,...)} draws arcs or ellipses.
\ Each is defined by six integer coordinates. \ \textsf{x}, \textsf{y},
\textsf{width} and \textsf{height} define a bounding rectangle around
the arc; the center of the arc is the point
\textsf{(x+(width)/2,y+(height)/2)}. Angles are specified in radians.
\ Angle \textsf{a1} is the starting position of the arc, where 0.0 is
the 3 o{\textquotesingle}clock position and the positive direction is
counter-clockwise. \ Angle \textsf{a2} is not the end position, but
rather specifies the direction and extent of the arc.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawCircle(w, x, y, radius, a1:0.0, a2:2*\&pi, ...) :
window \hfill draw circle}

\noindent
\textsf{DrawCircle()} draws a circle or arc, centered at
(\textsf{x},\textsf{y}) and otherwise similar to \textsf{DrawArc()}
with \textsf{width=height}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawCube(w, x, y, z, len ...) : record \hfill draw cube}

\noindent
\textsf{DrawCube(w, x, y, z, len{\dots}) \ }draws a cube with sides of
length \textsf{len} at the position (\textsf{x}, \textsf{y},
\textsf{z}) on the 3D window \textsf{w}. The display list element is
returned. This procedure fails if the context attribute \textsf{dim} is
set to 2. 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawCurve(w, x1, y1, ...) : window \hfill draw curve}

\noindent
\textsf{DrawCurve(w,x1,y1,...,xn,yn)} draws a smooth curve connecting
each \textsf{x,y} pair in the argument list. \ \ If the first and last
point are the same, the curve is smooth and closed through that point.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf DrawCylinder(w, x, y, z, h, r1, r2, ...) : record \hfill draw cylinder}

\noindent
\textsf{DrawCylinder(w, x, y, z, h, r1, r2, {\dots})} \ draws a cylinder
with a top of radius \textsf{r1}, a bottom with radius \textsf{r2}, and
a height \textsf{h} on 3D window \textsf{w}. \ The disk is centered at
the point (\textsf{x}, \textsf{y}, \textsf{z}). The display list
element is returned. This procedure fails if the context attribute
\textsf{dim} is set to 2.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf DrawDisk(w, x, y, z, r1, r2, a1, a2, ...) : record \hfill draw disk}

\noindent
\textsf{DrawDisk(W, x, y, z, r1, r2, a1, a2, {\dots})}\texttt{ }draws a
disk or partial disk centered at (\textsf{x}, \textsf{y}, \textsf{z})
on 3D window \textsf{w}. The inner circle has radius \textsf{r1} and
the outer circle has radius \textsf{r2}. The parameters \textsf{a1} and
\textsf{a2} are optional. If they are specified, a partial disk is
drawn with a starting angle \textsf{a1} and sweeping angle \textsf{a2}.
The display list element is returned.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawImage(w, x, y, s) : window \hfill draw bitmapped figure}

\noindent
\textsf{DrawImage(w,x,y, s)} draws an image specified in string
\textsf{s} at location \textsf{x,y}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawLine(w, x1, y1, z1 ...) : window [list] \hfill draw line}

\noindent
\textsf{DrawLine(w,x1,y1,...,xn,yn)} draws lines between each adjacent
\textsf{x,y} pair of arguments. In 3D, \textsf{DrawLine()} takes from
2-4 coordinates per vertex and returns the list that represents the
lines on the display list for refresh purposes.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawPoint(w, x1, y1, ...) : window [list] \hfill draw point}

\noindent
\textsf{DrawPoint(w,x1,y1,...,xn,yn)} draws points. In 3D,
\textsf{DrawPoint()} takes from 2-4 coordinates per vertex and returns
the list that represents the points on the display list for refresh
purposes.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf DrawPolygon(w, x1, y1, [z1,] ...) : window [list] \hfill draw polygon}

\noindent
\textsf{DrawPolygon(w,x1,y1,...,xn,yn)} draws a polygon. In 3D\textsf{,
DrawPolygon()} takes from 2-4 coordinates per vertex and returns the
list that represents the polygon on the display list for refresh
purposes.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawRectangle(w, x1, y1, width1, height1 ...) : window \hfill
draw rectangle}

\noindent
\textsf{DrawRectangle(w,x1,y1,width1,height1,...)} draws rectangles.
Arguments \textsf{width} and \textsf{height} define the perceived size
of the rectangle; the actual rectangle drawn is \textsf{width+1} pixels
wide and \textsf{height+1} pixels high.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf DrawSegment(w, x1, y1, [z1,] ...) : window [list] \hfill draw line segment}

\noindent
\textsf{DrawSegment(w,x1,y1,...,xn,yn)} draws lines between alternating
\textsf{x,y} pairs in the argument list. In 3D, \textsf{DrawSegment()}
takes from 2-4 coordinates per vertex and returns the list that
represents the segments on the display list for refresh purposes.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawSphere(w, x, y, z, r, ...) : record \hfill draw sphere}

\noindent
\textsf{DrawSphere(w, x, y, z, r,{\dots})} \ draws a sphere with radius
r centered at (x, y, z) on 3D window w. The display list element is
returned. This procedure fails if the context attribute \textsf{dim} is
set to 2.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawString(w, x1, y1, s1, ...) : window \hfill draw text}

\noindent
\textsf{DrawString(w,x,y,s)} draws text \textsf{s} at coordinates (x,
y). \ This function does not draw any background; only the
characters{\textquotesingle} actual pixels are drawn. It is possible to
use \textsf{{\textquotedbl}drawop=reverse{\textquotedbl}} with this
function to draw erasable text. \textsf{DrawString()} does not affect
the text cursor position. Newlines present in \textsf{s} cause
subsequent characters to be drawn starting at (\textsf{x, current\_y +
leading}), where \textsf{x} is the \textsf{x} supplied to the function,
\textsf{current\_y} is the \textsf{y} coordinate the newline would have
been drawn on, and leading is the current leading associated with the
binding.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf DrawTorus(w, x, y, z, r1, r2, ...) :
record \hfill draw torus}

\noindent
\textsf{DrawTorus(w, x, y, z, r1, r2,{\dots})} \ draws a torus with
inner radius \textsf{r1}, outside radius \textsf{r2}, and centered at
(\textsf{x,y,z}) on 3D window \textsf{w}. The display list element is
returned. This procedure fails if the context attribute \textsf{dim} is
set to 2.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf EraseArea(w, x:0, y:0, width:0, height:0. ...) : window \hfill
erase rectangular area}

\noindent
\textsf{EraseArea(w,x,y,width,height,...)} erases rectangular areas
within the window to the background color. \ If \textsf{width} is 0,
the region cleared extends from \textsf{x} to the right side of the
window. \ If \textsf{height} is 0, the region erased extends from
\textsf{y} to the bottom of the window. In 3D, \textsf{EraseArea(W)}
clears the contents of the entire window.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf Event(w, i:infinity) : string{\textbar}integer \hfill
 read event on window}

\noindent
\textsf{Event(w, i)} retrieves the next event available for window
\textsf{w}. If no events are available, \textsf{Event()} waits for
\textsf{i} milliseconds. Keystrokes are encoded as strings, while mouse
events are encoded as integers. \ The retrieval of an event is
accompanied by assignments to the keywords \textsf{\&x}, \textsf{\&y},
\textsf{\&row}, \textsf{\&col}, \textsf{\&interval},
\textsf{\&control}, \textsf{\&shift}, \textsf{\&meta}, and if 3D
attribute \textsf{{\textquotedblleft}pick=on{\textquotedblright}},
\textsf{\&pick}. \textsf{Event()} fails if the timeout expires before
an event occurs.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Fg(w, s) : string \hfill foreground color}

\noindent
\textsf{Fg(w)} retrieves the current foreground color. \textsf{Fg(w,s)}
sets the foreground by name or value. \textsf{Fg()} fails if the
foreground cannot be set to the requested color. In 3D, \textsf{Fg(w,
s)} changes the material properties of subsequently drawn objects to
the material properties specified by \textsf{s}. The string \textsf{s}
must be one or more semi-colon separated material properties. A
material property is of the form 

\ \ \ \ \ \ \ \ [diffuse {\textbar} ambient {\textbar} specular
{\textbar} emission] \textit{color name} or
{\textquotedblleft}shininess n{\textquotedblright}, 0 {\textless}= n
{\textless}= 128.

If string \textsf{s} is omitted, the current values of the material
properties will be returned.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf FillArc(w, x, y, width, height, a1, a2, ...) : window \hfill
draw filled arc}

\noindent
\textsf{FillArc(w,x,y,width,height,a1,a2,...)} draws filled arcs,
ellipses, and/or circles. \ Coordinates are as in \textsf{DrawArc()}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf FillCircle(w, x, y, radius, a1, a2, ...) : window \hfill
draw filled circle}

\noindent
\textsf{FillCircle(w,x,y, radius,a1,a2,...)} draws filled circles.
\ Coordinates are as in \textsf{DrawCircle()}.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf FillPolygon(w, x1, y1, [z1,] ...) : window \hfill draw filled polygon}

\noindent
\textsf{FillPolygon(w,x1,y1,...,xn,yn)} draws a filled polygon. \ The
beginning and ending points are connected if they are not the same. In
3D\textsf{, FillPolygon()} takes from 2-4 coordinates per vertex and
returns the list that represents the polygon on the display list for
refresh purposes. 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf FillRectangle(w, x:0, y:0, width:0, height:0, ...) :
window \hfill draw filled rectangle}

\noindent
\textsf{FillRectangle(w,x,y,width,height,...)} draws filled rectangles.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Font(w, s) : string \hfill font}

\noindent
\textsf{Font(w)} produces the name of the current font.
\textsf{Font(w,s)} sets the window context{\textquotesingle}s font to
\textsf{s} and produces its name or fails if the font name is invalid.
\ The valid font names are largely system-dependent but follow the
format \textsf{family[,styles],size}, where styles optionally add bold
or italic or both. Four font names are portable: \textsf{serif} (Times
or similar), \textsf{sans} (Helvetica or similar), \textsf{mono} (a
mono spaced sans serif font) and \textsf{typewriter} (Courier or
similar). \ \textsf{Font()} fails if the requested font name does not
exist.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf FreeColor(w, s, ...) : window \hfill release colors}

\noindent
\textsf{FreeColor(w,s1,...,sn)} allows the window system to re-use the
corresponding color map entries. \ Whether this call has an effect is
dependent upon the particular implementation. \ If a freed color is
still in use at the time it is freed, unpredictable results will occur.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf GotoRC(w, row:1, col:1) : window \hfill go to row,column}

\noindent
\textsf{GotoRC(w,row,col)} moves the text cursor to a particular row and
column, given in numbers of characters; the upper-left corner is
coordinate (1,1). \ The column calculation used by \textsf{GotoRC()}
assigns to each column the pixel width of the widest character in the
current font. \ If the current font is of fixed width, this yields the
usual interpretation.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf GotoXY(w, x:0, y:0) : window \hfill go to pixel}

\noindent
\textsf{GotoXY(w,x,y)} moves the text cursor to a specific cursor
location in pixels.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf IdentityMatrix(w) : record \hfill load the identity matrix}

\noindent
\textsf{IdentityMatrix(w)} changes the current matrix to the identity
matrix on 3D window \textsf{w}. The display list element is returned. 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Lower(w) : window \hfill lower window}

\noindent
\textsf{Lower(w)} moves window \textsf{w} to the bottom of the window
stack.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf MatrixMode(w, s) : record \hfill set matrix mode}

\noindent
\textsf{MatrixMode(w, s)} changes the matrix mode to \textsf{s} on 3D
window \textsf{w}. The string \textsf{s} must be either
\textsf{{\textquotedblleft}projection{\textquotedblright}} or
\textsf{{\textquotedblleft}modelview{\textquotedblright}}; otherwise
this procedure fails. The display list element is returned.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf MultMatrix(w, L) : record \hfill multiply transformation matrix}

\noindent
\textsf{MultMatrix(w, L)} multiplies the current transformation matrix
used in 3D window w by the 4x4 matrix represented as a list of 16
values L.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf NewColor(w, s) : integer \hfill allocate mutable color}

\noindent
\textsf{NewColor(w,s)} allocates an entry in the color map and returns a
small negative integer for this entry, usable in calls to routines that
take a color specification, such as \textsf{Fg()}. \ If \textsf{s} is
specified, the entry is initialized to the given color.
\textsf{NewColor()} fails if it cannot allocate an entry.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PaletteChars(w, s) : string \hfill pallete characters}

\noindent
\textsf{PaletteChars(w,s)} produces a string containing each of the
letters in palette \textsf{s}. The palletes
{\textquotedblleft}c1{\textquotedblright} through
{\textquotedblleft}c6{\textquotedblright} define different color
encodings of images represented as string data; see [Griswold98].

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PaletteColor(w, p, s) : string \hfill pallete color}

\noindent
\textsf{PaletteColor(w,s)} returns the color of key \textsf{s} in
palette \textsf{p} in
\textsf{{\textquotedblleft}}\textsf{\textit{r}}\textsf{,}\textsf{\textit{g}}\textsf{,}\textsf{\textit{b}}\textsf{{\textquotedblright}}
format.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PaletteKey(w, p, s) : integer \hfill pallete key}

\noindent
\textsf{PaletteKey(w,s)} returns the key of closest color to \textsf{s}
in palette \textsf{p}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Pattern(w, s) : w \hfill define stipple pattern}

\noindent
\textsf{Pattern(w,s)} selects stipple pattern \textsf{s} for use during
draw and fill operations. \ \textsf{s} may be either the name of a
system-dependent pattern or a literal of the form
\textit{width},\textit{bits}. \ Patterns are only used when the
\textsf{fillstyle} attribute is \textsf{stippled} or
\textsf{opaquestippled}. \ \textsf{Pattern()} fails if a named pattern
is not defined. An error occurs if \textsf{Pattern()} is given a
malformed literal.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Pending(w, x, ...) : L \hfill produce event queue}

\noindent
\textsf{Pending(w)} produces the list of events waiting to be read from
window \textsf{w}. \ If no events are available, the list is empty (its
size is 0). \ \textsf{Pending(w,x1,...,xn)} adds \textsf{x1} through
\textsf{xn} to the end of \textsf{w}{\textquotesingle}s pending list in
guaranteed consecutive order.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Pixel(w, x:0, y:0, width:0, height:0) : i1...in \hfill
generate window pixels}

\noindent
\textsf{Pixel(w,x,y,width,height)} generates pixel contents from a
rectangular area within window \textsf{w}. \ \textsf{width * height}
results are generated starting from the upper-left corner and advancing
down to the bottom of each column before the next one is visited.
\ Pixels are returned in integer values; ordinary colors are encoded
nonnegative integers, while mutable colors are negative integers that
were previously returned by \textsf{NewColor()}. Ordinary colors are
encoded with the most significant eight bits all zero, the next eight
bits contain the red component, the next eight bits the green
component, and the least significant eight bits contain the blue
component. \textsf{Pixel()} fails if part of the requested rectangle
extends beyond the canvas.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PopMatrix(w) : record \hfill pop the matrix stack}

\noindent
\textsf{PopMatrix(w)} pops the top matrix from either the projection or
modelview matrix stack on 3D window \textsf{w}, depending on the
current matrix mode\textsf{.} This procedure fails if there is only one
matrix on the matrix stack. \ The display list element is returned. 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PushMatrix(w) : record \hfill push the matrix stack}

\noindent
\textsf{PushMatrix(w)} pushes a copy of the current matrix onto the
matrix stack on 3D window \textsf{w}. The current matrix mode
determines on what stack is pushed. This procedure fails if the stack
is full. The \textsf{{\textquotedblleft}projection{\textquotedblright}}
stack is of size two; the
\textsf{{\textquotedblleft}modelview{\textquotedblright}} stack is of
size thirty two. The display list element is returned.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PushRotate(w, a, x, y, z) : record \hfill push and rotate}

\noindent
\textsf{PushRotate()} is equivalent to \textsf{PushMatrix()} followed by
\textsf{Rotate()}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PushScale(w, x, y, z) : record \hfill push and scale}

\noindent
{\sffamily
PushScale()\textrm{ is equivalent to }PushMatrix()\textrm{ followed by
}Scale()\textrm{.}}

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf PushTranslate(w, x, y, z) : record \hfill push and translate}

\noindent
{\sffamily
PushTranslate()\textrm{ is equivalent to }PushMatrix()\textrm{ followed
by }Translate()\textrm{.}}

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf QueryPointer(w) : x, y \hfill produce mouse position}

\noindent
\textsf{QueryPointer(w)} generates the \textsf{x} and \textsf{y}
coordinates of the mouse relative to window \textsf{w}. \ If \textsf{w}
is omitted, \textsf{QueryPointer()} generates the coordinates relative
to the upper-left corner of the entire screen.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Raise(w) : window \hfill raise window}

\noindent
\textsf{Raise(w)} moves window \textsf{w} to the top of the window
stack, making it entirely visible and possibly obscuring other windows.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf ReadImage(w, s, x:0, y:0) : integer \hfill load image file}

\noindent
\textsf{ReadImage(w,s,x,y)} loads an image from the file named by s into
window w at offset \textsf{x,y}. \textsf{\ x} and \textsf{y} are
optional and default to 0,0. GIF, JPG, and BMP formats are supported,
along with platform-specific formats. If \textsf{ReadImage()} reads the
image into \textsf{w}, it returns either an integer 0 indicating no
errors occurred or a nonzero integer indicating that one or more colors
required by the image could not be obtained from the window system.
\ \textsf{ReadImage()} fails if file \textsf{s} cannot be opened for
reading or is an invalid file format.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Refresh(w) : window \hfill redraw the window}

\noindent
\textsf{Refresh(w) }redraws the contents of window \textsf{w}. It is
used mainly when objects have been moved in a 3D scene. The window
\textsf{w} is returned. 

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Rotate(w, a, x, y, z) : record \hfill rotate objects}

\noindent
\textsf{Rotate(w, a, x, y, z,{\dots})} rotates subsequent objects drawn
on 3D window \textsf{w} by angle \textsf{a} degrees, in the direction
(\textsf{x,y,z}). \ The display list element is returned.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Scale(w, x, y, z) : record \hfill\ scale
objects}

\noindent
\textsf{Scale(w, x, y, z,{\dots})} scales subsequent objects drawn on 3D
window \textsf{w} according to the given coordinates. The display list
element is returned.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf Texcoord(w, x, y, ...) : list \hfill define texture coordinates}

\noindent
\textsf{Texcoord(W, x}\textsf{\textsubscript{1}}\textsf{,
y}\textsf{\textsubscript{1}}\textsf{, {\dots},
x}\textsf{\textsubscript{n}}\textsf{,
y}\textsf{\textsubscript{n}}\textsf{) }sets the texture coordinates to
\textsf{x}\textsf{\textsubscript{1}}\textsf{,
y}\textsf{\textsubscript{1}}\textsf{, {\dots},
x}\textsf{\textsubscript{n}}\textsf{, y}\textsf{\textsubscript{n}} in
3D window w. Each x, y, pair forms one texture coordinate.
\textsf{Texcoord(W, L)} sets the texture coordinates to those specified
in the list \textsf{L}. \textsf{Texcoord(W, s) }sets the texture
coordinates to those specified by \textsf{s}. The string \textsf{s}
must be \textsf{{\textquotedblleft}auto{\textquotedblright}} otherwise
the procedure will fail. \ In all cases the display list element is
returned.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf TextWidth(w, s) : integer \hfill pixel width of text}

\noindent
\textsf{TextWidth(w,s)} computes the pixel width of string \textsf{s} in
the font currently defined for window \textsf{w}.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Texture(w, s) : record \hfill apply texture}

\noindent
\textsf{Texture(w, s) }specifies a texture image that is applied to
subsequent objects drawn on 3D window \textsf{w}. The string \textsf{s}
specifies the texture image as a filename, a string of the form
\textsf{width,pallet,data} or \textsf{width,\#,data}, where pallet is a
pallet from the Unicon 2D graphics facilities and data is the
hexadecimal representation of an image. \textsf{Texture(w1, w2)
}specifies that the contents of 2D or 3D window \textsf{w2} be used as
a texture image that is applied to subsequent objects on the window
\textsf{w1}. The display list element is returned.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf Translate(w, x, y, z, ...) : record \hfill translate object positions}

\noindent
\textsf{Translate(w, x, y, z,{\dots})} moves objects drawn subsequently
on 3D window w in the direction (\textsf{x,y,z}). The display list
element is returned.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf Uncouple(w) : window \hfill release binding}

\noindent
\textsf{Uncouple(w)} releases the binding associated with file
\textsf{w}. \textsf{Uncouple()} closes the window only if all other
bindings associated with that window are also closed.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf WAttrib(w, s1, ...) : x, ... \hfill generate or set attributes}

\noindent
\textsf{WAttrib(w, s1, ...)} retrieves and/or sets window and context
attributes. If called with exactly one attribute, integers are produced
for integer-value attributes; all other values are represented by
strings. If called with more than one attribute argument,
\textsf{WAttrib()} produces one string result per argument, prefixing
each value by the attribute name and an equals sign (=). \ If
\textsf{xi} is a window, subsequent attributes apply to \textsf{xi}.
\ \textsf{WAttrib()} fails if an attempt is made to set the attribute
\textsf{font}, \textsf{fg}, \textsf{bg}, or \textsf{pattern} to a value
that is not supported. A run-time error occurs for an invalid attribute
name or invalid value.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf WDefault(w, program, option) : string \hfill query user preference}

\noindent
\textsf{WDefault(w,program,option)} returns the value of option for
program as registered with the X resource manager. In typical use this
supplies the program with a default value for window attribute option
from a program.option entry in an .XDefaults file.
\ \textsf{WDefault()} fails if no user preference for the specified
option is available.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf WFlush(w) : window \hfill flush window output}

\noindent
\textsf{WFlush(w)} flushes window output on window systems that buffer
text and graphics output. \ Window output is automatically flushed
whenever the program blocks on window input. \ When this behavior is
not adequate, a call to \textsf{WFlush()} sends all window output
immediately, but does not wait for all commands to be received and
acted upon. \textsf{WFlush()} is a no-op on window systems that do not
buffer output.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf WindowContents(w) : list \hfill window display list}

\noindent
\textsf{WindowContents(w)} returns a list of display elements, which are
records or lists. Each element has a function name followed by the
parameters of the function, or an attribute followed by its value.

\bigskip\hrule\vspace{0.1cm}
\noindent
{\bf WriteImage(w, s, x:0, y:0, width:0, height:0) : window
\hfill save image file}

\noindent
\textsf{WriteImage(w,s,x,y,width,height)} saves an image of dimensions
width, height from window w at offset \textsf{x,y} to a file named
\textsf{s}. \ \ The default is to write the entire window. \ The file
is written according to the filename extension, in either GIF, JPG,
BMP, PNG, or a platform specific format such as XBM or XPM.
\ \textsf{WriteImage()} fails if \textsf{s} cannot be opened for
writing.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf WSection(w, s) : record \hfill define window section}

\noindent
\textsf{WSection(w,s)} starts a new window section named \textsf{s} on
3D window \textsf{w} and returns a display list section marker record.
During window refreshes if the section marker{\textquotesingle}s
\textsf{skip} field is 1, the section is skipped. The section name
\textsf{s} is produced by \textsf{\&pick} if a primitive in the block
is clicked on while attribute
\textsf{{\textquotedblleft}pick=on{\textquotedblright}}.
\textsf{WSection(w)} marks the end of a preceding section.
\textsf{WSection()} blocks may be nested.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf WSync(w, s) : w \hfill synchronize with window system server}

\noindent
\textsf{WSync(w,s)} synchronizes the program with the server attached to
window \textsf{w} on those window systems that employ a client-server
model. \ Output to the window is flushed, and \textsf{WSync()} waits
for a reply from the server indicating all output has been processed.
\ If \textsf{s} is \textsf{{\textquotedbl}yes{\textquotedbl}}, all
events pending on \textsf{w} are discarded. \textsf{WSync()} is a no-op
on window systems that do not use a client-server model.

\subsection{Preprocessor}

Unicon features a simple \index{preprocessor}preprocessor \ that
supports file inclusion and symbolic constants. It is a subset of the
capabilities found in the C preprocessor, and is used primarily to
support platform-specific code sections and large collections of
symbols.

\subsubsection{Preprocessor Commands}

Preprocessor directives are lines beginning with a dollar sign. The
available preprocessor commands are:

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \$define symbol text \hfill symbolic substitution}

\noindent
\index{define symbols}All subsequent occurrences of \textit{symbol} are
replaced by the \textit{text} within the current file. Note that
\$define does not support arguments, unlike C.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \$include filename \hfill insert source file}

\noindent
\index{include}The named file is inserted into the compilation in place
of the \$include line.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \$ifdef symbol \hfill conditional compilation}

\noindent\index{ifdef symbol}{\textbf{\$ifndef}
\textit{symbol} \hfill conditional compilation}
\linebreak
{\textbf{\$else} \hfill conditional alternative}
\linebreak
{\textbf{\$endif} \hfill end of conditional code}

The subsequent lines of code, up to an \$else or \$endif, are discarded
unless \textit{symbol} is defined by some \$define directive. \$ifndef
reverses this logic.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \$error text \hfill compile error}

\noindent
\index{compile}The \index{compiler}compiler will emit an error with the
supplied text as a message.


\bigskip\hrule\vspace{0.1cm}
\noindent {\textbf{\$line} \textit{number}
[\textit{filename}] \hfill source code line}
\index{source code \$line}
{\textbf{\#line} \textit{number}
[\textit{filename}] \hfill source code line}

\noindent
The subsequent lines of code are treated by the compiler as commencing
from line \textit{number} in the file \textit{filename} or the current
file if no filename is given.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf \$undef symbol \hfill remove symbol definition}

\noindent
\index{undef}Subsequent occurrences of \textit{symbol} are no longer
replaced by any substitute text.

\bigskip\hrule\vspace{0.1cm}
\noindent {\bf EBCDIC transliterations \hfill alternative bracket characters}

\noindent
These character combinations were introduced for legacy keyboards that
were missing certain bracket characters.

\iconcode{
{\textbf \$ for \ \{ } \\
{\textbf \$) for \} } \\
{\textbf \${\textless}\ for $[$ } \\
{\textbf \${\textgreater} for $]$ }
}

These character combinations are substitutes for curly and square
brackets on keyboards that do not have these characters.

\subsubsection{Predefined Symbols}

\index{predefined symbols}Predefined symbols are provided for each
platform and each feature that is optionally compiled in on some
platforms. These symbols include:

{\bfseries
Preprocessor Symbol\ \ \ \ Feature}

\_V9\ \ \ \ \ \ \ \ \ \ Version 9\\
\_AMIGA\ \ \ \ \ \ \ \ Amiga\\
\_ACORN\ \ \ \ \ \ \ \ Acorn Archimedes\\
\_CMS\ \ \ \ \ \ \ \ \ \ CMS\\
\_MACINTOSH\ \ \ \ \ \ Macintosh\\
\_MSDOS\_386\ \ \ \ \ \ MS-DOS/386\\
\_MS\_WINDOWS\_NT\ \ \ \ MS Windows NT\\
\_MSDOS\ \ \ \ \ \ \ \ MS-DOS\\
\_MVS\ \ \ \ \ \ \ \ \ \ MVS\\
\_OS2\ \ \ \ \ \ \ \ \ \ OS/2\\
\_PORT\ \ \ \ \ \ \ \ PORT\\
\_UNIX\ \ \ \ \ \ \ \ \ \ UNIX\\
\_POSIX\ \ \ \ \ \ \ \ POSIX\\
\_DBM\ \ \ \ \ \ \ \ \ \ \index{DBM}DBM\\
\_VMS\ \ \ \ \ \ \ \ \ \ VMS\\
\_ASCII\ \ \ \ \ \ \ \ \index{ASCII}ASCII\\
\_EBCDIC\ \ \ \ \ \ \ \ \index{EBCDIC}EBCDIC\\
\_CO\_EXPRESSIONS\ \ \ \ co-expressions\\
\_CONSOLE\_WINDOW\ \ \ \ console window\\
\_DYNAMIC\_LOADING\ \ \ \ dynamic loading\\
\_EVENT\_MONITOR\ \ \ \ event monitoring\\
\_EXTERNAL\_FUNCTIONS\ \ external functions\\
\_KEYBOARD\_FUNCTIONS\ \ \index{keyboard}keyboard functions\\
\_LARGE\_INTEGERS\ \ \ \ large integers\\
\_MULTITASKING\ \ \ \ \ \ multiple programs\\
\_PIPES\ \ \ \ \ \ \ \ pipes\\
\_RECORD\_IO\ \ \ \ \ \ record I/O\\
\_SYSTEM\_FUNCTION\ \ \ \ system function\\
\_MESSAGING\ \ \ \ \ \ messaging\\
\_GRAPHICS\ \ \ \ \ \ \ \ graphics\\
\_X\_WINDOW\_SYSTEM\ \ \ \ X Windows\\
\_MS\_WINDOWS\ \ \ \ \ \ MS Windows\\
\_WIN32\ \ \ \ \ \ \ \ Win32\\
\_PRESENTATION\_MGR\ \ \ \ Presentation Manager\\
\_ARM\_FUNCTIONS\ \ \ \ Archimedes extensions\\
\_DOS\_FUNCTIONS\ \ \ \ \ \ MS-DOS extensions

\subsection{Execution Errors}

There are two kinds of errors that can occur during the execution of an
Icon program: runtime errors and system errors. Runtime errors occur
when a semantic or logic error in a program results in a computation
that cannot perform as instructed. System errors occur when an
operating system call \index{fail!system call}fails to perform a
required service.

\subsubsection{Runtime Errors}

By default, a \index{runtime error}runtime error causes program
execution to abort. Runtime errors are reported by name as well as by
number. They are accompanied by an error traceback that shows the
procedure call stack and value that caused the error, if there is one.
The errors are listed below to illustrate the kinds of situations that
can cause execution to terminate.

The keyword \&error allows a program to convert runtime errors into
expression failure. When an expression fails due to a converted runtime
error, the keywords \&errornumber, \&errortext, and \&errorvalue
provide information about the nature of the error.

101 \ \ \ \ \ \ \ integer expected or out of range\\
102 \ \ \ \ \ \ \ numeric expected\\
103 \ \ \ \ \ \ \ string expected\\
104 \ \ \ \ \ \ \ cset expected\\
105 \ \ \ \ \ \ \ file expected\\
106 \ \ \ \ \ \ \ procedure or integer expected\\
107 \ \ \ \ \ \ \ record expected\\
108 \ \ \ \ \ \ \ list expected\\
109 \ \ \ \ \ \ \ string or file expected\\
110 \ \ \ \ \ \ \ string or list expected\\
111 \ \ \ \ \ \ \ variable expected\\
112 \ \ \ \ \ \ \ invalid type to size operation\\
113 \ \ \ \ \ \ \ invalid type to random operation\\
114 \ \ \ \ \ \ \ invalid type to subscript operation\\
115 \ \ \ \ \ \ \ structure expected\\
116 \ \ \ \ \ \ \ invalid type to element generator\\
117 \ \ \ \ \ \ \ missing main procedure\\
118 \ \ \ \ \ \ \ co-expression expected\\
119 \ \ \ \ \ \ \ set expected\\
120 \ \ \ \ \ \ \ two csets or two sets expected\\
121 \ \ \ \ \ \ \ function not supported\\
122 \ \ \ \ \ \ \ set or table expected\\
123 \ \ \ \ \ \ \ invalid type\\
124 \ \ \ \ \ \ \ table expected\\
125 \ \ \ \ \ \ \ list, record, or set expected\\
126 \ \ \ \ \ \ \ list or record expected\\
140 \ \ \ \ \ \ \ window expected\\
141 \ \ \ \ \ \ \ program terminated by window manager\\
142 \ \ \ \ \ \ \ attempt to read/write on closed window\\
143 \ \ \ \ \ \ \ malformed event queue\\
144 \ \ \ \ \ \ \ window system error\\
145 \ \ \ \ \ \ \ bad window attribute\\
146 \ \ \ \ \ \ \ incorrect number of arguments to drawing
function\\
147 \ \ \ \ \ \ \ window attribute cannot be read or written as
requested\\
160 \ \ \ \ \ \ \ cannot open file\\
161 \ \ \ \ \ \ \ bad file attribute\\
162 \ \ \ \ \ \ \ cannot open socket\\
170 \ \ \ \ \ \ \ string or integer expected\\
171 \ \ \ \ \ \ \ posix header file not included\\
172 \ \ \ \ \ \ \ posix record overridden by global value\\
173 \ \ \ \ \ \ \ directory opened for writing\\
174 \ \ \ \ \ \ \ directory or database invalid as file\\
175 \ \ \ \ \ \ \ invalid mode string\\
176 \ \ \ \ \ \ \ invalid signal\\
177 \ \ \ \ \ \ \ invalid operation to flock/fcntl\\
178 \ \ \ \ \ \ \ invalid procedure type\\
179 \ \ \ \ \ \ \ fdup of closed file\\
180 \ \ \ \ \ \ \ low-level read or select mixed with buffered
read\\
181 \ \ \ \ \ \ \ not a network connection\\
182 \ \ \ \ \ \ \ not a UDP socket\\
183 \ \ \ \ \ \ \ invalid protocol name\\
184 \ \ \ \ \ \ \ invalid permission string for umask\\
190 \ \ \ \ \ \ \ database expected\\
201 \ \ \ \ \ \ \ division by zero\\
202 \ \ \ \ \ \ \ remaindering by zero\\
203 \ \ \ \ \ \ \ integer overflow\\
204 \ \ \ \ \ \ \ real overflow, underflow, or division by zero\\
205 \ \ \ \ \ \ \ invalid value\\
206 \ \ \ \ \ \ \ negative first argument to real exponentiation\\
207 \ \ \ \ \ \ \ invalid field name\\
208 \ \ \ \ \ \ \ second and third arguments to map of unequal
length\\
209 \ \ \ \ \ \ \ invalid second argument to open\\
210 \ \ \ \ \ \ \ non-ascending arguments to detab/entab\\
211 \ \ \ \ \ \ \ by value equal to zero\\
212 \ \ \ \ \ \ \ attempt to read file not open for reading\\
213 \ \ \ \ \ \ \ attempt to write file not open for writing\\
214 \ \ \ \ \ \ \ input/output error\\
215 \ \ \ \ \ \ \ attempt to refresh \&main\\
216 \ \ \ \ \ \ \ external function not found\\
301 \ \ \ \ \ \ \ evaluation stack overflow\\
302 \ \ \ \ \ \ \ memory violation\\
303 \ \ \ \ \ \ \ inadequate space for evaluation stack\\
304 \ \ \ \ \ \ \ inadequate space in qualifier list\\
305 \ \ \ \ \ \ \ inadequate space for static allocation\\
306 \ \ \ \ \ \ \ inadequate space in string region\\
307 \ \ \ \ \ \ \ inadequate space in block region\\
308 \ \ \ \ \ \ \ system stack overflow in co-expression\\
401 \ \ \ \ \ \ \ co-expressions not implemented\\
402 \ \ \ \ \ \ \ program not compiled with debugging option\\
500 \ \ \ \ \ \ \ program malfunction\\
600 \ \ \ \ \ \ \ vidget usage error

\subsubsection{System Errors}

If an error occurs during the execution of a \index{error!system}system
function, by default the function fails and keywords \&errornumber,
\&errortext and \&errorvalue will be set. This contrasts with runtime
errors, which terminate execution by default. Whereas runtime errors
can be converted to failure by setting \&error, system errors can be
converted to a runtime error by setting keyword \&syserr to a non-null
value.

The complete set of \index{system error}system errors is by definition
platform specific. Error numbers above the value 1000 are used for
system errors. Many of the POSIX standard system errors are supported
across platforms, and error numbers between 1001 and 1040 are reserved
for the system errors listed below. Platforms may report other system
error codes so long as they do not conflict with existing runtime or
system error codes.

1001 \ \ \ \ \ Operation not permitted\\
1002 \ \ \ \ \ No such file or directory\\
1003 \ \ \ \ \ No such process\\
1004 \ \ \ \ \ Interrupted system call\\
1005 \ \ \ \ \ I/O error\\
1006 \ \ \ \ \ No such device or address\\
1007 \ \ \ \ \ Arg list too long\\
1008 \ \ \ \ \ Exec format error\\
1009 \ \ \ \ \ Bad file number\\
1010 \ \ \ \ \ No child processes\\
1011 \ \ \ \ \ Try again\\
1012 \ \ \ \ \ Out of memory\\
1013 \ \ \ \ \ Permission denied\\
1014 \ \ \ \ \ Bad address\\
1016 \ \ \ \ \ Device or resource busy\\
1017 \ \ \ \ \ File exists\\
1018 \ \ \ \ \ Cross-device \index{link!file system}link\\
1019 \ \ \ \ \ No such device\\
1020 \ \ \ \ \ Not a directory\\
1021 \ \ \ \ \ Is a directory\\
1022 \ \ \ \ \ Invalid argument\\
1023 \ \ \ \ \ File table overflow\\
1024 \ \ \ \ \ Too many open files\\
1025 \ \ \ \ \ Not a typewriter\\
1027 \ \ \ \ \ File too large\\
1028 \ \ \ \ \ No space left on device\\
1029 \ \ \ \ \ Illegal seek\\
1030 \ \ \ \ \ Read-only file system\\
1031 \ \ \ \ \ Too many links\\
1032 \ \ \ \ \ Broken pipe\\
1033 \ \ \ \ \ Math argument out of domain of func\\
1034 \ \ \ \ \ Math result not representable\\
1035 \ \ \ \ \ Resource deadlock would occur\\
1036 \ \ \ \ \ File name too long\\
1037 \ \ \ \ \ No record locks available\\
1038 \ \ \ \ \ Function not implemented\\
1039 \ \ \ \ \ Directory not empty


#ifdef PatternType

/* #define PRINTF_DEBUG 1 or some other level if you want debugging */
#ifdef PRINTF_DEBUG
#define DEBUGF(lev, x) if (lev <= PRINTF_DEBUG) fprintf x
#else  /* DEBUG not defined */
#define DEBUGF(lev, x)
#endif /* DEBUG not defined */

dptr processFuncCallList(struct b_list *list, int csr);
dptr processMethodCallList(struct b_list *list, int csr);
int internal_match(char * pat_sub, int Length, int Pat_S,
		struct b_pelem * pattern, int *Start, int *Stop,
		int initial_cursor, int Anchored_Mode);
void cnv_str_pattern(dptr s, dptr p);
void cnv_cset_pattern(dptr s, dptr p);

struct b_pelem EOP = {0, PC_EOP,(union block *)NULL, 0, {D_Null,0}};

union block *pattern_make(int stck_size, struct b_pelem * pnext,
      	    		  int pattern_code, int index, struct descrip param
#ifdef PatternImage
			  , struct descrip image)
#else                                  /* PatternImage */
      	    		  )
#endif                                  /* PatternImage */
{
   tended struct b_pelem *lpnext = pnext;
   tended struct descrip lparam = param;
   tended struct b_pelem *pelem = alcpelem(pattern_code);
#ifdef PatternImage
   tended struct descrip limage = image;
#endif                                  /* PatternImage */
   tended union block * bp = (union block *)alcpattern(stck_size);
   pelem->pthen = (union block *) lpnext;
   pelem->parameter = lparam;
   pelem->index = index;
#ifdef PatternImage
   pelem->patimage = limage;
#endif                                  /* PatternImage */
   BlkPH(bp,Pattern,pe) = (union block *)pelem;
   return bp;
}

union block *pattern_make_pelem(int stck_size, struct b_pelem * pe)
{
   tended struct b_pelem *lpe = pe;
   union block * bp = (union block *)alcpattern(stck_size);
   BlkPH(bp,Pattern,pe) = (union block *)lpe;
   return bp;
}

union block *pelem_make(struct b_pelem * pnext, int pattern_code, int index,
#ifdef PatternImage
			struct descrip param, struct descrip image)
#else                                  /* PatternImage */
			struct descrip param)
#endif                                  /* PatternImage */
{
   struct b_pelem *pelem;
   union block * bp;
   tended struct b_pelem *lpnext = pnext;
   tended struct descrip lparam = param;
#ifdef PatternImage
   tended struct descrip limage = image;
#endif                                  /* PatternImage */
   bp = (union block *)alcpelem(pattern_code);
   pelem  = (struct b_pelem *)bp;
   pelem->pthen =(union block *) lpnext;
   pelem->parameter = lparam;
   pelem->index = index;
#ifdef PatternImage
   pelem->patimage = limage;
#endif                                  /* PatternImage */
   return bp;
}

union block *pelem_copy(struct b_pelem * p2copy)
{
   struct b_pelem *pelem;
   union block * bp;
   tended struct b_pelem *lp2copy = p2copy;
   bp = (union block *)alcpelem(lp2copy->pcode);
   pelem  = (struct b_pelem *)bp;
   pelem->pthen = lp2copy->pthen;
   pelem->parameter = lp2copy->parameter;
   pelem->index = lp2copy->index;
#ifdef PatternImage
   pelem->patimage = lp2copy->patimage; 
#endif					/* PatternImage */
   return bp;
}

#begdef Has_Alt(pcode)
(
(pcode == PC_Alt) ||
(pcode == PC_Arb_X) ||
(pcode == PC_Arbno_S)||
(pcode == PC_Arbno_X)
)
#enddef

/*
 * Recursive function that walks through a pelem linked list and fills in
 * an array of pelems, indexed by pelem indices.
 */
void Record_PE (struct b_pelem * E, struct b_pelem *RA[])
{
   DEBUGF(20, (stdout,"  Record_PE called\n"));
   if (E ==  &EOP || RA[E->index] != NULL){
      DEBUGF(20, (stdout," nothing to do\n"));
      return;
      }
   else {
      DEBUGF(20, (stdout," recording %ld\n",E->index));
      RA[E->index] = E;
      Record_PE ((struct b_pelem *)E->pthen, RA);
      if (Has_Alt(E->pcode))
	 Record_PE ((struct b_pelem *)BlkLoc(E->parameter),RA);
      }
}

void Build_Ref_Array(struct b_pelem * E, struct b_pelem *RA[] )
{
   DEBUGF(20,(stdout, "\nEntering Build_Ref_Array\n"));
   Record_PE(E, RA);
}

/*
 * What "Resolve" means is probably: turn string names into pointers to
 * actual variables in some execution context.  Copy/transform a list
 * into a list with actual pointers in it.
 */
struct b_list *ResolveList(struct b_list *lp)
{
   struct descrip proc;
   tended struct b_lelem *elsrc;
   tended struct b_lelem *eldest;
   int i, b, nargs;
   tended struct b_list *lpsrc;
   tended struct b_list *lpdest;
   struct b_list *lptemp;
   int complement;
   struct b_cset *cp, *cpx;

   lpsrc = lp;
   lpdest = alclist(lpsrc->size,lpsrc->size);
   DEBUGF(20,(stdout, "Resolving function name and parameters from list\n"));
   nargs = lpsrc->size -1;
   elsrc = (struct b_lelem *)lpsrc->listhead;

   proc.dword = D_Proc;
   /* The first element of the list must be string. */
   if (!is:string(elsrc->lslots[0])) {
      t_errornumber = 103;
      t_errorvalue = elsrc->lslots[0];
      return NULL;
      }
   /* convert string into procedure and store in proc */
   BlkLoc(proc)= (union block *)strprc(&elsrc->lslots[0],nargs);
   if (BlkLoc(proc) == NULL) {
      fprintf(stderr, "Unable to find proc in ResolveList\n");
      t_errornumber = 106;
      t_errorvalue = elsrc->lslots[0];
      return NULL;
      }
   eldest = (struct b_lelem *)lpdest->listhead;
   eldest->lslots[0] = proc;
   /*
    * For now, there is a limitation of only handling single-element-block
    * lists. Deemed OK for something only called internally for our own
    * constructed lists for unevaluated expressions.
    */
   if (BlkType(elsrc->listnext) == T_Lelem) {
      fprintf(stderr, "uneval cannot handle multi-element-block list\n");
      t_errornumber = 164;
      t_errorvalue.dword = D_List;
      t_errorvalue.vword.bptr = (union block *)lpsrc;
      return NULL;
      }

   for (i = 1; i < elsrc->nused; i++) {
      tended char * varname;
      struct descrip parm;
      dptr pvar;
      if (is:string(elsrc->lslots[i])) {
         /*
	  * if a string constant, drop double quotes,
	  * else lookup using getvar()
	  */
	 cnv:C_string(elsrc->lslots[i], varname);
	 if (StrLen(elsrc->lslots[i])>0) {
	    complement = 0;
	    if (strcspn(varname, "~") == 0) {
	       /* resolve complement */
	       StrLoc(elsrc->lslots[i]) = StrLoc(elsrc->lslots[i]) + 1;
	       StrLen(elsrc->lslots[i]) = StrLen(elsrc->lslots[i]) - 1;
	       cnv:C_string(elsrc->lslots[i], varname);
	       complement = 1;
	       }

	    if (strcspn(varname, "\"") == 0) {
	       /* drop the quotes, pass string contents */
	       StrLoc(elsrc->lslots[i]) = StrLoc(elsrc->lslots[i]) + 1;
	       StrLen(elsrc->lslots[i]) = StrLen(elsrc->lslots[i]) - 2;
	       cnv:string(elsrc->lslots[i], elsrc->lslots[i]);
	       }
	    else if (strcspn(varname, "\'") == 0) { 
	       /* drop the quotes, but pass string as a cset */
	       StrLoc(elsrc->lslots[i]) = StrLoc(elsrc->lslots[i]) + 1;
	       StrLen(elsrc->lslots[i]) = StrLen(elsrc->lslots[i]) - 2;
	       cnv:cset(elsrc->lslots[i], elsrc->lslots[i]);
	       }
	    else if (strcspn(varname, "&") == 0) {
	       if (getkeyword(varname, &parm) == Failed) {
		  t_errornumber = 160;
		  AsgnCStr(t_errorvalue, varname);
		  return NULL;
		  }
	       cnv:cset(parm, elsrc->lslots[i]);
	       if(complement) {
		  Protect(cp = alccset(), fatalerr(307, NULL));
		  cpx = (struct b_cset *)BlkD(elsrc->lslots[i], Cset);
		  for (b = 0; b < CsetSize; b++) 
		     cp->bits[b] = ~cpx->bits[b];
		  elsrc->lslots[i].vword.bptr = (union block *)cp;
		  }
	       }
	    else if (strcspn(varname, "1234567890") == 0) {
	       cnv:integer(elsrc->lslots[i], elsrc->lslots[i]);
	       }
	    else {
	       if (getvar(varname, &parm) == Failed) {
		  t_errornumber = 160;
		  AsgnCStr(t_errorvalue, varname);
		  return NULL;
		  }
	       pvar = VarLoc(parm);
	       elsrc->lslots[i] = parm; /* = *pvar too aggressive */

	       if (complement) {
		  Protect(cp = alccset(), fatalerr(307, NULL));
		  cpx = (struct b_cset *)StrLoc(elsrc->lslots[i]);
		  for (b = 0; b < CsetSize; b++) 
		     cp->bits[b] = ~cpx->bits[b];
		  elsrc->lslots[i].vword.bptr = (union block *)cp;
		  }
	       }
	    parm = elsrc->lslots[i];
	    }
	 else {
	    /* uneval string of length zero, probably should be runerr */
	    return NULL;
	    }
	 }
      else if (is:list(elsrc->lslots[i])) {
	 /* recursively visit sublists, do same stuff */
	 lptemp = (struct b_list *)BlkD(elsrc->lslots[i], List);
	 parm.dword = D_List;
	 if ((parm.vword.bptr = (union block *)ResolveList(lptemp)) == NULL)
	    return NULL;
	 }
      else { 
	 /* cset, integer constant, ... */
	 parm = elsrc->lslots[i];
	 }
      eldest->lslots[i] = parm;
      }
   return lpdest;
   }

/*
 *  ----------
 *  -- Resolve References --
 *  ----------
 *  Maps identifier names to variable references
 */
static struct b_pelem * ResolveReferences(struct b_pelem * P )
{
   if (P == NULL) {
      t_errornumber = 162;
      t_errorvalue = nulldesc;
      return NULL;
      }
   else {
      /*            --  References to elements in P, indexed by Index field */
      struct b_pelem ** Refs;
      /*            --  Copies of elements of P, indexed by Index field. */
      struct b_pelem **Copy;
      tended struct b_pelem * E;
      int J;
      int RefLen = P->index + 1;
      reserve(Blocks, RefLen * sizeof(struct b_pelem));

      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Copy = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));

      Build_Ref_Array (P, Refs);

      /*
       * Now copy all nodes
       */
      for(J = 1; J < RefLen; J++)
	 Copy[J] = (struct b_pelem *)pelem_copy(Refs[J]);

      /*
       * Adjust all internal references
       */
      for(J = 1; J < RefLen; J++) {
	 E = Copy[J];
	 /*
	  * Adjust successor pointer to point to copy
	  */
	 if (E->pthen !=(union block *) &EOP)
	    E->pthen =(union block *)
	       Copy[((struct b_pelem *)(E->pthen))->index];
	 /*
	  * Adjust Alt pointer if there is one to point to copy
	  */
	 if (Has_Alt(E->pcode) &&
	     ((struct b_pelem *)(BlkLoc(E->parameter)) != &EOP))
	    (BlkLoc(E->parameter)) = (union block *)
	       Copy[((struct b_pelem *)(BlkLoc(E->parameter)))->index];
	 /*
	  * Resolve references
	  */
	 switch(E->pcode){
	 case PC_Pos_NP:
	 case PC_Len_NP:
	 case PC_RPos_NP: 
	 case PC_RTab_NP:
	 case PC_Tab_NP: 
	 case PC_Any_VP:
	 case PC_Break_VP:
	 case PC_BreakX_VP:
	 case PC_NotAny_VP:
	 case PC_NSpan_VP:
	 case PC_Span_VP:
	 case PC_Assign_OnM:
	 case PC_Assign_Imm: 
	 case PC_Rpat:{
	    tended char * varname;				
	    if (is:list(E->parameter)) {
	       /*
		* we know our list
		* it has only 2 elements object variable name and field name
		* so we dont perform all the sanity checks
		*/
	       tended struct b_lelem *ep;
	       tended struct b_record *rp;
	       tended struct b_list *lp = (struct b_list *)BlkLoc(E->parameter);
	       ep = (struct b_lelem *)lp->listhead;
	       if (is:string(ep->lslots[0])) {
	          cnv:C_string(ep->lslots[0],varname);
		  if (getvar(varname,&ep->lslots[0])== Failed) {
		     t_errornumber = 160;
		     AsgnCStr(t_errorvalue, varname);
		     return NULL;
		     }
		  }
	       }
	    else {
	       if (is:string(E->parameter)){
	          cnv:C_string(E->parameter, varname);
		  DEBUGF(2, (stdout, "Looking up variable name = %s\n",
				   varname));
		  if (getvar(varname,&E->parameter)== Failed) {
		     t_errornumber = 160;
		     AsgnCStr(t_errorvalue, varname);
		     return NULL;
		     }
		  }
	       }
	    break;
	    }
	 case PC_Pos_NF:
	 case PC_Len_NF:
	 case PC_RPos_NF:
	 case PC_RTab_NF:
	 case PC_Tab_NF:
	 case PC_Any_VF:
	 case PC_Break_VF:
	 case PC_BreakX_VF:
	 case PC_NotAny_VF:
	 case PC_NSpan_VF:
	 case PC_Span_VF:
	 case PC_Pred_Func:
	 case PC_String_VF:{
	    tended struct b_list *lpsrc;
	    tended struct b_list *lpdest;
	    lpsrc = (struct b_list *)BlkD(E->parameter, List);    
	    if ((lpdest = ResolveList(lpsrc)) == NULL)
	       return NULL;
	    E->parameter.dword = D_List;
	    E->parameter.vword.bptr = (union block *) lpdest;
	    }
	 }
      }
   E =  Copy[P->index];
   free(Refs);
   free(Copy);
   return E;
   }
}

/*
 * Copy a pattern element.
 */
struct b_pelem * Copy (struct b_pelem * P )
{
   if (P == NULL) {
      fatalerr(162, NULL);
      }
   else {
      /* References to elements in P, indexed by Index field */
      struct b_pelem ** Refs;
      /* Holds copies of elements of P, indexed by Index field. */
      struct b_pelem **Copy;
      struct b_pelem * E;
      int J;
      int RefLen = P->index + 1;

      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Copy = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));

      Build_Ref_Array (P, Refs);

      /* Now copy all nodes */
      for(J = 1; J < RefLen; J++)
	 Copy[J] = (struct b_pelem *)pelem_copy(Refs[J]);
      /* Adjust all internal references */
      for(J = 1; J < RefLen; J++){
	 E = Copy[J];
	 /*
	  * Adjust successor pointer to point to copy
	  */
	 if (E->pthen !=(union block *) &EOP)
	    E->pthen =(union block *)
	       Copy[((struct b_pelem *)(E->pthen))->index];

	 /*
	  * Adjust Alt pointer if there is one to point to copy
	  */
	 if (Has_Alt(E->pcode) &&
	     ((struct b_pelem *)(BlkLoc(E->parameter)) != &EOP))
	    (BlkLoc(E->parameter)) = (union block *)Copy[((struct b_pelem *)
					(BlkLoc(E->parameter)))->index];
	 }
      E =  Copy[P->index];
      free(Refs);
      free(Copy);
      return E;
      }
}


struct b_pelem * Concat (struct b_pelem * L, struct b_pelem *R, int Incr )
{
   tended struct b_pelem *lpe = L;
   tended struct b_pelem *rpe = R;
   if (lpe == &EOP)
      return rpe;
   else if (rpe == &EOP)
      return lpe;
   else {
      struct b_pelem **Refs;
      /*
       * We build a reference array for L whose N'th element points to
       * the pattern element of L whose original Index value is N.
       */
      struct b_pelem * P;
      int J;
      int RefLen = lpe->index + 1;
      Refs=(struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
#ifdef PatternImage
      lpe->patimage = construct_image(lpe->patimage, get_patimage(PI_CONCAT),
				      rpe->patimage);
#endif					/* PatternImage */
      Build_Ref_Array (lpe, Refs);
      for (J = 1; J < RefLen;J++) {
	 P = Refs[J];
	 P->index += rpe->index;
	 if (P->pcode == PC_Arbno_Y){
	    IntVal(P->parameter) += Incr;
	    }
	 if ((struct b_pelem *)P->pthen == &EOP)
	    P->pthen = (union block *)rpe;
	 if (Has_Alt(P->pcode) &&
	     (BlkLoc(P->parameter) == (union block *)&EOP)) {
	    tended struct descrip param;
	    param.dword = D_Pelem;
	    param.vword.bptr = (union block *) rpe;
	    P->parameter = param;
	    }
	 }
      free(Refs);
      return lpe;
      }
}

#begdef OK_For_Simple_Arbno(pcode)
(
(pcode  == PC_Any_CS)     ||
(pcode  == PC_Any_CH)     ||
(pcode  == PC_Any_VF)     ||
(pcode  == PC_Any_VP)     ||
(pcode  == PC_Char)       ||
(pcode  == PC_Len_Nat)    ||
(pcode  == PC_NotAny_CS)  ||
(pcode  == PC_NotAny_CH)  ||
(pcode  == PC_NotAny_VF)  ||
(pcode  == PC_NotAny_VP)  ||
(pcode  == PC_Span_CS)    ||
(pcode  == PC_Span_CH)    ||
(pcode  == PC_Span_VF)    ||
(pcode  == PC_Span_VP)    ||
(pcode  == PC_String)
)
#enddef

struct b_pelem * ResolvePattern(struct b_pattern *pat)
{
   struct descrip key;
   tended struct descrip val;    
   int res;
   uword hn;
   struct b_telem *te;
   tended struct b_pelem *phead;
   union block **pd;

   key.dword = D_Integer;
   IntVal(key) = pat->id;
   hn = hash(&key);
   if (pfp->pattern_cache == NULL) {
      pfp->pattern_cache =  (struct b_table *)hmake(T_Table, (word)0,(word)0);
      }
   else { /* we have a table check if the pattern is already resolved */
      pd = memb( (union block *)pfp->pattern_cache,&key,hn,&res);
      if (res != 0) { /*the element is in the table*/
	 te = (struct b_telem *) *pd;
	 return (struct b_pelem *)BlkLoc(te->tval);
	 }
      }
   /* if it is not in table, first resolve references */
   if ((phead = ResolveReferences(&(pat->pe->Pelem))) == NULL) return NULL;
   val.dword = D_Pelem;
   BlkLoc(val) = (union block *)phead;
   /* get table element now because can't tend pb */
   if ((te = alctelem()) == NULL) {
      fatalerr(307, NULL);
      }
   /* find where to insert cannot just reuse pd as it cannot be tended*/
   pd = memb( (union block *)pfp->pattern_cache,&key,hn,&res);
   pfp->pattern_cache->size++;
   te->clink = *pd;
   *pd =  (union block *)te;
   te->hashnum = hn;
   te->tref = key;
   te->tval = val;
   if (TooCrowded(pfp->pattern_cache))
      hgrow( (union block *)pfp->pattern_cache);
   return phead;
}


function {*} pattern_match(underef psub -> dpsub, pat)
   declare {
      int use_trap = 0;
      }
   /*
    *  psub must either be a string or be convertible to one. Decide
    *  whether a substring trapped variable can be created.
    */
   if is:variable(psub) && is:string(dpsub) then {
      abstract {
	 return new tvsubs(type(psub))
	 }
      inline {
	 use_trap = 1;
	 }
      }
   else if cnv:tmp_string(dpsub) then
      abstract {
	 return string
	 }
   else
      runerr(114, dpsub);

   body {
      int oldpos, start, stop;
      struct b_pattern *pattern;
      tended struct b_pelem *phead;

      int subject_len;
#if !ConcurrentCOMPILER
      CURTSTATE();
#endif					/* ConcurrentCOMPILER */
    
      DEBUGF(20,(stdout, "(729)begin pattern_match()\n"));
      /*
       * Is k_pos really 0-based and not 1-based?
       * If we are assigning new values to &subject/&pos for a match,
       * do we need to save & restore old values when finished?
       */
      k_pos = 0;
      k_subject = dpsub;
      subject_len = StrLen(k_subject);

      type_case pat of {
	 string: {
	    cnv_str_pattern(&pat,&pat);
	    }
	 cset: {
	    cnv_cset_pattern(&pat,&pat);
	    }
	 pattern: {
	    }
	 default: {
	    runerr(127);
	    }
	 }

      pattern = (struct b_pattern *)BlkLoc(pat);
      if ((phead = ResolvePattern(pattern)) == NULL) runerr(0);

      while ((k_pos >= 0) &&
	     internal_match(StrLoc(k_subject), subject_len, pattern->stck_size,
			    phead, &start, &stop, k_pos, 0)
	     ){
	 oldpos = k_pos;
	 k_pos = stop;			/* should this be +1 ? */

	 /* check of psub no longer refers to what k_subject holds.
	  * if so, we can't suspend a trapped variable reference to it.
	  */
	 if ((use_trap == 1) &&
	     (StrLoc(*(psub.vword.descptr)) == StrLoc(k_subject)) &&
	     (StrLen(*(psub.vword.descptr)) == StrLen(k_subject)) ) {
	    suspend tvsubs(&psub, start+1,stop - start /* + 1 ? */);
	    }
	 else {
	    suspend string(stop - start /* + 1 ? */, StrLoc(dpsub)+ start);
	    }
	 deref(&psub,&dpsub);
	 k_subject = dpsub;
	 if (subject_len != StrLen(dpsub)) {
	    k_pos += StrLen(dpsub) - subject_len;
	    subject_len = StrLen(dpsub);
	    }
	 }
      fail;
      }
end

void cnv_str_pattern(dptr s, dptr p)
{
#ifdef PatternImage
   struct descrip image;
   union block *bp;
   image = construct_image(get_patimage(PI_QUOTE), *s, get_patimage(PI_QUOTE));
   bp = pattern_make(0, &EOP,PC_String,1, *s, image);
#else					/* PatternImage */
   union block *bp = pattern_make(0, &EOP,PC_String,1, *s);
#endif					/* PatternImage */
   p->dword = D_Pattern;
   BlkLoc(*p) = bp;
}

void cnv_cset_pattern(dptr s, dptr p)
{
#ifdef PatternImage
   struct descrip quote;
   struct descrip image = *s;
   union block *bp;
   tended struct descrip char_set = *s;
   cnv:string(image, image);    
   image = construct_image(get_patimage(PI_SQUOTE), image,
			   get_patimage(PI_SQUOTE));
   bp = pattern_make(0, &EOP,PC_Any_CS,1, char_set, image);
#else					/* PatternImage */
   union block *bp = pattern_make(0, &EOP,PC_Any_CS,1, *s);
#endif					/* PatternImage */
   p->dword = D_Pattern;
   BlkLoc(*p) = bp;
}

/*
 *
 * Set_Successor
 *
 * Note: this procedure is not used by the normal concatenation circuit,
 * since other fixups are required on the left operand in this case, and
 * they might as well be done all together.
 */
static void Set_Successor (struct b_pelem * Pat , struct b_pelem *Succ)
{
   if (Pat == NULL) {
      syserr("set_successor NULL pattern error");
      }
   else if (Pat == &EOP) {
      syserr("set_successor logic error");
      }
   else {
      struct b_pelem **Refs;
      /*
       * We build a reference array for L whose N'th element points to
       * the pattern element of L whose original Index value is N.
       */
      struct b_pelem * P ;
      int J;
      int RefLen = Pat->index + 1;
      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Build_Ref_Array (Pat, Refs);
      for (J = 1; J < RefLen;J++){
	 P = Refs[J];
	 if ((struct b_pelem *)P->pthen == &EOP)
	    P->pthen = (union block *)Succ;
	 if (Has_Alt(P->pcode) &&
	     ((struct b_pelem *)BlkLoc(P->parameter) == &EOP)){
	    struct descrip param;
	    param.dword = D_Pelem;
	    param.vword.bptr = (union block *) Succ;
	    P->parameter = param;
	    }
	 }
      free(Refs);
      }
}

/*
 * Bracket
 */
struct b_pelem *Bracket(struct b_pelem *E,struct b_pelem * P,
			    struct b_pelem * A)
{
   if (P == &EOP) {
      E->pthen =  (union block *)A;
      E->index = 2;
      A->index = 1;
      }
   else {
      E->pthen =  (union block *)P;
      Set_Successor (P, A);
      E->index = P->index + 2;
      A->index = P->index + 1;
      }
   return E;
}


#ifdef PatternImage
#begdef ConvertPatternArgumentCset(arg, bp, ptype, strtype)
   type_case arg of {
      pattern: {
         struct descrip image;
         tended struct descrip param = arg; 
	 struct b_pattern *pat = (struct b_pattern *)BlkLoc(arg);
	 tended struct b_pelem *pe = (struct b_pelem *)pat->pe;
	 switch(pe->pcode) {
	 case PC_Rpat: {
            image = construct_image(strtype, pe->patimage,
				    get_patimage(PI_BPAREN)); 
	    bp = pattern_make(0, &EOP,ptype ## _VP,1, pe->parameter, image);
	    break;
	    }
	 case PC_Pred_Func:
	 case PC_String_VF: {
            image = construct_image(strtype, pe->patimage,
				    get_patimage(PI_BPAREN));
	    bp = pattern_make(0, &EOP,ptype ## _VF,1, pe->parameter, image);
	    break;
	    }
	 case PC_Pred_MF:
	 case PC_String_MF: {
            image = construct_image(strtype, pe->patimage,
				    get_patimage(PI_BPAREN));
	    bp = pattern_make(0, &EOP,ptype ## _MF,1, pe->parameter, image); 
	    break;
	    }
	 default: {
	    runerr(127);
	    }
	    }
	 }
      default: {
         struct descrip image;
         tended struct descrip param = arg;  
	 if (!cnv_cset(&param, &param))
	    runerr(104, param);
	 image = construct_image(strtype, arg_image(param, PT_EVAL),
				 get_patimage(PI_BPAREN));
	 bp = pattern_make(0, &EOP, ptype ## _CS, 1, param, image);
	 }
   }
#enddef
#else					/* PatternImage */
#begdef ConvertPatternArgumentCset(arg, bp, ptype)
   type_case arg of {
      pattern: {
	 struct b_pattern *pat = (struct b_pattern *)BlkLoc(arg);
	 tended struct b_pelem *pe = (struct b_pelem *)pat->pe;
	 switch(pe->pcode) {
	 case PC_Rpat: {
	    bp = pattern_make(0, &EOP,ptype ## _VP,1, pe->parameter);
	    break;
	    }
	 case PC_Pred_Func:
	 case PC_String_VF: {
	    bp = pattern_make(0, &EOP,ptype ## _VF,1, pe->parameter);
	    break;
	    }
	 case PC_Pred_MF:
	 case PC_String_MF: {
	    bp = pattern_make(0, &EOP,ptype ## _MF,1, pe->parameter);
	    break;
	    }
	 default: {
	    runerr(127);
	    }
	    }
	 }
      default: {
	 if (!cnv_cset(&arg, &arg))
	    runerr(104, arg);
	 bp = pattern_make(0, &EOP, ptype ## _CS,1, arg);
	 }
   }
#enddef
#endif					/* PatternImage */

function {1} Any(charset)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Any("); 
      ConvertPatternArgumentCset(charset, bp, PC_Any, strtype);
#else					/* PatternImage */
      ConvertPatternArgumentCset(charset, bp, PC_Any);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} Break(charset)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Break(");  
      ConvertPatternArgumentCset(charset, bp, PC_Break, strtype);
#else					/* PatternImage */
      ConvertPatternArgumentCset(charset, bp, PC_Break);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} NotAny(char_set)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "NotAny("); 
      ConvertPatternArgumentCset(char_set, bp, PC_NotAny, strtype);
#else					/* PatternImage */
      ConvertPatternArgumentCset(char_set, bp, PC_NotAny);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} Span(char_set)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Span("); 
      ConvertPatternArgumentCset(char_set, bp, PC_Span, strtype);
#else					/* PatternImage */
      ConvertPatternArgumentCset(char_set, bp, PC_Span);
#endif					/* PatternImage */
      return pattern(bp);
      }
end


struct b_pattern * breakx_make(struct b_pelem * B)
{
#ifdef PatternImage
   tended struct b_pelem *X =  pelem_make(B,PC_BreakX_X, 2, nulldesc,
					  B->patimage);
#else					/* PatternImage */
   tended struct b_pelem *X =  pelem_make(B,PC_BreakX_X, 2, nulldesc);
#endif					/* PatternImage */
   tended struct descrip param;
   tended struct b_pelem *A;
   param.dword = D_Pelem;
   BlkLoc(param) =  (union block *)X;
#ifdef PatternImage
   A =  (struct b_pelem *)pelem_make(&EOP,PC_Alt, 1, param, nulldesc);
#else					/* PatternImage */
   A =  (struct b_pelem *)pelem_make(&EOP,PC_Alt, 1, param);
#endif					/* PatternImage */
   B->pthen =  (union block *)A;
   return (struct b_pattern *)pattern_make_pelem(2, B);
}

/*
 * BreakX
 */
function {1} Breakx(char_set)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      struct b_pelem *peBreakx;
#ifdef PatternImage
      struct descrip strtype;
      struct descrip image;
      AsgnCStr(strtype, "Breakx(");
#endif					/* PatternImage */
      type_case char_set of {
      pattern: {
	 struct b_pattern *pat = (struct b_pattern *)BlkLoc(char_set);
	 tended struct b_pelem *pe = (struct b_pelem *)pat->pe;
	 struct descrip image; 
	 switch(pe->pcode){
	 case PC_Rpat:{
#ifdef PatternImage
            image = construct_image(strtype, arg_image(char_set, PT_VP),
				    get_patimage(PI_BPAREN));
	    peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_VP, 3,
						    pe->parameter, image);
#else					/* PatternImage */
	    peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_VP, 3,
						    pe->parameter);
#endif					/* PatternImage */
	    break;
	    }
	 case PC_Pred_Func:
	 case PC_String_VF: {
#ifdef PatternImage
            image = construct_image(strtype, arg_image(char_set, PT_VF),
				    get_patimage(PI_BPAREN));
	    peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_VF, 3,
						    pe->parameter, image);
#else					/* PatternImage */
	    peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_VF, 3,
						    pe->parameter);
#endif					/* PatternImage */
	    break;
	    }
	 default: {
	    runerr(128);
	    }
	    }
	 }
      default: {
	 if (!cnv_cset(&char_set, &char_set))
	    runerr(104, char_set);
#ifdef PatternImage
	 AsgnCStr(strtype, "Breakx(");
	 image = construct_image(strtype, arg_image(char_set, PT_EVAL),
				 get_patimage(PI_BPAREN)); 
	 peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_CS, 3,
						 char_set, image);
#else					/* PatternImage */
	 peBreakx = (struct b_pelem *)pelem_make(NULL, PC_BreakX_CS, 3,char_set);
#endif					/* PatternImage */
	 }
	 }
      bp = (union block *)breakx_make(peBreakx);
      return pattern(bp);
      }
end

#ifdef PatternImage
#begdef ConvertPatternArgumentInt(arg, bp, ptype, strtype)
   type_case arg of{
      pattern: {
         struct descrip image;
	 struct b_pattern *pat = (struct b_pattern *)BlkLoc(arg);
	 tended struct b_pelem *pe = (struct b_pelem *)pat->pe;
	 switch(pe->pcode){
	 case PC_Rpat: {
            image = construct_image(strtype, pe->patimage,
				    get_patimage(PI_BPAREN)); 
	    bp =  (union block *)pattern_make(0, &EOP,ptype ## _NP,
					      1, pe->parameter, image);
	    break;
	    }
	 case PC_Pred_Func:
	 case PC_String_VF: {
            image = construct_image(strtype, pe->patimage,
				    get_patimage(PI_BPAREN));
	    bp =  (union block *)pattern_make(0, &EOP,ptype ## _NF,
					      1, pe->parameter, image);
	    break;
	    }
	 case PC_Pred_MF:
	 case PC_String_MF: {
            image = construct_image(strtype, pe->patimage,
				    get_patimage(PI_BPAREN));
	    bp =  (union block *)pattern_make(0, &EOP,ptype ## _NMF,
					      1, pe->parameter, image);
	    break;
	    }
	 default: {
	    runerr(128);
	    }
	    }
	 }
      default: {
         struct descrip image;
         tended struct descrip param = arg;
      	 if (!cnv_int(&param, &param))
	    runerr(102, param);
	 image = construct_image(strtype, arg_image(param, PT_EVAL),
				 get_patimage(PI_BPAREN));
	 bp =  (union block *)pattern_make(0, &EOP, ptype ## _Nat,1,param,image);
	 }
	 }
#enddef
#else					/* PatternImage */

#begdef ConvertPatternArgumentInt(arg, bp, ptype)
   type_case arg of{
      pattern: {
	 struct b_pattern *pat = (struct b_pattern *)BlkLoc(arg);
	 tended struct b_pelem *pe = (struct b_pelem *)pat->pe;
	 switch(pe->pcode){
	 case PC_Rpat: {
	    bp =  (union block *)pattern_make(0, &EOP,ptype ## _NP,
					      1, pe->parameter);
	    break;
	    }
	 case PC_Pred_Func:
	 case PC_String_VF: {
	    bp =  (union block *)pattern_make(0, &EOP,ptype ## _NF,
					      1, pe->parameter);
	    break;
	    }
	 case PC_Pred_MF:
	 case PC_String_MF: {
	    bp =  (union block *)pattern_make(0, &EOP,ptype ## _NMF,
					      1, pe->parameter);
	    break;
	    }
	 default: {
	    runerr(128);
	    }
	    }
	 }
      default: {
	 if (!cnv_int(&arg, &arg))
	    runerr(102, arg);
	 bp =  (union block *)pattern_make(0, &EOP, ptype ## _Nat,1, arg);
	 }
	 }
#enddef
#endif					/* PatternImage */

function {1} Len(count)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Len("); 
      ConvertPatternArgumentInt(count,bp,PC_Len,strtype);
#else					/* PatternImage */
      ConvertPatternArgumentInt(count,bp,PC_Len);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} Pos(position)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Pos("); 
#endif					/* PatternImage */
      /*
       * check if position is negative
       */
      if(position.vword.integr < 1) {
         /* change position to a positive value and use RPos */
         position.vword.integr = -position.vword.integr;
#ifdef PatternImage
         ConvertPatternArgumentInt(position,bp,PC_RPos, strtype);
#else					/* PatternImage */
         ConvertPatternArgumentInt(position,bp,PC_RPos);
#endif					/* PatternImage */
	 } 
      else {
#ifdef PatternImage
         ConvertPatternArgumentInt(position,bp,PC_Pos, strtype);
#else					/* PatternImage */
         ConvertPatternArgumentInt(position,bp,PC_Pos);
#endif					/* PatternImage */
         }
      return pattern(bp);
      }
end

function {1} Rpos(position)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Rpos("); 
      ConvertPatternArgumentInt(position,bp,PC_RPos,strtype);
#else					/* PatternImage */
      ConvertPatternArgumentInt(position,bp,PC_RPos);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} Tab(count)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Tab("); 
#endif					/* PatternImage */
      /*
       * check if count is negative
       */
      if(count.vword.integr < 1) {
         /* change count to a positive value and use RTab */
         count.vword.integr = -count.vword.integr;
#ifdef PatternImage
         ConvertPatternArgumentInt(count,bp,PC_RTab, strtype);
#else					/* PatternImage */
         ConvertPatternArgumentInt(count,bp,PC_RTab);
#endif					/* PatternImage */
	 }
      else {
#ifdef PatternImage
         ConvertPatternArgumentInt(count,bp,PC_Tab, strtype);
#else					/* PatternImage */
         ConvertPatternArgumentInt(count,bp,PC_Tab);
#endif					/* PatternImage */
         }
      return pattern(bp);
      }
end

function {1} Rtab(count)
   if !cnv:integer(count) then
      runerr(102,count)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip strtype;
      AsgnCStr(strtype, "Rtab("); 
      ConvertPatternArgumentInt(count,bp,PC_RTab, strtype);
#else					/* PatternImage */
      ConvertPatternArgumentInt(count,bp,PC_RTab);
#endif					/* PatternImage */
      return pattern(bp);
      }
end


/*
 * Arb
 *    +---+
 *    | X |---->
 *    +---+
 *      .
 *      .
 *    +---+
 *    | Y |---->
 *    +---+
 *
 *  The PC_Arb_X element is numbered 2, and the PC_Arb_Y element is 1.
*/

function {1} Arb()
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      tended struct descrip var;
      tended struct b_pelem * X;
#ifdef PatternImage
      tended struct b_pelem * Y = pelem_make(&EOP,PC_Arb_Y,1,nulldesc, nulldesc);
      tended struct descrip image;
      AsgnCStr(image, "Arb()");
#else					/* PatternImage */
      tended struct b_pelem * Y = pelem_make(&EOP,PC_Arb_Y,1,nulldesc);
#endif					/* PatternImage */
      var.dword = D_Pelem;
      BlkLoc(var) =  (union block *)Y;
#ifdef PatternImage
      X = (struct b_pelem *)pelem_make(&EOP,PC_Arb_X,2,var, image);
#else					/* PatternImage */
      X = (struct b_pelem *)pelem_make(&EOP,PC_Arb_X,2,var);
#endif					/* PatternImage */
      bp = pattern_make_pelem(1,X);
      return pattern(bp);
      }
end


/*
 * Arbno
 */

struct b_pelem * Arbno_Simple(struct b_pelem *pe)
{
   tended struct descrip var;
   tended struct b_pelem *S;
   var.dword = D_Pelem;
   BlkLoc(var) =  (union block *)pe;
#ifdef PatternImage
   S = (struct b_pelem *)pelem_make(&EOP,PC_Arbno_S, pe->index + 1,var,nulldesc);
#else					/* PatternImage */
   S = (struct b_pelem *)pelem_make(&EOP,PC_Arbno_S, pe->index + 1, var);
#endif					/* PatternImage */
   Set_Successor(pe,S);
   return S;
}

function {1} Arbno(ARBPAT)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      struct b_pattern * P;
      tended struct b_pelem * X;
#ifdef PatternImage
      struct descrip strtype; 
      tended struct descrip image;
      AsgnCStr(strtype, "Arbno("); 
#endif					/* PatternImage */
      type_case ARBPAT of {
	 string : {
#ifdef PatternImage
            image = construct_image(strtype, arg_image(ARBPAT, PT_EVAL),
				    get_patimage(PI_BPAREN));
#endif					/* PatternImage */
	    cnv_str_pattern(&ARBPAT,&ARBPAT);
	    P =  (struct b_pattern *)BlkLoc(ARBPAT);
	    X = Arbno_Simple((struct b_pelem *)P->pe);
#ifdef PatternImage
            X->patimage = image;
#endif					/* PatternImage */
	    bp = pattern_make_pelem(0,X);
	    return pattern(bp);
	    }
	 cset : {
#ifdef PatternImage
            image = construct_image(strtype, arg_image(ARBPAT, PT_EVAL),
				    get_patimage(PI_BPAREN));
#endif					/* PatternImage */
	    cnv_cset_pattern(&ARBPAT,&ARBPAT);
	    P = (struct b_pattern *)BlkLoc(ARBPAT);
	    X = Arbno_Simple((struct b_pelem *)P->pe);
#ifdef PatternImage
            X->patimage = image;
#endif					/* PatternImage */
	    bp = pattern_make_pelem(0,X);
	    return pattern(bp);
	    }
         pattern: {
	    tended struct b_pelem *Pat;
	    P =  (struct b_pattern *)BlkLoc(ARBPAT);
	    Pat = Copy((struct b_pelem *)P->pe);
	    if ( (P->stck_size == 0) &&OK_For_Simple_Arbno(Pat->pcode)) {
	       /*
		*
		* Arbno_Simple
		*
		*
		*      +-------------+
		*      |             ^
		*      V             |
		*    +---+           |
		*    | S |---->      |
		*    +---+           |
		*      .             |
		*      .             |
		*    +---+           |
		*    | P |---------->+
		*    +---+
		*
		*  The node numbering of the constituent pattern P is not
		*  affected. The S node has a node number of P.Index + 1.
		*
		*  Note that we know that P cannot be EOP, because a null
		*  pattern does not meet the requirements for simple Arbno.
		*/

	       X = Arbno_Simple(Pat);
#ifdef PatternImage
               image = construct_image(strtype, Pat->patimage,
				       get_patimage(PI_BPAREN)); 
               X->patimage = image; 
#endif					/* PatternImage */
	       bp = pattern_make_pelem(1,X);
	       return pattern(bp);
	       }
	    else {
	       /*
		*  This is the complex case, either the pattern makes stack
		*  entries or it is possible for the pattern to match the null
		*  string (more accurately, we don't know that this is not the
		* case).
		*
		*      +--------------------------+
		*      |                          ^
		*      V                          |
		*    +---+                        |
		*    | X |---->                   |
		*    +---+                        |
		*      .                          |
		*      .                          |
		*    +---+     +---+     +---+    |
		*    | E |---->| P |---->| Y |--->+
		*    +---+     +---+     +---+
		*
		* The node numbering of the constituent pattern P is not
		* affected. Where N is the number of nodes in P, the Y node is
		* numbered N + 1, the E node is N + 2, and the X node is N + 3.
		*/
	       tended struct b_pelem * E;
	       tended struct b_pelem * Y;
	       tended struct b_pelem *EPY;
	       tended struct descrip var;
#ifdef PatternImage
	       image = construct_image(strtype, Pat->patimage,
				       get_patimage(PI_BPAREN));
	       E =  (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,
						 0,nulldesc, nulldesc);
#else					/* PatternImage */
	       E =  (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,
						 0,nulldesc);
#endif					/* PatternImage */
	       var.dword = D_Pelem;
	       BlkLoc(var) =  (union block *)E;
#ifdef PatternImage
	       X =  (struct b_pelem *)pelem_make(&EOP,PC_Arbno_X,0,var, image);
#else					/* PatternImage */
	       X =  (struct b_pelem *)pelem_make(&EOP,PC_Arbno_X,0,var);
#endif					/* PatternImage */
	       var.dword = D_Integer;
	       IntVal(var) = P->stck_size + 3;
#ifdef PatternImage
	       Y =  (struct b_pelem *)pelem_make(X,PC_Arbno_Y,0,var, nulldesc);
#else					/* PatternImage */
	       Y =  (struct b_pelem *)pelem_make(X,PC_Arbno_Y,0,var);
#endif					/* PatternImage */
	       EPY = Bracket (E, Pat, Y);
	       var.dword = D_Pelem;
	       BlkLoc(var) =  (union block *)EPY;
	       X->parameter = var;
	       X->index = EPY->index + 1;
	       bp = pattern_make_pelem(P->stck_size,X);
	       return pattern(bp);
	       }
	    }
      default: {
	 runerr(127,ARBPAT);
	 }
	 }
      }
end


/*
 * Succeed
 */
function {1} Succeed()
   abstract {
      return pattern;
      }
   body {
#ifdef PatternImage
      struct descrip image;
      AsgnCStr(image, "Succeed()");
      return pattern(pattern_make(1, &EOP,PC_Succeed,1, nulldesc, image));
#else					/* PatternImage */
      return pattern(pattern_make(1, &EOP,PC_Succeed,1, nulldesc));
#endif					/* PatternImage */
      }
end

/*
 * bal
 */
function {1} Bal()
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      AsgnCStr(image, "Bal()");
      bp = pattern_make(1, &EOP,PC_Bal,1, nulldesc, image);
#else					/* PatternImage */
      bp = pattern_make(1, &EOP,PC_Bal,1, nulldesc);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} pattern_fieldeval (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      bp = pattern_make(0, &EOP,PC_UNEVALFIELD,1, var_list, nulldesc);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_UNEVALFIELD,1, var_list);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} pattern_stringfunccall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      tended struct descrip param;
      AsgnCStr(image, "pattern_funccall");
      bp = pattern_make(0, &EOP,PC_String_VF,1, param, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_String_VF,1, var_list);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} pattern_stringmethodcall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      tended struct descrip param = var_list;
      AsgnCStr(image, "pattern_stringmethodcall");
      bp = pattern_make(0, &EOP,PC_String_MF,1, param, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_String_MF,1, var_list);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} pattern_boolfunccall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      tended struct descrip param = var_list;
      image = arg_image(param, PT_VF); 
      bp = pattern_make(0, &EOP,PC_Pred_Func,1, param, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_Pred_Func,1, var_list);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} pattern_boolmethodcall (var_list)
   if !is:list(var_list) then
      runerr(108, var_list)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      tended struct descrip param = var_list;
      image = arg_image(param, PT_MF);
      bp = pattern_make(0, &EOP,PC_Pred_MF,1, param, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_Pred_MF,1, var_list);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

/*
 * Unevaluated variables
 */

function {1} pattern_unevalvar (name)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      tended struct descrip param = name;
      image = arg_image(param, PT_VP);
      bp = pattern_make(3, &EOP,PC_Rpat,1, param, image);
#else					/* PatternImage */
      bp = pattern_make(3, &EOP,PC_Rpat,1, name);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

function {1} pattern_concat(L, R)
   abstract {
      return pattern;
      }
   body {
      union block *bp;
      tended struct b_pattern *lpattern;
      tended struct b_pattern *rpattern;
      struct b_pelem *pe;
      type_case L of {
      string:
	 cnv_str_pattern(&L,&L);
      cset:
	 cnv_cset_pattern(&L,&L);
      pattern: {
	 }
      default:{
	 runerr(127);
	 }
	 }

      type_case R of {
      string:
	 cnv_str_pattern(&R,&R);
      cset:
	 cnv_cset_pattern(&R,&R);
      pattern: {
	 }
      default: {
	 runerr(127);
	 }
	 }

      lpattern = (struct b_pattern *)BlkLoc(L);
      rpattern = (struct b_pattern *)BlkLoc(R);
      pe = Concat(Copy((struct b_pelem *)lpattern->pe),
		  Copy((struct b_pelem *)rpattern->pe), rpattern->stck_size);
      bp = pattern_make_pelem(lpattern->stck_size + rpattern->stck_size,pe);
      return pattern(bp);
      }
end

struct b_pelem * Alternate(struct b_pelem * L,struct b_pelem * R)
{
   tended struct b_pelem *lpe = L;
   tended struct b_pelem *rpe = R; 
   tended struct descrip param;
   param.dword = D_Pelem;
   param.vword.bptr = (union block *)rpe;
   if (lpe == &EOP) {

#ifdef PatternImage
      return (struct b_pelem *)pelem_make(&EOP, (word)PC_Alt,
                                          (word)rpe->index + 1, param, nulldesc);
#else					/* PatternImage */
      return (struct b_pelem *)pelem_make(&EOP, (word)PC_Alt,
                                          (word)rpe->index + 1, param);
#endif					/* PatternImage */
      }
   /*
    *  If the left pattern is non-null, then build a reference vector
    *  for its elements, and adjust their index values to acccomodate
    *  the right hand elements. Then add the alternation node.
    */
   else {
      struct b_pelem **Refs;
      /*
       *  We build a reference array for L whose N'th element points to
       *  the pattern element of L whose original Index value is N.
       */
      struct b_pelem * P ;
      int J;
      int RefLen = lpe->index + 1;
#ifdef PatternImage
      lpe->patimage = construct_image(lpe->patimage, get_patimage(PC_Alt),
				      rpe->patimage);
#endif					/* PatternImage */
      Refs = (struct b_pelem **)alloc(RefLen * sizeof(struct b_pelem *));
      Build_Ref_Array (lpe, Refs);
      for (J = 1; J < RefLen;J++){
	 P = Refs[J];
	 P->index += rpe->index;
	 }
#ifdef PatternImage
      return (struct b_pelem *)pelem_make(lpe, PC_Alt, lpe->index + 1, param,
					  lpe->patimage);
#else					/* PatternImage */
      return (struct b_pelem *)pelem_make(lpe, PC_Alt, lpe->index + 1, param);
#endif					/* PatternImage */
      }
}

#begdef MAX(x,y)
((x) > (y)? (x):(y))
#enddef

function{1} pattern_alternate (LPAT, RPAT )
   abstract {
      return pattern;
      }
   body {
      tended struct b_pattern * lpattern;
      tended struct b_pattern * rpattern;
      struct b_pelem *pe;
      union block *bp;
      type_case LPAT of {
      string:
	 cnv_str_pattern(&LPAT,&LPAT);
      cset:
	 cnv_cset_pattern(&LPAT,&LPAT);
      pattern:{
	 }
      default:{
	 /*raise error type mismatch*/
	 runerr(127);
	 }
	 }
      type_case RPAT of {
      string:
	 cnv_str_pattern(&RPAT,&RPAT);
      cset:
	 cnv_cset_pattern(&RPAT,&RPAT);
      pattern: {
	 }
      default: {
	 /*raise error type mismatch*/
	 runerr(127);
	 }
	 }
      lpattern = (struct b_pattern *)BlkLoc(LPAT);
      rpattern = (struct b_pattern *)BlkLoc(RPAT);
      pe = Alternate(Copy((struct b_pelem *)lpattern->pe),
		     Copy((struct b_pelem *)rpattern->pe)
		     );
      bp =pattern_make_pelem(MAX(lpattern->stck_size, rpattern->stck_size),pe);
      return pattern(bp);
      }
end

/*
 * Setcur
 */
function {1} pattern_setcur (underef var, name )
   abstract{
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      image = construct_image(get_patimage(PI_EMPTY), get_patimage(PC_Setcur),
			      name); 
      bp = pattern_make(0, &EOP,PC_Setcur,1, name, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_Setcur,1, name);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

/*
 *  Assign immediate
 *
 *    +---+     +---+     +---+
 *    | E |---->| P |---->| A |---->
 *    +---+     +---+     +---+
 *
 *  The node numbering of the constituent pattern P is not affected.
 *  Where N is the number of nodes in P, the A node is numbered N + 1,
 *  and the E node is N + 2.
 */
function {1} pattern_assign_immediate (PAT, underef var, name)
   abstract {
      return pattern;
      }
   body {
      tended struct b_pattern * p;
      union block *bp;
      tended struct b_pelem *P;
      tended struct b_pelem *E;
      struct b_pelem *A;
#ifdef PatternImage
      tended struct b_pelem *pe;
      struct descrip image; 
#else					/* PatternImage */
      struct b_pelem *pe;
#endif					/* PatternImage */
      type_case PAT of {
      string:
	 cnv_str_pattern(&PAT,&PAT);
      cset:
	 cnv_cset_pattern(&PAT,&PAT);
      pattern: {
	 }
      default:{
	 runerr(127);
	 }
	}
      p = (struct b_pattern *)BlkLoc(PAT);
      P = Copy((struct b_pelem *)p->pe);
#ifdef PatternImage
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc, nulldesc);
      A = (struct b_pelem *)pelem_make(&EOP,PC_Assign_Imm,0,name, nulldesc);
#else					/* PatternImage */
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc);
      A = (struct b_pelem *)pelem_make(&EOP,PC_Assign_Imm,0,name);
#endif					/* PatternImage */
      pe = Bracket(E,P,A);
#ifdef PatternImage
      image = construct_image(P->patimage, get_patimage(PC_Assign_Imm), name);
      pe->patimage = image;
#endif					/* PatternImage */
      bp = pattern_make_pelem(p->stck_size + 3,pe);
      return pattern(bp);
      }
end

/*
 *  Fence
 *
 *    +---+     +---+     +---+
 *    | E |---->| P |---->| X |---->
 *    +---+     +---+     +---+
 *
 *  The node numbering of the constituent pattern P is not affected.
 *  Where N is the number of nodes in P, the X node is numbered N + 1,
 *  and the E node is N + 2.
 */
function {1} Fence(P)
   abstract {
      return pattern;
      }
   if is:null (P) then
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      AsgnCStr(image, "Fence()");
      bp = pattern_make(1, &EOP,PC_Fence,1, nulldesc, image);
#else					/* PatternImage */
      bp = pattern_make(1, &EOP,PC_Fence,1, nulldesc);
#endif					/* PatternImage */
      return pattern(bp);
      }
   else
   body {
       struct b_pattern * p;
      union block *bp;
      struct b_pelem *Pat;
      struct b_pelem *E;
      struct b_pelem *X;
#ifdef PatternImage
       struct descrip image;
      AsgnCStr(image, "Fence()");
#endif					/* PatternImage */
      type_case P of {
      string:
	 cnv_str_pattern(&P,&P);
      cset:
	 cnv_cset_pattern(&P,&P);
      pattern: {
	 }
      default:{
	 runerr(127);
	 }
	}
      p = (struct b_pattern *)BlkLoc(P);
      Pat = Copy((struct b_pelem *)p->pe);
#ifdef PatternImage
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc, nulldesc);
      X = (struct b_pelem *)pelem_make(&EOP,PC_Fence_X,0, nulldesc, image);
#else					/* PatternImage */
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc);
      X = (struct b_pelem *)pelem_make(&EOP,PC_Fence_X,0, nulldesc);
#endif					/* PatternImage */

      bp = pattern_make_pelem(p->stck_size + 1,Bracket(E,Pat,X));
      return pattern(bp);
      }
end

/*
 *  Assign on match
 *
 *    +---+     +---+     +---+
 *    | E |---->| P |---->| A |---->
 *    +---+     +---+     +---+
 *
 *  The node numbering of the constituent pattern P is not affected.
 *  Where N is the number of nodes in P, the A node is numbered N + 1,
 *  and the E node is N + 2.
 */

function {1} pattern_assign_onmatch (PAT, underef var, name)
   abstract {
      return pattern;
      }
   body {
      struct b_pattern *p;
      union block *bp;
      struct b_pelem *P;
      struct b_pelem *E;
      struct b_pelem *A;
#ifdef PatternImage
      tended struct b_pelem *pe;
      struct descrip image;
#else					/* PatternImage */
      struct b_pelem *pe;
#endif					/* PatternImage */
      type_case PAT of {
      string:
	 cnv_str_pattern(&PAT,&PAT);
      cset:
	 cnv_cset_pattern(&PAT,&PAT);
      pattern: {
	 }
      default:{
	 runerr(127);
	 }
	}

      p = (struct b_pattern *)BlkLoc(PAT);
      P = Copy((struct b_pelem *)p->pe);
#ifdef PatternImage
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc,nulldesc);
      A = (struct b_pelem *)pelem_make(&EOP,PC_Assign_OnM,0,name,nulldesc);
#else					/* PatternImage */
      E = (struct b_pelem *)pelem_make(&EOP,PC_R_Enter,0, nulldesc);
      A = (struct b_pelem *)pelem_make(&EOP,PC_Assign_OnM,0,name);
#endif					/* PatternImage */
      pe = Bracket(E,P,A);
#ifdef PatternImage
      image = construct_image(P->patimage, get_patimage(PC_Assign_OnM), name);
      pe->patimage = image; 
#endif					/* PatternImage */
      bp = pattern_make_pelem(p->stck_size + 3,pe);
      return pattern(bp);
      }
end

/*
 * The following functions take the parameter "var" which is not used in
 * the body of the function.
 * pattern_assign_onmatch
 * pattern_assign_immediate
 * pattern_recursive
 * pattern_unevalvar
 *
 * The unicon compiler converts expressions such as P -> X to
 * pattern_assign_immediate(P,X,"X"). During the pattern matching
 * process the variable X is looked up using the string X. Passing the
 * variable to the function frees the programmer from having to declare it.
 */

function {1} Abort()
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image; 
      AsgnCStr(image, "Abort()");
      bp = pattern_make(0, &EOP,PC_Abort,1, nulldesc, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_Abort,1, nulldesc);
#endif					/* PatternImage */
      return pattern(bp);
      }
end


function {1} Rem()
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image; 
      AsgnCStr(image, "Rem()");
      bp = pattern_make(0, &EOP,PC_Rest,1, nulldesc, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_Rest,1, nulldesc);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

/* PFail() moved to bottom (function Fail()) */

static void MYWriteToFile(FILE *fd, int len, char *s)
{
   int i;
   for (i = 0; i < len; i++){
      fprintf(fd,"%c",s[i]);
      }
   fprintf(fd,"\n");	
}

/*
 * Set_String assign to variable v new string from the subject
 */
static void Set_String(dptr V, char * pat, int start, int end)
{
   struct descrip d;
   StrLen(d) = end - start;
   StrLoc(d) = pat + start;
   *V = d;
}


/*
 * Constant Pattern elements used only on stack
 *  CP_Assign    : aliased PE := (PC_Assign,    0, N);
 *  CP_Abort    : aliased PE := (PC_Abort,    0, N);
 *  CP_Fence_Y   : aliased PE := (PC_Fence_Y,   0, N);
 *  CP_R_Remove  : aliased PE := (PC_R_Remove,  0, N);
 *  CP_R_Restore : aliased PE := (PC_R_Restore, 0, N);
 */

static struct b_pelem CP_Assign    =
   {T_Pelem, PC_Assign,    (union block *)NULL, 0, {D_Null,0}};
static struct b_pelem CP_Abort    =
   {T_Pelem, PC_Abort,    (union block *)NULL, 0, {D_Null,0}};
static struct b_pelem CP_Fence_Y   =
   {T_Pelem, PC_Fence_Y,   (union block *)NULL, 0, {D_Null,0}};
static struct b_pelem CP_R_Remove  =
   {T_Pelem, PC_R_Remove,  (union block *)NULL, 0, {D_Null,0}};
static struct b_pelem CP_R_Restore =
   {T_Pelem, PC_R_Restore, (union block *)NULL, 0, {D_Null,0}};

/*
 * Stack used to maintain history during pattern matching
 */

typedef struct stack_entry {
   int cursor;
   struct b_pelem *node;
   } stack_entry;

/*
 *
 * Pop_Region
 *
 *
 *     procedure Pop_Region is
 *     begin
 *        -- If nothing was pushed in the inner region, we can just get
 *        -- rid of it entirely, leaving no traces that it was ever there
 *
 *       if Stack_Ptr = Stack_Base then
 *          Stack_Ptr := Stack_Base - 2;
 *          Stack_Base := Stack (Stack_Ptr + 2).Cursor;
 *
 *       --  If stuff was pushed in the inner region, then we have to
 *       --  push a PC_R_Restore node so that we properly handle possible
 *       --  rematches within the region.
 *
 *       else
 *          Stack_Ptr := Stack_Ptr + 1;
 *          Stack (Stack_Ptr).Cursor := Stack_Base;
 *          Stack (Stack_Ptr).Node   := CP_R_Restore'Access;
 *          Stack_Base := Stack (Stack_Base).Cursor;
 *       end if;
 *    end Pop_Region;
 */

#begdef Pop_Region()
if (Stack_Ptr == Stack_Base) {
   Stack_Ptr = Stack_Base - 2;
   Stack_Base = Stack[Stack_Ptr + 2].cursor;
}
else {
   Stack_Ptr++;
   Stack[Stack_Ptr].cursor = Stack_Base;
   Stack[Stack_Ptr].node = &CP_R_Restore;
   Stack_Base = Stack[Stack_Base].cursor;
}
#enddef
/*
 * Push
 *
 *    procedure Push (Node : PE_Ptr) is
 *    begin
 *       Stack_Ptr := Stack_Ptr + 1;
 *       Stack (Stack_Ptr).Cursor := Cursor;
 *       Stack (Stack_Ptr).Node   := Node;
 *    end Push;
 */

#begdef Push(Node)
Stack_Ptr++;
Stack[Stack_Ptr].cursor = Cursor;
Stack[Stack_Ptr].node   = Node;
#enddef

/*
 * Push_Region
 *
 *    procedure Push_Region is
 *    begin
 *       Stack_Ptr := Stack_Ptr + 2;
 *       Stack (Stack_Ptr).Cursor := Stack_Base;
 *       Stack (Stack_Ptr).Node   := CP_R_Remove'Access;
 *       Stack_Base := Stack_Ptr;
 *    end Push_Region;
 */
#begdef Push_Region()
Stack_Ptr = Stack_Ptr + 2;
Stack[Stack_Ptr].cursor = Stack_Base;
Stack[Stack_Ptr].node   = &CP_R_Remove;
Stack_Base = Stack_Ptr;
#enddef

/*
 * GetVarFromNodeParameter() is a macro used many many times in
 * internal_match(). Since internal_match uses its return value to
 * indicate whether a successful/resumable match was found, it is not
 * free to return an error code, so errors in here are fatalerr().
 *
 * The macro is used to convert the string or list stored in the parameter
 * field of a node to the variable location and value the variable location
 * is stored in the pvar (used when the variable needs to be assigned to)
 * the variable value is stored in var
 */
#begdef GetVarFromNodeParameter(Node)
struct descrip var;
struct descrip varref;
dptr pvar;
tended char * varname;
if (is:list(Node->parameter)) {
   tended struct b_lelem *ep;
   tended struct b_record *rp;
   union block *bptr;
   struct descrip fieldptr;
   int i,nfields, fnum;
   struct b_list *lp = (struct b_list *)BlkLoc(Node->parameter);
   ep = (struct b_lelem *)lp->listhead;
   var = ep->lslots[0];
   deref(&var, &var);

   if (!is:record(var))
      fatalerr(107, &var);

   fieldptr = ep->lslots[1];
   if (!is:string(fieldptr)) {
      fatalerr(103, &fieldptr);
      }
   rp = (struct b_record *)BlkLoc(var);
   bptr = rp->recdesc;
   nfields = bptr->Proc.nfields;
   for (i=0;i<nfields;i++) {
      if ((StrLen(fieldptr) == StrLen(bptr->Proc.lnames[i])) &&
	  !strncmp(StrLoc(fieldptr),
		   StrLoc(bptr->Proc.lnames[i]),StrLen(fieldptr)))
	 break;
      }
   if (i<nfields)
      fnum = i;
   else {
      fatalerr(160, &(ep->lslots[1]));
      }
   pvar = &rp->fields[fnum];
   varref = var = rp->fields[fnum];
   }
else {
   tended char *varnam;
   if (is:string(Node->parameter)) {
      cnv:C_string(Node->parameter, varnam);
      if (getvar(varnam, &varref) == Failed) {
	 fatalerr(160, &(Node->parameter));
	 }
      pvar = VarLoc(varref);
      var = *pvar;
      }
   else if (Var(Node->parameter)) {
      pvar = VarLoc(Node->parameter);
      var = *pvar;
      }
   else if (is:null(Node->parameter)) {
      fatalerr(165, NULL);
      }
   else {
      fprintf(stderr, "parameter\n\n\t%16lx\n\t%16lx\n\npvar %p\n",
	      (unsigned long int)Node->parameter.dword,
	      (unsigned long int)Node->parameter.vword.integr,
	      pvar);
      syserr("bad descriptor in .> or some such");
      }
   }
#enddef

int isMethod(struct b_lelem *ep){
   struct b_record *rp;
   union block *bptr;
   int i, found__m = -1;
   if (is:record(ep->lslots[0])){
      rp = (struct b_record *)BlkLoc(ep->lslots[0]);
      bptr = rp->recdesc;
      }
   else if (is:proc(ep->lslots[0])){
      bptr = ep->lslots[0].vword.bptr;
      }
   else fatalerr(107, &(ep->lslots[0]));
   for( i = 0; i < bptr->Proc.nfields;i++) {
      if ((StrLoc(bptr->Proc.lnames[i]) != NULL) &&
	  !strcmp(StrLoc(bptr->Proc.lnames[i]), "__m")) {
	 found__m = i;
	 break;
	 }
      }/* for ... nfields */
   return found__m;
   }

dptr processFuncCallList(struct b_list *lp, int csr){
   tended struct b_lelem *ep;
   struct descrip proc;
   int i, nargs = lp->size - 1, Cursor = csr, oldPos;
   dptr rv;
   struct descrip *procargs;
   tended struct descrip cresult;
   dptr call_result;
   tended char *temp;

   oldPos = k_pos;
   ep = (struct b_lelem *)lp->listhead;
   proc = ep->lslots[0];
   if ((procargs = calloc(ep->nused, sizeof(struct descrip))) == NULL) {
      fatalerr(307, &nulldesc);
      }

   DEBUGF(25,(stdout, "processFuncCallList\n")); fflush(stdout);
   DEBUGF(25,(stdout, "nargs %d\n", nargs); fflush(stdout));
   for (i = 1; i < ep->nused; i++) {
      if(i == 1 && is:list(ep->lslots[i])) {
	 /*check for method call else function call*/
	 DEBUGF(25,(stdout, "is a list\n"));fflush(stdout);
	 if(isMethod(ep) >= 0) {
	    rv = processMethodCallList(BlkD(ep->lslots[i], List), Cursor);
	    }
	 else {
	    rv = processFuncCallList(BlkD(ep->lslots[i], List), Cursor);
	    }
	 if (rv == 0) { free(procargs); return 0; }
	 procargs[i - 1] = *rv;
	 }
      else if (is:variable(ep->lslots[i])) {
	 DEBUGF(25,(stdout, "replacing var %16lx : %16lx\n", 
		  ep->lslots[i].dword,
		  (long)ep->lslots[i].vword.bptr));
	 fflush(stdout);
	 procargs[i - 1] = *(ep->lslots[i].vword.descptr);
	 }
      else {	
	 procargs[i - 1] = ep->lslots[i];
	 DEBUGF(25,(stdout, "nargs %d arg %d val %16lx : %16lx\n",
		  nargs, i-1, procargs[i-1].dword, (long)procargs
		  [i-1].vword.bptr));fflush(stdout);
         }
      }
   DEBUGF(25,(stdout, "proc %16lx : %16lx\n", proc.dword,
	  (unsigned long int)proc.vword.bptr); fflush(stdout));
   DEBUGF(25,(stdout, "nargs %d\n", nargs));fflush(stdout);
   k_pos = Cursor + 1;
#if COMPILER
   fatalerr(164, NULL);
   call_result = NULL;
#else					/* COMPILER */
   call_result = (dptr)calliconproc(proc,procargs,nargs);
#endif					/* COMPILER */
   free(procargs);
   k_pos = oldPos;
   return call_result;
   }

dptr processMethodCallList(struct b_list *lp, int csr)
{
   int nargs;
   tended struct b_lelem *ep;
   tended struct b_record *rp;
   union block *bptr;
   struct descrip methodptr;
   struct descrip proc;
   struct descrip self;
   struct descrip argmnt;
   dptr rv;
   int Cursor;
   struct descrip procargs[10];
   dptr call_result;
   struct descrip var;
   tended char *varname;
   tended char *classname;
   int nfields, fnum, cnlen;
   int oldPos;
   int i, found__m = 0;

   oldPos = k_pos;
   DEBUGF(25,(stdout, "processMethodCallList\n")); fflush(stdout);
   Cursor = csr;
   nargs = lp->size;
   ep = (struct b_lelem *)lp->listhead;
   cnv:C_string(ep->lslots[0], varname);
   if (getvar(varname, &var) == Failed) {
      t_errornumber = 160;
      AsgnCStr(t_errorvalue, varname);
      return NULL;
      }
   procargs[0] = var;
   deref(&var,&var);
   if (!is:record(var)) {
      err_msg(107, &var);
      return NULL;
      }

   ep->lslots[0] = var;
   self = var;
   classname = var.vword.bptr->Record.recdesc->Proc.pname.vword.sptr;  
   cnlen = strcspn(classname, "_");
   classname = strncpy(classname, classname, cnlen);
   classname[cnlen] = '_';
   classname[cnlen + 1] = '\0';
   methodptr = ep->lslots[1];
   rp = (struct b_record *)BlkLoc(var);
   bptr = rp->recdesc;

   found__m = isMethod(ep);

   if (found__m == -1) {
      fatalerr(163, NULL);
      }
   var = rp->fields[found__m];
   rp = (struct b_record *)BlkLoc(var);
   bptr = rp->recdesc;
   nfields = bptr->Proc.nfields;
   for (i=0; i<nfields; i++) {
      if ((StrLen(methodptr) == StrLen(bptr->Proc.lnames[i])) &&
	  !strncmp(StrLoc(methodptr),
		   StrLoc(bptr->Proc.lnames[i]),StrLen(methodptr)))
	 break;
      }
   if (i<nfields)
      fnum = i;  
   nfields = bptr->Proc.nfields;
   proc = rp->fields[fnum];
   bptr = rp->recdesc;
   for (i = 1; i < ep->nused; i++) {
      if(is:list(ep->lslots[i])) {
	 /* check for method call else function call*/
	 if(isMethod(ep) >= 0) {
	    rv = processMethodCallList(BlkD(ep->lslots[i], List), Cursor);
	    }
	 else {
	    rv = processFuncCallList(BlkD(ep->lslots[i], List), Cursor);
	    }
	 if (rv == 0) return 0;
	    procargs[i - 1] = *rv;
	    }
	 else if (is:variable(ep->lslots[i])) {
	    procargs[i - 1] = *(ep->lslots[i].vword.descptr);
	 }
      else {
	 if (i == 1) procargs[i - 1] = self;
	 if(strpbrk(ep->lslots[i].vword.sptr,
	       "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_") == 
	       NULL) {
	    cnv:integer(ep->lslots[i], argmnt);
	    procargs[i - 1] = argmnt;
	    }
         else {
            tended char * varname;
	    tended char * varstring;
	    struct descrip parm;
            cnv:C_string(ep->lslots[i], varname);
	    varstring = alloc(strlen(classname) + strlen(varname) + 1);
	    strcat(varstring, classname);
	    strcat(varstring, varname);
	    if (getvar(varstring,&parm) == Failed) {
	       t_errornumber = 160;
	       AsgnCStr(t_errorvalue, varstring);
	       return NULL;
	       }
	    free(varstring);
	    procargs[i -1] = parm;
            }
	 }
      }
   k_pos = Cursor + 1;
#if COMPILER
   fatalerr(164, NULL);
   call_result = NULL;
#else					/* COMPILER */
   call_result = (dptr)calliconproc(proc,procargs,nargs);
#endif					/* COMPILER */
   k_pos = oldPos;
   return call_result;
   }

/*
 * uses the list stored in the parameter field of a node to
 * 1. obtains the name of the procedure from the first element of the list
 * 2. the remaining elements of the list are used as paramters to the function
 */
#begdef GetResultFromFuncCall()
   tended struct descrip cresult;
   dptr call_result;
   tended struct b_list *lp = (struct b_list *)BlkLoc(Node->parameter);
   call_result = processFuncCallList(lp, Cursor);
   if (call_result != 0) {
      cresult = *call_result;
      if(is:integer(cresult) || is:cset(cresult)) {
	 internalStorage = cresult.vword.bptr;
	 }
      }
#enddef

/*
 * uses the list stored in the parameter field of a node to
 * 1. first obtain the object from the first element of the list
 * 2. access the method from the object using the second element of the list
 * 3. remaining elements of the list are parameters to the method invocation
 */
#begdef GetResultFromMethodCall()
int nargs;
tended struct descrip cresult;
dptr call_result;
tended struct b_list *lp = (struct b_list *)BlkLoc(Node->parameter);
nargs = lp->size -1;

if (is:list(Node->parameter)) {
   call_result = processMethodCallList(lp, Cursor);
   if (call_result != 0) { 
      cresult = *call_result;
      if(is:integer(cresult) || is:cset(cresult)) {
	 internalStorage = cresult.vword.bptr;
	 }
      }
   }
else {
   fatalerr(163, NULL);
   }
#enddef

#define Stack_Init 1
#define Stack_Size 200
/*
 * Revised as part of 2015 integration
 *   added Anchored_Mode to signature to allow external definition
 *   pattern mode.
 */
int internal_match(char * pat_sub, int Length, int Pat_S,
		   struct b_pelem * pattern, int *Start, int *Stop,
		   int initial_cursor,
		   int Anchored_Mode
		   )
{
   stack_entry Stack[Stack_Size];
   int Stack_Ptr , Stack_Base ;
   int Cursor = initial_cursor;
   struct b_pelem * Node = NULL;
   struct b_pelem PE_Unanchored = {0, PC_Unanchored, (union block *)pattern,
				      0, {D_Null,0}};
   int Assign_OnM = 0;
   int Region_Level = 0;
   union block *internalStorage = NULL;
   DEBUGF(2, (stdout,
	  "Initiating pattern match\nsubject = \"%*s\", len = %d, pos = %d\n",
	      Length,pat_sub,Length, Cursor));
   DEBUGF(25, (stdout, "internal_match\n"));

   if (pattern == NULL) {
      fatalerr(162, NULL);
      }
   if (Pat_S > Stack_Size - 1) {
      fatalerr(309, NULL);
      }
   /* In anchored mode, the bottom entry on the stack is a cancel entry */
   if (Anchored_Mode) {
      Stack[Stack_Init].node = &CP_Abort;
      Stack[Stack_Init].cursor = initial_cursor;
      }
/*
 *       --  In unanchored mode, the bottom entry on the stack references
 *       --  the special pattern element PE_Unanchored, whose Pthen field
 *       --  points to the initial pattern element. The cursor value in this
 *       --  entry is the number of anchor moves so far.
 */
   else {
      Stack[Stack_Init].node = &PE_Unanchored;
      Stack[Stack_Init].cursor = initial_cursor;
      }
   Stack_Ptr = Stack_Init;
   Stack_Base = Stack_Ptr;
   Node = pattern;
   goto Match;
   /*
    *
    * Main Pattern Matching State Control
    *
    *       --  This is a state machine which uses gotos to change state. The
    *       --  initial state is Match, to initiate the matching of the first
    *       --  element, so the goto Match above starts the match. In the
    *       --  following descriptions, we indicate the global values that
    *       --  are relevant for the state transition.
    */

/*
 *       --  Come here if entire match fails
 */

Match_Fail:
   DEBUGF(20,(stdout,"Match fails\n"));
   *Start = 0;
   *Stop = 0;
   return 0;
/*
 *       --  Come here if entire match succeeds
 *
 *       --  Cursor        current position in subject string
 */
Match_Succeed:
   DEBUGF(2,(stdout,"Match Succeeds\n"));
   *Start = Stack[Stack_Init].cursor;
   *Stop = Cursor;
   DEBUGF(2,(stdout, "first matched character index =%d\n", *Start));
   DEBUGF(2,(stdout, "last matched character index =%d\n" ,*Stop));
   if (Assign_OnM) {
      int S;
      for ( S = Stack_Init; S <= Stack_Ptr; S++) {
	 if (Stack[S].node == &CP_Assign){
	    int Inner_Base = Stack[S + 1].cursor;
	    int Special_Entry =  Inner_Base - 1;
	    struct b_pelem * Node_OnM = Stack[Special_Entry].node;
	    int Start = Stack[Special_Entry].cursor;
	    int Stop = Stack[S].cursor;
	    GetVarFromNodeParameter(Node_OnM);
	    if (Node_OnM->pcode == PC_Assign_OnM){
	       if (var.dword == D_File) {
		  struct b_file *f;
		  f = (struct b_file *)BlkLoc(var);
		  MYWriteToFile(f->fd.fp,Stop - Start,pat_sub + Start);
		  }
	       else
		  Set_String(pvar,pat_sub,Start, Stop );
	       }
	    else {
	       syserr("logic error in internal_match");
	       }
	    }
	 }
      }
   return 1;
Node_Fail:
/*
 *       --  Come here if attempt to match current element fails
 *
 *       --    Stack_Base    current stack base
 *       --    Stack_Ptr     current stack pointer
 */
   Cursor = Stack[Stack_Ptr].cursor;
   Node   = Stack[Stack_Ptr].node;
   Stack_Ptr--;
   goto Match;
Node_Succeed:
/*
 *       --  Come here if attempt to match current element succeeds
 *
 *       --    Cursor        current position in subject string
 *       --    Node          pointer to node successfully matched
 *       --    Stack_Base    current stack base
 *       --    Stack_Ptr     current stack pointer
 */

    Node = (struct b_pelem *)Node->pthen;
/*
 *       --  Come here to match the next pattern element
 *
 *       --    Cursor        current position in subject string
 *       --    Node          pointer to node to be matched
 *       --    Stack_Base    current stack base
 *       --    Stack_Ptr     current stack pointer
 */
 Match:
/*
 *
 *       -- Main Pattern Match Element Matching Routines --
 *
 *
 *       --  Here is the case statement that processes the current node. The
 *       --  processing for each element does one of five things:
 *
 *       --    goto Succeed        to move to the successor
 *       --    goto Match_Succeed  if the entire match succeeds
 *       --    goto Match_Fail     if the entire match fails
 *       --    goto Fail           to signal failure of current match
 */
   DEBUGF(5, (stdout, "match: %ld, Cursor: %d\n", Node->pcode, Cursor); fflush(stdout));
   switch(Node->pcode) {
   case PC_Alt: {
      DEBUGF(20,(stdout,"Setting up alternative \n"));
      Push((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
   case PC_Any_CS:{
      DEBUGF(20,(stdout,"Matching Any\n"));
      if ((Cursor < Length) && Testb(ToAscii(pat_sub[Cursor]), Node->parameter)){
	 Cursor++;
	 goto Node_Succeed;
	 }
      else {
	 goto Node_Fail;
	 }
      break;
      }
   case PC_Any_VP:{
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Any unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
	 fatalerr(104, &var);
	 }
      if ((Cursor < Length) && Testb(ToAscii(pat_sub[Cursor]), var)) {
	 Cursor++;
	 goto Node_Succeed;
	 }
      else {
	 goto Node_Fail;
	 }
      break;
      }
   case PC_Any_VF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Any unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      if ((Cursor < Length) && Testb(ToAscii(pat_sub[Cursor]), cresult)) {
	 Cursor++;
	 goto Node_Succeed;
	 }
      else {
	 goto Node_Fail;
	 }
      break;
      }
   case PC_Any_MF: {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Any unevaluated method call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      if ((Cursor < Length) && Testb(ToAscii(pat_sub[Cursor]), cresult)) {
	 Cursor++;
	 goto Node_Succeed;
	 }
      else {
	 goto Node_Fail;
	 }
      break;
      }

      /*
       *  Arb (initial match)
       */
   case PC_Arb_X : {
      DEBUGF(20,(stdout, "matching Arb\n"));
      Push ((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
      /*
       *  Arb (extension)
       */
   case PC_Arb_Y : {
      DEBUGF(20,(stdout, "extending Arb"));
      if (Cursor < Length){
	 Cursor++;
	 Push (Node);
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      break;
      }
      /*
       *  Arbno_S (simple Arbno initialize). This is the node that
       *  initiates the match of a simple Arbno structure.
       */
   case PC_Arbno_S : {
      DEBUGF(20,(stdout,"setting up Arbno alternative "));
      Push ((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
      /*
       *   Arbno_X (Arbno initialize). This is the node that initiates
       *   the match of a complex Arbno structure.
       */
   case PC_Arbno_X: {
      DEBUGF(20,(stdout,"setting up Arbno alternative "));
      Push ((struct b_pelem *)BlkLoc(Node->parameter));
      Node = (struct b_pelem *)Node->pthen;
      goto Match;
      break;
      }
      /*
       *   Arbno_Y (Arbno rematch). This is the node that is executed
       *   following successful matching of one instance of a complex
       *   Arbno pattern.
       */
   case PC_Arbno_Y : {
      int  Null_Match = 0;
      if (Cursor == Stack[Stack_Base - 1].cursor)
	 Null_Match = 1;
      DEBUGF(20,(stdout,"extending Arbno"));
      Pop_Region();

      /*
       *   If arbno extension matched null, then immediately fail
       */
      if (Null_Match){
	 DEBUGF(20,(stdout,"Arbno extension matched null, so fails"));
	 goto Node_Fail;
	 }
      /*
       *   Here we must do a stack check to make sure enough stack
       *   is left. This check will happen once for each instance of
       *   the Arbno pattern that is matched. The parameter field of a
       *   PC_Arbno pattern contains the maximum stack entries needed
       *   for the Arbno with one instance and the successor pattern
       */
      if (Stack_Ptr + IntVal(Node->parameter) >= Stack_Size){
	 fatalerr(309, NULL);
	 }
      goto Node_Succeed;
      }
      /*
       *  Assign. If this node is executed, it means the assign-on-match
       *  or write-on-match operation will not happen after all, so we
       *  is propagate the failure, removing the PC_Assign node.
       */
   case PC_Assign : {
      goto Node_Fail;
      }
      /*
       *   Assign immediate. This node performs the actual assignment.
       */
   case  PC_Assign_Imm : {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout, "executing immediate assignment\n"));
      if (var.dword == D_File) {
	 struct b_file *f;
	 f = (struct b_file *)BlkLoc(var);
	 MYWriteToFile(f->fd.fp,Cursor - Stack[Stack_Base - 1].cursor,
		       pat_sub + Stack[Stack_Base - 1].cursor);
	 }
      else {
	 Set_String(pvar, pat_sub, Stack[Stack_Base - 1].cursor, Cursor);
	 }
      Pop_Region();
      goto Node_Succeed;
      }
      /*
       * Assign on match. This node sets up for the eventual assignment
       */
   case PC_Assign_OnM : {
      Stack[Stack_Base - 1].node = Node;
      Push (&CP_Assign);
      Pop_Region();
      Assign_OnM = 1;
      goto Node_Succeed;
      }
      /*
       * Abort
       */
   case PC_Abort: {
      DEBUGF(20,(stdout, "matching Abort"));
      goto Match_Fail;
      }
      /*
       *   Bal
       */
   case PC_Bal : {
      DEBUGF(2,(stdout,"matching or extending Bal\n"));
      if ((Cursor >= Length) || pat_sub[Cursor] == ')')
	 goto Node_Fail;
      else if (pat_sub[Cursor] == '('){
	 int Paren_Count = 1;
	 DEBUGF(2,(stdout,
		   "Paren_Count = %d  Cursor = %d\n", Paren_Count,Cursor));
	 while(1) {
	    Cursor++;
	    if (Cursor >= Length)
	       goto Node_Fail;
	    else if (pat_sub[Cursor] == '(' ){
	       Paren_Count++;
	       DEBUGF(2,(stdout,
			 " Found ( Paren_Count = %d  Cursor = %d\n",
			 Paren_Count,Cursor));
	       }
	    else if (pat_sub[Cursor] == ')'){
	       Paren_Count--;
	       DEBUGF(2,(stdout,
			 "Found ) Paren_Count = %d  Cursor = %d\n",
			 Paren_Count,Cursor));
	       }
	    if (Paren_Count == 0) {
	       DEBUGF(2,(stdout,
			 "Paren_Count = %d  Cursor = %d\n",
			 Paren_Count,Cursor));
	       break;
	       }
	    }
	 }
	Cursor++;
	Push (Node);
	DEBUGF(2,(stdout,
		  "matching or extending Bal succeeded, Cursor = %d\n",
		  Cursor));
	goto Node_Succeed;
    }

      /*
       * Break (character set case)
       */
   case PC_Break_CS : {
      DEBUGF(20,(stdout, "matching Break\n"));
      while( Cursor < Length ){	
	 if (Testb(ToAscii(pat_sub[Cursor]), Node->parameter))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }
   case PC_Break_VP :{
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Break unevaluated variable\n"));
      if (!cnv_cset(&var,&var)){
	 fatalerr(104, &var);
	 }
      while( Cursor < Length ){
	 if (Testb(ToAscii(pat_sub[Cursor]), var))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }
   case PC_Break_VF :{
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Break unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      while (Cursor < Length ){
	 if (Testb(ToAscii(pat_sub[Cursor]), cresult))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }

   case PC_Break_MF :{
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Break unevaluated method call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      while( Cursor < Length ){
	 if (Testb(ToAscii(pat_sub[Cursor]), cresult))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }

      /*
       * BreakX (character set case)
       */
   case PC_BreakX_CS: {
      DEBUGF(20,(stdout, "matching BreakX\n"));
      while( Cursor < Length ){
	 if (Testb(ToAscii(pat_sub[Cursor]), Node->parameter))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }
   case PC_BreakX_VP : {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching BreakX unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
	 fatalerr(104, &var);
	 }

      while (Cursor < Length) {
	 if (Testb(ToAscii(pat_sub[Cursor]), var))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }
   case PC_BreakX_VF : {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching BreakX unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      while (Cursor < Length) {
	 if (Testb(ToAscii(pat_sub[Cursor]), cresult))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }
   case PC_BreakX_MF : {
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching BreakX unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      while (Cursor < Length) {
	 if (Testb(ToAscii(pat_sub[Cursor]), cresult))
	    goto Node_Succeed;
	 else {
	    Cursor++;
	    }
	 }
      goto Node_Fail;
      break;
      }

      /*
       *   BreakX_X (BreakX extension). See section on "Compound Pattern
       *   Structures". This node is the alternative that is stacked to
       *   skip past the break character and extend the break.
       */
   case  PC_BreakX_X : {
      Cursor++;
      goto Node_Succeed;
      }

      /*
       * Fail
       */
   case PC_Fail: {
      DEBUGF(20,(stdout, "matching Fail"));
      goto Node_Fail;
      }

      /*
       *   Fence (built in pattern)
       */
   case PC_Fence : {
      Push (&CP_Abort);
      goto Node_Succeed;
      }

      /*
       *   Fence function node X. This is the node that gets control
       *   after a successful match of the fenced pattern.
       */
   case  PC_Fence_X : {
      Stack_Ptr++;
      Stack[Stack_Ptr].cursor = Stack_Base;
      Stack[Stack_Ptr].node   = &CP_Fence_Y;
      Stack_Base = Stack[Stack_Base].cursor;
      goto Node_Succeed;
      }

      /*
       *   Fence function node Y. This is the node that gets control on
       *   a failure that occurs after the fenced pattern has matched.
       *
       *   Note: the Cursor at this stage is actually the inner stack
       *   base value. We don't reset this, but we do use it to strip
       *   off all the entries made by the fenced pattern.
       */
   case PC_Fence_Y : {
      Stack_Ptr = Cursor - 2;
      goto Node_Fail;
      }

      /*
       *  Unevaluated function call
       */
   case  PC_Pred_Func: {
      GetResultFromFuncCall();
      /* review assumption as to what call_result can be pointing at */
      if ((call_result == 0) || (call_result->vword.descptr == 0)) {
	 goto Node_Fail;
	 }
      else {
#if 0
	 int LV_Len;
	 /*
	  * Review assumption as to possible return values and their meaning.
	  * If we call a function as part of a pattern and the function fails,
	  * we know what failure means. Does success mean anything? Previously
	  * we interpreted it as advancing (for string returns) or setting
	  * (for integer returns) the cursor, but this limits what predicates
	  * can be used, so for now success will not mean anything.
	  */
	 if(is:string(cresult)) {
	    LV_Len = StrLen(cresult);
	    DEBUGF(20,(stdout,"Matching String\n"));
	    if ((Length - Cursor >= LV_Len) &&
	          !strncmp(pat_sub + Cursor, StrLoc(cresult), LV_Len)) {
	       Cursor = Cursor + LV_Len;
	       goto Node_Succeed;
	       }
            else {
	       goto Node_Fail;
	       }
	    }
	 else {
	    Cursor = cresult.vword.integr;
	    Cursor = Cursor - 1;
	    }
#endif
	 goto Node_Succeed;
	 }
      break;
      }

   case  PC_Pred_MF:{
      GetResultFromMethodCall();
      if (call_result == 0)
	 goto Node_Fail;
      else {
	 if(is:string(cresult)) {
	    int LV_Len = StrLen(cresult);
	    DEBUGF(20,(stdout,"Matching String\n"));
	    if ((Length - Cursor >= LV_Len) &&
	          !strncmp(pat_sub + Cursor, StrLoc(cresult), LV_Len)) {
	       Cursor = Cursor + LV_Len;
	       goto Node_Succeed;
	       }
            else {
	       goto Node_Fail;
	       }
	    }
	 goto Node_Succeed;
	 }
      break;
      }

   case PC_Len_Nat: {
      DEBUGF(20,(stdout, "matching Len\n"));
      if (Cursor + IntVal(Node->parameter) > Length)
	 goto Node_Fail;
      else {
	 Cursor = Cursor + IntVal(Node->parameter);
	 }
      goto Node_Succeed;
      break;
      }
   case PC_Len_NP: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Len unevaluated variable\n"));
      if (!cnv_int(&var,&var)) {
	 fatalerr(101, &var);
	 }
      DEBUGF(20,(stdout, "matching Len\n"));
      if (Cursor + IntVal(var) > Length)
	 goto Node_Fail;
      else {
	 Cursor = Cursor + IntVal(var);
	 }
      goto Node_Succeed;
      break;
      }
   case PC_Len_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Len unevaluated function call\n"));
      if (!cnv_int(&cresult,&cresult))
	 fatalerr(101, &cresult);
      if(!is:integer(cresult) && (internalStorage != NULL)) {
	 cresult.vword.bptr = internalStorage;
	 internalStorage = NULL;
	 }
      if (Cursor + IntVal(cresult) > Length)
	 goto Node_Fail;
      else {
	 Cursor = Cursor + IntVal(cresult);
	 }
      goto Node_Succeed;
      break;
      }

   case PC_Len_NMF:{
      GetResultFromMethodCall();
      DEBUGF(20,(stdout,"Matching Len unevaluated function call\n"));
      if (!cnv_int(&cresult,&cresult))
	 fatalerr(101, &cresult);
      if(!is:integer(cresult) && internalStorage != NULL) {
	 cresult.vword.bptr = internalStorage;
	 internalStorage = NULL;
	 }
      if (Cursor + IntVal(cresult) > Length)
	 goto Node_Fail;
      else {
	 Cursor = Cursor + IntVal(cresult);
	 }
      goto Node_Succeed;
      break;
      }

   case PC_NotAny_CS : {
      DEBUGF(20,(stdout, "matching NotAny\n"));
      if ((Cursor < Length) &&
	  !Testb(ToAscii(pat_sub[Cursor]), Node->parameter)) {
	 Cursor++;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case PC_NotAny_VP : {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching NotAny unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
	 fatalerr(104, &var);
	 }
      DEBUGF(20,(stdout, "matching NotAny_VP\n"));
      if ((Cursor < Length) &&
	  !Testb(ToAscii(pat_sub[Cursor]), var)){
	 Cursor++;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case PC_NotAny_VF :{
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching NotAny unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      DEBUGF(20,(stdout, "matching NotAny\n"));
      if ((Cursor < Length) &&
	  !Testb(ToAscii(pat_sub[Cursor]), cresult)){
	 Cursor++;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

      /*
       *  Initiate recursive match (pattern pointer case)
       */
   case PC_Rpat: {
      GetVarFromNodeParameter(Node);
      type_case var of {
      string: {
	 int LV_Len = StrLen(var);
	 DEBUGF(20,(stdout, "Matching unevaluated String variable \n"));
	 if ((Length - Cursor >= LV_Len )
	     && !strncmp(pat_sub + Cursor, StrLoc(var), LV_Len)){
	    Cursor = Cursor + LV_Len;
	    goto Node_Succeed;
	    }
	 else
	    goto Node_Fail;
	 break;
	 }

      cset: {
	 DEBUGF(20,(stdout,"Matching unevaluated cset variable\n"));
	 if ((Cursor < Length) && Testb(ToAscii(pat_sub[Cursor]), var)) {
	    Cursor++;
	    goto Node_Succeed;
	    }
	 else
	    goto Node_Fail;
	 break;
	 }
      pattern: {
	 DEBUGF(20,(stdout, "Matching unevaluated pattern variable\n"));
	 Stack[Stack_Ptr + 1].node = (struct b_pelem *)Node->pthen;
	 Push_Region();
	 if (Stack_Ptr +
	     ((struct b_pattern *)BlkLoc(var))->stck_size >= Stack_Size) {
	    fatalerr(309, NULL);
	    }
	 else {
	    Node = (struct b_pelem *) ((struct b_pattern *)BlkLoc(var))->pe;
	    goto Match;
	    }
	 break;
	 }
      default: {
	 fatalerr(161, NULL);
	 }
	 }
      }

      /*
       *  Pos
       */
   case PC_Pos_Nat: {
      if (Cursor == IntVal(Node->parameter) - 1)
	 goto Node_Succeed;
      else
	 goto Node_Fail;
      }

   case PC_Pos_NP:{
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Pos unevaluated variable\n"));
      if (!cnv_int(&var,&var)) {
	 fatalerr(101, &var);
	 }
      DEBUGF(20,(stdout, "matching Len\n"));
      if (Cursor == IntVal(var) - 1)
	 goto Node_Succeed;
      else
	 goto Node_Fail;
      }

   case PC_Pos_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Len unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(101, &cresult);
      if(!is:integer(cresult) && internalStorage != NULL) {
	 cresult.vword.bptr = internalStorage;
	 internalStorage = NULL;
	 }
      if (Cursor == IntVal(cresult) - 1)
	 goto Node_Succeed;
      else
	 goto Node_Fail;
      }

      /*
       *   Tab (integer case)
       */
   case  PC_Tab_Nat: {
      if (Cursor <= IntVal(Node->parameter) - 1){
	 Cursor = IntVal(Node->parameter) - 1;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_Tab_NP: {
      GetVarFromNodeParameter(Node);
      if (!cnv_int(&var,&var)) {
	 fatalerr(101, &var);
	 }
      if (Cursor <= IntVal(var) - 1){
	 Cursor = IntVal(var) - 1;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_Tab_NF: {
      GetResultFromFuncCall();
      if (call_result == 0)
	 goto Node_Fail;
      else {
	 if (!cnv_int(&cresult,&cresult))
	    fatalerr(101, &cresult);
	 if(!is:integer(cresult) && internalStorage != NULL) {
	    cresult.vword.bptr = internalStorage;
	    internalStorage = NULL;
	    }
	 }
      if (Cursor <= IntVal(cresult) - 1) {
	 Cursor = IntVal(cresult) - 1;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

      /*
       * Rest
       */
   case PC_Rest: {
      Cursor = Length;
      goto Node_Succeed;
      }

      /*
       *  RPos
       */
   case PC_RPos_Nat: {
      if (Cursor == (Length - IntVal(Node->parameter)))
	 goto Node_Succeed;
      else
	 goto Node_Fail;
      }

   case PC_RPos_NP: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Rpos unevaluated variable\n"));
      if (!cnv_int(&var,&var)){
	 fatalerr(101, &var);
	 }
      DEBUGF(20,(stdout, "matching Len\n"));
      if (Cursor == (Length - IntVal(Node->parameter)))
	 goto Node_Succeed;
      else
	 goto Node_Fail;
      }

   case PC_RPos_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching RPos unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      if(!is:integer(cresult) && internalStorage != NULL) {
	 cresult.vword.bptr = internalStorage;
	 internalStorage = NULL;
	 }
      if (Cursor == (Length - IntVal(cresult)))
	 goto Node_Succeed;
      else
	 goto Node_Fail;
      }

      /*
       *   RTab (integer case)
       */
   case  PC_RTab_Nat: {
      if (Cursor <= (Length - IntVal(Node->parameter))){
	 Cursor = Length - IntVal(Node->parameter);
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_RTab_NP: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching RTab unevaluated variable\n"));
      if (!cnv_int(&var,&var)){
	 fatalerr(101, &var);
	 }
      DEBUGF(20,(stdout, "matching Len\n"));
      if (Cursor <= (Length - IntVal(var))){
	 Cursor = Length - IntVal(var);
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_RTab_NF: {
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching RTab unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      if(!is:integer(cresult) && internalStorage != NULL) {
	 cresult.vword.bptr = internalStorage;
	 internalStorage = NULL;
	 }
      if (Cursor <= (Length - IntVal(cresult))){
	 Cursor = Length - IntVal(cresult);
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

      /*
       *   Region Enter. Initiate new pattern history stack region
       */
   case PC_R_Enter : {
      DEBUGF(20,(stdout, "starting match of nested pattern\n"));
      Stack[Stack_Ptr + 1].cursor = Cursor;
      Push_Region();
      goto Node_Succeed;
      }

      /*
       *   Region Remove node. This is the node stacked by an R_Enter.
       *   It removes the special format stack entry right underneath, and
       *   then restores the outer level stack base and signals failure.
       *
       *   Note: the cursor value at this stage is actually the (negative)
       *   stack base value for the outer level.
       */
   case PC_R_Remove : {
      DEBUGF(20,(stdout,"failure, match of nested pattern terminated\n"));
      Stack_Base = Cursor;
      Region_Level--;
      Stack_Ptr--;
      goto Node_Fail;
      }

      /*
       *   Region restore node. This is the node stacked at the end of an
       *   inner level match. Its function is to restore the inner level
       *   region, so that alternatives in this region can be sought.
       *
       *   Note: the Cursor at this stage is actually the negative of the
       *   inner stack base value, which we use to restore the inner region.
       */
   case  PC_R_Restore : {
      DEBUGF(20,(stdout,
		 "failure, search for alternatives in nested pattern\n"));
      Region_Level = Region_Level + 1;
      Stack_Base = Cursor;
      goto Node_Fail;
      }

   case PC_Setcur: {
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout, "Matching Setcur assigning Cursor = %d\n", Cursor));
      pvar->dword = D_Integer;
      IntVal(*pvar) = Cursor + 1;
      goto Node_Succeed;
      }

   case  PC_Span_CS : {
      int P = Cursor;
      DEBUGF(20,(stdout,"Matching Span_CS\n"));
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),Node->parameter))
	 P++;
      if (P != Cursor) {
	 Cursor = P;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_Span_VP : {
      int P = Cursor;
      GetVarFromNodeParameter(Node);
      DEBUGF(20,(stdout,"Matching Span unevaluated variable\n"));
      if (!cnv_cset(&var,&var)) {
	 fatalerr(104, &var);
	 }
      DEBUGF(20,(stdout,"Matching Span_VP\n"));
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),var))
	 P++;
      if (P != Cursor) {
	 Cursor = P;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_Span_VF : {
      int P = Cursor;
      GetResultFromFuncCall();
      DEBUGF(20,(stdout,"Matching Span_VF unevaluated function call\n"));
      if (!cnv_cset(&cresult,&cresult))
	 fatalerr(104, &cresult);
      while ((P < Length) && Testb(ToAscii(pat_sub[P]),cresult))
	 P++;
      if (P != Cursor) {
	 Cursor = P;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_String : {
      int LV_Len = StrLen(Node->parameter);
      DEBUGF(20,(stdout,"Matching String \"%*s\" against %s, Length %d Cursor %d Len %d\n", LV_Len, StrLoc(Node->parameter), pat_sub+Cursor, Length, Cursor, LV_Len));
      if ((Length - Cursor >= LV_Len) &&
	  !strncmp(pat_sub + Cursor, StrLoc(Node->parameter), LV_Len)) {
	 Cursor = Cursor + LV_Len;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

   case  PC_String_VP : {
      int LV_Len;
      GetVarFromNodeParameter(Node);
      LV_Len = StrLen(var);
      DEBUGF(20,(stdout,"Matching String\n"));
      if ((Length - Cursor >= LV_Len) &&
	  !strncmp(pat_sub + Cursor, StrLoc(var), LV_Len)) {
	 Cursor = Cursor + LV_Len;
	 goto Node_Succeed;
	 }
      else
	 goto Node_Fail;
      }

      /*
       */
   case  PC_String_VF: {
      GetResultFromFuncCall();
      if (call_result == 0)
	 goto Node_Fail;
      else {
	 if (cnv_str(&cresult,&cresult)){
	    int LV_Len = StrLen(cresult);
	    DEBUGF(20,(stdout,"Matching String\n"));
	    if ((Length - Cursor >= LV_Len) &&
		!strncmp(pat_sub + Cursor, StrLoc(cresult), LV_Len)) {
	       Cursor = Cursor + LV_Len;
	       goto Node_Succeed;
	       }
	    else
	       goto Node_Fail;
	    }
	 goto Node_Succeed;
	 }
      break;
      }

   case  PC_String_MF: {
      GetResultFromMethodCall();
      if (call_result == 0)
	 goto Node_Fail;
      else {
	 if (cnv_str(&cresult,&cresult)){
	    int LV_Len = StrLen(cresult);
	    DEBUGF(20,(stdout,"Matching String\n"));
	    if ((Length - Cursor >= LV_Len )
		&& !strncmp(pat_sub + Cursor, StrLoc(cresult), LV_Len)){
	       Cursor = Cursor + LV_Len;
	       goto Node_Succeed;
	       }
	    else
	       goto Node_Fail;
	    }
	 goto Node_Succeed;
	 }
      break;
      }

      /*
       *  Succeed
       */
   case  PC_Succeed: {
      DEBUGF(20,(stdout,"matching Succeed"));
      Push (Node);
      goto Node_Succeed;
      }

   case PC_Unanchored : {
      /* --  All done if we tried every position  */
      if (Cursor > Length )
	 goto Match_Fail;
      /* --  Otherwise extend the anchor point, and restack ourself */
      else{
	 Cursor++;
	 Push (Node);
	 goto Node_Succeed;
	 }
      }

      /*
       *  End of Pattern
       */
   case  PC_EOP: {
      if (Stack_Base == Stack_Init) {
	 goto Match_Succeed;
	 }
      /*
       *   End of recursive inner match. See separate section on
       *   handing of recursive pattern matches for details.
       */
      else {
	 Node = Stack[Stack_Base - 1].node;
	 Pop_Region();
	 goto Match;
	 }
      }
      }
   syserr("Unrecognized pcode in internal match.");
}

/* keep this at the end so the #undef Fail affects no-one else */
#undef Fail
function {1} Fail()
   abstract {
      return pattern;
      }
   body {
      union block *bp;
#ifdef PatternImage
      struct descrip image;
      AsgnCStr(image, "Fail()");
      bp = pattern_make(0, &EOP,PC_Fail,1, nulldesc, image);
#else					/* PatternImage */
      bp = pattern_make(0, &EOP,PC_Fail,1, nulldesc);
#endif					/* PatternImage */
      return pattern(bp);
      }
end

#endif					/* PatternType */

#
#  buffertextlist.icn - modified editabletextlist
#
#  Author: Nolan Clayton, Hani bani Salameh, Clinton Jeffery
#
#  Adds line numbers, syntax coloring and error highlighting for an
#  IDE to the generic EditableTextlist.
#
#  To do: separate out Unicon language dependency so it is extensible.
#

#
#  A scrollable editable text area.  An {Event} is generated whenever the
#  contents are changed by the user.
#
link graphics

import gui
import undo
import lang

$include "guih.icn"
$include "../unicon/ytab_h.icn"

class BuffEditableTextList : EditableTextList(
   moved,	# to-do: check if we need this and if so, implement it.
   mouse_locked,
   scroll_locked,
   vi,      #virtual line index
   undolist,# taken from old-version editabletextlist
   wordlist, # taken from old-version editabletextlist
   noedit, # taken from old-version editabletextlist
   startdragx, # taken from old-version editabletextlist
   enddragx, # taken from old-version editabletextlist
   startdragy, # taken from old-version editabletextlist
   enddragy, # taken from old-version editabletextlist
   donedrag, # taken from old-version editabletextlist
   highlightcolor, # taken from buffertextlist
   autoindent, # taken from buffertextlist
   scroll_y,  # taken from buffertextlist
   errorLineNumber,
   doReparse
   )

   method on_vsb(ev,y_coor,enter_here)
      if /enter_here & \scroll_locked then fail #lock scrollbar
      self.EditableTextList.on_vsb(ev)
      if \enter_here=1 then {
	 if \self.vsb then {
	    self.vsb.set_value(y_coor)
	    enter_here := 0
	    }
	 }
   end

   method on_hsb(ev,x_coor,enter_here)
      if /enter_here & \scroll_locked then fail#lock scrollbar
      self.EditableTextList.on_hsb(ev)
      if \enter_here=1 then {
	 if \self.hsb then {
	    self.hsb.set_value(x_coor)
	    enter_here := 0
	    }
	 }
   end

   method handle_press(e,received)
      if /received & \mouse_locked then fail #lock mouse
      self.EditableTextList.handle_press(e)
   end

   method handle_drag(e,received)
      if /received & \mouse_locked then fail #lock mouse
      self.EditableTextList.handle_drag(e)
   end

   method handle_release(e,received)
      if /received & \mouse_locked then fail #lock mouse
      self.EditableTextList.handle_release(e)
   end

   method handle_key_home(e)
      self.EditableTextList.handle_start_of_line(e)
   end

   method handle_key_end(e)
      self.EditableTextList.handle_end_of_line(e)
   end

   method handle_return(e)
      local i, str
      self.EditableTextList.handle_return(e)
      if \autoindent then{ 
	 str := contents[cursor_y - 1]
	 i := 1

         while i < *str + 1  do {	    
            case str[i] of { 
               " "     : handle_default(" ")
               #"\t"    : handle_tab_text("\t")
               default : i := *str +2
               }
            i +:= 1
	    }
        }
      # Reparse code when the cursor moves in the Y axis
      ReparseCode( )
   end

   #
   # Overrides default handle_event() re-parsing on line changes, etc.
   #
   method handle_event(e)
   local old_contents_size, old_mw, meth
       
      (\self.vsb).handle_event(e)
      (\self.hsb).handle_event(e)
      old_contents_size := *contents

      if e === (&lpress | &rpress) then
	 handle_press(e)
      else if integer(e) = &mpress then
	 simulate_wheelbutton()
      else if e === (&ldrag | &rdrag | &mdrag) then
	 handle_drag(e)
      else if e === (&lrelease | &rrelease | &mrelease) then
	 handle_release(e)
      else if \self.has_focus then {
	 meth := kmap.handle_key(e)
	 self.__m[meth](self,e)
      }

      if \moved then {
	 #
	 # Cursor moved.  Make sure still on screen; update scrollbars,
	 # and refresh text.
	 #
	 # Reparse code when the cursor moves in the Y axis
	 case e of {
	    Key_PgUp | Key_PgDn | Key_Up | Key_Down | Key_Home | Key_End : {
	       # Clear line error since the cursor moved
	       ReparseCode()
	       }
	    }
	 constrain_line()
	 refresh(1)
	 return _Event(e, self, 0)
	 }

      else if \changed then {
	 if ((*contents ~= old_contents_size) | \long_line | 
	    (old_mw ~= TextWidth(cwin, contents[long_line]))) then {
	    #
	    # Contents changed.  Re-compute all internal fields, ensure on
	    # screen and re-display whole object.
	    #
	    set_internal_fields()
	    constrain_line()
	    display()

	    # Set reparse flag
	    doReparse := 1
	    } 
	 else {
	    constrain_line()
	    refresh(1)
	    }
	 return _Event(e, self, 0)
      }
   end

   #
   # The virtual x position of a line in the canvas, except
   # that we have line numbering turned on at the left.
   #
   method get_left_pos()
      local lineno_space := 0
      # if \pegasus.line_no then
      #lineno_space := TextWidth(cwin,*contents) + 3
      lineno_space := 35
      return lineno_space +
         ((self.view.x - (\self.hsb).get_value()) | self.view.x)
   end

   method draw(subject_x, subject_y, vx, vy, vw, vh)
      local rev, first_line, last_line, xp, yp, i

      #
      # Which lines to draw
      #
      first_line := get_first_line()
      last_line := get_last_line()
      last_line >:= get_line_count()

      #
      # Where to draw them
      #
      yp := vy + self.line_height / 2

      #
      # Left offset
      #
      xp := vx - subject_x

      rev := Clone(self.cbwin, "drawop=reverse")

      #
      # Write the lines
      #
      every i := first_line to last_line do {
         draw_line(xp+35, yp, i, rev)
         yp +:= self.line_height
         }

      Uncouple(rev)
      rev := &null
      return
   end


   method draw_line(xp, yp, i, rev)
      local si, s, off, off1, off2, v, r, fh, asc, desc, yp2, cw

      fh := WAttrib(self.cbwin, "fheight")
      asc := WAttrib(self.cbwin, "ascent")
      desc := WAttrib(self.cbwin, "descent")
      v := self.view_list[i]
      s := v.str
      si := self.cursor_x - v.first + 1

      left_string(self.cbwin, xp, yp, detab(s, self.tab_width))

      Fg(self.cbwin, "pale greyish white")  #rectangle color
      yp2 :=  yp + ((asc - desc)/2) - asc
      FillRectangle(self.cbwin, xp - 35, yp2, 40, fh) #rectangle pos
      Fg(self.cbwin, "weak greyish blue")   #line_num color
      left_string(self.cbwin, xp - TextWidth(self.cwin, i) - 3 , yp, i)  #line_num pos

      Fg(cbwin, "black")

     # Check if an error line has been set.
      if \errorLineNumber then {
         # Check if this string belong to the error line
         if ( i = errorLineNumber ) then {
            # Set error line color (red)
            Fg( self.cbwin, "Red" )
            }
         }

      left_string_unicon ( self.cbwin, xp, yp, detab(s, tab_width), i )

      if (v.index = \self.cursor_y) & 
         (v.first <= \self.cursor_x <= v.last) then {
         if \self.has_focus then {
            cw := Clone(self.cbwin, "bg=red", "fg=white")
            off := TextWidthEx(self.cbwin, s, 1, si, self.tab_width)
            EraseRectangle(cw, xp + off, 1 + yp - self.line_height / 2, 
                           CharWidth(self.cbwin, s[si]), self.line_height)

            if s[si] ~== "\t" then
               left_string(cw, xp + off, yp + 1, s[si])

            Uncouple(cw)
            } 
         else {
            cw := Clone(self.cbwin, "fg=red")
            Rectangle(cw, 
                      xp + TextWidthEx(self.cbwin, s, 1, si, self.tab_width), 
                      1 + yp - self.line_height / 2, 
                      CharWidth(self.cbwin, s[si]), 
                      self.line_height)
            Uncouple(cw)
            }
         }

      if \self.mark_y then {
         if (self.mark_y < v.index < self.cursor_y) | 
            (self.mark_y > v.index > self.cursor_y) then {
            # Whole line selected
            r := [v.first, v.last]
            } 
         else if v.index = self.mark_y = self.cursor_y then {
            # Part of line
            if self.mark_x < self.cursor_x then {
               r := range(v.first, v.last, self.mark_x, self.cursor_x)
               }
            else if self.mark_x > self.cursor_x then {
               r := range(v.first, v.last, self.cursor_x + 1 , self.mark_x)
               }
            } 
         else if v.index = self.mark_y then {
            if self.mark_y < self.cursor_y then {
               r := range(v.first, v.last, self.mark_x, *self.contents[v.index] + 1)
               } 
            else {
               r := range(v.first, v.last, 1, self.mark_x)
               }
            } 
         else if v.index = self.cursor_y then {
            if self.mark_y > self.cursor_y then {
               r := range(v.first, v.last, self.cursor_x + 1, *self.contents[v.index] + 1)
               } 
            else {
               r := range(v.first, v.last, 1, self.cursor_x)
               }
            }
         if \r then {
            off1 := TextWidthEx(self.cbwin, s, 1, r[1] - v.first + 1, self.tab_width)
            off2 := TextWidthEx(self.cbwin, s, 1, r[2] - v.first + 1, self.tab_width)
            FillRectangle(rev, xp + off1, 1 + yp - self.line_height / 2,  off2 - off1, self.line_height)
            }
         }
   end

   method toggle_autoindent()
      if \autoindent then  autoindent:= &null
      else autoindent := 1
   end

   #Not a very good simulation !!!
   method simulate_wheelbutton()

      if \self.has_focus then {
         scroll_y := &y

         while Event() === &mdrag do {
            if &y > scroll_y then {
               handle_key_down()
               handle_key_down()
               handle_key_down()
               }

            if &y < scroll_y  then {
               handle_key_up()
               handle_key_up()
               handle_key_up()
              }
            self.constrain_line()
            self.refresh(1)
            }
         }
   end

   method highlight_line(i)
      start_handle()
      if /i  then i := 1
      if not(*contents >=  i > 1) then i := 1

      mark_x := 1
      mark_y := i
      cursor_y := i
      cursor_x := *contents[i] + 1
      end_handle()
   end

   # New left_string for the UniconTextList
   method left_string_unicon(win, x, y, s, currentLine)
      local i, token, last_s_Position, new_s_Position, off, remainder

      y +:= (WAttrib(win, "ascent") - WAttrib(win, "descent")) / 2
      # Check if an error line has been set.
      if \errorLineNumber then {
         # Check if this string belong to the error line
         if ( currentLine = errorLineNumber ) then {
            # Set error line color (red)
            Fg( win, "Red" )
            # Print the string
            DrawString( win, x, y, s )
            # Exit this method
            return
            }
         }	

      # Reinitialize error counter in the yyerror function.  This is done in
      # order to avoid the istop() function being called from within the
      # yyerror() function when the merr error counter gets to 10.  This is
      # only helpful within this syntax coloring procedure.
      yyerror( "reinitialize merr errors" )

      # Reinitialize lexical analyzer
      yyin := s
      yylex_reinit()

      # Initialize string s position variables
      off := 0
      new_s_Position  := 1
      last_s_Position := 1

      # Get string s tokens
      while (token := yylex()) ~=== EOFX do {
         # Set token color
         case token of {
            ABSTRACT | BREAK | BY | CASE | CLASS | CREATE | 
            DEFAULT | DO | ELSE | END | EVERY | FAIL | 
            GLOBAL | IF | IMPORT | INITIALLY | 
            iconINITIAL | INVOCABLE | LINK | LOCAL | 
            METHOD | NEXT | NOT | OF | PACKAGE | 
            PROCEDURE | RECORD | REPEAT | RETURN | STATIC | 
            SUSPEND | THEN | TO | UNTIL | WHILE | GLOBAL | 
            LOCAL                                         : Fg(win, "Blue")
            STRINGLIT | CSETLIT                           : Fg(win, "Dark Red")
            default                                       : Fg(win, "Black")
            }
            # Get token end position in string s
            new_s_Position := yytoken["column"] + *yytoken["s"] - 1
            # Print the string
            DrawString(win, x, y, s[ last_s_Position : (new_s_Position + 1)])
            # Get the printed text of string s offset
            off := TextWidth(win, s[ last_s_Position : (new_s_Position + 1)])

           # Get the new last string s starting position
           last_s_Position := new_s_Position + 1
           # Add the offset to the x position
           x +:= off
      }
      # Draw the rest of the string s that was not a token
      Fg( win, "green" ) #Green
      remainder := s[ last_s_Position : ( *s + 1 ) ]
      if *(trim(\remainder)) > 0 then
         DrawString( win, x, y, s[ last_s_Position : ( *s + 1 ) ] )
      Fg( win, "light green" ) #Light Green
   end

   method SetErrorLineNumber ( lineNumber )
      if lineNumber > *contents then
         errorLineNumber := *contents
      else
         errorLineNumber := lineNumber
   end

   method ReparseCode ()
      local s, rv, x, errorObject, timeElapsed, lineNumberOffset

      if doReparse == 1 then {
         # Get time spent in reparsing the code
         timeElapsed := &time
         # Clear errors
         SetErrorLineNumber ( 0 )

         # Initialize preprocessor variables
         uni_predefs := predefs()

         # Get the line number offset and the code
         s := []
         x := 1
         s |||:= GetCode()

         # Extract the line number offset		
         lineNumberOffset := s[1]

         # Remove the line number offset from the list
         pop( s )

         # Call the preprocessor but instead of passing a file name, 
         # we will pass a list containing the code
	 preproc_err_count := 0
         yyin := ""
         every yyin ||:= preprocessor(s, uni_predefs) do yyin ||:= "\n"
	 if preproc_err_count = 0 then {
	    # Reinitialize lexical analyzer
	    yylex_reinit()
	    # Initialize variables
	    /yydebug := 0
	    parsingErrors := []
	    # Reparse the code
	    rv := yyparse()
	    }
         # Display errors	
         if errors + (\yynerrs|0) + preproc_err_count > 0 then {
            every errorObject := !parsingErrors do {
               # display the error
               errorObject.lineNumber +:= lineNumberOffset
               SetErrorLineNumber( errorObject.lineNumber )
               MsgBox.set_contents([errorObject.lineNumber ||": " ||
                                   errorObject.errorMessage])
               }
            }
        else MsgBox.set_contents(["(no errors)"])
        doReparse := 0
        }	
   end

   method GetCode()
      local codeSubStringList, originalPositionY, currentPositionY, 
              startPositionY, endPositionY, token

      # Initialize positions	
      startPositionY := 0
      endPositionY := 0

      # Search up for the enclosing procedure, method or class
      originalPositionY := currentPositionY := cursor_y
      while currentPositionY > 0 do {
         # Reinitilize lexical analyzer
         yyin := contents[currentPositionY]
         yylex_reinit()
         # Get string s tokens
         while (token := yylex()) ~=== EOFX do {
            # Get tokens
            case token of {
               METHOD | PROCEDURE | CLASS : {
                  startPositionY := currentPositionY
                  break
                  }
               END : {
                  if originalPositionY ~= currentPositionY then {
                     startPositionY := currentPositionY + 1
                     break
                     }
                  }
               default : break
               }
            }
         if startPositionY ~= 0 then break
         # go up
         currentPositionY -:= 1
         }
      # Search down for the enclosing end
      currentPositionY := cursor_y
      while currentPositionY < *contents + 1 do {
         # Reinitialize lexical analyzer
         yyin := contents[ currentPositionY ]
         yylex_reinit()
         # Get string s tokens
         while ( token := yylex() ) ~=== EOFX do {
            # Get tokens
            case token of {
               END : {
                  endPositionY := currentPositionY
                  break
                  }
               CLASS | PROCEDURE | METHOD : {
                  endPositionY := currentPositionY - 1
                  break
                  }
               default : break
               }
            }
         if endPositionY ~= 0 then break
         # go down
         currentPositionY +:= 1
         }
      # Check if a valid enclosing end was found
      if endPositionY = 0 then {
         # Return all code
         codeSubStringList := [ 0 ] ||| contents 		
         return codeSubStringList
         }
      # Send only the enclosing sub string list
      if startPositionY = 0 then startPositionY := 1
      codeSubStringList := [ startPositionY ] ||| 
                           contents[ startPositionY : endPositionY + 1 ]
      # Return the sub string list
      return codeSubStringList
   end

   initially
      self$EditableTextList.initially()
      highlightcolor := "65535,65535,32428"
      autoindent := &null
      scroll_y := 1

      errorLineNumber := 0
      doReparse := 0

      # This variable comes from the unilex.icn file
      errors := 0
end

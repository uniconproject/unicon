# <p>
#   produces the absolute value of N.
#   <[param n]>
#   <[returns {1} integer]>
#   <[returns {1} real]>
# </p>
# Source: fconv.r
procedure abs(n)
end

# <p>
#   
#   <[param x]>
#   <[returns {0,1} empty_type]>
#   <[returns {0,1} t]>
# </p>
# Source: fconv.r
procedure t(x)
end

# <p>
#   produces a value of type string resulting from the conversion
#    of x, but fails if the conversion is not possible.
#   <[param x[n]]>
#   <[returns {0,1} string]>
#   <[returns {0,1} empty_type]>
# </p>
# Source: fconv.r
procedure string(x[n])
end

# <p>
#   produces an integer or real number resulting from the 
#   type conversion of x, but fails if the conversion is not possible.
#   <[param n]>
#   <[returns {0,1} integer]>
#   <[returns {0,1} empty_type]>
#   <[returns {0,1} real]>
# </p>
# Source: fconv.r
procedure numeric(n)
end

# <p>
#   convert x to a procedure if possible; use i to resolve 
#   ambiguous string names.
#   <[param x]>
#   <[param i]>
#   <[param c]>
#   <[returns {0,1} empty_type]>
#   <[returns {0,1} proc]>
# </p>
# Source: fconv.r
procedure proc(x,i,c)
end

# <p>
#   get information about columns in an ODBC table
#   <[param f]>
#   <[param table_name]>
#   <[returns {0,1} list]>
# </p>
# Source: fdb.r
procedure dbcolumns(f,table_name)
end

# <p>
#   get information about ODBC table primary keys
#   <[param f]>
#   <[param table_name]>
#   <[returns {1} list]>
# </p>
# Source: fdb.r
procedure dbkeys(f, table_name)
end

# <p>
#   submit an SQL query on an ODBC file f
#   <[param f]>
#   <[param query]>
#   <[returns {0,1} integer]>
# </p>
# Source: fdb.r
procedure sql(f, query)
end

# <p>
#   get information about an ODBC file column
#   <[param f]>
#   <[returns {0,1} list]>
# </p>
# Source: fdb.r
procedure dbtables(f)
end

# <p>
#   load C function dynamically.
#   <[param filename]>
#   <[param funcname]>
#   <[returns {0,1} proc]>
# </p>
# Source: fload.r
procedure loadfunc(filename,funcname)
end

# <p>
#   
#   <[param x]>
#   <[returns {1} real]>
# </p>
# Source: fmath.r
procedure funcname(x)
end

# <p>
#   r1, r2  in radians; if r2 is present, produces atan2(r1,r2).
#   <[param x]>
#   <[param y]>
#   <[returns {1} real]>
# </p>
# Source: fmath.r
procedure atan(x,y)
end

# <p>
#   logarithm of r1 to base r2.
#   <[param x]>
#   <[param b]>
#   <[returns {1} real]>
# </p>
# Source: fmath.r
procedure log(x,b)
end

# <p>
#   return the maximum of the arguments
#   <[param argv[argc]]>
#   <[returns {1} any_value]>
# </p>
# Source: fmath.r
procedure max(argv[argc])
end

# <p>
#   return the minimum of the arguments
#   <[param argv[argc]]>
#   <[returns {1} any_value]>
# </p>
# Source: fmath.r
procedure min(argv[argc])
end

# <p>
#   produce number of arguments for procedure x.
#   <[param x]>
#   <[param i]>
#   <[returns {0,1} any_value]>
#   <[returns {0,1} integer]>
# </p>
# Source: fmisc.r
procedure args(x,i)
end

# <p>
#   
#   <[param x[nargs]]>
# </p>
# Source: fmisc.r
procedure callout(x[nargs])
end

# <p>
#   produce a string consisting of character i.
#   <[param i]>
#   <[returns {1} string]>
# </p>
# Source: fmisc.r
procedure char(i)
end

# <p>
#   call garbage collector to ensure i2 bytes in region i1.
#    no longer works.
#   <[param region]>
#   <[param bytes]>
#   <[returns {1} null]>
# </p>
# Source: fmisc.r
procedure collect(region, bytes)
end

# <p>
#   make a copy of object x.
#   <[param x]>
#   <[returns {1} type(x)]>
# </p>
# Source: fmisc.r
procedure copy(x)
end

# <p>
#   display local variables of i most recent
#    procedure activations, plus global variables.
#   <[param i]>
#   <[param f]>
#   <[param c]>
#   <[returns {1} null]>
# </p>
# Source: fmisc.r
procedure display(i,f,c)
end

# <p>
#   clear error condition.
#   <[param ]>
#   <[returns {1} null]>
# </p>
# Source: fmisc.r
procedure errorclear()
end

# <p>
#   generate the names of the functions.
#   <[param ]>
#   <[returns {*} string]>
# </p>
# Source: fmisc.r
procedure function()
end

# <p>
#   
#   <[param i]>
#   <[param j]>
#   <[returns {1} integer]>
# </p>
# Source: fmisc.r
procedure func_name(i,j)
end

# <p>
#   produce bitwise complement (one's complement) of i.
#   <[param i]>
#   <[returns {1} integer]>
# </p>
# Source: fmisc.r
procedure icom(i)
end

# <p>
#   
#   <[param x]>
#   <[param i]>
#   <[returns {1} string]>
# </p>
# Source: fmisc.r
procedure pindex_image(x, i)
end

# <p>
#   return string image of object x.
#   <[param x]>
#   <[returns {1} string]>
# </p>
# Source: fmisc.r
procedure image(x)
end

# <p>
#   produce i shifted j bit positions (left if j<0, right if j>0).
#   <[param i]>
#   <[param j]>
#   <[returns {1} integer]>
# </p>
# Source: fmisc.r
procedure ishift(i,j)
end

# <p>
#   produce integer ordinal (value) of single character.
#   <[param s]>
#   <[returns {1} integer]>
# </p>
# Source: fmisc.r
procedure ord(s)
end

# <p>
#   return the name of a variable.
#   <[param underef v]>
#   <[param c]>
#   <[returns {0,1} string]>
# </p>
# Source: fmisc.r
procedure name(underef v, c)
end

# <p>
#   produce runtime error i with value x.
#   <[param i]>
#   <[param x[n]]>
# </p>
# Source: fmisc.r
procedure runerr(i,x[n])
end

# <p>
#   generate i, i+j, i+2*j, ... .
#   <[param from]>
#   <[param by]>
#   <[returns {1,*} integer]>
# </p>
# Source: fmisc.r
procedure seq(from, by)
end

# <p>
#   sort structure x by method i (for tables)
#   <[param t]>
#   <[param i]>
#   <[returns {1} store[type(t).tbl_key]>
#   <[returns {1} list(store[type(t).set_elem])]>
#   <[returns {1} type(t)]>
#   <[returns {1} type(t).tbl_val])]>
#   <[returns {1} list(store[type(t).all_fields])]>
#   <[returns {1} new]>
#   <[returns {1} list(new]>
#   <[returns {1} list(store[type(t).tbl_key]>
# </p>
# Source: fmisc.r
procedure sort(t, i)
end

# <p>
#   sort list or set x on field i of each member
#   <[param t]>
#   <[param i]>
#   <[returns {1} list(store[type(t).set_elem])]>
#   <[returns {1} type(t)]>
#   <[returns {1} list(any_value)]>
#   <[returns {1} new]>
# </p>
# Source: fmisc.r
procedure sortf(t, i)
end

# <p>
#   return type of x as a string.
#   <[param x]>
#   <[returns {1} string]>
# </p>
# Source: fmisc.r
procedure type(x)
end

# <p>
#   find the variable with name s and return a
#    variable descriptor which points to its value.
#   <[param s]>
#   <[param c]>
#   <[param i]>
#   <[param trap_local]>
#   <[returns {0,1} variable]>
# </p>
# Source: fmisc.r
procedure variable(s,c,i,trap_local)
end

# <p>
#   generate the fieldnames of record r
#   <[param r]>
#   <[returns {*} string]>
# </p>
# Source: fmisc.r
procedure fieldnames(r)
end

# <p>
#   transmit a co-expression failure to CE
#   <[param CE]>
#   <[returns {0,1} any_value]>
# </p>
# Source: fmisc.r
procedure cofail(CE)
end

# <p>
#   produce the names of local variables
#    in the procedure activation i levels up in ce
#   <[param ce]>
#   <[param i]>
#   <[returns {*} string]>
# </p>
# Source: fmisc.r
procedure localnames(ce,i)
end

# <p>
#   produce the names of static variables
#    in the current procedure activation in ce
#   <[param ce]>
#   <[param i]>
#   <[returns {*} string]>
# </p>
# Source: fmisc.r
procedure staticnames(ce,i)
end

# <p>
#   produce the names of the parameters
#    in the current procedure activation in ce
#   <[param ce]>
#   <[param i]>
#   <[returns {1,*} string]>
# </p>
# Source: fmisc.r
procedure paramnames(ce,i)
end

# <p>
#   load
#    a program corresponding to string s as a co-expression.
#   <[param s]>
#   <[param arglist]>
#   <[param infile]>
#   <[param outfile]>
#   <[param errfile]>
#   <[param 
		 blocksize]>
#   <[param stringsize]>
#   <[param stacksize]>
#   <[returns {1} coexpr]>
# </p>
# Source: fmisc.r
procedure load(s,arglist,infile,outfile,errfile,
		 blocksize, stringsize, stacksize)
end

# <p>
#   given a ce, return &main for that ce's parent
#   <[param ce]>
#   <[returns {1} coexpr]>
# </p>
# Source: fmisc.r
procedure parent(ce)
end

# <p>
#   given a ce, get or set that program's event mask
#   <[param ce]>
#   <[param cs]>
#   <[param vmask]>
#   <[returns {1} cset]>
#   <[returns {1} null]>
# </p>
# Source: fmisc.r
procedure eventmask(ce,cs,vmask)
end

# <p>
#   produce the names of identifiers global to ce
#   <[param ce]>
#   <[returns {*} string]>
# </p>
# Source: fmisc.r
procedure globalnames(ce)
end

# <p>
#   produce a keyword in ce's thread
#   <[param keyname]>
#   <[param ce]>
#   <[param i]>
#   <[returns {*} any_value]>
# </p>
# Source: fmisc.r
procedure keyword(keyname,ce,i)
end

# <p>
#   create and initialize a condition variable. Reuse the mutex mtx if it is supplied
#   <[param x]>
#   <[returns {1} integer]>
#   <[returns {1} list]>
# </p>
# Source: fmisc.r
procedure condvar(x)
end

# <p>
#   signal the condition variable x y times. Default y is 1, y=0 means broadcast
#   <[param x]>
#   <[param y]>
#   <[returns {0,1} coexpr]>
#   <[returns {0,1} integer]>
# </p>
# Source: fmisc.r
procedure signal(x, y)
end

# <p>
#   create and initialize a mutex. To be extended later to allow for naming mutexes.
#   <[param x]>
#   <[param y]>
#   <[returns {1} type(x)]>
#   <[returns {1} integer]>
# </p>
# Source: fmisc.r
procedure mutex(x, y)
end

# <p>
#   lock mutex x
#   <[param x]>
#   <[returns {1} type(x)]>
# </p>
# Source: fmisc.r
procedure lock(x)
end

# <p>
#   try locking mutex x
#   <[param x]>
#   <[returns {0,1} type(x)]>
# </p>
# Source: fmisc.r
procedure trylock(x)
end

# <p>
#   unlock mutex x
#   <[param x]>
#   <[returns {1} type(x)]>
# </p>
# Source: fmisc.r
procedure unlock(x)
end

# <p>
#   evaluate co-expression
#    or procedure x concurrently
#   <[param x]>
#   <[param blocksize]>
#   <[param stringsize]>
#   <[param stacksize]>
#   <[param soft]>
#   <[returns {0,1} coexpr]>
# </p>
# Source: fmisc.r
procedure spawn(x, blocksize, stringsize, stacksize, soft)
end

# <p>
#   read/write thread attributes
#   <[param argv[argc]]>
#   <[returns {1} integer]>
# </p>
# Source: fmisc.r
procedure Attrib(argv[argc])
end

# <p>
#   get devices info and their attributes
#   <[param argv[argc]]>
#   <[returns {1} integer]>
# </p>
# Source: fmisc.r
procedure opencl(argv[argc])
end

# <p>
#   send event with event code x and event value y.
#   <[param x]>
#   <[param y]>
#   <[param ce]>
# </p>
# Source: fmonitr.r
procedure EvSend(x,y,ce)
end

# <p>
#   read through the next event token having a code matched 
#    by cset c.
#   <[param cs]>
#   <[param vmask]>
#   <[param flag]>
# </p>
# Source: fmonitr.r
procedure EvGet(cs,vmask,flag)
end

# <p>
#   gets the istate attribute.
#   <[param ce]>
#   <[param attrib]>
#   <[returns {*} integer]>
# </p>
# Source: fmonitr.r
procedure istate(ce,attrib)
end

# <p>
#   move &pos by i, return substring of &subject spanned.
#    Reverses effects if resumed.
#   <[param i]>
#   <[returns {0,1+} string]>
# </p>
# Source: fscan.r
procedure move(i)
end

# <p>
#   test if &pos is at position i in &subject.
#   <[param i]>
#   <[returns {0,1} integer]>
# </p>
# Source: fscan.r
procedure pos(i)
end

# <p>
#   set &pos to i, return substring of &subject spanned.
#   Reverses effects if resumed.
#   <[param i]>
#   <[returns {0,1+} string]>
# </p>
# Source: fscan.r
procedure tab(i)
end

# <p>
#   pad s1 on left and right with s2 to length i.
#   <[param s1]>
#   <[param n]>
#   <[param s2]>
# </p>
# Source: fstr.r
procedure center(s1,n,s2)
end

# <p>
#   replace tabs with spaces, with stops at columns indicated.
#   <[param s]>
#   <[param i[n]]>
#   <[returns {1} string]>
# </p>
# Source: fstr.r
procedure detab(s,i[n])
end

# <p>
#   replace spaces with tabs, with stops at columns indicated.
#   <[param s]>
#   <[param i[n]]>
#   <[returns {1} string]>
# </p>
# Source: fstr.r
procedure entab(s,i[n])
end

# <p>
#   pad s1 on right with s2 to length i.
#   <[param s1]>
#   <[param n]>
#   <[param s2]>
# </p>
# Source: fstr.r
procedure left(s1,n,s2)
end

# <p>
#   map s1, using s2 and s3.
#   <[param s1]>
#   <[param s2]>
#   <[param s3]>
#   <[returns {1} string]>
# </p>
# Source: fstr.r
procedure map(s1,s2,s3)
end

# <p>
#   concatenate i copies of string s.
#   <[param s]>
#   <[param n]>
#   <[returns {1} type(s)]>
#   <[returns {1} string]>
# </p>
# Source: fstr.r
procedure repl(s,n)
end

# <p>
#   reverse string s.
#   <[param x]>
#   <[returns {1} type(x)]>
#   <[returns {1} string]>
# </p>
# Source: fstr.r
procedure reverse(x)
end

# <p>
#   pad s1 on left with s2 to length i.
#   <[param s1]>
#   <[param n]>
#   <[param s2]>
# </p>
# Source: fstr.r
procedure right(s1,n,s2)
end

# <p>
#   trim trailing characters in c from s.
#   <[param s]>
#   <[param c]>
#   <[param ends]>
#   <[returns {1} string]>
# </p>
# Source: fstr.r
procedure trim(s,c,ends)
end

# <p>
#   produces min(i1,i2)+1 if s[min(i1,i2)] is contained 
#   in c and i1 ~= i2, but fails otherwise.
#   <[param c]>
#   <[param s]>
#   <[param i]>
#   <[param j]>
# </p>
# Source: fstranl.r
procedure any(c,s,i,j)
end

# <p>
#   generates the sequence of integer positions in s up to
#    a character of c1 in s[i1:i2] that is balanced with respect to characters in
#   <[param c1]>
#   <[param c2]>
#   <[param c3]>
#   <[param s]>
#   <[param i]>
#   <[param j]>
# </p>
# Source: fstranl.r
procedure bal(c1,c2,c3,s,i,j)
end

# <p>
#   generates the sequence of positions in s2 at which 
#   s1 occurs as a substring in s2[i1:i2], but fails if there is no such position.
#   <[param s1]>
#   <[param s2]>
#   <[param i]>
#   <[param j]>
# </p>
# Source: fstranl.r
procedure find(s1,s2,i,j)
end

# <p>
#   produces the position in s after the longest initial 
#   sequence of characters in c in s[i1:i2] but fails if there is none.
#   <[param c]>
#   <[param s]>
#   <[param i]>
#   <[param j]>
# </p>
# Source: fstranl.r
procedure many(c,s,i,j)
end

# <p>
#   produces i1+*s1 if s1==s2[i1+:*s1], but fails otherwise.
#   <[param s1]>
#   <[param s2]>
#   <[param i]>
#   <[param j]>
# </p>
# Source: fstranl.r
procedure match(s1,s2,i,j)
end

# <p>
#   generates the sequence of integer positions in s up to a 
#   character in c in s[i2:i2], but fails if there is no such position.
#   <[param c]>
#   <[param s]>
#   <[param i]>
#   <[param j]>
# </p>
# Source: fstranl.r
procedure upto(c,s,i,j)
end

# <p>
#   delete element x2 from set, table, or list x1 if it is there
#    (always succeeds and returns x1).
#   <[param s]>
#   <[param x[n]]>
#   <[returns {1} **]>
#   <[returns {1} type(s)]>
#   <[returns {1} table]>
#   <[returns {1} (set]>
#   <[returns {1} list)]>
# </p>
# Source: fstruct.r
procedure delete(s, x[n])
end

# <p>
#   
#   <[param x]>
#   <[param i]>
#   <[returns {0,1} string]>
#   <[returns {0,1} store[type(x).lst_elem]]>
# </p>
# Source: fstruct.r
procedure get_or_pop(x,i)
end

# <p>
#   generate successive keys (entry values) from table T.
#   <[param t]>
#   <[returns {*} store[type(t).tbl_key]]>
#   <[returns {*} integer]>
#   <[returns {*} string]>
# </p>
# Source: fstruct.r
procedure key(t)
end

# <p>
#   insert element x2 into set or table x1 if not already there.
#    If x1 is a table, the assigned value for element x2 is x3.
#   <[param s]>
#   <[param x[n]]>
#   <[returns {1} type(s)]>
#   <[returns {1} string]>
# </p>
# Source: fstruct.r
procedure insert(s, x[n])
end

# <p>
#   get name of class for instance r
#   <[param r]>
#   <[returns {0,1} string]>
# </p>
# Source: fstruct.r
procedure classname(r)
end

# <p>
#   get list of the member vars for class instance r
#   <[param r]>
#   <[returns {0,1} list(string)]>
#   <[returns {0,1} new]>
# </p>
# Source: fstruct.r
procedure membernames(r)
end

# <p>
#   get list of method names for class instance r
#   <[param r]>
#   <[param cooked_names]>
#   <[returns {1} list(string)]>
#   <[returns {1} new]>
# </p>
# Source: fstruct.r
procedure methodnames(r, cooked_names)
end

# <p>
#   get list of methods for class instance r
#   <[param r]>
#   <[returns {1} list(proc)]>
#   <[returns {1} new]>
# </p>
# Source: fstruct.r
procedure methods(r)
end

# <p>
#   get list of methods for class instance r
#   <[param s]>
#   <[returns {1} list(proc)]>
#   <[returns {1} new]>
# </p>
# Source: fstruct.r
procedure methods_fromstr(s)
end

# <p>
#   get the operations record for class instance r
#   <[param r]>
#   <[returns {0,1} variable]>
# </p>
# Source: fstruct.r
procedure oprec(r)
end

# <p>
#   create a list of size i, with initial value x.
#   <[param n]>
#   <[param x]>
#   <[returns {1} list(store[type(n).set_elem])]>
#   <[returns {1} list(type(x))]>
#   <[returns {1} new]>
#   <[returns {1} type(n)]>
# </p>
# Source: fstruct.r
procedure list(n, x)
end

# <p>
#   returns x1 if x2 ... are members of x1 but fails otherwise.
#   x1 may be a set, cset, table, list, database file or record.
#   <[param s]>
#   <[param x[n]]>
#   <[returns {0,1} store[type(s).tbl_key]]>
#   <[returns {0,1} **]>
#   <[returns {0,1} type(s)]>
#   <[returns {0,1} store[type(s).set_elem]]>
#   <[returns {0,1} type(x)]>
#   <[returns {0,1} cset]>
#   <[returns {0,1} string]>
#   <[returns {0,1} store[type(x).lst_elem]]>
# </p>
# Source: fstruct.r
procedure member(s, x[n])
end

# <p>
#   pull an element from end of list L.
#   <[param x]>
#   <[param n]>
#   <[returns {0,1} store[type(x).lst_elem]]>
# </p>
# Source: fstruct.r
procedure pull(x,n)
end

# <p>
#   push x onto beginning of list L.
#   <[param x]>
#   <[param vals[n]]>
#   <[returns {1} type(x)]>
# </p>
# Source: fstruct.r
procedure push(x, vals[n])
end

# <p>
#   put elements onto end of list L.
#   <[param x]>
#   <[param vals[n]]>
#   <[returns {1} type(x)]>
# </p>
# Source: fstruct.r
procedure put(x, vals[n])
end

# <p>
#   create a set with members in list L.
#     The members are linked into hash chains which are
#   <[param x[n]]>
#   <[returns {1} ??]>
#   <[returns {1} set(empty_type)]>
#   <[returns {1} return]>
#   <[returns {1} set(type(x))]>
#   <[returns {1} anything]>
#   <[returns {1} should]>
#   <[returns {1} set(store[type(x).lst_elem])]>
#   <[returns {1} new]>
#   <[returns {1} be]>
#   <[returns {1} /*]>
#   <[returns {1} */]>
# </p>
# Source: fstruct.r
procedure set(x[n])
end

# <p>
#   create a table with default value x.
#   <[param x[n]]>
#   <[returns {1} type(x))]>
#   <[returns {1} empty_type]>
#   <[returns {1} new]>
#   <[returns {1} table(empty_type]>
# </p>
# Source: fstruct.r
procedure table(x[n])
end

# <p>
#   produce a new record constructor
#   <[param s]>
#   <[param x[n]]>
#   <[returns {1} proc]>
# </p>
# Source: fstruct.r
procedure constructor(s, x[n])
end

# <p>
#   
#   <[param x[n]]>
#   <[returns {1} real)]>
#   <[returns {1} new]>
#   <[returns {1} list(integer]>
# </p>
# Source: fstruct.r
procedure array(x[n])
end

# <p>
#   close file f.
#   <[param f]>
#   <[returns {0,1} file]>
#   <[returns {0,1} integer]>
# </p>
# Source: fsys.r
procedure close(f)
end

# <p>
#   exit process with status i, which defaults to 0.
#   <[param status]>
# </p>
# Source: fsys.r
procedure exit(status)
end

# <p>
#   return contents of environment variable s.
#   <[param s]>
#   <[returns {0,1} string]>
# </p>
# Source: fsys.r
procedure getenv(s)
end

# <p>
#   open file named s1 with options s2
#    and attributes given in trailing arguments.
#   <[param fname]>
#   <[param spec]>
#   <[param attr[n]]>
#   <[returns {0,1} file]>
# </p>
# Source: fsys.r
procedure open(fname, spec, attr[n])
end

# <p>
#   read line on file f.
#   <[param f]>
#   <[returns {0,1} string]>
# </p>
# Source: fsys.r
procedure read(f)
end

# <p>
#   read i characters on file f.
#   <[param f]>
#   <[param i]>
#   <[returns {0,1} string]>
# </p>
# Source: fsys.r
procedure reads(f,i)
end

# <p>
#   remove the file named s.
#   <[param s]>
#   <[returns {0,1} null]>
# </p>
# Source: fsys.r
procedure remove(s)
end

# <p>
#   rename the file named s1 to have the name s2.
#   <[param s1]>
#   <[param s2]>
#   <[returns {0,1} null]>
# </p>
# Source: fsys.r
procedure rename(s1,s2)
end

# <p>
#   save the run-time system in file s
#   <[param s]>
#   <[returns {0,1} integer]>
# </p>
# Source: fsys.r
procedure save(s)
end

# <p>
#   seek to offset i in file f.
#    [[ What about seek error ? ]]
#   <[param f]>
#   <[param o]>
#   <[returns {0,1} file]>
# </p>
# Source: fsys.r
procedure seek(f,o)
end

# <p>
#   create a new process, optionally mapping its stdin/stdout/stderr.
#   <[param argv]>
#   <[param d_stdin]>
#   <[param d_stdout]>
#   <[param d_stderr]>
#   <[param mode]>
#   <[returns {1} integer]>
#   <[returns {1} null]>
# </p>
# Source: fsys.r
procedure system(argv, d_stdin, d_stdout, d_stderr, mode)
end

# <p>
#   return current offset position in file f.
#   <[param f]>
#   <[returns {0,1} integer]>
# </p>
# Source: fsys.r
procedure where(f)
end

# <p>
#   return a character from console.
#   <[param ]>
#   <[returns {0,1} string]>
# </p>
# Source: fsys.r
procedure getch()
end

# <p>
#   return a character from console with echo.
#   <[param ]>
#   <[returns {0,1} string]>
# </p>
# Source: fsys.r
procedure getche()
end

# <p>
#   Check to see if there is a keyboard character waiting to be read.
#   <[param ]>
#   <[returns {0,1} null]>
# </p>
# Source: fsys.r
procedure kbhit()
end

# <p>
#   change working directory to s.
#   <[param s]>
#   <[returns {0,1} string]>
# </p>
# Source: fsys.r
procedure chdir(s)
end

# <p>
#   delay for i milliseconds.
#   <[param n]>
#   <[returns {0,1} null]>
# </p>
# Source: fsys.r
procedure delay(n)
end

# <p>
#   flush file f.
#   <[param f]>
#   <[returns {1} type(f)]>
# </p>
# Source: fsys.r
procedure flush(f)
end

# <p>
#   produce the next active window
#   <[param ]>
#   <[returns {0,1} file]>
# </p>
# Source: fwindow.r
procedure Active()
end

# <p>
#   Alert the user
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure Alert(argv[argc])
end

# <p>
#   background color
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure Bg(argv[argc])
end

# <p>
#   set context clip rectangle
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure Clip(argv[argc])
end

# <p>
#   create a new context bound to w's canvas
#   <[param argv[argc]]>
#   <[returns {1} Graphics3D]>
#   <[returns {1} return]>
#   <[returns {1} file]>
#   <[returns {1} record]>
#   <[returns {1} #endif]>
#   <[returns {1} /*]>
#   <[returns {1} */]>
#   <[returns {1} #else]>
# </p>
# Source: fwindow.r
procedure Clone(argv[argc])
end

# <p>
#   return or set color map entries
#   <[param argv[argc]]>
#   <[returns {0,1} file]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure Color(argv[argc])
end

# <p>
#   produce RGB components from string color name
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure ColorValue(argv[argc])
end

# <p>
#   copy area
#   <[param argv[argc]]>
#   <[returns {0,1} file]>
# </p>
# Source: fwindow.r
procedure CopyArea(argv[argc])
end

# <p>
#   couple canvas to context
#   <[param w]>
#   <[param w2]>
#   <[returns {0,1} file]>
# </p>
# Source: fwindow.r
procedure Couple(w,w2)
end

# <p>
#   {1} - draw arc
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawArc(argv[argc])
end

# <p>
#   {1} - draw circle
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawCircle(argv[argc])
end

# <p>
#   {1} - draw curve
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawCurve(argv[argc])
end

# <p>
#   draw bitmapped figure
#   <[param argv[argc]]>
#   <[returns {0,1} integer]>
#   <[returns {0,1} null]>
# </p>
# Source: fwindow.r
procedure DrawImage(argv[argc])
end

# <p>
#   {1} - draw line
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawLine(argv[argc])
end

# <p>
#   {1} - draw point
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawPoint(argv[argc])
end

# <p>
#   {1} - draw polygon
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawPolygon(argv[argc])
end

# <p>
#   {1} - draw rectangle
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawRectangle(argv[argc])
end

# <p>
#   {1} - draw line segment
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawSegment(argv[argc])
end

# <p>
#   {1} - draw text
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure DrawString(argv[argc])
end

# <p>
#   clear an area of the window
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure EraseArea(argv[argc])
end

# <p>
#   return an event from a window
#   <[param argv[argc]]>
#   <[returns {1} integer]>
#   <[returns {1} string]>
# </p>
# Source: fwindow.r
procedure Event(argv[argc])
end

# <p>
#   foreground color
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure Fg(argv[argc])
end

# <p>
#   {1} - fill arc
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure FillArc(argv[argc])
end

# <p>
#   {1} - draw filled circle
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure FillCircle(argv[argc])
end

# <p>
#   {1} - fill polygon
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure FillPolygon(argv[argc])
end

# <p>
#   {1} - draw filled rectangle
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure FillRectangle(argv[argc])
end

# <p>
#   get/set font
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure Font(argv[argc])
end

# <p>
#   free colors
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure FreeColor(argv[argc])
end

# <p>
#   move cursor to a particular text row and column
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure GotoRC(argv[argc])
end

# <p>
#   move cursor to a particular pixel location
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure GotoXY(argv[argc])
end

# <p>
#   lower w to the bottom of the window stack
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure Lower(argv[argc])
end

# <p>
#   allocate an entry in the color map
#   <[param argv[argc]]>
#   <[returns {0,1} integer]>
# </p>
# Source: fwindow.r
procedure NewColor(argv[argc])
end

# <p>
#   return the characters forming keys to palette p
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure PaletteChars(argv[argc])
end

# <p>
#   return color of key s in palette p
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure PaletteColor(argv[argc])
end

# <p>
#   return key of closest color to s in palette p
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure PaletteKey(argv[argc])
end

# <p>
#   sets the context fill pattern by string name
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure Pattern(argv[argc])
end

# <p>
#   produce a list of events pending on window
#   <[param argv[argc]]>
#   <[returns {0,1} list]>
# </p>
# Source: fwindow.r
procedure Pending(argv[argc])
end

# <p>
#   produce the contents of some pixels
#   <[param argv[argc]]>
#   <[returns {3} integer]>
#   <[returns {3} string]>
# </p>
# Source: fwindow.r
procedure Pixel(argv[argc])
end

# <p>
#   produce mouse position
#   <[param w]>
#   <[returns {0,2} integer]>
# </p>
# Source: fwindow.r
procedure QueryPointer(w)
end

# <p>
#   raise w to the top of the window stack
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure Raise(argv[argc])
end

# <p>
#   load image file
#   <[param argv[argc]]>
#   <[returns {0,1} integer]>
# </p>
# Source: fwindow.r
procedure ReadImage(argv[argc])
end

# <p>
#   synchronize with server
#   <[param w]>
#   <[returns {1} file]>
#   <[returns {1} null]>
# </p>
# Source: fwindow.r
procedure WSync(w)
end

# <p>
#   compute text pixel width
#   <[param argv[argc]]>
#   <[returns {1} integer]>
# </p>
# Source: fwindow.r
procedure TextWidth(argv[argc])
end

# <p>
#   uncouple window
#   <[param w]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure Uncouple(w)
end

# <p>
#   read/write window attributes
#   <[param argv[argc]]>
#   <[returns {*} file]>
#   <[returns {*} integer]>
#   <[returns {*} string]>
# </p>
# Source: fwindow.r
procedure WAttrib(argv[argc])
end

# <p>
#   get a default value from the environment
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure WDefault(argv[argc])
end

# <p>
#   flush all output to window w
#   <[param argv[argc]]>
#   <[returns {1} file]>
# </p>
# Source: fwindow.r
procedure WFlush(argv[argc])
end

# <p>
#   write an image to a file
#   <[param argv[argc]]>
#   <[returns {0,1} file]>
# </p>
# Source: fwindow.r
procedure WriteImage(argv[argc])
end

# <p>
#   return the application associated with an extension
#   <[param ext]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure WinAssociate(ext)
end

# <p>
#   play a multimedia resource
#   <[param argv[argc]]>
#   <[returns {0,1} null]>
# </p>
# Source: fwindow.r
procedure WinPlayMedia(argv[argc])
end

# <p>
#   install a pushbutton with label s on window w
#   <[param argv[argc]]>
#   <[returns {0,1} file]>
# </p>
# Source: fwindow.r
procedure WinButton(argv[argc])
end

# <p>
#   install a scrollbar
#   <[param argv[argc]]>
#   <[returns {0,1} file]>
# </p>
# Source: fwindow.r
procedure WinScrollBar(argv[argc])
end

# <p>
#   install a set of top-level menus
#   <[param argv[argc]]>
#   <[returns {0,1} file]>
# </p>
# Source: fwindow.r
procedure WinMenuBar(argv[argc])
end

# <p>
#   = install an edit box with label s
#   <[param argv[argc]]>
#   <[returns {0, 2} file]>
#   <[returns {0, 2} string]>
# </p>
# Source: fwindow.r
procedure WinEditRegion(argv[argc])
end

# <p>
#   choose a color for a window's context
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure WinColorDialog(argv[argc])
end

# <p>
#   choose a font for a window's context
#   <[param argv[argc]]>
#   <[returns {0,2} string]>
# </p>
# Source: fwindow.r
procedure WinFontDialog(argv[argc])
end

# <p>
#   choose a file to open
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure WinOpenDialog(argv[argc])
end

# <p>
#   select from a set of choices
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure WinSelectDialog(argv[argc])
end

# <p>
#   choose a file to save
#   <[param argv[argc]]>
#   <[returns {0,1} string]>
# </p>
# Source: fwindow.r
procedure WinSaveDialog(argv[argc])
end

# <p>
#   draw a torus
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure DrawTorus(argv[argc])
end

# <p>
#   {1} - draw a cube
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure DrawCube(argv[argc])
end

# <p>
#   {1} - draw a sphere
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure DrawSphere(argv[argc])
end

# <p>
#   {1} - draw a cylinder
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure DrawCylinder(argv[argc])
end

# <p>
#   {1} - draw a disk
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure DrawDisk(argv[argc])
end

# <p>
#   {1} - get/set eye attributes
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure Eye(argv[argc])
end

# <p>
#   {1} - rotates objects
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure Rotate(argv[argc])
end

# <p>
#   {1} - translates objects
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure Translate(argv[argc])
end

# <p>
#   {1} - scales objects
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure Scale(argv[argc])
end

# <p>
#   {1} - pop the matrix stack
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure PopMatrix(argv[argc])
end

# <p>
#   {1} - push a copy of the top matrix onto the matrix stack
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure PushMatrix(argv[argc])
end

# <p>
#   {1} - push a copy of the top matrix onto the matrix stack and apply translations
#   <[param argv[argc]]>
#   <[returns {2} record]>
# </p>
# Source: fwindow.r
procedure PushTranslate(argv[argc])
end

# <p>
#   {1} - push a copy of the top matrix onto the matrix stack and apply rotations
#   <[param argv[argc]]>
#   <[returns {2} record]>
# </p>
# Source: fwindow.r
procedure PushRotate(argv[argc])
end

# <p>
#   {1} - push a copy of the top matrix onto the matrix stack and apply scales
#   <[param argv[argc]]>
#   <[returns {2} record]>
# </p>
# Source: fwindow.r
procedure PushScale(argv[argc])
end

# <p>
#   {1} - change the top matrix to the identity
#   <[param argv[argc]]>
#   <[returns {1} record]>
# </p>
# Source: fwindow.r
procedure IdentityMatrix(argv[argc])
end

# <p>
#   {1} - use the matrix stack specified by s
#   <[param argv[argc]]>
#   <[returns {1} record]>
# </p>
# Source: fwindow.r
procedure MatrixMode(argv[argc])
end

# <p>
#   apply the texture defined by the string or window x as a texture
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure Texture(argv[argc])
end

# <p>
#   {1} - set texture coordinate to those defined by the string s or the list L
#   <[param argv[argc]]>
#   <[returns {1} list]>
# </p>
# Source: fwindow.r
procedure Texcoord(argv[argc])
end

# <p>
#   
#   <[param argv[argc]]>
#   <[returns {1} list]>
# </p>
# Source: fwindow.r
procedure Normals(argv[argc])
end

# <p>
#   {1} - multiply transformation matrix by the list L
#   <[param argv[argc]]>
#   <[returns {1} list]>
# </p>
# Source: fwindow.r
procedure MultMatrix(argv[argc])
end

# <p>
#   {1} - redraws the window
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure Refresh(argv[argc])
end

# <p>
#   {1} - returns an Icon list of lists, which contains all objects drawn on window
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure WindowContents(argv[argc])
end

# <p>
#   {1} - mark section
#   <[param argv[argc]]>
# </p>
# Source: fwindow.r
procedure WSection(argv[argc])
end

# <p>
#   Play audio file.
#   <[param fname]>
#   <[returns {0,1} integer]>
# </p>
# Source: fxaudio.ri
procedure PlayAudio(fname)
end

# <p>
#   
#   <[param f]>
#   <[returns {1} integer]>
# </p>
# Source: fxaudio.ri
procedure StopAudio(f)
end

# <p>
#   set voice attribute.
#   <[param f]>
#   <[param attrib]>
#   <[returns {0,1} integer]>
#   <[returns {0,1} string]>
#   <[returns {0,1} list]>
# </p>
# Source: fxaudio.ri
procedure VAttrib(f,attrib)
end

# <p>
#   perform an interrupt
#   <[param a]>
#   <[returns {1} list]>
# </p>
# Source: fxmsdos.ri
procedure Int86(a)
end

# <p>
#   read from memory
#   <[param addr]>
#   <[param len]>
#   <[returns {1} string]>
# </p>
# Source: fxmsdos.ri
procedure Peek(addr,len)
end

# <p>
#   write to memory
#   <[param addr]>
#   <[param s]>
#   <[returns {1} null]>
# </p>
# Source: fxmsdos.ri
procedure Poke(addr,s)
end

# <p>
#   allocate memory block
#   <[param i]>
#   <[returns {1} integer]>
# </p>
# Source: fxmsdos.ri
procedure GetSpace(i)
end

# <p>
#   free allocated memory block
#   <[param a]>
#   <[returns {1} null]>
# </p>
# Source: fxmsdos.ri
procedure FreeSpace(a)
end

# <p>
#   return a value from port i
#   <[param i]>
#   <[returns {1} integer]>
# </p>
# Source: fxmsdos.ri
procedure InPort(i)
end

# <p>
#   write i2 to port i1
#   <[param i1]>
#   <[param i2]>
#   <[returns {1} null]>
# </p>
# Source: fxmsdos.ri
procedure OutPort(i1,i2)
end

# <p>
#   
#   <[param LPAT]>
#   <[param RPAT]>
#   <[returns {1} pattern]>
# </p>
# Source: fxpattrn.ri
procedure pattern_alternate (LPAT, RPAT )
end

# <p>
#   get the error string corresponding to an &errno value.
#   <[param e]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure sys_errstr(e)
end

# <p>
#   get parent pid.
#   <[param ]>
#   <[returns {0,1} integer]>
# </p>
# Source: fxposix.ri
procedure getppid()
end

# <p>
#   get process pid.
#   <[param ]>
#   <[returns {0,1} integer]>
# </p>
# Source: fxposix.ri
procedure getpid()
end

# <p>
#   create a link to a file.
#   <[param s1]>
#   <[param s2]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure hardlink(s1, s2)
end

# <p>
#   create a symlink to a file.
#   <[param s1]>
#   <[param s2]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure symlink(s1, s2)
end

# <p>
#   read a symbolic link.
#   <[param s]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure readlink(s)
end

# <p>
#   send a signal to a process.
#   <[param pid]>
#   <[param signal]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure kill(pid, signal)
end

# <p>
#   trap a signal.
#   <[param nsignal]>
#   <[param handler]>
#   <[returns {0,1} proc]>
# </p>
# Source: fxposix.ri
procedure trap(nsignal, handler)
end

# <p>
#   change the owner of a file.
#   <[param s]>
#   <[param u]>
#   <[param g]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure chown(s, u, g)
end

# <p>
#   change the permission on a file.
#   <[param s]>
#   <[param m]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure chmod(s, m)
end

# <p>
#   change the root directory.
#   <[param d]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure chroot(d)
end

# <p>
#   remove an empty directory.
#   <[param s]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure rmdir(s)
end

# <p>
#   make a new directory.
#   <[param s]>
#   <[param m]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure mkdir(s, m)
end

# <p>
#   truncate a file at a certain position.
#   <[param f]>
#   <[param l]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure truncate(f, l)
end

# <p>
#   apply or remove a lock on a file.
#   <[param f]>
#   <[param cmd]>
#   <[returns {0} null]>
# </p>
# Source: fxposix.ri
procedure flock(f, cmd)
end

# <p>
#   control a file.
#   <[param f]>
#   <[param action]>
#   <[param options]>
#   <[returns {0,1} integer]>
#   <[returns {0,1} string]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure fcntl(f, action, options)
end

# <p>
#   set access and/or modification times on a file.
#   <[param f]>
#   <[param atime]>
#   <[param mtime]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure utime(f, atime, mtime)
end

# <p>
#   control a device driver.
#   <[param f]>
#   <[param action]>
#   <[param options]>
#   <[returns {0,1} integer]>
# </p>
# Source: fxposix.ri
procedure ioctl(f, action, options)
end

# <p>
#   create a connected bidirectional pair of files.
#   <[param ]>
#   <[returns {0,1} list(file)]>
#   <[returns {0,1} new]>
# </p>
# Source: fxposix.ri
procedure filepair()
end

# <p>
#   create a pipe.
#   <[param ]>
#   <[returns {0,1} list(file)]>
#   <[returns {0,1} new]>
# </p>
# Source: fxposix.ri
procedure pipe()
end

# <p>
#   spawn a new identical process.
#   <[param ]>
#   <[returns {0,1} integer]>
# </p>
# Source: fxposix.ri
procedure fork()
end

# <p>
#   duplicate a file (including its Unix fd).
#   <[param src]>
#   <[param dest]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure fdup(src, dest)
end

# <p>
#   replace the executing Icon program with a new program.
#   <[param f]>
#   <[param argv[argc]]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure exec(f, argv[argc])
end

# <p>
#   get the real user identity.
#   <[param ]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure getuid()
end

# <p>
#   get the effective user identity.
#   <[param ]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure geteuid()
end

# <p>
#   get the real group identity.
#   <[param ]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure getgid()
end

# <p>
#   get the effective group identity.
#   <[param ]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure getegid()
end

# <p>
#   set the real and/or effective user identity.
#   <[param u]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure setuid(u)
end

# <p>
#   set the real and/or effective group identity.
#   <[param g]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure setgid(g)
end

# <p>
#   get the process group.
#   <[param ]>
#   <[returns {0,1} integer]>
# </p>
# Source: fxposix.ri
procedure getpgrp()
end

# <p>
#   set the process group.
#   <[param ]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure setpgrp()
end

# <p>
#   the password encryption function.
#   <[param key]>
#   <[param salt]>
#   <[returns {0} string]>
# </p>
# Source: fxposix.ri
procedure crypt(key, salt)
end

# <p>
#   set the umask and return the old value.
#   <[param mask]>
#   <[returns {0,1} integer]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure umask(mask)
end

# <p>
#   wait for process (or co-exp thread) to terminate or stop.
#   the return value is `status' from the wait(2) manpage.
#   <[param pid]>
#   <[param options]>
#   <[returns {0,1} coexpr]>
#   <[returns {0,1} integer]>
#   <[returns {0,1} string]>
# </p>
# Source: fxposix.ri
procedure wait(pid, options)
end

# <p>
#   get time since the epoch (Jan 1, 1970 00:00:00).
#   <[param ]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure gettimeofday()
end

# <p>
#   get resource usage.
#   <[param who]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure getrusage(who)
end

# <p>
#   get file status without following symlinks.
#   <[param f]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure lstat(f)
end

# <p>
#   get file status.
#   <[param f]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure stat(f)
end

# <p>
#   send a UDP datagram.
#   <[param addr]>
#   <[param msg]>
#   <[param timeout]>
#   <[param fam]>
#   <[returns {0,1} integer]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure send(addr, msg, timeout, fam)
end

# <p>
#   receive a UDP datagram.
#   <[param f]>
#   <[param timeout]>
#   <[returns {0,1} any_value]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure receive(f, timeout)
end

# <p>
#   fetch a value from a dbm database.
#   <[param d]>
#   <[param k]>
#   <[returns {0,1} string]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure fetch(d, k)
end

# <p>
#   wait for i/o to be available on files.
#   <[param files[nargs]]>
#   <[returns {0,1} list(file)]>
#   <[returns {0,1} new]>
# </p>
# Source: fxposix.ri
procedure select(files[nargs])
end

# <p>
#   get password file information.
#   <[param u]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure getpw(u)
end

# <p>
#   get group information.
#   <[param g]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure getgr(g)
end

# <p>
#   get host information.
#   <[param h]>
#   <[param f]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure gethost(h, f)
end

# <p>
#   get network service information.
#   <[param s]>
#   <[param proto]>
#   <[returns {0,1} record]>
# </p>
# Source: fxposix.ri
procedure getserv(s, proto)
end

# <p>
#   reset the password file.
#   <[param ]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure setpwent()
end

# <p>
#   reset the group file.
#   <[param ]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure setgrent()
end

# <p>
#   reset host processing.
#   <[param so]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure sethostent(so)
end

# <p>
#   reset network service entry processing.
#   <[param so]>
#   <[returns {0,1} null]>
# </p>
# Source: fxposix.ri
procedure setservent(so)
end

# <p>
#   low level non-blocking read with no buffering.
#   <[param f]>
#   <[param i]>
#   <[returns {0, 1} string]>
# </p>
# Source: fxposix.ri
procedure ready(f, i)
end

# <p>
#   low level write with no buffering.
#   <[param f]>
#   <[param s]>
#   <[returns {0, 1} integer]>
# </p>
# Source: fxposix.ri
procedure syswrite(f, s)
end

# <p>
#   set an environment variable.
#   <[param name]>
#   <[param value]>
#   <[returns {0, 1} null]>
# </p>
# Source: fxposix.ri
procedure setenv(name, value)
end


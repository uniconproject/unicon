/*
 * ropengl2d.ri - OpenGL-specific runtime file for the 2D graphics facilities.
 *
 * For easier searching:
 *
 * (1) OpenGL 2D utility functions
 * (2) Drawing functions
 * (3) Context attribute functions
 * (4) Window management functions (platform independent)
 * (5) Window management functions (platform specific)
 */

/*
 * #define for debugging
 */
//#define GL2D_IMMEDIATE_RENDER 1

/*
 * Macros
 */
/*
 * Make sure {desc} and {ap} are tended.
 * Would like to move to rmacros.h, but gets compilation error. Problem
 * with Protect() macro.
 */
#define AlcRealarrayList(desc, ap, size, failval) do {\
   if (!reserve(Blocks, (word)(sizeof(struct b_list) +\
                               sizeof(struct b_realarray) +\
                               (size-1)*sizeof(double))))\
      return failval;\
   Protect(ap = (struct b_realarray *)alcrealarray(size), return failval);\
   Protect(BlkLoc(desc) = (union block *)alclisthdr(size, (union block *)ap),\
           return failval);\
   (desc).dword = D_List;\
   (ap)->dims = NULL;\
   } while(0)

#define DEFAULTFONTNAME "mono"

/*
 * debugging prototypes
 */
void print_arc(struct b_record *rp, const char *s);
void print_pixmap(unsigned char *pixmap, int nbytes, int width, int height,
   char *s);
void print_bitmap(unsigned char *bitmap, int width, int height, char *s);
void printlist2d(wsp ws);
char *getDLiteminfo2d(struct b_record *rp);

/*
 * prototypes
 */
struct b_record *getlastlistitem(wbp w, int intcode);
void bitmap_to_pixmap(unsigned char *bitmap, int width, int height,
   unsigned char *pixmap, int invert, int bitorder);
int traverselist2d(wbp w, struct b_lelem *bp, int start, int end, int used,
   word k);

struct b_list *segment_line(wbp w, int num, struct b_realarray * ap2,
   double *v2, word n2);

static wfp loadfont(wdp wd, char *s, int len);
char *find_fontfile(char *family, int flags);

int write_xbm(char *filename, int width, int height, unsigned char *pixmap,
   unsigned char bg[4]);
int write_xpm(char *filename, int width, int height, unsigned char *pixmap);
char *load_xbm(char *filename, unsigned int *width, unsigned int *height);
char *load_xpm(wbp w, char *filename, unsigned int *width,
    unsigned int *height);

/*
 * Debugging print functions for 2d primitives
 */
#ifdef GL2D_DEBUG
void print_bitmap(unsigned char *bitmap, int width, int height, char *s)
   {
   int bmwidth, ix, iy;
   unsigned char bitmask;
   glprintf("%s\n",s);

   bmwidth = width/8 + 1;

   for (iy=height-1; iy>=0; iy--) {
      for (ix=0; ix<width; ix++) {
         bitmask = 1 << (7 - ix%8);
         if (bitmap[iy*bmwidth+ix/8] & bitmask)
            glprintf("1 ");
         else
            glprintf("0 ");
         }
      glprintf("\n");
      }
   }
#else                                   /* GL2D_DEBUG */
void print_bitmap(unsigned char *bitmap, int width, int height, char *s)
   {
   }
#endif                                  /* GL2D_DEBUG */

#ifdef GL2D_DEBUG
void print_arc(struct b_record *rp, const char *s)
   {
   double v1, v2, v3, v4, v5, v6;
   int tmp;
   struct b_proc *pp;

   if (rp == NULL) {
      glprintf("rp is NULL\n");
      return;
      }

   pp = Blk(rp->recdesc,Proc);
   //glprintf("name: %s, title: %ld, blksize: %ld, nfields: %ld\n",\
              StrLoc(pp->recname),pp->title,pp->blksize,pp->nfields);

   /* check values */
   switch (tmp = IntVal(rp->fields[1])) {
      case GL2D_FILLCIRCLE:
      case GL2D_DRAWCIRCLE:
         GetReal(&(rp->fields[2]),v1);
         GetReal(&(rp->fields[3]),v2);
         GetReal(&(rp->fields[4]),v3);
         GetReal(&(rp->fields[5]),v4);
         GetReal(&(rp->fields[6]),v5);
         glprintf("%s(%s: %ld) %s: %f, %s: %f, %s: %f, %s: %f, %s: %f\n",s,\
                  StrLoc(rp->fields[0]),rp->id,StrLoc(pp->lnames[2]),v1,\
                  StrLoc(pp->lnames[3]),v2,StrLoc(pp->lnames[4]),v3,\
                  StrLoc(pp->lnames[5]),v4,StrLoc(pp->lnames[6]),v5);
         break;
      case GL2D_FILLARC:
      case GL2D_DRAWARC:
         GetReal(&(rp->fields[2]),v1);
         GetReal(&(rp->fields[3]),v2);
         GetReal(&(rp->fields[4]),v3);
         GetReal(&(rp->fields[5]),v4);
         GetReal(&(rp->fields[6]),v5);
         GetReal(&(rp->fields[7]),v6);
         glprintf("%s(%s: %ld) %s: %f, %s: %f, %s: %f, %s: %f, %s: %f, %s: %f"\
                  "\n",s,StrLoc(rp->fields[0]),rp->id,StrLoc(pp->lnames[2]),\
                  v1,StrLoc(pp->lnames[3]),v2,StrLoc(pp->lnames[4]),v3,\
                  StrLoc(pp->lnames[5]),v4,StrLoc(pp->lnames[6]),v5,\
                  StrLoc(pp->lnames[7]),v6);
         break;
      default:
         glprintf("got code %d\n",tmp);
      }
   }
#else                                   /* GL2D_DEBUG */
void print_arc(struct b_record *rp, const char *s)
   {
   }
#endif                                  /* GL2D_DEBUG */

#ifdef GL2D_DEBUG
void print_pixmap(unsigned char *pixmap, int nbytes, int width, int height,
   char *s)
   {
   int i, j, rwidth;

   rwidth = width*nbytes;

   glprintf("%s\n",s);
   for (j=height-1; j>=0; j--) {
      for (i=0; i<rwidth; i++) {
/*
         switch (nbytes) {
            case 1: glprintf("%1d ",pixmap[j*rwidth + i]); break;
            default: glprintf("%3d ",pixmap[j*rwidth + i]); break;
            }
*/
         glprintf("%3d ",pixmap[j*rwidth + i]);
         }
      glprintf("\n");
      }
   }
#else                                   /* GL2D_DEBUG */
void print_pixmap(unsigned char *pixmap, int nbytes, int width, int height,
   char *s)
   {
   }
#endif                                  /* GL2D_DEBUG */

#ifdef GL2D_DEBUG
void printlist2d(wsp ws)
   {
   if (is:list(ws->funclist2d)) {
      struct b_lelem *bp;
      struct b_list *lp;
      word i, size, used, k;

      lp = BlkD(ws->funclist2d, List);
      size = lp->size;

      bp = (struct b_lelem *)BlkD(ws->funclist2d, List)->listhead;

      if (bp->nused<=0) {
         bp = (struct b_lelem *) bp->listnext;
         lp->listhead = (union block *) bp;
         bp->listprev = (union block *) lp;
         }

      used = bp->nused;
      k = bp->first;
      for (i = 0; i < size; i++) {
         struct b_record *rp;
         struct descrip desc;

         desc = bp->lslots[k++];
         used--;
         if (used <= 0) {
            bp = (struct b_lelem *) bp->listnext;
            k = bp->first;
            used = bp->nused;
            }
         if (!is:record(desc)) {
            glprintf("item %ld is not a record\n",i);
            break;
            }

         rp = BlkD(desc, Record);
         glprintf("(%ld) %s\n",i,getDLiteminfo2d(rp));
         }
      }
   }
#else                                   /* GL2D_DEBUG */
void printlist2d(wsp ws)
   {
   }
#endif                                  /* GL2D_DEBUG */


/*
 * Debugging print function for display list items (records).
 */
#ifdef GL2D_DEBUG
#define GetRealarray(desc, s, val) do {\
   struct b_list *lp;\
   struct b_realarray *ap;\
   word i, n;\
   lp = (struct b_list *)BlkD(desc,List);\
   n = lp->size;\
   ap = (struct b_realarray *)lp->listhead;\
   v = ap->a;\
   for (i = val; i < n; i++) {\
      if (i == n-1)\
         s += sprintf(s,"%f",v[i]);\
      else\
         s += sprintf(s,"%f, ",v[i]);\
      }\
   } while(0)

char *getDLiteminfo2d(struct b_record *rp)
   {
   static char buf[100000]; /* hopefully no overflow when debugging */
   char *s, *s1;
   word i, n;
   struct b_realarray *ap;
   struct b_list *lp;
   double *v;

   if (rp) {
      int intcode;
      char *recname;
      double v1, v2, v3, v4, v5, v6;

      if (!rp->recdesc || Blk(rp->recdesc,Proc)->nfields < 2) return NULL;

      recname = StrLoc(Blk(rp->recdesc,Proc)->recname);
      intcode = IntVal(rp->fields[1]);

      switch(intcode) {
         case GL2D_BLIMAGE:
            sprintf(buf,"[%s] x: %ld, y: %ld, width: %ld, height: %ld, s: "
                    "'%.*s', ch: %c",recname,IntVal(rp->fields[2]),
                    IntVal(rp->fields[3]),IntVal(rp->fields[4]),
                    IntVal(rp->fields[5]),(int)StrLen(rp->fields[6]),
                    StrLoc(rp->fields[6]),(char)IntVal(rp->fields[7]));
            break;
         case GL2D_COPYAREA:
            sprintf(buf,"[%s] x1: %ld, y1: %ld, width: %ld, height: %ld, x2: "
                        "%ld, y2: %ld",recname,IntVal(rp->fields[3]),
                        IntVal(rp->fields[4]),IntVal(rp->fields[5]),
                        IntVal(rp->fields[6]),IntVal(rp->fields[7]),
                        IntVal(rp->fields[8]));
            break;
         case GL2D_ERASEAREA:
            sprintf(buf,"[%s] x: %ld, y: %ld, width: %ld, height: %ld",
                    recname,IntVal(rp->fields[2]),IntVal(rp->fields[3]),
                    IntVal(rp->fields[4]),IntVal(rp->fields[5]));
            break;
         case GL2D_FILLPOLYGON:
         case GL2D_DRAWPOLYGON:
         case GL2D_DRAWSEGMENT:
         case GL2D_DRAWLINE:
         case GL2D_DRAWPOINT:
            sprintf(buf,"[%s]",recname);
/*
            s = buf;
            s += sprintf(buf,"[%s] v: ",recname);
            GetRealarray(rp->fields[2], s, 1);
            s += sprintf(s," uncooked v: ");
            GetRealarray(rp->fields[3], s, 0);
*/
            break;

         case GL2D_FILLCIRCLE:
         case GL2D_DRAWCIRCLE:
            sprintf(buf,"[%s]",recname);
/*
            GetReal(&(rp->fields[3]),v1);
            GetReal(&(rp->fields[4]),v2);
            GetReal(&(rp->fields[5]),v3);
            GetReal(&(rp->fields[6]),v4);
            GetReal(&(rp->fields[7]),v5);
            s = buf;
            s += sprintf(buf,"[%s] x: %f, y: %f, r: %f, theta: %f, alpha: %f",
                         recname,v1,v2,v3,v4,v5);
            s += sprintf(s," v: ");
            GetRealarray(rp->fields[2], s, 1);
*/
            break;
         case GL2D_DRAWARC:
         case GL2D_FILLARC:
            sprintf(buf,"[%s]",recname);
/*
            GetReal(&(rp->fields[3]),v1);
            GetReal(&(rp->fields[4]),v2);
            GetReal(&(rp->fields[5]),v3);
            GetReal(&(rp->fields[6]),v4);
            GetReal(&(rp->fields[7]),v5);
            GetReal(&(rp->fields[8]),v6);
            s = buf;
            s += sprintf(buf,"[%s] x: %f, y: %f, width: %f, height: %f, "
                         "theta: %f, alpha: %f",recname,v1,v2,v3,v4,v5,v6);
            s += sprintf(s," v: ");
            GetRealarray(rp->fields[2], s, 1);
*/
            break;
         case GL2D_DRAWRECTANGLE:
         case GL2D_FILLRECTANGLE:
            sprintf(buf,"[%s]",recname);
/*
            s = buf;
            s += sprintf(buf,"[%s] x: %ld, y: %ld, width: %ld, height: %ld",
                         recname,IntVal(rp->fields[3]),IntVal(rp->fields[4]),
                         IntVal(rp->fields[5]),IntVal(rp->fields[6]));
            s += sprintf(s," v: ");
            GetRealarray(rp->fields[2], s, 1);
*/
            break;


         case GL2D_STRIMAGE:
            sprintf(buf,"[%s] x: %ld, y: %ld, width: %ld, height: %ld",
                    recname,IntVal(rp->fields[2]),IntVal(rp->fields[3]),
                    IntVal(rp->fields[4]),IntVal(rp->fields[5]));
            break;
         case GL2D_READIMAGE:
            sprintf(buf,"[%s] x: %ld, y: %ld, width: %ld, height: %ld",
                    recname,IntVal(rp->fields[2]),IntVal(rp->fields[3]),
                    IntVal(rp->fields[4]),IntVal(rp->fields[5]));
            break;
         case GL2D_DRAWSTRING:
         case GL2D_WWRITE:
            sprintf(buf,"[%s] x: %ld, y: %ld, s: '%.*s'",
                    recname,IntVal(rp->fields[2]),IntVal(rp->fields[3]),
                    (int)StrLen(rp->fields[4]),StrLoc(rp->fields[4]));
            break;

         case GL2D_FG:
         case GL2D_BG:
            if (is:null(rp->fields[2]))
               sprintf(buf,"[%s] r: %ld, g: %ld, b: %ld, a: %ld", recname,
                       IntVal(rp->fields[3]),IntVal(rp->fields[4]),
                       IntVal(rp->fields[5]),IntVal(rp->fields[6]));
            else
               sprintf(buf,"[%s] mutable id: %ld",recname,
                       -IntVal(rp->fields[2]));
            break;
         case GL2D_REVERSE:
            sprintf(buf,"[%s]",recname);
            break;
         case GL2D_GAMMA:
            GetReal(&(rp->fields[2]),v1);
            sprintf(buf,"[%s] gamma: %f",recname,v1);
            break;
         case GL2D_DRAWOP:
            sprintf(buf,"[%s] drawop: '%.*s'",recname,
                    (int)StrLen(rp->fields[2]),StrLoc(rp->fields[2]));
            break;
         case GL2D_FONT:
            sprintf(buf,"[%s] font: '%.*s'",recname,(int)StrLen(rp->fields[2]),
                    StrLoc(rp->fields[2]));
            break;
         case GL2D_LEADING:
            sprintf(buf,"[%s] leading: %ld",recname,IntVal(rp->fields[2]));
            break;
         case GL2D_LINEWIDTH:
            sprintf(buf,"[%s] linewidth: %ld",recname,IntVal(rp->fields[2]));
            break;
         case GL2D_LINESTYLE:
            sprintf(buf,"[%s] linestyle: '%.*s'",recname,
                    (int)StrLen(rp->fields[2]),StrLoc(rp->fields[2]));
            break;
         case GL2D_FILLSTYLE:
            sprintf(buf,"[%s] fillstyle: '%.*s'",recname,
                    (int)StrLen(rp->fields[2]),StrLoc(rp->fields[2]));
            break;
         case GL2D_PATTERN:
            sprintf(buf,"[%s] s: '%.*s'",recname,(int)StrLen(rp->fields[2]),
                    StrLoc(rp->fields[2]));
            break;
         case GL2D_CLIP:
            sprintf(buf,"[%s] x: %ld, y: %ld, width: %ld, height: %ld",
                    recname,IntVal(rp->fields[2]),IntVal(rp->fields[3]),
                    IntVal(rp->fields[4]),IntVal(rp->fields[5]));
            break;
         case GL2D_DX:
            sprintf(buf,"[%s] dx: %ld",recname,IntVal(rp->fields[2]));
            break;
         case GL2D_DY:
            sprintf(buf,"[%s] dy: %ld",recname,IntVal(rp->fields[2]));
            break;
         default:
            glprintf("Not a valid 2d display list item\n");
            return NULL;
         }
      }
   return buf;
   }
#else                                   /* GL2D_DEBUG */
char *getDLiteminfo2d(struct b_record *rp)
   {
     return NULL; /* Avoid clang: "non-void function does not return a value" */
   }
#endif                                  /* GL2D_DEBUG */



/***********************************
 * (1) OpenGL 2D utility functions *
 ***********************************/



int create_display_list2d(wbp w, int size)
   {
   struct b_list *lp;

   if ((lp = alclist(0, size)) == NULL)
      return RunError; /* out of space */
   BlkLoc(w->window->funclist2d) = (union block *)lp;
   w->window->funclist2d.dword = D_List;

   return Succeeded;
   }


/*
 * Returns a record constructor for a 2d graphics primitive. Used to allocate
 * a new 2d graphics object.
 */
dptr rec_structor2d(int type)
   {
   static int first = 1;

   /* Graphic primitives */
   static struct descrip gl2d_blimage = {D_Null};
   static struct descrip gl2d_readimage = {D_Null};
   static struct descrip gl2d_strimage = {D_Null};
   static struct descrip gl2d_drawstring = {D_Null};
   static struct descrip gl2d_wwrite = {D_Null};
   static struct descrip gl2d_copyarea = {D_Null};
   static struct descrip gl2d_erasearea = {D_Null};
   static struct descrip gl2d_fillpolygon = {D_Null};
   static struct descrip gl2d_drawpolygon = {D_Null};
   static struct descrip gl2d_drawline = {D_Null};
   static struct descrip gl2d_drawpoint = {D_Null};
   static struct descrip gl2d_drawsegment = {D_Null};
   static struct descrip gl2d_drawcircle = {D_Null};
   static struct descrip gl2d_fillcircle = {D_Null};
   static struct descrip gl2d_drawarc = {D_Null};
   static struct descrip gl2d_fillarc = {D_Null};
   static struct descrip gl2d_fillrectangle = {D_Null};
   static struct descrip gl2d_drawrectangle = {D_Null};

   /*
    * (Context) Attribute assignment
    */
   static struct descrip gl2d_fg = {D_Null};
   static struct descrip gl2d_bg = {D_Null};
   static struct descrip gl2d_reverse = {D_Null};
   static struct descrip gl2d_gamma = {D_Null};
   static struct descrip gl2d_drawop = {D_Null};
   static struct descrip gl2d_font = {D_Null};
   static struct descrip gl2d_leading = {D_Null};
   static struct descrip gl2d_linewidth = {D_Null};
   static struct descrip gl2d_linestyle = {D_Null};
   static struct descrip gl2d_fillstyle = {D_Null};
   static struct descrip gl2d_pattern = {D_Null};
   static struct descrip gl2d_clip = {D_Null};
   static struct descrip gl2d_dx = {D_Null};
   static struct descrip gl2d_dy = {D_Null};


   /*
    * record field names - the following are fixed:
    *
    * field[0] - function name: "name"
    * field[1] - function code: "code"
    */
   static char *gl2d_blimage_fields[] = {
      "x", "y", "width", "height", "__s", "__ch", "__texid", "__index"
      };
   static char *gl2d_readimage_fields[] = {
      "x", "y", "width", "height", "__is_pixmap", "__pixmap", "__texid",
      "__index"
      };
   static char *gl2d_strimage_fields[] = {"x", "y", "width", "height",
      "__pixmap", "__texid", "__index"
      };
   static char *gl2d_drawstring_fields[] = {"x", "y", "s"};
   static char *gl2d_wwrite_fields[] = {"x", "y", "s"};
   static char *gl2d_copyarea_fields[] = {
      "__w1", "__x1", "__y1", "__width", "__height", "x", "y", "__texid", "__index"
      };
   static char *gl2d_erasearea_fields[] = {"x", "y", "width", "height"};

   static char *gl2d_fillpolygon_fields[] = {"__v", "__coords", "__type"};
   static char *gl2d_drawpolygon_fields[] = {"__v", "__coords", "__vseg"};
   static char *gl2d_drawline_fields[] = {"__v", "__coords", "__vseg"};
   static char *gl2d_drawsegment_fields[] = {"__v", "__coords", "__vseg"};
   static char *gl2d_drawpoint_fields[] = {"__v", "__coords"};
   static char *gl2d_drawcircle_fields[] = {
      "__v", "x", "y", "r", "theta", "alpha", "__x", "__y", "__r", "__theta",
      "__alpha", "__vseg"
      };
   static char *gl2d_fillcircle_fields[] = {
      "__v", "x", "y", "r", "theta", "alpha", "__x", "__y", "__r", "__theta",
      "__alpha"
      };
   static char *gl2d_drawarc_fields[] = {
      "__v", "x", "y", "width", "height", "theta", "alpha", "__x", "__y",
      "__width", "__height", "__theta", "__alpha", "__vseg"
      };
   static char *gl2d_fillarc_fields[] = {
      "__v", "x", "y", "width", "height", "theta", "alpha", "__x", "__y",
      "__width", "__height", "__theta", "__alpha"
      };
   static char *gl2d_drawrectangle_fields[] = {
      "__v", "x", "y", "width", "height", "__x", "__y", "__width", "__height",
      "__vseg"
      };
   static char *gl2d_fillrectangle_fields[] = {
      "__v", "x", "y", "width", "height", "__x", "__y", "__width", "__height"
      };

   /*
    * (context) attributes
    */
   static char *gl2d_fg_fields[] = {"index", "r", "g", "b", "a"};
   static char *gl2d_bg_fields[] = {"index", "r", "g", "b", "a"};
   static char *gl2d_reverse_fields[] = {NULL};
   static char *gl2d_gamma_fields[] = {"val"};
   static char *gl2d_drawop_fields[] = {"s"};
   static char *gl2d_font_fields[] = {"s"};
   static char *gl2d_leading_fields[] = {"val"};
   static char *gl2d_linewidth_fields[] = {"val"};
   static char *gl2d_linestyle_fields[] = {"s"};
   static char *gl2d_fillstyle_fields[] = {"s"};
   static char *gl2d_pattern_fields[] = {
      "s", "__s", "__width", "__height", "__texid", "__index"
      };
   static char *gl2d_clip_fields[] = {"x", "y", "width", "height"};
   static char *gl2d_dx_fields[] = {"val", "__val"};
   static char *gl2d_dy_fields[] = {"val", "__val"};

   /*
    * Initialize all constructors
    */
   if (first) {
      first = 0;

      /*
       * Primitives
       */
      Protect(rec_structor2dinit(&gl2d_blimage, "gl2d_blimage", 10,
                                 gl2d_blimage_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_readimage, "gl2d_readimage", 10,
                                 gl2d_readimage_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_strimage, "gl2d_strimage", 9,
                                 gl2d_strimage_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawstring, "gl2d_drawstring", 5,
                                 gl2d_drawstring_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_wwrite, "gl2d_wwrite", 5,
                                 gl2d_wwrite_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_copyarea, "gl2d_copyarea", 11,
                                 gl2d_copyarea_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_erasearea, "gl2d_erasearea", 6,
                                 gl2d_erasearea_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_fillpolygon, "gl2d_fillpolygon", 5,
                                 gl2d_fillpolygon_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawpolygon, "gl2d_drawpolygon", 5,
                                 gl2d_drawpolygon_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawline, "gl2d_drawline", 5,
                                 gl2d_drawline_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawsegment, "gl2d_drawsegment", 5,
                                 gl2d_drawsegment_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawpoint, "gl2d_drawpoint", 4,
                                 gl2d_drawpoint_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawcircle, "gl2d_drawcircle", 14,
                                 gl2d_drawcircle_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_fillcircle, "gl2d_fillcircle", 13,
                                 gl2d_fillcircle_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawarc, "gl2d_drawarc", 16,
                                 gl2d_drawarc_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_fillarc, "gl2d_fillarc", 15,
                                 gl2d_fillarc_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawrectangle, "gl2d_drawrectangle", 12,
                                 gl2d_drawrectangle_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_fillrectangle, "gl2d_fillrectangle", 11,
                                 gl2d_fillrectangle_fields), return NULL);

      /*
       * Attributes
       */
      Protect(rec_structor2dinit(&gl2d_fg, "gl2d_fg", 7, gl2d_fg_fields),
                                 return NULL);
      Protect(rec_structor2dinit(&gl2d_bg, "gl2d_bg", 7, gl2d_bg_fields),
                                 return NULL);
      Protect(rec_structor2dinit(&gl2d_reverse, "gl2d_reverse", 2,
                                 gl2d_reverse_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_gamma, "gl2d_gamma", 3,
                                 gl2d_gamma_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_drawop, "gl2d_drawop", 3,
                                 gl2d_drawop_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_font, "gl2d_font", 3, gl2d_font_fields),
                                 return NULL);
      Protect(rec_structor2dinit(&gl2d_leading, "gl2d_leading", 3,
                                 gl2d_leading_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_linewidth, "gl2d_linewidth", 3,
                                 gl2d_linewidth_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_linestyle, "gl2d_linestyle", 3,
                                 gl2d_linestyle_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_fillstyle, "gl2d_fillstyle", 3,
                                 gl2d_fillstyle_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_pattern, "gl2d_pattern", 8,
                                 gl2d_pattern_fields), return NULL);
      Protect(rec_structor2dinit(&gl2d_clip, "gl2d_clip", 6, gl2d_clip_fields),
                                 return NULL);
      Protect(rec_structor2dinit(&gl2d_dx, "gl2d_dx", 4, gl2d_dx_fields),
                                 return NULL);
      Protect(rec_structor2dinit(&gl2d_dy, "gl2d_dy", 4, gl2d_dy_fields),
                                 return NULL);
      }

   switch(type) {
      case GL2D_BLIMAGE: /* DrawImage() */
         return &gl2d_blimage;
      case GL2D_STRIMAGE: /* ReadImage()/DrawImage() */
         return &gl2d_strimage;
      case GL2D_READIMAGE: /* ReadImage() */
         return &gl2d_readimage;
      case GL2D_DRAWSTRING: /* DrawString() */
         return &gl2d_drawstring;
      case GL2D_WWRITE: /* WWrite() */
         return &gl2d_wwrite;
      case GL2D_COPYAREA: /* CopyArea() */
         return &gl2d_copyarea;
      case GL2D_ERASEAREA: /* EraseArea() */
         return &gl2d_erasearea;

      case GL2D_FILLPOLYGON: /* FillPolygon() */
         return &gl2d_fillpolygon;
      case GL2D_DRAWPOLYGON: /* DrawPolygon() */
         return &gl2d_drawpolygon;
      case GL2D_DRAWLINE: /* DrawLine()/DrawCurve() */
         return &gl2d_drawline;
      case GL2D_DRAWPOINT: /* DrawPoint() */
         return &gl2d_drawpoint;
      case GL2D_DRAWSEGMENT: /* DrawSegment() */
         return &gl2d_drawsegment;
      case GL2D_DRAWCIRCLE: /* DrawCircle() */
         return &gl2d_drawcircle;
      case GL2D_FILLCIRCLE: /* FillCircle() */
         return &gl2d_fillcircle;
      case GL2D_DRAWARC: /* DrawArc() */
         return &gl2d_drawarc;
      case GL2D_FILLARC: /* FillArc() */
         return &gl2d_fillarc;
      case GL2D_DRAWRECTANGLE: /* DrawRectangle() */
         return &gl2d_drawrectangle;
      case GL2D_FILLRECTANGLE: /* FillRectangle() */
         return &gl2d_fillrectangle;

      /*
       * Attributes
       */
      case GL2D_FG: /* Fg()/WAttrib() */
         return &gl2d_fg;
      case GL2D_BG: /* Bg()/WAttrib() */
         return &gl2d_bg;
      case GL2D_REVERSE: /* WAttrib() */
         return &gl2d_reverse;
      case GL2D_GAMMA: /* WAttrib() */
         return &gl2d_gamma;
      case GL2D_DRAWOP: /* WAttrib() */
         return &gl2d_drawop;
      case GL2D_FONT: /* WAttrib() */
         return &gl2d_font;
      case GL2D_LEADING: /* WAttrib() */
         return &gl2d_leading;
      case GL2D_LINEWIDTH: /* WAttrib() */
         return &gl2d_linewidth;
      case GL2D_LINESTYLE: /* WAttrib() */
         return &gl2d_linestyle;
      case GL2D_FILLSTYLE: /* WAttrib() */
         return &gl2d_fillstyle;
      case GL2D_PATTERN: /* WAttrib() */
         return &gl2d_pattern;
      case GL2D_CLIP: /* WAttrib() */
         return &gl2d_clip;
      case GL2D_DX: /* WAttrib() */
         return &gl2d_dx;
      case GL2D_DY: /* WAttrib() */
         return &gl2d_dy;
      default:
         fprintf(stderr,"%d is not a valid display list record\n",type);
         return NULL;
      }
   }



dptr rec_structor2dinit(dptr dp, char *name, int nfields, char *field_names[])
   {
   struct descrip s;
   struct descrip fields[16];
   int i;
   const int nfixed = 2; /* number of fixed fields */

   /* initialize record constructor */
   if (is:null(*dp)) {
      AsgnCStr(s, name);
      AsgnCStr(fields[0], "name");
      AsgnCStr(fields[1], "code");
      for (i=nfixed; i<nfields; i++)
         AsgnCStr(fields[i], field_names[i-nfixed]);
      dp->dword = D_Proc;
      if ((BlkLoc(*dp) = (union block *)dynrecord(&s, fields, nfields)) == NULL)
         return NULL;
      }
   return dp;
   }



/*
 * Called by traversefunclist2d(). Traverses any contiguous subset of a
 * Unicon list.
 */
int traverselist2d(wbp w, struct b_lelem *bp, int start, int end, int used,
   word k)
   {
   tended struct b_lelem *bp_t = bp;
   struct b_record *rp;
   struct descrip desc;
   int i, tmp, rv;

   /*
    * The ith element of the list is a list with information
    * about the function call made on the window.
    */
   for (i=start; i<end; i++) {
      desc = bp_t->lslots[k];
      k++;
      used--;
      if (k>=bp_t->nslots) k=0;

      if (used<=0) {
         bp_t = (struct b_lelem *) bp_t->listnext;
         used = bp_t->nused;
         k = bp_t->first;
         }
      if (!is:record(desc)) {
         /* all items on 2D display list must be records */
         return RunError;
         }

      rp = BlkD(desc, Record);
      tmp = IntVal(rp->fields[1]);

      switch(tmp) {
         /*
          * Primitives
          */
         case GL2D_BLIMAGE:
            rv = drawblimage2d(w,rp);
            break;
         case GL2D_READIMAGE:
            rv = drawreadimage2d(w,rp);
            break;
         case GL2D_STRIMAGE:
            rv = drawstrimage2d(w,rp);
            break;
         case GL2D_COPYAREA:
            rv = copyarea2d(w,rp);
            break;
         case GL2D_ERASEAREA:
            rv = erasearea2d(w,rp);
            break;
         case GL2D_FILLPOLYGON:
         case GL2D_DRAWPOLYGON:
         case GL2D_DRAWLINE:
         case GL2D_DRAWSEGMENT:
         case GL2D_DRAWPOINT:
         case GL2D_DRAWCIRCLE:
         case GL2D_DRAWARC:
         case GL2D_FILLCIRCLE:
         case GL2D_FILLARC:
         case GL2D_DRAWRECTANGLE:
         case GL2D_FILLRECTANGLE:
            rv = drawgeometry2d(w,rp);
            break;
         case GL2D_DRAWSTRING:
         case GL2D_WWRITE:
            rv = drawstring2d(w,rp);
            break;

         /*
          * (Context) Attributes
          */
         case GL2D_FG:
         case GL2D_BG:
            rv = setcolor2d(w,rp,0);
            break;
         case GL2D_REVERSE:
            rv = togglefgbg2d(w);
            break;
         case GL2D_GAMMA:
            rv = setgamma2d(w,rp);
            break;
         case GL2D_DRAWOP:
            rv = setdrawop2d(w,rp);
            break;
          case GL2D_FONT:
            rv = setfont2d(w,rp);
            break;
         case GL2D_LEADING:
            rv = setleading2d(w,rp);
            break;
          case GL2D_LINEWIDTH:
            rv = setlinewidth2d(w,rp);
            break;
         case GL2D_LINESTYLE:
            rv = setlinestyle2d(w,rp);
            break;
         case GL2D_FILLSTYLE:
            rv = setfillstyle2d(w,rp);
            break;
         case GL2D_PATTERN:
            rv = setpattern2d(w,rp);
            break;
         case GL2D_CLIP:
            rv = setclip2d(w,rp);
            break;
         case GL2D_DX:
            rv = setdx2d(w,rp);
            break;
         case GL2D_DY:
            rv = setdy2d(w,rp);
            break;
         default: /* Invalid display list item */
            fprintf(stderr,"Invalid display list item\n");
            return RunError;
            break;
         }
         if (rv == RunError) return RunError;
      }
   return Succeeded;
   }

/*
 * Traverses and renders the 2d display list {w->window->funclist2d}
 */
int traversefunclist2d(wbp w)
   {
   wsp ws = w->window;
   int i, intcode, rv;
   int used;
   word k;
   int elements;
   struct b_list *hp;
   tended struct b_lelem *bp;

   /*
    * Initialize flags
    */
   ws->dx_flag = ws->dy_flag = 0;

   hp = BlkD(ws->funclist2d, List);
   elements = hp->size;

   if (elements <= 0) return Succeeded;
   bp = (struct b_lelem *) hp->listhead;

   if (bp->nused<=0) {
      /* get rid of useless lelem block */
      bp = (struct b_lelem *) bp->listnext;
      hp->listhead = (union block *) bp;
      bp->listprev = (union block *) hp;
      }
   k = bp->first;
   used = bp->nused;

   /*
    * Traverse the list while keeping an eye out for EraseArea
    */
   if (ws->is_3D) { /* integrated 2d/3d mode traversal */
      struct descrip desc;
      struct b_record *rp;
      wcp wcr = &(ws->wcrender);
      word last_k = k;
      int last_used = used, last_i;
      tended struct b_lelem *last_bp = bp;
      struct _wcontext last_wc = {0};
      copy_2dcontext(&last_wc, wcr);

      for (i=0, last_i=0; i< elements; i++) {
         desc = bp->lslots[k];
         k++;
         used--;
         if (k>=bp->nslots) k=0;

         if (used<=0) {
            bp = (struct b_lelem *) bp->listnext;
            used = bp->nused;
            k = bp->first;
            }
         if (!is:record(desc)) {
            /* all items on 2D display list must be records */
            return RunError;
            }

         rp = BlkD(desc, Record);
         intcode = IntVal(rp->fields[1]);

         if (intcode == GL2D_ERASEAREA) {

            /*
             * Draw area to be erased into stencil buffer
             */
            erasearea2d(w, rp);

            /*
             * Setup stencil buffer and render context to traverse all
             * contiguous non-erasearea display list records before this
             */
            ws->stencil_mask = GL2D_ERASE_BIT;
            DefaultStencilFunc(w);
            copy_2dcontext(wcr, &last_wc);
            init_2dcanvas(w);
            rv = traverselist2d(w, last_bp, last_i, i, last_used, last_k);
            if (rv != Succeeded) return rv;

            /*
             * Set stencil buffer states back to default and save the current
             * render context state and position in display list
             */
            ws->stencil_mask = 0;
            DefaultStencilFunc(w);
            copy_2dcontext(&last_wc, wcr);
            last_k = k;
            last_i = i+1;
            last_used = used;
            last_bp = bp;
            }
         else if (i == elements-1 && last_i < i) {

            /*
             * Traverse the remaining non-erasearea elements of the list
             */
            copy_2dcontext(wcr, &last_wc);
            rv = traverselist2d(w, last_bp, last_i, i+1, last_used, last_k);
            if (rv != Succeeded) return rv;
            }
         else {

            /*
             * Only traverse context attributes to update the render context
             */
            switch(intcode) {
               case GL2D_FG:
               case GL2D_BG:
                  rv = setcolor2d(w,rp,0);
                  break;
               case GL2D_REVERSE:
                  rv = togglefgbg2d(w);
                  break;
               case GL2D_GAMMA:
                  rv = setgamma2d(w,rp);
                  break;
               case GL2D_DRAWOP:
                  rv = setdrawop2d(w,rp);
                  break;
               case GL2D_FONT:
                  rv = setfont2d(w,rp);
                  break;
               case GL2D_LEADING:
                  rv = setleading2d(w,rp);
                  break;
               case GL2D_LINEWIDTH:
                  rv = setlinewidth2d(w,rp);
                  break;
               case GL2D_LINESTYLE:
                  rv = setlinestyle2d(w,rp);
                  break;
               case GL2D_FILLSTYLE:
                  rv = setfillstyle2d(w,rp);
                  break;
               case GL2D_PATTERN:
                  rv = setpattern2d(w,rp);
                  break;
               case GL2D_CLIP:
                  rv = setclip2d(w,rp);
                  break;
               case GL2D_DX:
                  rv = setdx2d(w,rp);
                  break;
               case GL2D_DY:
                  rv = setdy2d(w,rp);
                  break;
               } /* end switch */
               if (rv == RunError) return RunError;
            } /* end else */
         } /* end for */
      } /* end if */
   else { /* 2d traversal */
      /*
       * Traverse all elements normally
       */
      rv = traverselist2d(w, bp, 0, elements, used, k);
      if (rv != Succeeded) return rv;
      }

   if (ws->resize) ws->resize = 0;
   if (ws->redraw_flag) ws->redraw_flag = 0;
   return Succeeded;
   }



/*
 * Find the last display list item from the 2d display list
 * and return the pointer to it if is of type {intcode}.
 *
 * Not currently used. TODO: Implement display list optimizations
 */
struct b_record *getlastlistitem(wbp w, int intcode)
   {
   struct b_list *dl;
   struct b_lelem *lastlelem;
   struct descrip *dptr;
   struct b_record *rp;
   word i, first;

   dl = BlkD(w->window->funclist2d,List);
   lastlelem = Blk(dl->listtail,Lelem);

   first = lastlelem->first;
   i = lastlelem->nused - 1;
   if (first)
      i += lastlelem->first;

   /* check type of last list element */
   dptr = &(lastlelem->lslots[i]);
   if (dptr && is:record(*dptr)) {
      rp = BlkD((*dptr), Record);
      if (IntVal(rp->fields[1]) == intcode)
         return rp;
      }
   return NULL;
   }



/*
 * Currently only applied to the 2d facilites.
 * Takes a diff of relevent context attributes. If any differ, create a
 * display list item for each and apply the relevent Unicon and OpenGL
 * state changes.
 *
 * For now, implement a brute-force approach. Create an efficient
 * algorithm after proof-of-concept
 *
 * The second parameter {intcode} is only for context attribute
 * item creation functions (to stop unwanted recursion).
 * Otherwise 0 is passed.
 */
int updaterendercontext(wbp w, int intcode)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   wcp wcr = &(ws->wcrender);
   char *s;
   ws->busy_flag = 1;

   if (ws->updateRC == 0) {
      ws->updateRC = 1;
      }
   else {
      glprintf("updateRC: need a mutex lock for updaterendercontext()...\n");
      return Failed;
      }

   /* apply drawop */
   if (intcode != GL2D_DRAWOP && wcr->drawop != wc->drawop) {
      if (wc->drawop == GL2D_DRAWOP_REVERSE)
         s = "reverse";
      else
         s = "copy";
      if (gl_setdrawop(w, s) == RunError) {
         return RunError;
         }
      }

   /* apply fg */
   if (intcode != GL2D_FG && !ColorEqual(wcr->glfg,wc->glfg)) {
      if (gl_color(w, GL2D_FG, 0, wc->glfg.name) == RunError) {
         return RunError;
         }
      }

   /* apply bg */
   if (intcode != GL2D_BG && !ColorEqual(wcr->glbg,wc->glbg)) {
      if (gl_color(w, GL2D_BG, 0, wc->glbg.name) == RunError) {
         return RunError;
         }
      }

   /* apply reverse */
   if (intcode != GL2D_REVERSE && wcr->reverse != wc->reverse) {
      if (gl_toggle_fgbg(w) == RunError) {
         return RunError;
         }
      }

   /* apply gamma */
   if (intcode != GL2D_GAMMA && wcr->gamma != wc->gamma) {
      if (gl_setgamma(w, wc->gamma) == RunError) {
         return RunError;
         }
      }

   /* apply font */
   if (intcode != GL2D_FONT && wc->font != wcr->font) {
      if (wc->font) {
         if (gl_setfont(w, &(wc->font->name)) == RunError)
            return RunError;
         }
      else if (wc->font) {
         /* hmmm... fonts were not allocated for some reason. let it be */
         }
      }


   /* apply leading */
   if (intcode != GL2D_LEADING && wcr->leading != wc->leading) {
      if (gl_setleading(w, wc->leading) == RunError)
         return RunError;
      }

   /* apply fillstyle */
   if (intcode != GL2D_FILLSTYLE && wcr->fillstyle != wc->fillstyle) {
      switch (wc->fillstyle) {
         case GL2D_FILL_SOLID:
            s = "solid";
            break;
         case GL2D_FILL_MASKED:
            s = "masked";
            break;
         case GL2D_FILL_TEXTURED:
            s = "textured";
            break;
         default:
            syserr("invalid fillstyle");
         }
      if (gl_setfillstyle(w, s) == RunError) {
         return RunError;
         }
      }

   /* apply linestyle */
   if (intcode != GL2D_LINESTYLE && wcr->linestyle != wc->linestyle) {
      switch (wc->linestyle) {
         case GL2D_LINE_SOLID:
            s = "solid";
            break;
         case GL2D_LINE_DASHED:
            s = "dashed";
            break;
         case GL2D_LINE_STRIPED:
            s = "striped";
            break;
         default:
            syserr("invalid linestyle");
         }
      if (gl_setlinestyle(w, s) == RunError) {
         return RunError;
         }
      }

   /*
    * apply pattern - {patternname} should never be NULL
    */
   if (intcode != GL2D_PATTERN && strcmp(wc->patternname,wcr->patternname)) {
      if (gl_SetPattern(w,wc->patternname,strlen(wc->patternname)) == RunError)
         return RunError;
      }


   /* apply linewidth */
   if (intcode != GL2D_LINEWIDTH && wcr->linewidth != wc->linewidth) {
      if (gl_setlinewidth(w, wc->linewidth) == RunError) {
         return RunError;
         }
      }

   /* apply dx */
   if (intcode != GL2D_DX && wcr->dx != wc->dx) {
      if (gl_setdx(w) == RunError) {
         return RunError;
         }
      }

   /* apply dy */
   if (intcode != GL2D_DY && wcr->dy != wc->dy) {
      if (gl_setdy(w) == RunError) {
         return RunError;
         }
      }

   /* apply clipping - just generalize for all four components */
   if (intcode != GL2D_CLIP &&
       (wcr->clipx != wc->clipx || wcr->clipy != wc->clipy ||
        wcr->clipw != wc->clipw || wcr->cliph != wc->cliph)) {
      if (gl_setclip(w) == RunError) {
         return RunError;
         }
      }

   if (ws->updateRC == 1) {
      ws->updateRC = 0;
      }
   else {
      glprintf("updateRC: need a mutex unlock for updaterendercontext()...\n");
      return Failed;
      }

   /* Save this as last context used */
   ws->lastwcserial = wc->serial;

   ws->busy_flag = 0;
   return Succeeded;
   }




/*
 * Function for setting the OpenGL capabilities needed for the Unicon
 * 2D facilities
 */
int init_2dcanvas(wbp w)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);

   /* byte alignment for OpenGL bitmaps/pixmaps */
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
   glPixelStorei(GL_PACK_ALIGNMENT, 1);

   glPixelTransferi(GL_INDEX_SHIFT, 0);
   glPixelTransferi(GL_INDEX_OFFSET, 0);

   /*
    * Fg/Bg colors - gamma/reverse are implicit (see SetDrawopColorState())
    */
   setcolor2d(w, NULL, GL2D_FG);
   setcolor2d(w, NULL, GL2D_BG);

   /*
    * Drawops
    */
   glLogicOp(GL2D_DRAWOP_REVERSE);
   ApplyDrawop(w, wcr->drawop);

   /*
    * Linewidth - linestyle/fillstyle are implicit (see drawgeometry2d())
    */
   ApplyLinewidth(wcr->linewidth);

   /*
    * Patterns
    */
   if (glIsEnabled(GL_STENCIL_TEST) == GL_FALSE)
      glEnable(GL_STENCIL_TEST);
   setpattern2d(w, NULL);

   /*
    * Clipping
    */
   setclip2d(w, NULL);

   /*
    * By default, only check for clipping and disable writing to stencil
    * buffer. NOTE: this may have changed. revisit
    */
   DefaultStencilFunc(w);
   DisableStencilWrite();

   return Succeeded;
   }



/*
 * Remember to call MakeCurrent() before calling this function
 */
int init_canvas(wbp w)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   wdp wd = ws->display;

   /*
    * Copy default context state to render context and default
    * context state
    */
   ws->lastwcserial = wc->serial;
   ws->wcdef.display = ws->wcrender.display = wd;
   copy_2dcontext(&(ws->wcdef), wc);
   copy_2dcontext(&(ws->wcrender), wc);

   ws->redraw_flag = 0;
   ws->busy_flag = 0;

   /*
    * Init specific mode states
    *
    * Need to check to make sure changes made to init_3dcanvas() did not
    * change behavior
    */
   init_2dcanvas(w);
   if (ws->is_3D)
      init_3dcanvas(w);

   /* Init all-encompassing mode states */
   glClearDepth(1.0);
   glEnable(GL_DEPTH_TEST);
   glDepthFunc(GL_LEQUAL);
   glEnable(GL_ALPHA_TEST);
   glAlphaFunc(GL_GEQUAL, 0.01); /* have a little buffer space */
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

   /*
    * Setup targets for drawing and reading
    */
   ApplyBuffermode(w, ws->buffermode);
   ApplyRendermode(w, wc->rendermode);

   /*
    * Init states common to both 2d and 3d modes
    */
   ClearScreenToColor(w, BG);

   /*
    * Initialize viewing volume (camera)
    */
   SetWindowSize(w);
   glLoadIdentity(); /* initialize modelview matrix */

   return Succeeded;
   }




/*
 * Can make this a macro
 */
int init_2dcontext(wcp wc)
   {
   wdp wd = wc->display;
   wfp *wfptr = &(wd->glfonts);

   wc->rendermode = 0;
   wc->alpha = 1.0;

   /* default fg is black */
   SetColor(wc->glfg, 0, 0, 0, 65535, 0);
   sprintf(wc->glfg.name,"black");
#ifdef XWindows
   wc->glfg.c = wd->colors[0].c;
   wd->colors[0].refcount++;
#endif                                  /* XWindows */

   /* default bg is white */
   SetColor(wc->glbg, 65535, 65535, 65535, 65535, 0);
   sprintf(wc->glbg.name,"white");
#ifdef XWindows
   wc->glbg.c = wd->colors[1].c;
   wd->colors[1].refcount++;
#endif                                  /* XWindows */

   wc->rgbmode = 2;
   wc->gamma = wd->gamma;
   wc->drawop = GL2D_DRAWOP_COPY;
   wc->reverse = 0;

   /* fonts */
   if (*wfptr) {
      wc->font = *wfptr;
      wc->leading = FT_FHEIGHT((*wfptr)->face);
      }
   else {
      glprintf("fonts not allocated\n");
      wc->font = NULL;
      wc->leading = 0;
      }

   /* drawing */
   wc->linewidth = 1;
   wc->linestyle = GL2D_LINE_SOLID;
   wc->fillstyle = GL2D_FILL_SOLID;

   /* "black" is default pattern */
   if (wc->patternname) {
      if (strcmp("black",wc->patternname)) {
         free(wc->patternname);
         wc->patternname = strdup("black");
         if (!wc->patternname) return RunError;
         }
      }
   else {
      wc->patternname = strdup("black");
      if (!wc->patternname) return RunError;
      }

   /* clipping */
   wc->clipx = wc->clipy = 0;
   wc->clipw = wc->cliph = -1;

   /* translation */
   wc->dx = wc->dy = 0;

   return Succeeded;
   }




int copy_2dcontext(wcp wcdest, wcp wcsrc)
   {
   wcdest->rendermode = wcsrc->rendermode;
   wcdest->alpha = wcsrc->alpha;

   CopyColor(wcdest->glfg, wcsrc->glfg);
   CopyColor(wcdest->glbg, wcsrc->glbg);
#ifdef XWindows
   wcdest->glfg.c = wcsrc->glfg.c;
   wcdest->glbg.c = wcsrc->glbg.c;
#endif                                  /* XWindows */

   wcdest->drawop = wcsrc->drawop;
   wcdest->gamma = wcsrc->gamma;
   wcdest->reverse = wcsrc->reverse;

   if (wcsrc->font) {
      if (wcdest->font)
         wcdest->font->refcount--;
      wcdest->font = wcsrc->font;
      wcdest->font->refcount++;
      wcdest->leading = wcsrc->leading;
      }

   if (wcdest->patternname) {
      if (strcmp(wcdest->patternname,wcsrc->patternname)) {
         free(wcdest->patternname);
         wcdest->patternname = strdup(wcsrc->patternname);
         }
      }
   else {
      wcdest->patternname = strdup(wcsrc->patternname);
      }

   wcdest->fillstyle = wcsrc->fillstyle;
   wcdest->linestyle = wcsrc->linestyle;
   wcdest->linewidth = wcsrc->linewidth;
   wcdest->clipx = wcsrc->clipx;
   wcdest->clipy = wcsrc->clipy;
   wcdest->clipw = wcsrc->clipw;
   wcdest->cliph = wcsrc->cliph;
   wcdest->dx = wcsrc->dx;
   wcdest->dy = wcsrc->dy;
   wcdest->bits = wcsrc->bits;

   return Succeeded;
   }



/*
 * Allocates {ntex} OpenGL textures. If more than one are requested, the
 * index returned is the first of the requested array.
 */
int get_tex_index(wdp wd, unsigned int ntex)
   {
   int rv;
   /* Max # is dependent on GLuint (65536), but reserve a fraction */
   const unsigned int MAX_TEXTURES = 32768;

   if (ntex == 0) return Failed;

   if (wd->numTexIds+ntex > wd->maxTexIds) {
      unsigned int *ptr = NULL;
      unsigned int n = wd->maxTexIds;

      if (wd->maxTexIds < MAX_TEXTURES) {
         ptr = (unsigned int *)realloc((wd)->texIds,2*n*sizeof(unsigned int));
         }

      if (!ptr) {
         /* if no memory left, delete half of the existing textures */
         delete_first_tex(wd, n/2);
         }
      else {
         wd->texIds= ptr;
         wd->maxTexIds = 2*n;
         }
      }
   rv = wd->numTexIds;
   wd->numTexIds += ntex;
   return rv;
   }

/*
 * Frees the first {ntex} (OpenGL) resources in the
 * texture array moves the remaining (if any) to the front
 * of the array.
 */
int delete_first_tex(wdp wd, unsigned int ndel)
   {
   unsigned int i, j, ntex = wd->numTexIds;
   unsigned int *a;

   if (ndel == 0) return Failed;
   else if (ndel > ntex) ndel = ntex;

   a = wd->texIds;
   j = ntex - ndel;

   glDeleteTextures(ndel, a);
   wd->numTexIds = j;

   for (i = 0; i < ndel; i++) {
      if (j < ntex) {
         a[i] = a[j];
         a[j++] = 0;
         }
      else
         a[i] = 0;
      }
   return Succeeded;
   }

/*
 * Frees the last {ntex} (OpenGL) resources in the texture array
 */
int delete_last_tex(wdp wd, unsigned int ndel)
   {
   unsigned int i, j, ntex = wd->numTexIds;
   unsigned int *a;

   if (ndel == 0) return Failed;
   else if (ndel > ntex) ndel = ntex;

   a = wd->texIds;
   j = ntex - ndel;

   glDeleteTextures(ndel, &(a[j]));
   wd->numTexIds = j;

   for (i = ntex; i > j; i--)
      a[i-1] = 0;

   return Succeeded;
   }



/*
 * Convert bitmap to a pixmap (RGBA). This is a helper function for using
 * an alpha-based pixmap for texture alpha testing.
 *
 * {n} dictates the number of bytes per bit in the conversion.
 * {invert} dictates  whether the bitmap is inverted across the y-axis. If
 * {bitmap} is OpenGL formatted, then no inversion is necessary.
 * {bitorder} specifies whether to read bits from {bitmap} as high-to-low
 * or low-to-high
 * {w} gives the option of specifying the fg and bg colors for the converted
 * pixmap. If {w} is NULL, only alpha bytes are set (0xFF for '1' and 0 for '0')
 */
#define DONT_INVERT 0
#define INVERT 1
#define LOW_TO_HIGH 0
#define HIGH_TO_LOW 1
void bitmap_to_pixmap(unsigned char *bitmap, int width, int height,
   unsigned char *pixmap, int invert, int bitorder)
   {
   int i, ix, iy, bmwidth;
   const int n = 4;
   int offset = n-1;

   if (bitorder != LOW_TO_HIGH && bitorder != HIGH_TO_LOW)
      bitorder = HIGH_TO_LOW;

   bmwidth = width/8;
   if (width % 8) bmwidth++;

   for (iy = 0; iy < height; iy++) {
      unsigned char byte, c;
      unsigned int m;
      int index;
      if (invert)
         index = n*((height-(iy+1))*width);
      else
         index = n*(iy*width);

      for (i = 0, ix = 0; i < width; i++, index+=n) {
         if (i && (i % 8 == 0)) ix++;
         byte = bitmap[iy*bmwidth + ix];

         if (bitorder == LOW_TO_HIGH)
            m = 1 << (i % 8);
         else if (bitorder == HIGH_TO_LOW)
            m = 1 << (7 - i % 8);
         c = byte & m;
         if (c) {
            pixmap[index+offset] = 0xFF;
            }
         else {
            pixmap[index+offset] = 0;
            }
         }
      }
   }



struct b_list *segment_line(wbp w, int num, struct b_realarray *ap2,
   double *v2, word n2)
   {
   wsp ws = (w)->window;
   wcp wcr = &(ws->wcrender);
   tended struct b_realarray *apseg, *ap2_t = ap2;
   tended struct descrip desc;
   word i, j, k, nseg;
   double dx, dy, len, *vseg;
   const double MIN_LEN = 4.0;

   if (n2 % 2) {
      glprintf("number of coordinates should be even, got %ld\n",n2);
      return NULL;
      }

   if (ap2_t) v2 = ap2_t->a;

   dx = wcr->dx;
   dy = wcr->dy;
   nseg = 0;

   /* Find the size of the segmented array */
   for (i = 0; i < n2; i+=num) {
      if (i+3 < n2) {
         double deltax = v2[i+2]-v2[i];
         double deltay = v2[i+3]-v2[i+1];
         len = sqrt(deltax*deltax + deltay*deltay);
         nseg += (word)(2*ceil(len/MIN_LEN)); /* x2 for 2d coords */
         }
      else if (i+1 < n2) {
         /* last vertex, add it to the segmented array */
         nseg += 2;
         }
      }

   /* Alloc segmented array */
   nseg++; /* +1 for drawcode */
   AlcRealarrayList(desc, apseg, nseg, NULL);
   vseg = apseg->a;
   vseg[0] = GL_LINES;
   if (ap2_t) v2 = ap2_t->a;

   /* Calculate points and place them on real array */
   for (i = 0, j = 1; i < n2; i+=num) {
      if (i+3 < n2) {
         /* two vertices available, segment the line */
         word n;
         double deltax, deltay, theta;
         deltax = v2[i+2]-v2[i];
         deltay = v2[i+3]-v2[i+1];
         theta = atan2(deltay, deltax);

         /* maybe use macros to make this faster */
         len = sqrt(deltax*deltax + deltay*deltay);
         n = (word)(2*ceil(len/MIN_LEN));

         /* add segmented vertices to array */
         for (k = 0; k < n; k+=2) {
            double delx = (k/2)*MIN_LEN*cos(theta);
            double dely = (k/2)*MIN_LEN*sin(theta);
            vseg[j+k] = GLWORLDCOORD_RENDER_X(w, v2[i]+dx+delx);
            vseg[j+k+1] = GLWORLDCOORD_RENDER_Y(w, v2[i+1]+dy+dely);
            }
         j+=n;
         }
      else if (i+1 < n2) {
         /* add last vertex to array */
         vseg[j] = GLWORLDCOORD_RENDER_X(w, v2[i]+dx);
         vseg[j+1] = GLWORLDCOORD_RENDER_Y(w, v2[i+1]+dy);
         j+=2;
         }
      }
   return (struct b_list *)BlkLoc(desc);
   }


/*
 * Allocates and calculates coordinates for all geometric
 * primitives (polygons, circles, arcs, rectangles, lines, points,
 * line segments). Incorporates fillstyle for the primitives which
 * are filled.
 */
int drawgeometry2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   double dx, dy, *v, *vseg, wx, wy;
   tended struct b_realarray *ap, *apseg;
   tended struct b_record *rp_t = rp;
   word n, nseg;
   word i, j, k;
   int fill, polytype = 0, drawcode, intcode, recalc = 0;
#if 0
   /* [DonW] Preserved to ask Gigi about it
    *        Inside #if 0 to stop clang complaining it isn't used anywhere
    */
   const int THRESHOLD = 2000; /* should research this */
#endif

   intcode = IntVal(rp->fields[1]);
   dx = wcr->dx;
   dy = wcr->dy;

   /*
    * Get the base types and determine whether coordinates need to be
    * recalculated
    */
   switch (intcode) {
      case GL2D_FILLPOLYGON:
         polytype = IntVal(rp->fields[4]);
         fill = 1;
         break;
      case GL2D_FILLCIRCLE:
         recalc = RecalcCircle(rp);
         UpdateCircle(rp);
         fill = 1;
         break;
      case GL2D_FILLARC:
         recalc = RecalcArc(rp);
         UpdateArc(rp);
         fill = 1;
         break;
      case GL2D_FILLRECTANGLE:
         recalc = RecalcRect(rp);
         UpdateRect(rp);
         fill = 1;
         break;

      case GL2D_DRAWCIRCLE:
         recalc = RecalcCircle(rp);
         UpdateCircle(rp);
         fill = 0;
         break;
      case GL2D_DRAWARC:
         recalc = RecalcArc(rp);
         UpdateArc(rp);
         fill = 0;
         break;
      case GL2D_DRAWRECTANGLE:
         recalc = RecalcRect(rp);
         UpdateRect(rp);
         fill = 0;
         break;

      /*
       * These primitives are not allowed to be updated by the
       * user because they would incur N comparisons each time
       * they are rendered.
       */
      case GL2D_DRAWPOLYGON:
      case GL2D_DRAWLINE:
      case GL2D_DRAWSEGMENT:
      case GL2D_DRAWPOINT:
         fill = 0;
         break;

      default:
         glprintf("Invalid record type\n");
         return Failed;
      }

   /*
    * Recalculate coordinates if necessary
    */
   if (!is:list(rp->fields[2]) || recalc || ws->resize || RecalcTranslation(w))
      {
      switch (intcode) {
         case GL2D_FILLCIRCLE:
         case GL2D_FILLARC:
         case GL2D_DRAWCIRCLE:
         case GL2D_DRAWARC: {
            double x, y, r, theta, alpha, width, height;
            double start, end, dtheta, rx, ry;
            int is_complete;
            const double RINGS = 5.0;
            const int SKIP = 4;

            intcode = IntVal(rp->fields[1]);
            switch (intcode) {
               case GL2D_FILLCIRCLE:
               case GL2D_DRAWCIRCLE:
                  GetDouble(rp->fields[3], x);
                  GetDouble(rp->fields[4], y);
                  GetDouble(rp->fields[5], r);
                  GetDouble(rp->fields[6], theta);
                  GetDouble(rp->fields[7], alpha);

                  AddDxDy(w, x, y, r, r);
                  wx = GLWORLDCOORD_RENDER_X(w, x);
                  wy = GLWORLDCOORD_RENDER_Y(w, y);
                  rx = GLRADIUS_X(w, r);
                  ry = GLRADIUS_Y(w, r);
                  break;

               case GL2D_DRAWARC:
               case GL2D_FILLARC:
                  GetDouble(rp->fields[3], x);
                  GetDouble(rp->fields[4], y);
                  GetDouble(rp->fields[5], width);
                  GetDouble(rp->fields[6], height);
                  GetDouble(rp->fields[7], theta);
                  GetDouble(rp->fields[8], alpha);

                  AddDxDy(w, x, y, width, height);

                  /* Do some extra argument correction */
                  wx = GLWORLDCOORD_RENDER_X(w, x+width/2.0);
                  wy = GLWORLDCOORD_RENDER_Y(w, y+height/2.0);
                  r = (width+height)/4.0;
                  rx = GLRADIUS_X(w, width/2.0);
                  ry = GLRADIUS_Y(w, height/2.0);
                  break;

               default:
                  return Failed;
               }
            /* runtime check */
            if (alpha < 0) alpha = -alpha;

            /* figure out draw code */
            if (alpha >= 2*Pi) {
               alpha = 2*Pi;
               is_complete = 1;
               drawcode = GL_LINE_LOOP;
               }
            else {
               is_complete = 0;
               drawcode = GL_LINE_STRIP;
               }
            if (fill) drawcode = GL_POLYGON;

            /* calculate values */
            dtheta = 2*Pi/(RINGS*r);
            n = 2*ceil(alpha/dtheta) + 1; /* +1 for drawcode */
            if (!is_complete && fill) /* for partial filled circled */
               n += 2;
            start = theta;
            end = theta + alpha;

            if (!is:list(rp->fields[2]) || n != BlkD(rp->fields[2], List)->size)
               AlcRealarrayList(rp_t->fields[2], ap, n, RunError);
            else
               ap = (struct b_realarray *)BlkD(rp->fields[2],List)->listhead;

            /*
             * For segmented array
             */
            if (!fill) {
               nseg = 2*ceil(((n-1)/2)/SKIP) + 1; /* +1 for drawcode */
               switch (intcode) {
                  case GL2D_DRAWCIRCLE:
                     if (!is:list(rp_t->fields[13]) ||
                        nseg != BlkD(rp_t->fields[13], List)->size)
                        {
                        AlcRealarrayList(rp_t->fields[13], apseg, nseg, RunError);
                        }
                     else {
                        apseg = (struct b_realarray *)BlkD(
                                rp_t->fields[13],List)->listhead;
                        }
                     break;
                  case GL2D_DRAWARC:
                     if (!is:list(rp_t->fields[15]) ||
                        nseg != BlkD(rp_t->fields[15], List)->size)
                        {
                        AlcRealarrayList(rp_t->fields[15],apseg,nseg,RunError);
                        }
                     else {
                        apseg = (struct b_realarray *)BlkD(
                                rp_t->fields[15],List)->listhead;
                        }
                     break;
                  }
               vseg = apseg->a;
               vseg[0] = GL_LINES;
               }

            i = 0;
            v = ap->a; /* assign here to avoid tending issues */
            v[i++] = drawcode;
            if (!is_complete && fill) { /* for partial filled circled */
               v[i++] = wx;
               v[i++] = wy;
               }

            /* calculate points */
            for (j = i, k = 1; j < n; j+=2) {
               v[j] = wx + rx*cos(start);
               v[j+1] = wy + ry*sin(-start); /* to imitate X11 rotation */

               if (!fill && ((j-i)/2 % SKIP == 0) && k < nseg) {
                  vseg[k] = v[j];
                  vseg[k+1] = v[j+1];
                  k+=2;
                  }
               start += dtheta;
               }

            /* calculate endpoint specifically */
            v[n-2] = wx + rx*cos(end);
            v[n-1] = wy + ry*sin(-end); /* to imitate X11 rotation */
            if (!fill) {
               vseg[nseg-2] = v[n-2];
               vseg[nseg-1] = v[n-1];
               }
            break;
            }

         case GL2D_FILLRECTANGLE:
         case GL2D_DRAWRECTANGLE: {
            double x, y, width, height;
            struct b_list *lp;

            GetDouble(rp->fields[3], x);
            GetDouble(rp->fields[4], y);
            GetDouble(rp->fields[5], width);
            GetDouble(rp->fields[6], height);

            /* alloc cooked array */
            if (!is:list(rp->fields[2])) {
               if (intcode == GL2D_DRAWRECTANGLE)
                  AlcRealarrayList(rp_t->fields[2],ap,8+1,RunError); /* for line loop */
               else
                  AlcRealarrayList(rp_t->fields[2],ap,12+1,RunError); /* for triangles */
               }
            else
               ap = (struct b_realarray *)BlkD(rp_t->fields[2],List)->listhead;
            v = ap->a;
            n = BlkD(rp_t->fields[2], List)->size;

            /* calculate values */
            j = 1;
            AddDxDy(w, x, y, width, height);
            if (intcode == GL2D_DRAWRECTANGLE) {
               const word SIZE = 10;
               double vtmp[SIZE];

               /* (x1,y1)->(x1,y2)->(x2,y2)->(x2,y1) */
               v[j] = v[j+2] = GLWORLDCOORD_RENDER_X(w, x); /* x1 */
               v[j+1] = v[j+7] = GLWORLDCOORD_RENDER_Y(w, y); /* y1 */
               v[j+4] = v[j+6] = GLWORLDCOORD_RENDER_X(w, x+width); /* x2 */
               v[j+3] = v[j+5] = GLWORLDCOORD_RENDER_Y(w, y+height); /* y2 */

               /*
                * Create segmented array
                */
               v[0] = GL_LINE_LOOP; /* assign here to avoid tending issues */
               vtmp[0] = vtmp[2] = vtmp[8] = x; /* x1 */
               vtmp[1] = vtmp[7] = vtmp[9] = y; /* y1 */
               vtmp[4] = vtmp[6] = x+width; /* x2 */
               vtmp[3] = vtmp[5] = y+height; /* y2 */

               if ((lp = segment_line(w,2,NULL,vtmp,SIZE)) == NULL) {
                  return RunError;
                  }
               BlkLoc(rp_t->fields[11]) = (union block *)lp;
               rp_t->fields[11].dword = D_List;
               nseg = lp->size;
               apseg = (struct b_realarray *)lp->listhead;
               vseg = apseg->a;
               v = ap->a; /* in case of GC */
               }
            else { /* fill */
               /* (x1,y1)->(x1,y2)->(x2,y1) (x2,y1)->(x1,y2)->(x2,y2) */
               v[0] = GL_TRIANGLES;
               v[j] = v[j+2] = v[j+8] = GLWORLDCOORD_RENDER_X(w, x);
               v[j+1] = v[j+5] = v[j+7] = GLWORLDCOORD_RENDER_Y(w, y);
               v[j+4] = v[j+6] = v[j+10] = GLWORLDCOORD_RENDER_X(w, x+width);
               v[j+3] = v[j+9] = v[j+11] = GLWORLDCOORD_RENDER_Y(w, y+height);
               }
            break;
            }

         case GL2D_FILLPOLYGON:
         case GL2D_DRAWPOINT:
         case GL2D_DRAWPOLYGON:
         case GL2D_DRAWLINE:
         case GL2D_DRAWSEGMENT: {
            tended struct b_realarray *ap2;
            struct b_list *lp;
            int num;
            word n2;
            double *v2;

            ap2 = (struct b_realarray *)BlkD(rp->fields[3],List)->listhead;
            n2 = BlkD(rp->fields[3], List)->size;
            n = n2+1;

            if (!is:list(rp->fields[2]) || n != BlkD(rp->fields[2], List)->size)
               AlcRealarrayList(rp_t->fields[2],ap,n,RunError);
            else
               ap = (struct b_realarray *)BlkD(rp_t->fields[2],List)->listhead;

            switch (intcode) {
               case GL2D_FILLPOLYGON:
                  switch (polytype) {
                     case POLY_NONCONVEX:
                     case POLY_COMPLEX:
                        drawcode = GL_TRIANGLE_FAN;
                        break;
                     case POLY_CONVEX:
                        drawcode = GL_POLYGON;
                        break;
                     }
                  break;
               case GL2D_DRAWPOLYGON:
               case GL2D_DRAWLINE:
                  drawcode = GL_LINE_STRIP;
                  break;
               case GL2D_DRAWSEGMENT:
                  drawcode = GL_LINES;
                  break;
               case GL2D_DRAWPOINT:
                  drawcode = GL_POINTS;
                  break;
               }

            v = ap->a;
            v2 = ap2->a; /* assign here to avoid tending issues */
            v[0] = drawcode;
            for (i = 1; i < n; i+=2) {
               v[i] = GLWORLDCOORD_RENDER_X(w, v2[i-1]+dx);
               v[i+1] = GLWORLDCOORD_RENDER_Y(w, v2[i]+dy);
               }

            if (!fill && intcode != GL2D_DRAWPOINT) { /* segment lines */
               if (intcode == GL2D_DRAWSEGMENT)
                  num = 4;
               else
                  num = 2;

               /* pass {ap2->a} instead of {v2} because its tended */
               if ((lp = segment_line(w,num,ap2,NULL,n2)) == NULL) {
                  return RunError;
                  }
               BlkLoc(rp_t->fields[4]) = (union block *)lp;
               rp_t->fields[4].dword = D_List;
               nseg = lp->size;
               apseg = (struct b_realarray *)lp->listhead;
               vseg = apseg->a;
               v = ap->a; /* in case of GC */
               }
            break;
            }
         default:
            glprintf("Invalid record type\n");
            return Failed;
         } /* end switch */
      } /* end if */
   else {
      /*
       * Get reference to real cooked array
       */
      ap = (struct b_realarray *)BlkD(rp->fields[2],List)->listhead;
      v = ap->a;
      n = BlkD(rp->fields[2], List)->size;

      /* get reference to segmented array */
      if (!fill && wcr->linestyle != GL2D_LINE_SOLID) {
         switch (intcode) {
            case GL2D_DRAWCIRCLE:
               apseg = (struct b_realarray*)BlkD(rp->fields[13],List)->listhead;
               nseg = BlkD(rp->fields[13], List)->size;
               vseg = apseg->a;
               break;
            case GL2D_DRAWARC:
               apseg = (struct b_realarray*)BlkD(rp->fields[15],List)->listhead;
               nseg = BlkD(rp->fields[15], List)->size;
               vseg = apseg->a;
               break;
            case GL2D_DRAWRECTANGLE:
               apseg = (struct b_realarray*)BlkD(rp->fields[11],List)->listhead;
               nseg = BlkD(rp->fields[11], List)->size;
               vseg = apseg->a;
               break;
            case GL2D_DRAWPOLYGON:
            case GL2D_DRAWLINE:
            case GL2D_DRAWSEGMENT:
               apseg = (struct b_realarray *)BlkD(rp->fields[4],List)->listhead;
               nseg = BlkD(rp->fields[4], List)->size;
               vseg = apseg->a;
               break;
            case GL2D_DRAWPOINT:
               break;
            default:
               return Failed;
            }
         }
      }

   /*
    * Render primitive
    *
    * Linestyle and fillstyle are accounted for during this time for line
    * and filled primitives respectively. Points are the only primitive
    * that are rendered as is.
    *
    * NOTE: Transparency won't work when drawop="xor"/"reverse".
    */
   glPushMatrix();
   glTranslated(0,0,-CNEAR);
   switch (intcode) {
      case GL2D_DRAWPOINT:
         RenderRealarray(v, n);
         break;

      case GL2D_FILLPOLYGON:
      case GL2D_FILLCIRCLE:
      case GL2D_FILLARC:
      case GL2D_FILLRECTANGLE:
         /*
          * For complex and nonconvex polygons:
          * Use a 2-pass stencil algorithm where writing to the color buffer is
          * disabled on the first pass to only draw to the stencil buffer.
          * Only regions drawn to an odd number of times (1st pass) will have a
          * '1' will be drawn to on the second pass.
          *
          * http://www.glprogramming.com/red/chapter14.html#name13
          */
         if (polytype == POLY_COMPLEX || polytype == POLY_NONCONVEX) {
            /*
             * First pass
             */
            EnableStencilWrite(GL2D_DRAW_BIT,0,GL_INVERT);
            glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
            RenderRealarray(v, n);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            DisableStencilWrite();

            /*
             * Second pass
             */
            RenderRealarrayFillstyle(w, v, n, GL2D_DRAW_BIT);
            }
         else {
            RenderRealarrayFillstyle(w, v, n, 0);
            }
         break;

      case GL2D_DRAWLINE:
      case GL2D_DRAWSEGMENT:
      case GL2D_DRAWPOLYGON:
      case GL2D_DRAWRECTANGLE:
      case GL2D_DRAWCIRCLE:
      case GL2D_DRAWARC:
         RenderRealarrayLinestyle(w, v, n, vseg, nseg);
         break;
      } /* end switch */
   glPopMatrix();

   return Succeeded;
   }



/*
 * Draws a bi-level image using bitmaps.
 */
int drawblimage2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   char c, ch, *s;
   int width, height, len, update = 0;
   double x, y;
   unsigned char *bitmap;
   unsigned int texid, index, *texptr;

   if (!rp) return Failed;

   GetDouble(rp->fields[2], x);
   GetDouble(rp->fields[3], y);
   GetInt(rp->fields[4], width);
   GetInt(rp->fields[5], height);
   GetStr(rp->fields[6], s, len);
   ch = (char)IntVal(rp->fields[7]);

   if (is:integer(rp->fields[8]) && is:integer(rp->fields[9])) {
      texid = IntVal(rp->fields[8]);
      index = IntVal(rp->fields[9]);

      if (wd->texIds[index] != texid)
         update = 1;
      else
         UGLBindTexture(GL_TEXTURE_2D, texid);
      }
   else
      update = 1;

   if (update) {
      tended struct b_record *rp_t = rp;
      unsigned int ix, iy, bmwidth, index, shift, m, msk1, bytes;
      unsigned char *tmp;

      /* determine bitmap dimensions, each byte contains 8 pixel values */
      bmwidth = width/8;
      if (width % 8)
         bmwidth++;
      bytes = bmwidth*height;

      bitmap = (unsigned char *)malloc(bytes);
      if (!bitmap) return RunError;

      /*
       * Read the image string and set the pixel values.  Note that
       * the hex digits in sequence fill the rows *right to left*.
       */
      m = width % 4;
      if (m == 0)
         msk1 = 8;
      else
         msk1 = 1 << (m - 1);              /* mask for first byte of row */

      ix = width;
      iy = 0;
      m = msk1;
      while (len--) {
         if (isxdigit(c = *s++)) {         /* if hexadecimal character */
            if (!isdigit(c))               /* fix bottom 4 bits if necessary */
               c += 9;
            while (m > 0) {                /* set (usually) 4 pixel values */
               --ix;
               index = ix/8 + bmwidth*(height-(iy+1));
               shift = 7 - ix % 8;
               if (c & m) {
                  bitmap[index] |= 1 << shift; /* set */
                  }
               else {
                  bitmap[index] &= ~(1 << shift); /* clear */
                  }
               m >>= 1;
               }
            if (ix == 0) {                 /* if end of row */
               ix = width;
               iy++;
               m = msk1;
               }
            else
               m = 8;
            }
         }
      if (ix > 0) {                        /* pad final row if incomplete */
         while (ix < width) {
            bitmap[ix/8 + bmwidth*(height-(iy+1))] &= ~(1 << (7 - ix % 8)); /* clear */
            }
         }

      /* create texture */
      tmp = malloc(4*width*height);
      if (!tmp) return RunError;
      bitmap_to_pixmap(bitmap, width, height, tmp, DONT_INVERT, HIGH_TO_LOW);

      index = get_tex_index(wd, 1);
      texptr = &(wd->texIds[index]);
      InitTexture2d(texptr);
      UGLTexImage2D(wd, GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA,
                    GL_UNSIGNED_BYTE, tmp, RunError);
      free(tmp);
      free(bitmap);

      MakeInt(*texptr, &(rp->fields[8]));
      MakeInt(index, &(rp->fields[9]));
      }

   AddDxDy(w, x, y, width, height);

   if (ch == TCH1) /* transparent background */
      RenderTexturedBitmapRect(w,x,y,width,height,width,height,-CNEAR,
                               TRANSP_BG);
   else
      RenderTexturedBitmapRect(w,x,y,width,height,width,height,-CNEAR,FILL_BG);
   UGLBindTexture(GL_TEXTURE_2D, 0); /* unbind */
   return Succeeded;
   }




/*
 * Draw an image loaded from a file
 */
int drawreadimage2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   int width, height, is_pixmap, update = 0;
   double x, y;
   unsigned char *img;
   unsigned int texid, index;

   if (!rp) return Failed;

   GetDouble(rp->fields[2], x);
   GetDouble(rp->fields[3], y);
   GetInt(rp->fields[4], width);
   GetInt(rp->fields[5], height);
   is_pixmap = IntVal(rp->fields[6]);

   if (is:integer(rp->fields[8]) && is:integer(rp->fields[9])) {
      texid = IntVal(rp->fields[8]);
      index = IntVal(rp->fields[9]);

      if (wd->texIds[index] != texid)
         update = 1;
      else
         UGLBindTexture(GL_TEXTURE_2D, texid);
      }
   else
      update = 1;

   if (update) {
      unsigned int *texptr;

      img = (unsigned char *)StrLoc(rp->fields[7]);
      index = get_tex_index(wd, 1);
      texptr = &(wd->texIds[index]);
      InitTexture2d(texptr);

      if (is_pixmap) {
         UGLTexImage2D(wd, GL_TEXTURE_2D, 0, GL_RGB8, width, height, 0, GL_RGB,
                       GL_UNSIGNED_BYTE, img, RunError);
         }
      else {
         unsigned char *tmp;

         tmp = malloc(4*width*height);
         if (!tmp) return RunError;
         bitmap_to_pixmap(img, width, height, tmp, DONT_INVERT, HIGH_TO_LOW);
         UGLTexImage2D(wd, GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0,
                       GL_RGBA, GL_UNSIGNED_BYTE, tmp, RunError);
         free(tmp);
         }

      MakeInt(texid = *texptr, &(rp->fields[8]));
      MakeInt(index, &(rp->fields[9]));
      }

   AddDxDy(w, x, y, width, height);

   if (is_pixmap) {
      RenderTexturedRect(w, x, y, width, height, width, height, -CNEAR);
      }
   else { /* bitmap */
      RenderTexturedBitmapRect(w, x, y, width, height, width, height, -CNEAR,
                               TRANSP_BG);
      }

   UGLBindTexture(GL_TEXTURE_2D, 0); /* unbind */
   return Succeeded;
   }



int drawstrimage2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wdp wd = ws->display;
   int width, height;
   double x, y;
   unsigned char *pixmap;
   unsigned int texid, index, update = 0;

   if (!rp) return Failed;

   GetDouble(rp->fields[2], x);
   GetDouble(rp->fields[3], y);
   GetInt(rp->fields[4], width);
   GetInt(rp->fields[5], height);

   if (is:integer(rp->fields[7]) && is:integer(rp->fields[8])) {
      texid = IntVal(rp->fields[7]);
      index = IntVal(rp->fields[8]);
      if (wd->texIds[index] != texid)
         update = 1;
      else
         UGLBindTexture(GL_TEXTURE_2D, texid);
      }
   else {
      update = 1;
      }

   /* (re)allocate texture */
   if (update) {
      unsigned int *texptr;

      pixmap = (unsigned char *)StrLoc(rp->fields[6]);
      index = get_tex_index(wd, 1);
      texptr = &(wd->texIds[index]);
      InitTexture2d(texptr);
      UGLTexImage2D(wd, GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA,
                    GL_UNSIGNED_BYTE, pixmap, RunError);

      MakeInt(texid = *texptr, &(rp->fields[7]));
      MakeInt(index, &(rp->fields[8]));
      }

   AddDxDy(w, x, y, width, height);
   RenderTexturedRect(w,x,y,width,height,width,height,-CNEAR);
   UGLBindTexture(GL_TEXTURE_2D, 0); /* unbind */
   return Succeeded;
   }



int drawstring2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   int len, fill, rv;
   double x, y;
   char *s;

   if (!rp) return Failed;

   switch (IntVal(rp->fields[1])) {
      case GL2D_DRAWSTRING:
         fill = 0;
         GetDouble(rp->fields[2], x);
         GetDouble(rp->fields[3], y);
         x += wcr->dx;
         y += wcr->dy;
         break;
      case GL2D_WWRITE:
         fill = 1;
         GetDouble(rp->fields[2], x);
         GetDouble(rp->fields[3], y);
         break;
      default:
         glprintf("invalid intcode for drawstring2d(): %ld\n",\
                  IntVal(rp->fields[1]));
         return Failed;
         break;
      }
   GetStr(rp->fields[4], s, len);

   switch (rv = drawstringhelper(w, x, y, -CNEAR, s, len, fill, 1)) {
      case Failed: return Failed;
      case RunError: return RunError;
      case Succeeded: return Succeeded;
      default: return rv;
      }
   }



/*
 * Uses FreeType to create the text pixmap. Creates the display list
 * entry and calls drawstring2d() to render the text pixmap.
 *
 * It appears that the RC or XY position specifies the bottom left corner
 * of the text block to be drawn.
 *
 * NOTE: Assumes a horizontal text layout for all texts used. Adding vertical
 * text layout could be a to-do item.
 *
 * TODO: This function only supports ASCII characters. Extend it to support more
 * (unicode?)
 */
#ifdef HAVE_LIBFREETYPE

/*
 * (x,y) specifies the lower-left hand corner of the string.
 */
int drawstringhelper(wbp w, double x, double y, double z, char *s, int len,
   int fill, int draw)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   wdp wd = ws->display;
   wfp wf = wcr->font;
   int fheight, fdescent, textwidth;
   double startx, penx, peny;
   char *ptr = s;
   FT_Face face = wf->face;

   fheight = FT_FHEIGHT(face);
   fdescent = FT_DESCENT(face);
   penx = startx = x;
   peny = y + fdescent; /* center vertically around global font baseline */
   textwidth = 0;

   /* If rendering characters, apply settings */
   if (draw) {
      EnableStencilWrite(GL2D_DRAW_BIT,0,GL_REPLACE);
      glEnable(GL_TEXTURE_2D);
      glDisable(GL_TEXTURE_GEN_S);
      glDisable(GL_TEXTURE_GEN_T);
      }

   while (len--) {
      unsigned char c = *ptr++;
      struct fontsymbol *sym = &wf->chars[c];

      /* initialize character */
      if (!sym->pixmap) {
         FT_GlyphSlot glyph;
         FT_Bitmap ftbitmap;
         int size, rv, bmwidth;
         unsigned char *bitmap;

         /* Load a monochrome bitmap (1 bit per pixel) */
         rv = FT_Load_Char(face, c, FT_LOAD_RENDER | FT_LOAD_MONOCHROME);
         if (rv) {
            /* what to do in the case of a failure to load a glyph? */
            glprintf("failed to find char '%c'\n",c);
            continue;
            }

         /* get glyph bitmap dimensions */
         glyph = wf->face->glyph;
         ftbitmap = glyph->bitmap;
         bitmap = ftbitmap.buffer;
         bmwidth = ftbitmap.pitch; /* # of bytes per row (incl. padding) */
         if (bmwidth < 0) bmwidth = -bmwidth;

         sym->height = ftbitmap.rows;
         sym->width = 8*bmwidth;
         sym->advance = glyph->advance.x >> 6;
         sym->top_bearing = glyph->bitmap_top;
         sym->left_bearing = glyph->bitmap_left;

         /* convert the bitmap to a pixmap (to be used as a texture) */
         size = 4*(sym->width)*(sym->height);
         sym->pixmap = (unsigned char *)malloc(size);
         if (!sym->pixmap) return RunError;
         bitmap_to_pixmap(bitmap, sym->width, sym->height, sym->pixmap, INVERT,
                          HIGH_TO_LOW);
         }

      if (draw) {
         double x1, y1;

         if (!sym->texid || wd->texIds[sym->index] != sym->texid) {
            unsigned int *texptr;

            /* allocate texture */
            sym->index = get_tex_index(wd, 1);
            texptr = &(wd->texIds[sym->index]);
            InitTexture2d(texptr);
            UGLTexImage2D(wd, GL_TEXTURE_2D, 0, GL_RGBA8, sym->width,
                          sym->height, 0, GL_RGBA, GL_UNSIGNED_BYTE,
                          sym->pixmap, RunError);
            sym->texid = *texptr;
            }
         else {
            UGLBindTexture(GL_TEXTURE_2D, sym->texid);
            }

         /*
          * Draw to stencil buffer
          *
          * Position character (low left corner) by using the left and top
          * bearing values. See FreeType glyph metrics.
          */
         x1 = penx + sym->left_bearing;
         y1 = peny - sym->top_bearing;
         _RenderTexturedRect(w,x1,y1,sym->width,sym->height,sym->width,
                             sym->height,z);
         penx += sym->advance;
         }

      textwidth += sym->advance;
      } /* end while */

   if (draw) { /* render text */
      glDisable(GL_TEXTURE_2D);
      glEnable(GL_TEXTURE_GEN_S);
      glEnable(GL_TEXTURE_GEN_T);
      DisableStencilWrite(); /* done writing to stencil buffer */
      UGLBindTexture(GL_TEXTURE_2D, 0); /* unbind */

      if (fill) { /* background fill */
         SetDrawopColorState(w, wcr->drawop, BG);
         RenderFilledRect(startx,y-fheight,textwidth,fheight,z);
         SetDrawopColorState(w, wcr->drawop, FG);
         }

      /* draw text */
      SetStencilFunc(w, GL2D_DRAW_BIT);
      RenderFilledRect(startx,y-fheight,textwidth,fheight,z);
      DefaultStencilFunc(w);
      }
   return textwidth;
   }

#else                                   /* HAVE_LIBFREETYPE */

int drawstringhelper(wbp w, double x, double y, double z, char *s, int len,
   int fill, int draw)
   {
   return Failed;
   }

#endif                                  /* HAVE_LIBFREETYPE */



/*
 * 2d CopyArea() semantics (!ws->is_3D)
 *    Copies all pixels (same as legacy semantics)
 *
 * 2d/3d CopyArea() semantics (ws->is_3D):
 *    Only copies 2D/HUD pixels
 */
#define OffscreenPixel(ws, x, y, ix, iy) \
   ((real_iy+y < 0 || real_iy+y > (ws)->height || ix+x < 0 ||\
    ix+x > (ws)->width))
int copyarea2d(wbp w2, struct b_record *rp)
   {
   wbp w, tmp1, tmp2;
   wsp ws2 = w2->window, ws;
   wdp wd;
   double x, y, x2, y2;
   int width, height, update = 0;
   unsigned char *depth, *pixmap = NULL;
   unsigned int texid, index, *texptr;

   if (!rp) return Failed;

   /* get attributes */
   if (!is:file(rp->fields[2]))
      w = NULL;
   else {
      w = BlkD(rp->fields[2],File)->fd.wb;
      if (!w || !w->refcount || !w->window || !w->context) {
         w = NULL;
         rp->fields[2] = nulldesc;
         }
      else {
         /* check if w is still valid */
         for (tmp1 = wbndngs, tmp2 = NULL; tmp1; tmp1 = tmp1->next) {
            if (tmp1 == w) {
               tmp2 = w;
               break;
               }
            }
         /* window (w) has been freed, make nulldesc */
         if (!tmp2) {
            w = NULL;
            rp->fields[2] = nulldesc;
            }
         }
      }

   GetDouble(rp->fields[3], x);
   GetDouble(rp->fields[4], y);
   GetInt(rp->fields[5], width);
   GetInt(rp->fields[6], height);
   GetDouble(rp->fields[7], x2);
   GetDouble(rp->fields[8], y2);

   /*
    * Grab cooked values
    */
   if (is:integer(rp->fields[9]) && is:integer(rp->fields[10])) {
      texid = (unsigned int)IntVal(rp->fields[9]);
      index = (unsigned int)IntVal(rp->fields[10]);

      if (w) {
         wd = w->window->display;
         }
      else {
         /* Since window is closed, the binding has been freed */
         rp->fields[2] = nulldesc;

         /*
          * if window is closed, assume same display
          * TODO: expand to encompass different displays
          */
         wd = ws2->display;
         }

      /* check if texture is still alive */
      if (wd->texIds[index] == texid)
         UGLBindTexture(GL_TEXTURE_2D, texid);
      else
         update = 1;
      }
   else if (w) {
      wd = w->window->display;
      if (wd != ws2->display) {
         glprintf("gl_copyArea() does not yet support two diff displays\n");
         return Failed;
         }
      update = 1;
      }
   else /* window closed before read... */
      return Failed;

   /*
    * Get the rectangular area from {w}
    */
   if (update) {
      tended struct b_record *rp_t = rp;
      int ix, iy, px, py;
      unsigned char bg[4];
      int outofbounds = 0, size;

      ws = w->window;

      /*
       * Get area from source window
       */
      MakeCurrent(w);
      AddDxDy(w, x, y, width, height);

      /* check for out-of-bounds rectangle */
      if ((x+width > ws->width || x < 0) || (y+height > ws->height || y < 0)) {
         outofbounds = 1;
         }

      px = x;
      py = ws->height - (y + height); /* correct for OpenGL conventions */

      /* get color buffer */
      size = width*height;
      pixmap = (unsigned char *)malloc(4*size);
      if (!pixmap) return RunError;
      glReadPixels(px,py,width,height,GL_RGBA,GL_UNSIGNED_BYTE,pixmap);

      if (ws->is_3D) {
         /* get depth buffer */
         depth = (unsigned char *)malloc(size);
         if (!depth) return RunError;
         glReadPixels(px,py,width,height,GL_DEPTH_COMPONENT,GL_UNSIGNED_BYTE,
                      depth);
         for (iy = 0; iy < height; iy++) {
            int real_iy = height-iy-1; /* unicon y-coord */
            for (ix = 0; ix < width; ix++) {
               /* make off-screen pixels transparent */
               if (outofbounds && OffscreenPixel(ws,x,y,ix,real_iy)) {
                  pixmap[4*(iy*width+ix)+3] = 0;
                  }
               /* make 3D pixels transparent */
               else if (depth[iy*width+ix] != 0) {
                  pixmap[4*(iy*width+ix)+3] = 0;
                  }
               }
            }
         free(depth);
         }
      /*
       * Fill offscreen pixels with bg color
       */
      else if (outofbounds) { /* !ws->is_3D */
         GetContextColorUC(w, BG, bg[0], bg[1], bg[2], bg[3]);
         for (iy = 0; iy < height; iy++) {
            int real_iy = height-iy-1; /* unicon y-coord */
            for (ix = 0; ix < width; ix++) {
               /* make off-screen pixels transparent */
               if (OffscreenPixel(ws,x,y,ix,real_iy)) {
                  int index = 4*(iy*width+ix);
                  AssignRGBA(&(pixmap[index]),bg[0],bg[1],bg[2],bg[3]);
                  }
               }
            }
         }
      MakeCurrent(w2); /* restore glX context */

      /* create texture */
      index = get_tex_index(wd, 1);
      texptr = &(wd->texIds[index]);
      InitTexture2d(texptr);
      UGLTexImage2D(wd, GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA,
                    GL_UNSIGNED_BYTE, pixmap, RunError);
      free(pixmap);

      /* Update field values */
      MakeInt(*texptr, &(rp_t->fields[9]));
      MakeInt(index, &(rp_t->fields[10]));
      }

   AddDxDy(w2, x2, y2, width, height);
   RenderTexturedRect(w2,x2,y2,width,height,width,height,-CNEAR);
   UGLBindTexture(GL_TEXTURE_2D, 0); /* unbind */

   return Succeeded;
   }



/*
 * 2D semantics (!ws->is_3D):
 *    Erases everything in the specified area
 * 2D/3D semantics (ws->is_3D):
 *    Erases only 2D/HUD pixels in the specified area. This is done with
 *    a unique traversal algorithm in traversefunclist2d().
 */
int erasearea2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   double x, y, width, height;

   if (!rp) return Failed;

   GetDouble(rp->fields[2], x);
   GetDouble(rp->fields[3], y);
   GetDouble(rp->fields[4], width);
   GetDouble(rp->fields[5], height);

   AddDxDy(w, x, y, width, height);

   if (ws->is_3D) {
      /* this should only run during a 3d's windows traversal redraw */
      glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
      glDepthMask(GL_FALSE);
      EnableStencilWrite(GL2D_ERASE_BIT,0xFF,GL_ZERO);
      RenderFilledRect(x, y, width, height, -CNEAR);
      DisableStencilWrite();
      glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
      glDepthMask(GL_TRUE);
      }
   else {
      /*
       * Draw bg color to the far plane of the viewing volumes. This
       * erases all primitives in the rectangular area. 3d primitives
       * are drawn after 2d primitives to make this work
       */
      SetDrawopColorState(w, wcr->drawop, BG);
      glDepthFunc(GL_ALWAYS); /* enable writing always (regardless of depth) */
      DepthRangeMax(); /* set depth range to max */
      RenderFilledRect(x,y,width,height,-CNEAR);
      DepthRange2d(); /* restore depth range */
      glDepthFunc(GL_LEQUAL); /* restore default */
      SetDrawopColorState(w, wcr->drawop, FG);
      }
   return Succeeded;
   }



/*
 * Attributes
 */



/*
 * Sets the render context's fg/bg to the appropriate values using
 * display list items.
 * SetDrawopColorState() actually sets the OpenGL color states.
 */
int setcolor2d(wbp w, struct b_record *rp, int type)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   int index, intcode;
   unsigned int r, g, b, a;

   /*
    * No display list entry, so use the current render context color
    * specified by type.
    */
   if (!rp) {
      switch (intcode = type) {
         case GL2D_FG:
            GetColorUS(w, wcr->glfg, r, g, b, a);
            index = wcr->glfg.id;
            break;
         case GL2D_BG:
            GetColorUS(w, wcr->glbg, r, g, b, a);
            index = wcr->glbg.id;
            break;
         default:
            glprintf("incorrect record type\n");
            return Failed;
         }
      }
   else {
      intcode = IntVal(rp->fields[1]);

      /* mutable color */
      if (is:integer(rp->fields[2])) {
         GetInt(rp->fields[2], index);
         if (find_mutable(w, index) == NULL) {
            glprintf("Mutable color not found\n");
            return Failed;
            }
         r = g = b = a = 0;
         }
      /* non-mutable color */
      else {
         index = 0;
         GetInt(rp->fields[3], r);
         GetInt(rp->fields[4], g);
         GetInt(rp->fields[5], b);
         GetInt(rp->fields[6], a);
         }
      }

   if (intcode == GL2D_FG) {
      SetColor(wcr->glfg, r, g, b, a, index);
      SetDrawopColorState(w, wcr->drawop, FG);
      }
   else if (intcode == GL2D_BG) {
      SetColor(wcr->glbg, r, g, b, a, index);
      if (wcr->reverse || wcr->drawop == GL2D_DRAWOP_REVERSE)
         SetDrawopColorState(w, wcr->drawop, FG);
      }

   return Succeeded;
   }



/*
 * Sets the current fg color to the fg color xor'd with the bg color
 * if drawop="reverse".
 *
 * Need to take into consideration mutable colors and the implications
 * for updating the fg color when in drawop="reverse"
 */
int setdrawop2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wc = w->context, wcr = &(ws->wcrender);
   char *s;
   int len;

   if (rp) {
      GetStr(rp->fields[2], s, len);
      if (!strncmp(s,"reverse",len) || !strncmp(s,"xor",len)) {
         wcr->drawop = GL2D_DRAWOP_REVERSE;
         }
      /* everything else is "copy", even if it's an invalid string? */
      else {
         wcr->drawop = GL2D_DRAWOP_COPY;
         }
      }
   else {
      wcr->drawop = wc->drawop;
      }

   ApplyDrawop(w, wcr->drawop);
   return Succeeded;
   }

int setgamma2d(wbp w, struct b_record *rp)
   {
   if (!rp) return Failed;
   GetReal(&(rp->fields[2]), w->window->wcrender.gamma);
   ApplyGamma(w);
   return Succeeded;
   }

/*
 * Toggles "reverse" attribute
 */
int togglefgbg2d(wbp w)
   {
   wcp wcr = &(w->window->wcrender);

   wcr->reverse = !(wcr->reverse);

   /* set OpenGL color state using render context */
   SetDrawopColorState(w, wcr->drawop, FG);
   return Succeeded;
   }

int setfont2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   wfp wf;
   char *s;
   int len;

   if (!rp) return Failed;

   GetStr(rp->fields[2], s, len);

   /* try to find/alloc font */
   wf = gl_alc_font(w, &s, len);
   if (!wf)
      return Failed;

   /* update render context */
   if (wcr->font)
      wcr->font->refcount--;
   wcr->font = wf;
   wcr->leading = FT_FHEIGHT(wf->face);
   wcr->font->refcount--;

   return Succeeded;
   }



int setleading2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);

   if (!rp) return Failed;
   GetInt(rp->fields[2], wcr->leading);
   return Succeeded;
   }



int setlinewidth2d(wbp w, struct b_record *rp)
   {
   wcp wcr = &(w->window->wcrender);

   /* should this be a double instead? */
   GetInt(rp->fields[2], wcr->linewidth);
   ApplyLinewidth(wcr->linewidth);
   return Succeeded;
   }



int setlinestyle2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   char *s;
   int len;

   if (!rp) return Failed;

   GetStr(rp->fields[2], s, len);
   if (!strncmp(s, "solid", len)) {
      wcr->linestyle = GL2D_LINE_SOLID;
      }
   else if (!strncmp(s, "dashed", len)) {
      wcr->linestyle = GL2D_LINE_DASHED;
      }
   else if (!strncmp(s, "striped", len)) {
      wcr->linestyle = GL2D_LINE_STRIPED;
      }
   else return Failed;
   return Succeeded;
   }



int setfillstyle2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   char *s;
   int len;

   if (!rp) return Failed;

   GetStr(rp->fields[2], s, len);
   if (!strncmp(s, "solid", len)) {
      wcr->fillstyle = GL2D_FILL_SOLID;
      }
   else if (!strncmp(s, "masked", len)) {
      wcr->fillstyle = GL2D_FILL_MASKED;
      }
   else if (!strncmp(s, "textured", len)) {
      wcr->fillstyle = GL2D_FILL_TEXTURED;
      }
   else return Failed;
   return Succeeded;
   }



int setpattern2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   wdp wd = ws->display;
   int width, nbits, slen, s1len, update;
   unsigned int index = 0;
   char *s, *s1;
   unsigned int texid = 0, *texptr = NULL;

   if (rp) {
      GetStr(rp->fields[2], s, slen);
      GetStr(rp->fields[3], s1, s1len);

      /* Check if pattern string has changed */
      update = (slen <= s1len) ? strncmp(s, s1, slen) : strncmp(s, s1, s1len);
      if (update) {
         /*
          * TODO: If a texture id is already active (and is not a std pattern),
          * load a new texture into it
          */
         MakeStr(s, slen, &(rp->fields[3]));
         }
      else {
         if (is:integer(rp->fields[6]) && is:integer(rp->fields[7])) {
            texid = (unsigned int) IntVal(rp->fields[6]);
            index = (unsigned int) IntVal(rp->fields[7]);

            /* Check if non-std pattern needs to be reallocated */
            if (index && texid != wd->texIds[index]) {
               update = 1;
               }
            else {
               width = IntVal(rp->fields[4]);
               nbits = IntVal(rp->fields[5]);
               UGLBindTexture(GL_TEXTURE_2D, texid);
               }
            }
         else {
            update = 1;
            }
         }
      }
   else {
     update = 1;
     s = wcr->patternname;
     slen = strlen(wcr->patternname);
     }

   if (update) {
      /*
       * Allocate texture
       */
      int size;
      int i, j;
      unsigned char *img;
      tended struct b_record *recp = rp;
      unsigned char data[MAXXOBJS];
      unsigned char *buf = data;
      C_integer v, bits[MAXXOBJS];
      int symbol;

      if ((slen > 0) && isdigit(s[0])) {
         /*
          * If the pattern starts with a number it is a width , bits encoding
          */
         nbits = MAXXOBJS;
         switch (parsepattern(s, slen, &width, &nbits, bits)) {
            case Failed:
               return Failed;
            case RunError:
               return RunError;
            }

         for(i = 0; i < nbits; i++) {
            v = bits[i];
            for(j=0; j<width; j+=8) {
               *buf++ = v;
               v >>= 8;
               }
            }
         index = get_tex_index(wd, 1);
         texptr = &(wd->texIds[index]);
         }
      else if ((symbol = si_s2i(siPatternSyms, s)) >= 0) {
         /*
          * Otherwise, it is a named pattern.  Find the symbol id.
          *
          * See if named pattern has been allocated already
          * If so, get texture id and move on
          */
         nbits = width = 8;
         if (wd->stdPatTexIds[symbol] > 0) {
            texid = wd->stdPatTexIds[symbol];
            }
         else {
            for(i = 0; i < 8; i++) {
               v = patbits[symbol * 8 + i];
               *buf++ = v;
               }
            texptr = &(wd->stdPatTexIds[symbol]);
            }
         }

      if (!texptr) { /* stdpat already allocated */
         UGLBindTexture(GL_TEXTURE_2D, texid);
         }
      else {
         /*
          * Convert from bits to bytes.
          *
          * Need to invert the pattern across the y-axis since OpenGL reads
          * from the lower left corner first (bottom to top, left to right)
          * from the array start to end.
          */
         size = 4*width*nbits;
         img = (unsigned char *)malloc(size);
         if (!img) return RunError;
         bitmap_to_pixmap(data, width, nbits, img, INVERT, LOW_TO_HIGH);

         /*
          * Generate a texture based off the pattern (img)
          */
         InitTexture2d(texptr);
         UGLTexImage2D(wd, GL_TEXTURE_2D, 0, GL_RGBA8, width, nbits, 0,
                       GL_RGBA, GL_UNSIGNED_BYTE, img, RunError);
         free(img);
         }

      /*
       * Update record fields
       */
      if (rp) {
         MakeInt(width, &(rp->fields[4]));
         MakeInt(nbits, &(rp->fields[5]));
         if (texptr)
            MakeInt(*texptr, &(rp->fields[6]));
         else
            MakeInt(texid, &(rp->fields[6]));
         /*
          * Index of 0 indicates it is a std pattern, otherwise it is the index
          * into the general texture id array (wd->texIds)
          */
         MakeInt(index, &(rp->fields[7]));
         }
      }

   /*
    * Update render context pattern name
    */
   if (rp) {
      if (wcr->patternname != NULL)
         free(wcr->patternname);
      wcr->patternname = malloc(slen+1);
      if (wcr->patternname == NULL) return RunError;
      strncpy(wcr->patternname, s, slen);
      wcr->patternname[slen] = '\0';
      }

   /*
    * Apply pattern to stencil buffer by using texture and alpha test
    */
   glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
   glDepthMask(GL_FALSE);
   EnableStencilWrite(GL2D_PATT_BIT,0,GL_REPLACE);

   RenderTexturedRect(w,0,0,ws->width,ws->height,width,nbits,-CNEAR);

   /* restore */
   DisableStencilWrite();
   glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
   glDepthMask(GL_TRUE);

   UGLBindTexture(GL_TEXTURE_2D, 0); /* unbind */

   return Succeeded;
   }



/*
 * Uses scissor test to implement 2D clipping.
 */
int setclip2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   int clipx, clipy, clipw, cliph;

   if (rp == NULL) {
      clipx = wcr->clipx;
      clipy = wcr->clipy;
      clipw = wcr->clipw;
      cliph = wcr->cliph;
      }
   else {
      GetInt(rp->fields[2], clipx);
      GetInt(rp->fields[3], clipy);
      GetInt(rp->fields[4], clipw);
      GetInt(rp->fields[5], cliph);

      /* update render context */
      wcr->clipx = clipx;
      wcr->clipy = clipy;
      wcr->clipw = clipw;
      wcr->cliph = cliph;
      }

   /* clipping disabled */
   if (clipx == 0 && clipy == 0 && clipw == -1 && cliph == -1) {
      if (glIsEnabled(GL_SCISSOR_TEST) == GL_TRUE)
         glDisable(GL_SCISSOR_TEST);
      }
   else {
      if (glIsEnabled(GL_SCISSOR_TEST) == GL_FALSE)
         glEnable(GL_SCISSOR_TEST);

      /* recook translation */
      clipx += wcr->dx;
      clipy += wcr->dy;
      glScissor(clipx, ws->height-(clipy+cliph), clipw, cliph);
      }
   return Succeeded;
   }



int setdx2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);

   GetInt(rp->fields[2], wcr->dx);
   if (wcr->dx != IntVal(rp->fields[3])) {
      ws->dx_flag = 1;
      IntVal(rp->fields[3]) = wcr->dx;
      }
   else
      ws->dx_flag = 0;
   return Succeeded;
   }



int setdy2d(wbp w, struct b_record *rp)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);

   GetInt(rp->fields[2], wcr->dy);
   if (wcr->dy != IntVal(rp->fields[3])) {
      ws->dy_flag = 1;
      IntVal(rp->fields[3]) = wcr->dy;
      }
   else
      ws->dy_flag = 0;
   return Succeeded;
   }



/******************************************************
 * (2) Drawing functions (creates display list entry) *
 ******************************************************/

/*
 * Draw a bi-level image (1-bit-per-pixel, encoded as a string) image.
 * Used in DrawImage(). Creates and stores bitmap record. The origin (x,y)
 * of the bi-level image is in the upper left-hand corner.
 *
 * Pixel value of 1 corresponds to fg color, 0 to bg color.
 */

int gl_blimage(wbp w, int x, int y, int width, int height, int ch,
   unsigned char *s, word len)
   {
   wsp ws = w->window;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_BLIMAGE;
   tended struct descrip f;
   tended struct b_record *rp;
   tended char *s2;
   int nfields, rv;

   ws->busy_flag = 1;

   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);
   Get2dRecordConstr(constr, intcode);
   nfields = (int) BlkD(*constr, Proc)->nfields;
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   /* remove dx/dy from non-defaulted values. default is 0 */
   RemoveDxDy(w, x, y, width, height);

   MakeStr("BilevelImage", 12, &(rp->fields[0])); /* record name */
   MakeInt(GL2D_BLIMAGE, &(rp->fields[1])); /* primitive code */
   MakeInt(x, &(rp->fields[2]));
   MakeInt(y, &(rp->fields[3]));
   MakeInt(width, &(rp->fields[4]));
   MakeInt(height , &(rp->fields[5]));

   Protect(s2 = alcstr((char *)s,len), return RunError);
   MakeStr(s2, len, &(rp->fields[6]));

   /* store transparency char */
   MakeInt((word)ch, &(rp->fields[7]));

   /*
    * Disable lighting to draw first bitmap.
    * Bitmap colors do not work with lighting enabled.
    */
   glDisable(GL_LIGHTING);
   rv = drawblimage2d(w, rp);
   glEnable(GL_LIGHTING);
   if (rv == RunError) return RunError;

   c_put(&(w->window->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;
   return Succeeded;
   }




/*
 * Called by ReadImage(). Read an image from file and draw it at (x,y).
 */
int gl_readimage(wbp w, char *filename, int x, int y, int *status)
   {
   wsp ws = w->window;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp;
   const int intcode = GL2D_READIMAGE;
   int nfields, rv, is_pixmap;
   tended char *img;
   unsigned int width, height;

   ws->busy_flag = 1;

   /* returned string (img) is allocated from string region with alcstr() */
   if (!x && !y)
      img = gl_loadimage(w, filename, &height, &width, 1, &is_pixmap);
   else
      img = gl_loadimage(w, filename, &height, &width, 0, &is_pixmap);
   if (!img) return Failed;

   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   Get2dRecordConstr(constr,intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   /* remove dx/dy */
   RemoveDxDy(w, x, y, width, height);

   MakeStr("ReadImage", 9, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(x, &(rp->fields[2]));
   MakeInt(y, &(rp->fields[3]));
   MakeInt(width, &(rp->fields[4]));
   MakeInt(height, &(rp->fields[5]));
   MakeInt(is_pixmap, &(rp->fields[6])); /* 0 is bitmap, nonzero is pixmap */
   MakeStr(img, strlen(img)+1, &(rp->fields[7]));

   glDisable(GL_LIGHTING);
   rv = drawreadimage2d(w, rp);
   glEnable(GL_LIGHTING);
   if (rv != Succeeded)
      return rv;

   c_put(&(ws->funclist2d), &f);
#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;

   return Succeeded;
   }



/*
 * Macro for strimage to use in place of XPutPixel(). (clr) is of type
 * (LinearColor) used in (struct palentry). Scale unsigned short (0-65535)
 * to unsigned char (0-255). Applies gamma correction and applies a max
 * alpha value
 */
#define PutPixelPixmap(w,pix,width,height,ix,iy,clr) do {\
   int index = 4*((height-1-iy)*width+ix);\
   AssignRGB(&(pix[index]),(clr).red,(clr).green,(clr).blue);\
   } while(0)

#define PutPixelPixmapEncodeGamma(w,pix,width,height,ix,iy,clr) do {\
   int index = 4*((height-1-iy)*width+ix);\
   wcp wcr = &(w->window->wcrender);\
   AssignRGB(&(pix[index]),EncodeGammaUSToUC((clr).red,wcr->gamma),\
      EncodeGammaUSToUC((clr).green,wcr->gamma),\
      EncodeGammaUSToUC((clr).blue,wcr->gamma));\
   } while(0)

/*
 * Draw image contained in (s) to (x,y) pixel position on screen (called by
 * DrawImage())
 */
int gl_strimage(wbp w, int x, int y, int width, int height, struct palentry *e,
   unsigned char *s, word len, int on_icon)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   const int intcode = GL2D_STRIMAGE;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp;
   tended char *pixmap, *shape;
   unsigned int ix, iy;
   unsigned char alpha;
   int nfields, c, v;
   int size;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   Get2dRecordConstr(constr,intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   /* remove dx/dy from non-defaulted values. default is 0 */
   RemoveDxDy(w, x, y, width, height);

   MakeStr("StringImage", 11, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(x, &(rp->fields[2]));
   MakeInt(y, &(rp->fields[3]));
   MakeInt(width, &(rp->fields[4]));
   MakeInt(height, &(rp->fields[5]));

   /* encode rgb values for each pixel */
   size = width*height;
   Protect(pixmap = alcstr(NULL,4*size), return RunError);

   /* store pre-cooked image value */
   MakeStr(pixmap, 4*size, &(rp->fields[6]));
   rp->fields[7] = nulldesc;
   rp->fields[8] = nulldesc;

   /*
    * String (s) specifies a color within palette entry (e). The RGB
    * values can be extrapolated by querying (e).
    *
    * Use "alpha" context attribute to determine alpha value.
    */
   ix = iy = 0;
   alpha = GLFToUC((float)wc->alpha);
   if (e) {
      /*
       * Read the image string and set the pixel values.
       */
      while (len--) {
         c = *s++;
         v = e[c].valid;
         if (v) {                               /* put char if valid */
            PutPixelPixmapEncodeGamma(w,pixmap,width,height,ix,iy,e[c].clr);
            }

         /* keep track of transparent pixels */
         if (e[c].transpt) {
            pixmap[4*((height-1-iy)*width+ix)+3] = 0;
            }
         else
            pixmap[4*((height-1-iy)*width+ix)+3] = alpha;

         if (v || e[c].transpt) {       /* advance if valid or transparent */
            if (++ix >= width) {
               ix = 0;                  /* reset for new row */
               iy++;
               }
            }
         }
      }
   /*
    * No palette entry. View string (s) as a string of RGB triplets. According
    * to Unicon color semantics, don't encode gamme into these color values.
    */
   else {
      LinearColor clr;
      while (iy < height) {
         ix = 0;
         while (ix < width) {
            /* convert to linear color */
            clr.red = *s++ * 257;
            clr.green = *s++ * 257;
            clr.blue = *s++ * 257;

            /* set pixel */
            PutPixelPixmap(w,pixmap,width,height,ix,iy,clr);

            /* keep track of non-transparent pixels */
            pixmap[4*((height-1-iy)*width+ix)+3] = alpha;
            ix++;
            }
         iy++;
         }
      }
   glDisable(GL_LIGHTING);
   drawstrimage2d(w, rp);
   glEnable(GL_LIGHTING);

   c_put(&(ws->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;

   return 0; /* OpenGL doesn't need to allocate colors... */
   }



/*
 * Draws text at (x,y) without background fill. Affected by translational
 * coordinates and not affect by cursor position.
 */
int gl_drawstrng(wbp w, int x, int y, char *s, int len)
   {
   wsp ws = w->window;
   wcp wcr = &(ws->wcrender);
   static struct descrip *constr = NULL;
   const int intcode = GL2D_DRAWSTRING;
   tended struct descrip f;
   tended struct b_record *rp;
   tended char *str, *tended_s = s;
   int nfields, rv;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   Get2dRecordConstr(constr,intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("DrawString", 10, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(x - wcr->dx, &(rp->fields[2]));
   MakeInt(y - wcr->dy, &(rp->fields[3]));

   Protect(str = alcstr(s, len), return RunError);
   MakeStr(str, len, &(rp->fields[4]));

   glDisable(GL_LIGHTING);
   rv = drawstring2d(w, rp);
   glEnable(GL_LIGHTING);
   if (rv == Failed || rv == RunError) {
      ws->busy_flag = 0;
      return rv;
      }

   c_put(&(ws->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;

   return Succeeded;
   }



/*
 * Draws text at (ws->posx,ws->posy) with background fill around the bounding
 * box of the text.
 */
int gl_xdis(wbp w, char *s, int len)
   {
   wsp ws = w->window;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_WWRITE;
   tended struct descrip f;
   tended struct b_record *rp;
   tended char *str;
   int nfields, rv;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   Get2dRecordConstr(constr,intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("WWrite", 5, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(ws->x, &(rp->fields[2]));
   MakeInt(ws->y, &(rp->fields[3]));

   Protect(str = alcstr(s, len), return RunError);
   MakeStr(str, len, &(rp->fields[4]));

   glDisable(GL_LIGHTING);
   rv = drawstring2d(w, rp);
   glEnable(GL_LIGHTING);
   if (rv == Failed || rv == RunError) {
      ws->busy_flag = 0;
      return rv;
      }
   ws->x += rv; /* update text cursor position */

   c_put(&(ws->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;

   return Succeeded;
   }



/*
 * Need to discuss semantics - if CopyArea() (no args), should it still
 * be a pixmap image, or should the display list be copied? It seems like
 * the former would be faster for a large display list.
 */
int gl_copyArea(wbp w1, wbp w2, int x, int y, int width, int height, int x2,
   int y2)
   {
   wsp ws1 = w1->window, ws2 = w2->window;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_COPYAREA;
   tended struct descrip f;
   tended struct b_record *rp;
   int nfields, rv;

   ws2->busy_flag = 1;

   MakeCurrent(w2);
   UpdateRenderContext(w2, 0);
   CheckRendermode(w2);

   /*
    * If the copied area obscures the destination window, the display
    * list is deleted before the display list item is appended.
    */
   if (x2<=0 && y2<=0 && (width-x >= ws2->width) && (height-y >= ws2->height)) {
      /* delete entire display list */
      if (create_display_list2d(w2, 40000) == Failed) {
         glprintf("could not realloc 2d display list\n");
         return RunError;
         }

      /*
       * Now that the display list is gone, make the current render
       * context the default context.
       * the window with the new context.
       */
      copy_2dcontext(&(ws2->wcdef), &(ws2->wcrender));
      }

   RemoveDxDy(w1, x, y, width, height);
   /*
    * Hard to know if (x,y) of (0,0) is a default, or has been dx/dy
    * corrected. For now, assume that (0,0) is a default.
    */
   RemoveDxDy(w2, x2, y2, width, height);

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("CopyArea", 8, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));

   rp->fields[2] = ws1->filep;
   MakeInt(x, &(rp->fields[3]));
   MakeInt(y, &(rp->fields[4]));
   MakeInt(width, &(rp->fields[5]));
   MakeInt(height, &(rp->fields[6]));
   MakeInt(x2, &(rp->fields[7]));
   MakeInt(y2, &(rp->fields[8]));

   /* if the copying fails, then don't add entry to display list */
   glDisable(GL_LIGHTING);
   rv = copyarea2d(w2, rp);
   glEnable(GL_LIGHTING);
   if (rv != Succeeded) {
      ws2->busy_flag = 0;
      return rv;
      }

   /* put on display list of window to be drawn to */
   c_put(&(ws2->funclist2d), &f);

   /* redraw so changes are seen onscreen */
#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w2);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws2->redraw_flag |= 1;
   ws2->busy_flag = 0;
   return Succeeded;
   }



int gl_eraseArea(wbp w, int x, int y, int width, int height)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   int nfields;
   const int intcode = GL2D_ERASEAREA;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp;

   ws->busy_flag = 1;

   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   /* check for default case: delete display list entries? */
   if (x == 0 && y == 0 && width == ws->width && height == ws->height) {
      /*
       * Delete display list
       */
      if (create_display_list2d(w, 40000) == Failed) {
         glprintf("could not realloc 2d display list\n");
         return RunError;
         }

      /*
       * Now that the display list is gone, make the current render
       * context the default context
       */
      copy_2dcontext(&(ws->wcdef), &(ws->wcrender));
      ClearScreenToColor(w, BG);

      ws->redraw_flag |= 1;
      ws->busy_flag = 0;
      return Succeeded;
      }

   /* out of bounds, might as well consider it a no-op */
   if (x > ws->width || y > ws->height || x + width < 0 || y + height < 0) {
      return Failed;
      }

   /* remove dx & dy to get the arg value */
   x -= wc->dx;
   y -= wc->dy;

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;

   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("EraseArea", 9, &(rp->fields[0]));
   MakeInt(GL2D_ERASEAREA, &(rp->fields[1]));

   MakeInt(x, &(rp->fields[2]));
   MakeInt(y, &(rp->fields[3]));
   MakeInt(width, &(rp->fields[4]));
   MakeInt(height, &(rp->fields[5]));

   if (!ws->is_3D) {
      glDisable(GL_LIGHTING);
      erasearea2d(w, rp);
      glEnable(GL_LIGHTING);
      ws->redraw_flag |= 1;
      }

   c_put(&(ws->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;
   return Succeeded;
   }



int gl_arcs(wbp w, XArc *arcs, int n, int circle, int fill)
   {
   wsp ws = w->window;
   static struct descrip *fillarc_constr, *drawarc_constr;
   static struct descrip *fillcirc_constr, *drawcirc_constr;
   tended struct descrip f;
   tended struct b_record *rp;
   tended struct b_realarray *ap;
   int nfillarc, ndrawarc, nfillcirc, ndrawcirc;
   int i;
   double x, y, r, width, height, theta, alpha;

   if (n <= 0) return Failed;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   /* initialize constructors - have same number of fields */
   Get2dRecordConstr(fillarc_constr, GL2D_FILLARC);
   nfillarc = (int) BlkD(*fillarc_constr, Proc)->nfields;
   Get2dRecordConstr(drawarc_constr, GL2D_DRAWARC);
   ndrawarc = (int) BlkD(*drawarc_constr, Proc)->nfields;
   Get2dRecordConstr(fillcirc_constr, GL2D_FILLCIRCLE);
   nfillcirc = (int) BlkD(*fillcirc_constr, Proc)->nfields;
   Get2dRecordConstr(drawcirc_constr, GL2D_DRAWCIRCLE);
   ndrawcirc = (int) BlkD(*drawcirc_constr, Proc)->nfields;

   glDisable(GL_LIGHTING);
   for (i = 0; i < n; i++) {
      x = arcs[i].x;
      y = arcs[i].y;
      width = ARCWIDTH(arcs[i]);
      height = ARCHEIGHT(arcs[i]);
      theta = -(arcs[i].angle1)/(180.0*64.0)*Pi;
      alpha = -(arcs[i].angle2)/(180.0*64.0)*Pi;

      if (circle) {
         if (fill) {
            Protect(rp = alcrecd(nfillcirc, BlkLoc(*fillcirc_constr)),
                    return RunError);
            f.dword = D_Record;
            BlkLoc(f) = (union block *)rp;

            MakeStr("FillCircle", 10, &(rp->fields[0]));
            MakeInt(GL2D_FILLCIRCLE, &(rp->fields[1]));
            }
         else {
            Protect(rp = alcrecd(ndrawcirc, BlkLoc(*drawcirc_constr)),
                    return RunError);
            f.dword = D_Record;
            BlkLoc(f) = (union block *)rp;

            MakeStr("DrawCircle", 10, &(rp->fields[0]));
            MakeInt(GL2D_DRAWCIRCLE, &(rp->fields[1]));
            rp->fields[13] = nulldesc;
            }

         /* recraft certain attributes */
         r = width/2.0;
         x += r - w->context->dx;
         y += r - w->context->dy;

         rp->fields[2] = nulldesc;
         MakeInt(x, &(rp->fields[3]));
         MakeInt(y, &(rp->fields[4]));
         MakeRealAlc(r, &(rp->fields[5]));
         MakeRealAlc(theta, &(rp->fields[6]));
         MakeRealAlc(alpha, &(rp->fields[7]));
         MakeInt(x, &(rp->fields[8]));
         MakeInt(y, &(rp->fields[9]));
         MakeRealAlc(r, &(rp->fields[10]));
         MakeRealAlc(theta, &(rp->fields[11]));
         MakeRealAlc(alpha, &(rp->fields[12]));
         }
      else { /* arc */
         if (fill) {
            Protect(rp = alcrecd(nfillarc, BlkLoc(*fillarc_constr)),
                    return RunError);
            f.dword = D_Record;
            BlkLoc(f) = (union block *)rp;

            MakeStr("FillArc", 7, &(rp->fields[0]));
            MakeInt(GL2D_FILLARC, &(rp->fields[1]));
            }
         else {
            Protect(rp = alcrecd(ndrawarc, BlkLoc(*drawarc_constr)),
                    return RunError);
            f.dword = D_Record;
            BlkLoc(f) = (union block *)rp;

            MakeStr("DrawArc", 7, &(rp->fields[0]));
            MakeInt(GL2D_DRAWARC, &(rp->fields[1]));
            rp->fields[15] = nulldesc;
            }

         /* recraft certain attributes */
         RemoveDxDy(w, x, y, width, height);

         rp->fields[2] = nulldesc;
         MakeInt(x, &(rp->fields[3]));
         MakeInt(y, &(rp->fields[4]));
         MakeInt(width, &(rp->fields[5]));
         MakeInt(height, &(rp->fields[6]));
         MakeRealAlc(theta, &(rp->fields[7]));
         MakeRealAlc(alpha, &(rp->fields[8]));
         MakeInt(x, &(rp->fields[9]));
         MakeInt(y, &(rp->fields[10]));
         MakeInt(width, &(rp->fields[11]));
         MakeInt(height, &(rp->fields[12]));
         MakeRealAlc(theta, &(rp->fields[13]));
         MakeRealAlc(alpha, &(rp->fields[14]));
         }

      drawgeometry2d(w, rp);
      c_put(&(w->window->funclist2d), &f);
      }
   glEnable(GL_LIGHTING);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;
   return Succeeded;
   }



int gl_fillcircles(wbp w, XArc *arcs, int n)
   {
   return gl_arcs(w, arcs, n, 1, 1);
   }



int gl_drawcircles(wbp w, XArc *arcs, int n)
   {
   return gl_arcs(w, arcs, n, 1, 0);
   }



/*
 * Creates a display list item
 */
int gl_fillarcs(wbp w, XArc *arcs, int n)
   {
   return gl_arcs(w, arcs, n, 0, 1);
   }



/*
 * Creates a display list item
 */
int gl_drawarcs(wbp w, XArc *arcs, int n)
   {
   return gl_arcs(w, arcs, n, 0, 0);
   }



int gl_rectangles(wbp w, XRectangle *recs, int n, int fill)
   {
   wsp ws = w->window;
   int i, nfill, ndraw;
   int x, y, width, height;
   static struct descrip *fill_constr, *draw_constr;
   tended struct b_record *rp;
   tended struct descrip f;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   Get2dRecordConstr(fill_constr, GL2D_FILLRECTANGLE);
   nfill = (int) BlkD(*fill_constr, Proc)->nfields;
   Get2dRecordConstr(draw_constr, GL2D_DRAWRECTANGLE);
   ndraw = (int) BlkD(*draw_constr, Proc)->nfields;

   glDisable(GL_LIGHTING);
   for (i=0; i<n; i++) {
      x = RECX(recs[i]);
      y = RECY(recs[i]);
      width = RECWIDTH(recs[i]);
      height = RECHEIGHT(recs[i]);

      if (fill) {
         Protect(rp = alcrecd(nfill,BlkLoc(*fill_constr)), return RunError);
         f.dword = D_Record;
         BlkLoc(f) = (union block *)rp;

         MakeStr("FillRectangle",13,&(rp->fields[0]));
         MakeInt(GL2D_FILLRECTANGLE, &(rp->fields[1]));
         }
      else {
         Protect(rp = alcrecd(ndraw,BlkLoc(*draw_constr)), return RunError);
         f.dword = D_Record;
         BlkLoc(f) = (union block *)rp;

         MakeStr("DrawRectangle",13,&(rp->fields[0]));
         MakeInt(GL2D_DRAWRECTANGLE, &(rp->fields[1]));
         rp->fields[11] = nulldesc;
         }

      RemoveDxDy(w, x, y, width, height);

      rp->fields[2] = nulldesc;
      MakeInt(x, &(rp->fields[3]));
      MakeInt(y, &(rp->fields[4]));
      MakeInt(width, &(rp->fields[5]));
      MakeInt(height, &(rp->fields[6]));
      MakeInt(x, &(rp->fields[7]));
      MakeInt(y, &(rp->fields[8]));
      MakeInt(width, &(rp->fields[9]));
      MakeInt(height, &(rp->fields[10]));

         drawgeometry2d(w,rp);

      /* add to display list */
      c_put(&(w->window->funclist2d), &f);
      }
   glEnable(GL_LIGHTING);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;
   return Succeeded;
   }



int gl_fillrectangles(wbp w, XRectangle *recs, int n)
   {
   return gl_rectangles(w, recs, n, 1);
   }



int gl_drawrectangles(wbp w, XRectangle *recs, int n)
   {
   return gl_rectangles(w, recs, n, 0);
   }



/*
 *
 * For DrawLine() and DrawPolygon() and DrawCurve().
 *
 * NOTE: Calls to DrawCurve() create GL2D_DRAWLINE primitives. It would
 * be possible to remedy this by changing the internal 2D API (drawlines())
 * to be able to determine the primitive type. However, a curve is still a
 * line primitive; so let GL2D_DRAWLINE encompasses DrawLine() and
 * DrawCurve().
 */
int gl_drawlines(wbp w, XPoint *points, int n)
   {
   wsp ws = w->window;
   tended struct descrip f;
   tended struct b_record *rp;
   tended struct b_realarray *ap;
   int i, nfields, size;
   const int intcode = GL2D_DRAWLINE;
   static struct descrip *line_constr, *poly_constr;
   double dx, dy;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   dx = w->context->dx;
   dy = w->context->dy;
   size = 2*n;

   Get2dRecordConstr(line_constr, GL2D_DRAWLINE);
   Get2dRecordConstr(poly_constr, GL2D_DRAWPOLYGON);
   nfields = (int)BlkD(*line_constr,Proc)->nfields; /* same # fields for both */

   /* create primitive */
   if (points[0].x == points[n-1].x && points[0].y == points[n-1].y) {
      Protect(rp = alcrecd(nfields,BlkLoc(*poly_constr)), return RunError);
      f.dword = D_Record;
      BlkLoc(f) = (union block *)rp;
      MakeStr("DrawPolygon",11,&(rp->fields[0]));
      MakeInt(intcode, &(rp->fields[1]));
      }
   else {
      Protect(rp = alcrecd(nfields,BlkLoc(*line_constr)), return RunError);
      f.dword = D_Record;
      BlkLoc(f) = (union block *)rp;
      MakeStr("DrawLine",8,&(rp->fields[0]));
      MakeInt(intcode, &(rp->fields[1]));
      }

   AlcRealarrayList(rp->fields[3], ap, size, RunError);

   /* get coordinates */
   for (i=0; i<n; i++) {
      ap->a[2*i] = points[i].x - dx;
      ap->a[2*i+1] = points[i].y - dy;
      }

   /* add to display list */
   glDisable(GL_LIGHTING);
   drawgeometry2d(w, rp);
   glEnable(GL_LIGHTING);

   c_put(&(w->window->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;

   return Succeeded;
   }



int gl_drawpoints(wbp w, XPoint *points, int n)
   {
   wsp ws = w->window;
   const int intcode = GL2D_DRAWPOINT;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp;
   tended struct b_realarray *ap;
   int i, nfields, size;
   double dx, dy;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   dx = w->context->dx;
   dy = w->context->dy;
   size = 2*n;

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;

   /* create primitive */
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("DrawPoint",9,&(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   rp->fields[2] = nulldesc;

   /* alloc realarray */
   AlcRealarrayList(rp->fields[3], ap, size, RunError);

   /* get coordinates */
   for (i=0; i<n; i++) {
      ap->a[2*i] = points[i].x - dx;
      ap->a[2*i+1] = points[i].y - dy;
      }

      glDisable(GL_LIGHTING);
      drawgeometry2d(w, rp);
      glEnable(GL_LIGHTING);

   /* add to display list */
   c_put(&(w->window->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;
   return Succeeded;
   }



int gl_drawsegments(wbp w, XSegment *segs, int n)
   {
   wsp ws = w->window;
   const int intcode = GL2D_DRAWSEGMENT;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp;
   tended struct b_realarray *ap;
   int i, nfields, size;
   double dx, dy;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   dx = w->context->dx;
   dy = w->context->dy;
   size = 4*n;

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;

   /* create primitive */
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("DrawSegment",11,&(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   rp->fields[2] = nulldesc;

   /* alloc realarray */
   AlcRealarrayList(rp->fields[3], ap, size, RunError);
   rp->fields[4] = nulldesc;

   /* get coordinates */
   for (i=0; i<n; i++) {
      ap->a[4*i] = segs[i].x1 - dx;
      ap->a[4*i+1] = segs[i].y1 - dy;
      ap->a[4*i+2] = segs[i].x2 - dx;
      ap->a[4*i+3] = segs[i].y2 - dy;
      }

      glDisable(GL_LIGHTING);
      drawgeometry2d(w, rp);
      glEnable(GL_LIGHTING);

   /* add to display list */
   c_put(&(w->window->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;
   return Succeeded;
   }



/*
 * Based off of algorithm provided by Rory Daulton:
 *   https://stackoverflow.com/questions/471962/how-do-i-efficiently-determine-if-a-polygon-is-convex-non-convex-or-complex/45372025#45372025
 *
 * Takes a set of order points and determines whether a polygon is complex,
 * convex, or nonconvex (based on XFillPolygon() conventions).
 * Returns Failed if not a polygon, otherwise returns a status code
 * of either complex (self-intersecting), convex, or nonconvex.
 * #define's can be found in src/h/opengl.h
 */
int polygon_type(XPoint *points, int n)
   {
   int i;
   double curr_x, curr_y, prev_x, prev_y;
   double curr_angle_abs, prev_angle_abs, last_angle, angle, accum_angle;
   const double TWO_PI = 2*Pi;

   /* check if polygon */
   if (n < 3) return Failed;

   prev_x = points[0].x;
   prev_y = points[0].y;
   curr_x = points[1].x;
   curr_y = points[1].y;
   curr_angle_abs = last_angle = angle = accum_angle = 0;
   prev_angle_abs = atan2(curr_y-prev_y, curr_x-prev_x);

   for (i = 2; i <= n; i++) {
      prev_angle_abs = curr_angle_abs;
      last_angle = angle;
      prev_x = curr_x;
      prev_y = curr_y;

      /* check to see if last point completes the polygon */
      if (i == n && (prev_x != points[0].x || prev_y != points[0].y)) {
         curr_x = points[0].x;
         curr_y = points[0].y;
         }
      else {
         curr_x = points[i].x;
         curr_y = points[i].y;
         }

      /* calculate angle */
      curr_angle_abs = atan2(curr_y-prev_y, curr_x-prev_x);
      angle = curr_angle_abs - prev_angle_abs;

      /* normalize angle difference between half-close interval (-PI, PI] */
      if (angle <= -Pi) angle += TWO_PI;
      else if (angle > Pi) angle -= TWO_PI;

      /* Not convex, interior angle greater than 180 deg */
      if (last_angle*angle < 0) {
         return POLY_NONCONVEX;
         }

      /* accumulate angle */
      accum_angle += angle;
      }

   /* check accumulated angle for self-intersection */
   if (accum_angle < 0) accum_angle = -accum_angle;
   if (accum_angle/TWO_PI > 1) return POLY_COMPLEX;

   return POLY_CONVEX;
   }



int gl_fillpolygon(wbp w, XPoint *points, int n)
   {
   wsp ws = w->window;
   const int intcode = GL2D_FILLPOLYGON;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp;
   tended struct b_realarray *ap;
   int i, nfields, size, polytype;
   double dx, dy;

   polytype = polygon_type(points, n);
   if (polytype == Failed)
      return Failed;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, 0);
   CheckRendermode(w);

   dx = w->context->dx;
   dy = w->context->dy;
   size = 2*n;

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;

   /* create primitive */
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("FillPolygon",11,&(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   rp->fields[2] = nulldesc;

   /*
    * alloc realarray - add an extra pair of vertices so the polygon
    * is complete
    */
   AlcRealarrayList(rp->fields[3], ap, size, RunError);
   MakeInt(polytype, &(rp->fields[4]));

   /* get coordinates */
   for (i=0; i<n; i++) {
      ap->a[2*i] = points[i].x - dx;
      ap->a[2*i+1] = points[i].y - dy;
      }

   glDisable(GL_LIGHTING);
   drawgeometry2d(w, rp);
   glEnable(GL_LIGHTING);

   c_put(&(w->window->funclist2d), &f);

#ifdef GL2D_IMMEDIATE_RENDER
   FlushWindow(w);
#endif  /* GL2D_IMMEDIATE_RENDER */

   ws->redraw_flag |= 1;
   ws->busy_flag = 0;

   return Succeeded;
   }



/*************************************************
 * Image-related functions (not on display list) *
 *************************************************/



/*
 * Write the RGB array (pixmap) to an XBM file specified by (filename)
 */
int write_xbm(char *filename, int width, int height, unsigned char *pixmap,
   unsigned char bg[4])
   {
   int ix, iy;
   FILE *fout;
   char buf[256], name[128], *p1, *p2;
   unsigned int byte, m;

   if (strlen(filename) - 4 > 127) {
      glprintf("filename '%s' too long\n",filename);
      return Failed;
      }

   if (!(fout = fopen(filename, "wb"))) {
      return Failed;
      }

   p1 = filename;
   p2 = name;
   while (*p1 != '\0' && *p1 != '.') *p2++ = *p1++;
   *p2 = '\0';

   /*
    * write #defines, don't define hotspot
    */
   sprintf(buf,"#define %s_width %d\n", name, width);
   fwrite(buf, strlen(buf), 1, fout);
   sprintf(buf,"#define %s_height %d\n", name, width);
   fwrite(buf, strlen(buf), 1, fout);

   /*
    * write the static array definition
    */
   sprintf(buf,"static unsigned char %s_bits[] = {\n", name);
   fwrite(buf, strlen(buf), 1, fout);

   /*
    * The upper left pixel in the XBM bitmap is specified by the lowest bit
    * of the first pixel in the static array
    */
   for (iy = 0; iy < height; iy++) {
      for (ix = 0; ix < width; ix++) {
         int index = 3*((height-(iy+1))*width+ix);

         if (ix % 8 == 0) {
            m = 1;
            byte = 0;
            }
         else m <<= 1;

         /* pixel is bg color, set to '0' */
         if (pixmap[index] == bg[0] && pixmap[index+1] == bg[1] &&
             pixmap[index+2] == bg[2]) {
            byte &= ~m;
            }
         /* set bit to '1' */
         else {
            byte |= m;
            }

         /* got a byte, write to file */
         if (m == 0x80) {
            sprintf(buf, "0x%02x, ", byte & 0xFF);
            fwrite(buf, strlen(buf), 1, fout);
            }
         else if (ix == width - 1) {
            if (iy == height - 1)
               sprintf(buf, "0x%02x\n", byte & 0xFF);
            else
               sprintf(buf, "0x%02x,\n", byte & 0xFF);
            fwrite(buf, strlen(buf), 1, fout);
            }
         }
      }
   buf[0] = '}';
   buf[1] = ';';
   buf[2] = '\0';
   fwrite(buf, 2, 1, fout);
   fclose(fout);

   return Succeeded;
   }



/*
 * Write the image at (x, y) to filename as a XPM file
 */
int write_xpm(char *filename, int width, int height, unsigned char *pixmap)
   {
   int ix, iy, i, j;
   FILE *fout;
   char buf[1028], name[128], tmp[32], *p1, *p2;
   struct color clist[DMAXCOLORS];
   int ncolors, chars_per_pixel;
   tended char *tended_s = filename;
   unsigned char *s;
   unsigned short *codes;

   /*
    * Cannot use control characters (0-31 + 127), double quote (34), or
    * blackslash (47). So the maximum number of chars supported is currently
    * 128-(33+2) = 93.
    */
   const int chars_avail = 93;
   const unsigned char chars[] = {
      0x20, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C,
      0x2D, 0x2E, 0x2F,
      0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
      0x3C, 0x3D, 0x3E, 0x3F,
      0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B,
      0x4C, 0x4D, 0x4E, 0x4F,
      0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B,
      0x5C, 0x5D, 0x5E, 0x5F,
      0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F,
      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B,
      0x7C, 0x7D, 0x7E
      };

   if (strlen(filename) - 4 > 127) {
      glprintf("filename '%s' too long\n",filename);
      return Failed;
      }

   if (!(fout = fopen(filename, "wb"))) {
      return Failed;
      }

   codes = (unsigned short *)malloc(width*height*sizeof(unsigned short));
   if (!codes)
      return RunError;

   p1 = filename;
   p2 = name;
   while (*p1 != '\0' && *p1 != '.') *p2++ = *p1++;
   *p2 = '\0';

   /*
    * Determine number of colors needed. For now, use DMAXCOLORS as the cap
    */
   ncolors = 0;
   for (iy = 0; iy < height; iy++) {
      for (ix = 0; ix < width; ix++) {
         int found, cindex, index = 3*((height-(iy+1))*width+ix);

         /* search for color */
         found = 0;
         for (i = 0; i < ncolors; i++) {
            if (clist[i].r == pixmap[index] && clist[i].g == pixmap[index+1] &&
                clist[i].b == pixmap[index+2]) {
               found = 1;
               cindex = i;
               break;
               }
            }

         /* add color if not found */
         if (!found) {
            /* too many colors */
            if (ncolors >= DMAXCOLORS) {
               free(codes);
               fclose(fout);
               return Failed;
               }
            clist[ncolors].r = pixmap[index];
            clist[ncolors].g = pixmap[index+1];
            clist[ncolors].b = pixmap[index+2];
            cindex = ncolors++;
            }
         codes[iy*width+ix] = cindex;
         }
      }

   /*
    * Encode pixels into a string
    */
   chars_per_pixel = ncolors/chars_avail;
   if (ncolors % chars_avail) chars_per_pixel++;
   s = (unsigned char *)malloc(width*height*chars_per_pixel);
   if (!s) {
      free(codes);
      fclose(fout);
      return RunError;
      }

   for (iy = 0; iy < height; iy++) {
      for (ix = 0; ix < width; ix++) {
         int index = iy*width + ix;
         int charcode = codes[index];
         for (i = chars_per_pixel-1; i >= 0; i--) {
            int rem = charcode % chars_avail;
            s[chars_per_pixel*index + i] = chars[rem];
            charcode /= chars_avail;
            }
         }
      }


   /*
    * write the static array definition
    */
   sprintf(buf, "/* XPM */\nstatic char * %s[] = {\n", name);
   fwrite(buf, strlen(buf), 1, fout);

   /*
    * encode values
    */
   sprintf(buf,"/* width height ncolors chars_per_pixel */\n\"%d %d %d %d\",\n",
           width, height, ncolors, chars_per_pixel);
   fwrite(buf, strlen(buf), 1, fout);

   /*
    * encode colors with RGB hex code
    */
   sprintf(buf,"/* colors */\n");
   fwrite(buf, strlen(buf), 1, fout);
   for (i = 0; i < ncolors; i++) {
      int charcode = i;
      for (j = chars_per_pixel-1; j >= 0; j--) {
         tmp[j] = chars[charcode % chars_avail];
         charcode /= chars_avail;
         }
      tmp[chars_per_pixel] = '\0';

      sprintf(buf, "\"%s c #%02x%02x%02x\",\n", tmp, clist[i].r, clist[i].g,
              clist[i].b);
      fwrite(buf, strlen(buf), 1, fout);
      }

   /*
    * encode pixels
    */
   sprintf(buf, "/* pixels */\n\"");
   fwrite(buf, strlen(buf), 1, fout);
   for (i = 0; i < height; i++) {
      fwrite(s + i*width*chars_per_pixel, width*chars_per_pixel, 1, fout);
      if (i == height - 1) {
         buf[0] = '\"';
         buf[1] = '\n';
         fwrite(buf, 2, 1, fout);
         }
      else {
         buf[0] = '\"';
         buf[1] = ',';
         buf[2] = '\n';
         buf[3] = '\"';
         fwrite(buf, 4, 1, fout);
         }
      }

   buf[0] = '}';
   buf[1] = ';';
   buf[2] = '\0';
   fwrite(buf, 2, 1, fout);

   fclose(fout);
   free(s);

   return Succeeded;
   }



/*
 * Given an XBM file, return a bitmap if valid, NULL if not
 */
char *load_xbm(char *filename, unsigned int *width, unsigned int *height)
   {
   char *bitmap; /* need not be tended */
   int rv, wid, ht, rowbytes, hotx, hoty, size;
   int ix, iy, i, j;
   char tmp[128];
   FILE *f;

   f = fopen(filename, "r");
   if (!f) return NULL;

   /*
    * optional comment?
    */

   /*
    * Parse #defines
    *
    * This is assuming it goes in the order:
    * width height [hotspotx hotspoty]
    */
   rv = fscanf(f, "#define %s %d \n", tmp, &wid);
   if (rv < 2) {
      fclose(f);
      return NULL;
      }
   rv = fscanf(f, "#define %s %d \n", tmp, &ht);
   if (rv < 2) {
      fclose(f);
      return NULL;
      }

   if (wid < 0 || ht < 0) {
      fclose(f);
      return NULL;
      }

   /* optional hotspot */
   rv = fscanf(f, "#define %s_x_hot %d \n", tmp, &hotx);
   rv = fscanf(f, "#define %s_y_hot %d \n", tmp, &hoty);

   /* Get through array definition */
   rv = fscanf(f, "static unsigned char %s = { \n", tmp);
   if (rv < 1) {
      while ((rv = fgetc(f)) != '{') {
         if (rv == EOF) {
            fclose(f);
            return NULL;
            }
         }
      }
   if (rv < 1) {
      fclose(f);
      return NULL;
      }

   /*
    * Allocate bitmap
    */
   rowbytes = wid/8;
   if (wid % 8) rowbytes++;
   size = rowbytes*ht;
   Protect(bitmap = alcstr(NULL, size+1), return NULL);
   bitmap[size] = 0;

   /*
    * Get bits
    */
   for (iy = 0; iy < ht; iy++) {
      for (ix = 0; ix < rowbytes; ix++) {
         int byte, rev_byte;

         rv = fscanf(f, " 0x%x, ", &byte);
         if (rv < 1)
            rv = fscanf(f, " 0x%x ", &byte);

         if (rv < 1) {
            glprintf("failed to scan, only scanned %d items out of 2\n",rv);
            fclose(f);
            free(bitmap);
            return NULL;
            }

         /*
          * XBM file readers read starting from the top left corner from
          * low to high bits. OpenGL starts at the bottom left corner and
          * reads from high to low bits.
          */
         rev_byte = 0;
         for (i = 1, j = 0x80; i & 0xFF; i <<= 1, j >>= 1) {
            if (byte & i) /* set bit */
               rev_byte |= j;
            }
         bitmap[(ht-iy-1)*rowbytes+ix] = (unsigned char) rev_byte;
         }
      }

   while ( (rv = fgetc(f)) != '}' ) {
      if (rv == EOF) {
         glprintf("missing '}'\n");
         free(bitmap);
         fclose(f);
         return NULL;
         }
      }
   while ( (rv = fgetc(f)) != ';' ) {
      if (rv == EOF) {
         glprintf("missing '}'\n");
         free(bitmap);
         fclose(f);
         return NULL;
         }
      }

   fclose(f);

   *width = rowbytes*8;
   *height = ht;
   return bitmap;
   }



/*
 * Given an XPM file, return a pixmap if valid, NULL if not
 */
char *load_xpm(wbp w, char *filename, unsigned int *width, unsigned int *height)
   {
   char *pixmap; /* need not be tended */
   char *buf, tmp[128], type[3], spec[40];
   long r, g, b, a;
   int ix, iy, i, j, rv, size;
   int wid, ht, ncolors, chars_per_pixel;
   struct color *clist;
   char **chars;
   FILE *f;

   f = fopen(filename, "r");
   if (!f) return NULL;

   rv = fscanf(f," /* XPM */"); /* optional */
   rv = fscanf(f, " static char * %s = { ", tmp);
   if (rv < 1) {
      fclose(f);
      return NULL;
      }

   rv = fscanf(f," /* width height ncolors chars_per_pixel */");
   rv = fscanf(f, " \" %d %d %d %d \", \n", &wid, &ht, &ncolors,
               &chars_per_pixel);
   if (rv < 4 || chars_per_pixel < 1 || wid < 1 || ht < 1 || ncolors < 1) {
      fclose(f);
      return NULL;
      }


   /*
    * Allocate structures needed for colors
    */
   size = 3*ht*wid;
   Protect(pixmap = alcstr(NULL, size+1), return NULL);
   pixmap[size] = 0;

   clist = (struct color *)malloc(ncolors*sizeof(struct color));
   if (!clist) {
      fclose(f);
      return NULL;
      }

   buf = (char *)malloc(wid*chars_per_pixel+1);
   if (!buf) {
      free(clist);
      fclose(f);
      return NULL;
      }

   chars = (char **)malloc(ncolors*sizeof(char *));
   if (!chars) {
      free(clist);
      free(buf);
      fclose(f);
      return NULL;
      }

   for (i = 0; i < ncolors; i++) {
      chars[i] = (char *)malloc(chars_per_pixel+1);
      if (!chars[i]) {
         for (j = 0; j < i; j++)
            free(chars[j]);
         free(chars);
         free(clist);
         free(buf);
         fclose(f);
         return NULL;
         }
      }

   /*
    * Get colors
    *
    * format: "pixel_chars type color_val"
    */
   rv = fscanf(f," /* colors */"); /* optional */
   for (i = 0; i < ncolors; i++) {
      char *ptr;
      while ((rv = fgetc(f)) != '\"') {
         if (rv == EOF) {
            for (j = 0; j < ncolors; j++)
               free(chars[j]);
            free(chars);
            free(clist);
            free(buf);
            fclose(f);
            return NULL;
            }
         }
      /* get the pixel chars */
      if (fgets(chars[i], chars_per_pixel+1, f) == NULL) {
         /* premature EOF */
         for (j = 0; j < ncolors; j++)
            free(chars[j]);
         free(chars);
         free(clist);
         free(buf);
         fclose(f);
         return NULL;
         }

      /* get type */
      if (fscanf(f, " %s", type) == EOF) {
         /* premature EOF */
         for (j = 0; j < ncolors; j++)
            free(chars[j]);
         free(chars);
         free(clist);
         free(buf);
         fclose(f);
         return NULL;
         }
      switch (type[0]) {
         case 'c':
            rv = fscanf(f, " %s\",", spec);
            if (rv) { /* find terminating double quote */
               ptr = strchr(spec, '\"');
               if (ptr) *ptr = '\0';
               }
            break;
         case 's': /* symbolic */
         case 'g': /* greyscale */
         case 'm': /* monochrome */
         default:
            rv = 0;
            break;
         }

      /* get color value */
      if (rv < 1 || parsecolor(w, spec, &r, &g, &b, &a) != Succeeded) {
         for (j = 0; j < ncolors; j++)
            free(chars[j]);
         free(chars);
         free(clist);
         free(buf);
         fclose(f);
         return NULL;
         }

      clist[i].r = r;
      clist[i].g = g;
      clist[i].b = b;
      clist[i].a = a;
      }

   /*
    * Get pixels
    */
   rv = fscanf(f," /* pixels */"); /* optional */
   for (iy = 0; iy < ht; iy++) {
      while ((rv = fgetc(f)) == ' ' || rv == '\n');
      if (rv != '\"' || !fgets(buf, wid*chars_per_pixel+1, f)) {
         for (j = 0; j < ncolors; j++)
            free(chars[j]);
         free(chars);
         free(clist);
         free(buf);
         fclose(f);
         return NULL;
         }
      rv = fgetc(f); /* \" */
      if (i <= ht-1)
         rv = fgetc(f); /* , */

      for (ix = 0; ix < wid; ix++) {
         int index = 3*((ht-iy-1)*wid + ix);
         for (i = 0; i < ncolors; i++) {
            if (!strncmp(chars[i],&buf[ix*chars_per_pixel],chars_per_pixel)) {
               AssignRGB(&(pixmap[index]),clist[i].r >> 8,clist[i].g >> 8,
                         clist[i].b >> 8);
               break;
               }
            }
         }
      }

   while ((rv = fgetc(f)) != '}' ) {
      if (rv == EOF) {
         glprintf("missing '}'\n");
         for (j = 0; j < ncolors; j++)
            free(chars[j]);
         free(chars);
         free(clist);
         free(buf);
         fclose(f);
         return NULL;
         }
      }
   while ((rv = fgetc(f)) != ';' ) {
      if (rv == EOF) {
         glprintf("missing '}'\n");
         for (j = 0; j < ncolors; j++)
            free(chars[j]);
         free(chars);
         free(clist);
         free(buf);
         fclose(f);
         return NULL;
         }
      }

   fclose(f);
   for (j = 0; j < ncolors; j++)
      free(chars[j]);
   free(chars);
   free(clist);
   free(buf);

   *width = wid;
   *height = ht;
   return pixmap;
   }




/*
 * dumpimage -- write an image to a disk file in an X format.
 *
 * Accepts only .xpm and .xbm file names, returning NoCvt for anything else.
 *
 * To make things simpler, read image as RGB format (for write_x*m())
 */
int gl_dumpimage(wbp w, char *filename, unsigned int x, unsigned int y,
   unsigned int width, unsigned int height)
   {
   int slen;
   wcp wc = w->context;
   wsp ws = w->window;
   unsigned char *tmp;
   int px, py, rv = NoCvt;   /* not an X format -- write GIF instead */
   unsigned short bgs[4];
   unsigned char bg[4];

   tmp = (unsigned char *)malloc(3*height*width);
   if (!tmp) return RunError;

   /*
    * Read pixel data into (tmp)
    */
   px = x;
   py = ws->height - y - height;
   MakeCurrent(w);

   glReadPixels(px,py,width,height,GL_RGB,GL_UNSIGNED_BYTE,tmp);

   /*
    * Check for bilevel XBM (X BitMap) format.
    */
   slen = strlen(filename);
   if ((slen > 4) &&
      (!strcmp(".xbm", filename + slen - 4) ||
       !strcmp(".XBM", filename + slen - 4)))
      {
      GetContextColorUS(w, BG, bgs[0], bgs[1], bgs[2], bgs[3]);
      EncodeGammaUSToUC_V4(bg, bgs, wc->gamma);
      rv = write_xbm(filename, width, height, tmp, bg);
      }

   /*
    * Check for XPM (color X PixMap) format.
    */
   else if (((slen > 4) &&
            (!strcmp(".xpm", filename + slen - 4) ||
             !strcmp(".XPM", filename + slen - 4))) ||
            ((slen > 6) && !strcmp(".xpm.Z", filename + slen - 6)))
      {
      rv = write_xpm(filename, width, height, tmp);
      }

   free(tmp);
   return rv;
   }





/*
 * The getimstr() code assumes that a maximum of 256 colors can be onscreen
 * at one time.  If DMAXCOLORS maximum is raised, code must be added for the
 * depth>8 case to reduce the local copy of the image to no more than the
 * 256-color maximum allowed in a GIF file.  This reduction operation is
 * nontrivial; look up "color quantization" in computer graphics literature.
 */
#passthru #if (DMAXCOLORS > 256)
#passthru   Deliberate Syntax error
#passthru #endif                                /* DMAXCOLORS */

/*
 * getimstr(w, x, y, width, height, ptbl, data) -- get image as a string.
 *
 * Stores the specified subimage in data, one pixel per byte, and sets
 * entries in ptbl corresponding to the pixel values that were used.
 *
 * This function is used to write BMP files
 */
int gl_getimstr(wbp w, int x, int y, int width, int height,
   struct palentry *ptbl, unsigned char *data)
   {
   wsp ws = w->window;
   int px, py, i, ix, iy;
   unsigned short *tmp;
   int ncolors;

   tmp = (unsigned short *)malloc(3*height*width*sizeof(unsigned short));
   if (!tmp) return RunError;

   /*
    * Read pixel data into (tmp). For some reason BMP files reverse
    * the R & B pixels somehow. Anyways, using BGR format and treating it
    * like RGB works somehow.
    */
   px = x;
   py = ws->height - y - height;
   MakeCurrent(w);

   glReadPixels(px,py,width,height,GL_RGB,GL_UNSIGNED_SHORT,tmp);

   /*
    * Go through each pixel and see how many colors are used. If there are over
    * DMAXCOLORS, then fail for now.
    *
    * Don't encode gamma for this
    */
   ncolors = 0;
   for (iy = 0; iy < height; iy++) {
      for (ix = 0; ix < width; ix++) {
         int found, index, cindex;

         /* look through palentry to see if we have the color */
         index = 3*((height-(iy+1))*width+ix);
         found = 0;
         for (i = 0; i < ncolors; i++) {
            if (ptbl[i].clr.red == tmp[index] &&
                ptbl[i].clr.green == tmp[index+1] &&
                ptbl[i].clr.blue == tmp[index+2])
               {
               found = 1;
               cindex = i;
               break;
               }
            }

         /* store color if not found */
         if (!found) {
            /* too many colors, failure or runerror? */
            if (ncolors >= DMAXCOLORS) {
               free(tmp);
               return Failed;
               }
            ptbl[ncolors].clr.red = tmp[index];
            ptbl[ncolors].clr.green = tmp[index+1];
            ptbl[ncolors].clr.blue = tmp[index+2];
            cindex = ncolors++;
            }

         /* put color in data */
         data[iy*width+ix] = cindex;
         }
      }
   free(tmp);
   return 1;
   }



/*
 * getimstr24 -- get an image as a string of RGB tuples.
 *
 * Stores the specified subimage in data, three bytes per pixel.
 * Used for writing PNG files
 */
int gl_getimstr24(wbp w, int x, int y, int width, int height,
   unsigned char *data)
   {
   wsp ws = w->window;
   int px, py, ix, iy, index, row_size;
   unsigned char *tmp;

   tmp = (unsigned char *)malloc(3*height*width);
   if (!tmp) return RunError;

   /* read pixel data into (tmp) */
   px = x;
   py = ws->height - y - height;
   MakeCurrent(w);

   glReadPixels(px,py,width,height,GL_RGB,GL_UNSIGNED_BYTE,tmp);

   /*
    * Since Unicon (top left) and OpenGL (bottom left) window origins differ,
    * flip the rows
    */
   row_size = 3*width;
   for (iy=0; iy < height; iy++) {
      memcpy(&(data[(height-(iy+1))*row_size]), &(tmp[iy*row_size]), row_size);
      }

   /* define out of bound pixels as background color */
   if (x < 0 || x + width >= ws->width ||
       y < 0 || y + height >= ws->height) {
      unsigned char bg[4];
      GetContextColorUC(w, BG, bg[0], bg[1], bg[2], bg[3]);

      for (ix=0; ix < width; ix++) {
         for (iy=0; iy < height; iy++) {
            if (x+ix < 0 || x+ix >= ws->width ||
                y+iy < 0 || y+iy >= ws->height) {
               index = 3*((height-iy-1)*width+ix);
               AssignRGB(&(data[index]),bg[0],bg[1],bg[2]);
               }
            }
         }
      }
   free(tmp);
   return 1;
   }



/*
 * Grabs a pixmap of a rectangular area from the OpenGL buffer.
 * So far, the getpixel*() class of functions will not be able to
 * suspend accurate pixel values if there are any additional drawing
 * operations between suspensions.
 *
 * Does this need a DL entry? If so, need to uncook dx/dy values from
 * x/y and update render context
 */
int gl_getpixel_init(wbp w, struct imgmem *imem)
   {
   wcp wc = w->context;
   int px, py, size, width, height, i;

   if (imem->width <= 0 || imem->height <= 0) {
#ifdef XWindows
      imem->im = NULL;
#endif                                  /* XWindows */
      return Succeeded;
      }
   width = imem->width;
   height = imem->height;
   px = imem->x;
   py = w->window->height - imem->y - height;
   size = width*height*4;
   imem->pixmap = (unsigned short *)malloc(size*sizeof(unsigned short));
   if (imem->pixmap == NULL)
      return RunError;

   MakeCurrent(w);
   glReadPixels(px,py,width,height,GL_RGBA,GL_UNSIGNED_SHORT,imem->pixmap);

   /* Decode gamma correction */
   for (i=0; i<size; i+=4) {
      imem->pixmap[i] = DecodeGammaUS(imem->pixmap[i], wc->gamma);
      imem->pixmap[i+1] = DecodeGammaUS(imem->pixmap[i+1], wc->gamma);
      imem->pixmap[i+2] = DecodeGammaUS(imem->pixmap[i+2], wc->gamma);
      }

   return Succeeded;
   }



int gl_getpixel_term(wbp w, struct imgmem *imem)
   {
   if (imem->pixmap != NULL)
      free(imem->pixmap);
   return Succeeded;
   }



int gl_getpixel(wbp w, int x, int y, long *rv, char *s, struct imgmem *imem)
   {
   int ix, iy, index;
   long r, g, b, a;

   /* out of bounds, get bg color */
   if (x < imem->x || x >= imem->x + imem->width ||
       y < imem->y || y >= imem->y + imem->height) {
      GetContextColorUS(w, BG, r, g, b, a);
      (void) a;  /* silence "not used" compiler warning */
      }
   else {
      ix = x - imem->x;
      iy = (imem->height - 1) + imem->y - y;
      index = 4*(iy*imem->width + ix);
      r = imem->pixmap[index];
      g = imem->pixmap[index+1];
      b = imem->pixmap[index+2];
      a = imem->pixmap[index+3];
      }
   sprintf(s, "%ld,%ld,%ld", r, g, b);

   *rv = 1;
   return Succeeded;
   }



/*
 * Load an image, currently only looking for XBM/XPM files
 */
char *gl_loadimage(wbp w, char *filename, unsigned int *height,
   unsigned int *width, int atorigin, int *is_pixmap)
   {
   char *rv;

   if (!strcmp(".xbm", filename + strlen(filename) - 4)) {
      *is_pixmap = 0;
      rv = load_xbm(filename, width, height);
      }
   else if (!strcmp(".xpm", filename + strlen(filename) - 4) ||
            !strcmp(".xpm.Z", filename + strlen(filename) - 6)) {
      *is_pixmap = 1;
      rv = load_xpm(w, filename, width, height);
      }
   /* try both */
   else {
      *is_pixmap = 0;
      rv = load_xbm(filename, width, height);
      if (!rv) {
         *is_pixmap = 1;
         rv = load_xpm(w, filename, width, height);
         }
      }
   return rv;
   }


/***********************************
 * (3) Context attribute functions *
 ***********************************/



void gl_getbg(wbp w, char *s)
   {
   sprintf(s, "%s", w->context->glbg.name);
   }



void gl_getfg(wbp w, char *s)
   {
   sprintf(s, "%s", w->context->glfg.name);
   }



void gl_getdrawop(wbp w, char *answer)
   {
   char *s;
   if (w->context->drawop == GL2D_DRAWOP_REVERSE) s = "reverse";
   else s = "copy";

   sprintf(answer, "%s", s);
   }



void gl_getlinestyle(wbp w, char *s)
   {
   wcp wc = w->context;
   sprintf(s,"%s",
           (wc->linestyle==GL2D_LINE_SOLID)?"solid":
           ((wc->linestyle==GL2D_LINE_DASHED)?"dashed":"striped"));
   }



void gl_getfntnam(wbp w, char *s)
   {
   sprintf(s,"%s", w->context->font->name);
   }



char *gl_get_mutable_name(wbp w, int mute_index)
   {
   struct color *mclr;
   char *colorname;

   if (!(mclr = find_mutable(w, mute_index)))
      return NULL;

   colorname = mclr->name;
   return colorname;
   }



int gl_set_mutable(wbp w, int mute_index, char *s)
   {
   wsp ws = w->window;
   int i = mute_index;
   struct color *mclr;
   long r, g, b, a;
   ws->busy_flag = 1;

   if (!(mclr = find_mutable(w, i)))
      return Failed; /* unable to find mutable */

   if (parsecolor(w, s, &r, &g, &b, &a) != Succeeded)
      return Failed; /* invalid color specification */

   SetColor(*mclr, r, g, b, a, i);
   redraw3D(w); /* color changed, re-render */

   ws->busy_flag = 0;
   return Succeeded;
   }



struct color *find_mutable(wbp w, int index)
   {
   wdp wd = w->window->display;
   struct color *mclr;

   if (wd->numMclrs > 0 || index < 0) {
      if (!wd->mclrs) {
         glprintf("mutable colors linked list improper linking\n");
         return NULL;
         }
      for (mclr=wd->mclrs; mclr; mclr = mclr->next) {
         if (mclr->id == index)
            return mclr;
         }
      }
   return NULL;
   }



struct color *alc_mutable_color(wbp w)
   {
   wdp wd = w->window->display;
   struct color **head, *new;

   new = (struct color *)calloc(1,sizeof(struct color));
   if (!new) {
      glprintf("failed allocating mutable color\n");
      return NULL;
      }

   wd->numMclrs++;
   new->id = -(++(wd->muteIdCount)); /* negative index for mutables */

   /* link to the front of list */
   head = &(wd->mclrs);
   if (*head) {
      new->next = *head;
      (*head)->prev = new;
      *head = new;
      }
   else {
      *head = new;
      }

   return new;
   }



void gl_free_mutable(wbp w, int mute_index)
   {
   wdp wd = w->window->display;
   struct color *mclr;

   /* try to find mutable */
   if (!(mclr = find_mutable(w, mute_index)))
      return;

   /* unlink */
   if (mclr->prev)
      mclr->prev->next = mclr->next;
   if (mclr->next)
      mclr->next->prev = mclr->prev;
   mclr->prev = mclr->next = NULL; /* unnecessary? */

   /* free */
   free(mclr);
   wd->numMclrs--;

   /* No mutable colors left, book-keeping */
   if (wd->numMclrs == 0) {
      wd->mclrs = NULL;
      wd->muteIdCount = 0;
      }
   }



void free_mutables(wdp wd) {
   struct color *mclr, *del;

   mclr = wd->mclrs;
   while (mclr) {
      del = mclr;
      mclr = mclr->next;

      /* unlink */
      if (mclr) {
         mclr->prev = NULL;
         del->next = NULL;
         }
      free(del);
      }
   wd->mclrs = NULL;
   wd->muteIdCount = wd->numMclrs = 0;
   }



/*
 * Should a mutable color even have a display list entry?
 */
int gl_mutable_color(wbp w, dptr argv, int warg, int *rv)
   {
   long r, g, b, a;
   int id;
   tended char *str;
   struct color *mclr;

   /*
    * check args
    */
   if (warg > 0) { /* set the color */
      if (warg != 1) return RunError;
      /*
       * old-style check for C integer
       * Check for mutable color id as arg
       */
      else if (is:integer(argv[0])) {/* check for color cell */
         if ((id = IntVal(argv[0])) >= 0)
            return Failed;        /* must be negative */

         /*
          * check to see if it's a valid mutable color
          */
         if (!(mclr = find_mutable(w, id)))
            return Failed; /* not a valid color */

         /* valid, get colors */
         r = mclr->r;
         g = mclr->g;
         b = mclr->b;
         a = mclr->a;
         }

      /*
       * String specification
       */
      else {
         if (!cnv:C_string(argv[0],str)) {
            ReturnErrVal(103,argv[0], RunError);
            }
         if (parsecolor(w, str, &r, &g, &b, &a) != Succeeded) {
            return Failed;                   /* invalid color specification */
            }
         }
      }
   else {
      return Failed;
      }

   /*
    * Allocate a mutable color
    */
   if (!(mclr = alc_mutable_color(w)))
      return Failed;
   SetColor(*mclr, r, g, b, a, mclr->id);
   *rv = mclr->id; /* store return value */
   return Succeeded;
   }



/*
 * Allocates a display list record for fg/bg color.
 * type - 0 for bg, 1 for fg
 */
int gl_color(wbp w, int intcode, int mindex, char *s)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   static struct descrip *fgconstr, *bgconstr;
   struct descrip *constr;
   tended struct descrip f;
   tended struct b_record *rp;
   int index, nfields, is_mutable = 0, rv;
   static char fgstr[] = "Fg", bgstr[] = "Bg";
   char *name;
   tended char *tended_s = s;
   long r, g, b, a;


   /* if given a negative int, assume mutable index */
   if (mindex < 0) {
      index = mindex;
      if (find_mutable(w, index) == NULL) {
         glprintf("could not find mutable color %d\n",mindex);
         return Failed;
         }
      is_mutable = 1;
      r = g = b = a = -1;
      }
   /* normal color with color specification */
   else if (s != NULL) {
      if (parsecolor(w, s, &r, &g, &b, &a) != Succeeded) {
         /* What to do if unable to parse color spec? */
         glprintf("unable to parse color specification '%s'\n",s);
         return Failed;
         }
      index = 0;
      }
   else {
      glprintf("not a mutable color or color spec?\n");
      return Failed;
      }


   /* Set context color */
   if (!ws->updateRC) {
      switch (intcode) {
         case GL2D_FG:
            SetColor(wc->glfg, r, g, b, a, index);
            break;
         case GL2D_BG:
            SetColor(wc->glbg, r, g, b, a, index);
            break;
         default:
            glprintf("incorrect color record type\n");
            return Failed;
         }
      }
   /*
    * Attribute initialization, find/alloc X11 color for border/background
    * pixel.
    */
   if (ws->initAttrs) {
      return Succeeded;
      }

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(fgconstr, GL2D_FG);
   Get2dRecordConstr(bgconstr, GL2D_BG);

   if (intcode == GL2D_FG) { /* fg */
      constr = fgconstr;
      name = fgstr;
      }
   else { /* bg */
      constr = bgconstr;
      name = bgstr;
      }

   /*
    * allocate record
    */
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   /*
    * Store attributes
    */
   MakeStr(name, 2, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   if (!is_mutable) {
      rp->fields[2] = nulldesc;
      MakeInt(r, &(rp->fields[3]));
      MakeInt(g, &(rp->fields[4]));
      MakeInt(b, &(rp->fields[5]));
      MakeInt(a, &(rp->fields[6])); /* alpha of 1 */
      }
   else {
      MakeInt(mindex, &(rp->fields[2]));
/*
      rp->fields[3] = nulldesc;
      rp->fields[4] = nulldesc;
      rp->fields[5] = nulldesc;
      rp->fields[6] = nulldesc;
*/
      }

   rv = setcolor2d(w, rp, 0);
   if (rv != Succeeded) {
      ws->busy_flag = 0;
      return rv;
      }

   c_put(&(w->window->funclist2d), &f);

   ws->busy_flag = 0;

   return Succeeded;
   }



int gl_setbgrgb(wbp w, int r, int g, int b)
   {
   char sbuf1[MaxCvtLen];
   sprintf(sbuf1, "%d,%d,%d", r, g, b);
   return gl_setbg(w, sbuf1);
   }



int gl_setfgrgb(wbp w, int r, int g, int b)
   {
   char sbuf1[MaxCvtLen];
   sprintf(sbuf1, "%d,%d,%d", r, g, b);
   return gl_setfg(w, sbuf1);
   }



/*
 * For setting a color to a mutable color using its negative integer
 * code. Otherwise generate a color.
 *
 * Creates a display list item
 */
int gl_isetbg(wbp w, int mindex)
   {
   struct color *mclr;

   if (!(mclr = find_mutable(w, mindex))) {
      /* Failed to find a mutable, what to do? */
      return Failed;
      }

   return gl_color(w, GL2D_BG, mindex, NULL);
   }



/*
 * For setting a color to a mutable color using its negative integer
 * code. Otherwise generate a color.
 *
 * Creates a display list item
 */
int gl_isetfg(wbp w, int mindex)
   {
   struct color *mclr;

   if (!(mclr = find_mutable(w, mindex))) {
      /* Failed to find a mutable, what to do? */
      return Failed;
      }

   return gl_color(w, GL2D_FG, mindex, NULL);
   }




/*
 * Creates a display list item
 */
int gl_setbg(wbp w, char *s)
   {
   return gl_color(w, GL2D_BG, 0, s); /* not mutable */
   }



/*
 * Creates a display list item
 */
int gl_setfg(wbp w, char *s)
   {
   return gl_color(w, GL2D_FG, 0, s); /* not mutable */
   }




int gl_toggle_fgbg(wbp w)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   tended struct descrip f;
   tended struct b_record *rp;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_REVERSE;
   int nfields;

   if (!ws->updateRC) {
      ISREVERSE(w) ? CLRREVERSE(w) : SETREVERSE(w); /* for legacy impl. */
      if (wc->reverse) wc->reverse = 0;
      else wc->reverse = 1;
      }

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);

   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Reverse", 7, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));

   togglefgbg2d(w);
   c_put(&(w->window->funclist2d), &f);

   ws->busy_flag = 0;
   return Succeeded;
   }



int gl_setgamma(wbp w, double gamma)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   tended struct descrip f;
   tended struct b_record *rp;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_GAMMA;
   int nfields;

   if (!ws->updateRC)
      wc->gamma = gamma;

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);

   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Gamma", 5, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeRealAlc(gamma, &(rp->fields[2]));

   setgamma2d(w,rp);
   c_put(&(w->window->funclist2d), &f);

   ws->busy_flag = 0;

   return Succeeded;
   }


/*
 * Context attributes set before call to this function
 */
int gl_setclip(wbp w)
{
   wsp ws = w->window;
   wcp wc = w->context;
   tended struct descrip f;
   tended struct b_record *rp;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_CLIP;
   int nfields, rv;
   int clipx, clipy, clipw, cliph;



   /* context attributes already set in wattrib() */
   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);

   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   clipx = wc->clipx;
   clipy = wc->clipy;
   clipw = wc->clipw;
   cliph = wc->cliph;

   /* uncook dx/dy values */
   if (clipx != 0 || clipy != 0 || clipw != -1 || cliph != -1) {
      clipx -= wc->dx;
      clipy -= wc->dy;
      }

   MakeStr("Clip", 4, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(clipx, &(rp->fields[2]));
   MakeInt(clipy, &(rp->fields[3]));
   MakeInt(clipw, &(rp->fields[4]));
   MakeInt(cliph, &(rp->fields[5]));

   if ((rv = setclip2d(w,rp)) != Succeeded) {
      ws->busy_flag = 0;
      return rv;
      }
   c_put(&(w->window->funclist2d), &f);

   ws->busy_flag = 0;
   return Succeeded;
   }



int gl_unsetclip(wbp w)
   {
   return gl_setclip(w);
   }



int gl_SetPattern(wbp w, char *name, int len)
   {
   wcp wc = w->context;
   wsp ws = w->window;
   const int intcode = GL2D_PATTERN;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp = NULL;
   tended char *s;
   int nfields;
   {
   CURTSTATE();

   /*
    * Update pattern name
    */
   if (!ws->updateRC) {
      if (wc->patternname != NULL)
         free(wc->patternname);
      wc->patternname = malloc(len+1);
      if (wc->patternname == NULL) ReturnErrNum(305, RunError);
      strncpy(wc->patternname, name, len);
      wc->patternname[len] = '\0';
      }

   /*
    * Attribute initialization only allocs the contexts pattern name
    */
   if (ws->initAttrs) {
      return Succeeded;
      }

   MakeCurrent(w);

   ws->busy_flag = 1;
   UpdateRenderContext(w, intcode);
   Get2dRecordConstr(constr, intcode);

   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Pattern", 7, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));

   Protect(s = alcstr(name,len), return RunError);
   MakeStr(s, len, &(rp->fields[2]));
   MakeStr(s, len, &(rp->fields[3]));

   /*
    * Set named pattern
    */
   switch (setpattern2d(w, rp)) {
      case Failed:
         ws->busy_flag = 0;
         return Failed;
      case RunError:
         ws->busy_flag = 0;
         ReturnErrNum(145, RunError);
         }

   c_put(&(w->window->funclist2d), &f);
   ws->busy_flag = 0;

   return Succeeded;
   }
   }



/*
 * Context attribute set in rwindow.r before the call to this function
 */
int gl_setdx(wbp w)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   tended struct descrip f;
   tended struct b_record *rp;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_DX;
   int nfields;

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);

   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Dx", 2, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(wc->dx, &(rp->fields[2]));
   MakeInt(wc->dx, &(rp->fields[3]));

   setdx2d(w,rp);
   c_put(&(w->window->funclist2d), &f);
   ws->busy_flag = 0;

   return Succeeded;
   }



/*
 * Context attribute set in rwindow.r before the call to this function
 */
int gl_setdy(wbp w)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   tended struct descrip f;
   tended struct b_record *rp;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_DY;
   int nfields;

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("WAttrib", 7, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(wc->dy, &(rp->fields[2]));
   MakeInt(wc->dy, &(rp->fields[3]));

   setdy2d(w,rp);

   c_put(&(w->window->funclist2d), &f);
   ws->busy_flag = 0;
   return Succeeded;
   }



int gl_setdrawop(wbp w, char *s)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_DRAWOP;
   tended struct descrip f;
   tended struct b_record *rp;
   char *s_op;
   int nfields, len;


   /* "reverse" */
   if (!ws->updateRC) {
      if (!strcmp(s,"reverse") || !strcmp(s,"xor"))
         wc->drawop = GL2D_DRAWOP_REVERSE;
      else if (!strcmp(s,"copy"))
         wc->drawop = GL2D_DRAWOP_COPY;
      /* consider both invalid strings and unsupported drawops as failure */
      else
         return Failed;
      }

   MakeCurrent(w);

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields, BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Drawop", 6, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   len = strlen(s);
   Protect(s_op = alcstr(s, len), return RunError);
   MakeStr(s_op, len, &(rp->fields[2]));

   setdrawop2d(w, rp);
   c_put(&(w->window->funclist2d), &f);
   ws->busy_flag = 0;

   return Succeeded;
   }



/*
 * Sets the fillstyle for the current context and render context.
 *
 * By default, the OpenGL implementation will use the clipping
 * plane of the stencil function. Only when the fillstyle is set
 * to a mode other than "solid" and a drawing operation on applicable
 * primitives is about to be performed, is the OpenGL stencil state
 * changed to accommodate it. After the drawing operation is completed,
 * the stencil state is restored to default (clipping only).
 */
int gl_setfillstyle(wbp w, char *s)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   const int intcode = GL2D_FILLSTYLE;
   static struct descrip *constr = NULL;
   tended struct descrip f;
   tended struct b_record *rp;
   tended char *s_op;
   int nfields, len;

   /*
    * Necessary to include "patterned", "stippled", "opaquestippled"
    * and "opaquepatterned"?
    */
   if (!ws->updateRC) {
      if (!strcmp(s, "solid"))
         wc->fillstyle = GL2D_FILL_SOLID;
      else if (!strcmp(s, "masked"))
         wc->fillstyle = GL2D_FILL_MASKED;
      else if (!strcmp(s, "textured"))
         wc->fillstyle = GL2D_FILL_TEXTURED;
      else return Failed;
      }

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Fillstyle", 9, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   len = strlen(s);
   Protect(s_op = alcstr(s, len), return RunError);
   MakeStr(s_op, len, &(rp->fields[2]));

   setfillstyle2d(w,rp);
   c_put(&(w->window->funclist2d), &f);
   ws->busy_flag = 0;

   return Succeeded;
   }



int gl_setlinestyle(wbp w, char *s)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_LINESTYLE;
   tended struct descrip f;
   tended struct b_record *rp;
   tended char *s_op;
   int nfields, len;

   /* is checking for "onoff" and "doubledash" really necessary? */
   if (strcmp(s,"solid") && strcmp(s,"dashed") && strcmp(s,"striped"))
      return Failed;

   if (!ws->updateRC) {
      if (!strcmp(s, "solid"))
         wc->linestyle = GL2D_LINE_SOLID;
      else if (!strcmp(s, "dashed"))
         wc->linestyle = GL2D_LINE_DASHED;
      else if (!strcmp(s, "striped"))
         wc->linestyle = GL2D_LINE_STRIPED;
      else return Failed;
      }

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Linestyle", 9, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   len = strlen(s);
   Protect(s_op = alcstr(s, len), return RunError);
   MakeStr(s_op, len, &(rp->fields[2]));

   setlinestyle2d(w,rp);
   c_put(&(w->window->funclist2d), &f);
   ws->busy_flag = 0;

   return Succeeded;
   }



/* setlinewidth() in ropengl.ri */
int gl_setlinewidth(wbp w, LONG linewidth)
   {
   wsp ws = w->window;
   wcp wc = w->context;
   tended struct descrip f;
   tended struct b_record *rp;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_LINEWIDTH;
   int nfields;

   if (!ws->updateRC)
      wc->linewidth = linewidth;

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);

   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Linewidth", 9, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(linewidth, &(rp->fields[2]));

   setlinewidth2d(w,rp);
   c_put(&(w->window->funclist2d), &f);
   ws->busy_flag = 0;

   return Succeeded;
   }



int gl_setfont(wbp w, char **s)
   {
   wsp ws = w->window;
   wcp wc = w->context, wcr = &(ws->wcrender);
   wfp wf;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_FONT;
   tended struct descrip f;
   tended struct b_record *rp;
   tended char *name;
   tended char *tended_s = *s;
   int nfields, len;

   /* try to find/alloc font */
   len = strlen(*s);
   wf = gl_alc_font(w, s, len);
   if (!wf)
      return Failed;

   if (!ws->updateRC) {
      if (wc->font)
         wc->font->refcount--;
      wc->font = wf;
      wc->leading = FT_FHEIGHT(wf->face);
      wc->font->refcount++;
      }

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Font", 4, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));

   Protect(name = alcstr(*s,len), return RunError);
   MakeStr(name, len, &(rp->fields[2]));

   /* update render context */
   if (wcr->font)
      wcr->font->refcount--;
   wcr->font = wf;
   wcr->leading = FT_FHEIGHT(wf->face);
   wcr->font->refcount--;

   c_put(&(w->window->funclist2d), &f);

   ws->busy_flag = 0;

   return Succeeded;
   }



/*
 * Allocate font (s) in the display attached to (w).
 *
 * This function may deal with Unicon strings. As such, use (len) to ensure
 * that memory violations don't occur.
 */
wfp gl_alc_font(wbp w, char **s, int len)
   {
   wdp wd = w->window->display;
   wfp *wfptr = &(wd->glfonts);
   wfp rv;

   /* what to do if empty string? */
   if (*s == NULL)
      return NULL;

   /*
    * see if the font is already loaded on this display
    */
   for(rv = *wfptr; rv != NULL; rv = rv->next) {
      if (strlen(rv->name) == len && !strncmp(*s,rv->name,len)) {
         break;
         }
      }
   if (rv) {
      rv->refcount++;
      return rv;
      }

   /*
    * load a new font
    */
   rv = loadfont(wd, *s, len);
   if (rv == NULL) {
      return NULL;
      }

   w->context->leading = rv->height;

   /*
    * link the font into this displays fontlist (but not at the head!)
    */
   if (!(*wfptr)) {
      *wfptr = rv;
      }
   else {
      rv->next = (*wfptr)->next;
      rv->previous = *wfptr;
      if ((*wfptr)->next) (*wfptr)->next->previous = rv;
      (*wfptr)->next = rv;
      }
   return rv;
   }



/*
 * This function may deal with Unicon strings. As such, use (len) to ensure
 * that memory violations don't occur.
 */
#ifdef HAVE_LIBFREETYPE

static wfp loadfont(wdp wd, char *s, int len)
   {
   int rv, flags, size, tp, i;
   int num_faces;
   char family[MAXFONTWORD+1], buf[MAXFONTWORD+1];
   char *fname;
   wfp wf;
   int platform_id, encoding_id, cmap_index;
   CURTSTATE();


   GRFX_ALLOC(wf, _wfont);
   wf->name = (char *)malloc(len+1);
   if (wf->name == NULL) ReturnErrNum(305, NULL);
   strncpy(wf->name,s,len);
   wf->name[len] = '\0';

   /* init library */
   rv = FT_Init_FreeType(&(wf->library));
   if (rv) {
      glprintf("Error %d occurred during FT library initialization\n",rv);
      return NULL;
      }

   /*
    * Try to convert (s) to a font spec
    *
    * a spec can start with "fc:" to indicate that it's in fontconfig
    * format.
    */
   if (len >= 3 && !strncmp(s, "fc:", 3))
       s += 3;
   if (!parsefont(s, family, &flags, &size, &tp)) {
      free(wf);
      return NULL;
      }

   /*
    * If we got here, we have the family name and other attributes.
    * Use fontconfig or something to find closest available font
    * file.
    */
   fname = find_fontfile(family, flags);
   if (!fname) { /* failed to find file or approx font file */
      free(wf);
      return NULL;
      }

   /*
    * Load font
    *
    * Start by looking at first font (0). The loop will continue
    * if there are more fonts and the first font didn't match the
    * requested font
    *
    * Maybe should keep track of a "best" font.
    *
    * TODO: How to search for {flags} specifiers. Currently,
    *       fonts of the type 'family,size' are accepted. Not
    *       'family[,styles],size'
    */
   for (i = 0, num_faces = 1; i < num_faces; i++) {
      rv = FT_New_Face(wf->library, fname, i, &(wf->face));
      if (rv == FT_Err_Unknown_File_Format) {
         glprintf("Font file format is not supported\n");
         free(wf);
         if (fname) free(fname);
         return NULL;
         }
      else if (rv) {
         glprintf("Error %d occurred loading font file\n",rv);
         free(wf);
         if (fname) free(fname);
         return NULL;
         }

      /*
       * Bits 0-15 contain the index of the current face. 0 if
       * there is only one face
       */
      num_faces = wf->face->num_faces & 0xFFFF;

      /*
       * Check family name
       */
      strcpy(buf, wf->face->family_name);
      s = buf;
      do { /* make case insensitive */
         int c = *s;
         if (c >= 65 && c <= 90) {
            *s -= ((int)'a' - (int)'A');
            }
      } while (*s++);

      /* if match, we're done */
      if (!strcmp(buf, family)) {
         break;
         }
      }

   /*
    * Size not specified, pick a size that makes the default font height
    * 13
    */
   if (size == -1)
      size = 10;

   rv = FT_Set_Pixel_Sizes(wf->face,
                          0, /* char width in pixels */
                          size); /* char height in pixels */
   if (rv) {
      glprintf("Failed to set character size, error code: %d\n",rv);
      free(wf);
      if (fname) free(fname);
      return NULL;
      }

   /*
    * Calculate Unicon font attributes
    */
   wf->size = size; /* in pixels */
   wf->ascent = FT_ASCENT(wf->face);
   wf->descent = FT_DESCENT(wf->face);
   wf->maxwidth = FT_FWIDTH(wf->face);
   wf->height = FT_FHEIGHT(wf->face);

   /*
    * If no unicode charmap, get one
    * NOTE: desired platform id & encoding id are known
    *
    * platform_id - 0 (Apple), 1 (Macintosh), 2 (ISO), 3 (MS), 4 (CUSTOM),
    *               5 (Adobe)
    *
    * For now, use (1,0), i.e., Macintosh platform_id, Apple roman encoding id.
    * According to FT documentation, most TrueType fonts support this
    * platform/encoding combination.... I suppose we'll see if it's true.
    */

   platform_id = 1; /* TT_PLATFORM_MACINTOSH */
   encoding_id = 0; /* TT_MAC_ID_ROMAN */
   cmap_index = -1;
   for (i = 0; i < wf->face->num_charmaps; i++) {
      if (wf->face->charmaps[i]->platform_id == platform_id &&
          wf->face->charmaps[i]->encoding_id == encoding_id)
         {
         cmap_index = i;
         break;
         }
      }

   if (cmap_index == -1) {
      /*
       * Check FT headers for the correct encoding type. FT_ENCODING_BIG5
       * was the encoding used in the tutorial example.
       */
      rv = FT_Select_Charmap(wf->face, FT_ENCODING_BIG5);
      if (rv) {
         glprintf("failed to get charmap, error code %d\n", rv);
         if (fname) free(fname);
         free(wf);
         return NULL;
         }
      }
   else {
      /* now, select the charmap for the face object */
      rv = FT_Set_Charmap(wf->face, wf->face->charmaps[i]);
      if (rv) {
         glprintf("failed to get charmap, error code %d\n", rv);
         if (fname) free(fname);
         free(wf);
         return NULL;
         }
      }

   for (i = 0; i < 256; i++) {
      wf->chars[i].pixmap = NULL;
      wf->chars[i].texid = wf->chars[i].index = 0;
      }

   if (fname) free(fname);
   return wf;
   }
#else                                   /* HAVE_LIBFREETYPE */

static wfp loadfont(wdp wd, char *s, int len)
   {
   return NULL;
   }

#endif                                  /* HAVE_LIBFREETYPE */



/*
 * Macros for readable font typechecking
 */

/* Font weight */
#define IS_FONT_LIGHT(flag) (flag & FONTFLAG_LIGHT)
#define IS_FONT_DEMI(flag) (flag & FONTFLAG_DEMI)
#define IS_FONT_MEDIUM(flag) (flag & FONTFLAG_MEDIUM)
#define IS_FONT_BOLD(flag) (flag & FONTFLAG_BOLD)
#define IS_FONT_DEMIBOLD(flag) (IS_FONT_DEMI(flag) & IS_FONT_BOLD(flag))

/* Font width */
#define IS_FONT_CONDENSED(flag) (flag & FONTFLAG_CONDENSED)
#define IS_FONT_EXTENDED(flag) (flag & FONTFLAG_EXTENDED)
#define IS_FONT_NARROW(flag) (flag & FONTFLAG_NARROW)
#define IS_FONT_NORMAL(flag) (flag & FONTFLAG_NORMAL)
#define IS_FONT_WIDE(flag) (flag & FONTFLAG_WIDE)

/* Font slant */
#define IS_FONT_ROMAN(flag) (flag & FONTFLAG_ROMAN)
#define IS_FONT_ITALIC(flag) (flag & FONTFLAG_ITALIC)
#define IS_FONT_OBLIQUE(flag) (flag & FONTFLAG_OBLIQUE)

/* Font spacing */
#define IS_FONT_MONO(flag) (flag & FONTFLAG_MONO)
#define IS_FONT_PROPORTIONAL(flag) (flag & FONTFLAG_PROPORTIONAL)

/* Font serif */
#define IS_FONT_SANS(flag) (flag & FONTFLAG_SANS)
#define IS_FONT_SERIF(flag) (flag & FONTFLAG_SERIF)

/*
 * Returns the filename for either a use provided TTF/OTF file or one of
 * the standard portable Unicon fonts in unicon/dat/fonts.
 *
 * This function allocates the return string with malloc()! Don't forget
 * to cleanup!!!
 */
#define MAX_LEN 512
char *find_fontfile(char *family, int flags) {
   static char fontdir[MAX_LEN];
   char *fname = NULL, *abspath, *ptr;
   int len;
#ifdef MSWindows
   const char PS = '\\';
#else                                   /* MSWindows */
   const char PS = '/';
#endif                                  /* MSWindows */

   /*
    * Check if {family} is a .ttf or .oft. Return the filename if so.
    */
   len = strlen(family);
   ptr = family + (len - 4);
   if (!strcmp(ptr,".ttf") || !strcmp(ptr,".otf")) {
      if (access(family, F_OK) != -1) {
         abspath = strdup(family);
         if (!abspath) return NULL;
         return abspath;
         }
      }

   /*
    * Get path to unicon/dat/fonts
    */
   if (!(fontdir[0])) {
      /* NOTE: findonpath() does not support '~' */
      if (!findonpath(UNICONX_EXE, fontdir, MAX_LEN)) {
         fprintf(stderr,"could not find iconx on path\n");
         return NULL;
         }

      /*
       * 12 for "../dat/fonts" and the 1's for the PS and null char respectively
       */
      len = strlen(fontdir) + 1 + 12 + 1;
      if (len > MAX_LEN) {
         glprintf("fonts directory name is too long, %d characters\n",len);
         return NULL;
         }

      /* strip "iconx" and append "../dat/fonts" */
      for (ptr = &(fontdir[len-14]); *ptr != PS; ptr--) {
         if (fontdir - ptr == 0) {
            glprintf("something's gone wrong...\n");
            return NULL;
            }
         }
      sprintf(ptr+1,"..%cdat%cfonts",PS,PS);
      }


   /*
    * Check first for special "standard" family names to add to flags
    */
   if (!strcmp(family, "fixed") || !strcmp(family, "mono")) {
      flags |= FONTFLAG_MONO | FONTFLAG_SANS;
      }
   else if (!strcmp(family, "typewriter")) {
      flags |= FONTFLAG_MONO | FONTFLAG_SERIF;
      }
   else if (!strcmp(family, "sans")) {
      flags |= FONTFLAG_PROPORTIONAL | FONTFLAG_SANS;
      }
   else if (!strcmp(family, "serif")) {
      flags |= FONTFLAG_PROPORTIONAL | FONTFLAG_SERIF;
      }

   /*
    * Otherwise the family name is the name of a font - use a decision tree
    *
    * The goal is to return a font if a font name is specified, so the
    * decision tree generalizes heavily. If there are issues, change the
    * logic manually for each font.
    */
   else { /* default? */
      if (!strcmp(family, "avant garde") || !strcmp(family, "avantgarde")) {
         if (IS_FONT_DEMI(flags)) {
            /* AvantGarde-DemiOblique - urwgo4.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "urwgo4.ttf";
               }
            /* AvantGarde-Demi - urwgo2.ttf */
            else {
               fname = "urwgo2.ttf";
               }
            }
         /* NOTE: do not have "Book" font weight option */
         /* AvantGarde-BookOblique - urwgo3.ttf */
         else if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
            fname = "urwgo3.ttf";
            }
         /* default to: AvantGarde-Book - urwgo1.ttf */
         else {
            fname = "urwgo1.ttf";
            }
         }

      else if (!strcmp(family, "bookman")) {
         if (IS_FONT_LIGHT(flags)) {
            /* Bookman-LightItalic - urwbo7.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "urwbo7.ttf";
               }
            /* Bookman-Light - urgwbo5.ttf */
            else {
               fname = "urwbo5.ttf";
               }
            }
         else if (IS_FONT_DEMI(flags)) {
            /* Bookman-DemiItalic - urgwbo8.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "urwbo8.ttf";
               }
            /* Bookman-Demi - urgwbo6.ttf */
            else {
               fname = "urwbo6.ttf";
               }
            }
         /* default to: Bookman-Demi - urgwbo6.ttf */
         else {
            fname = "urwbo6.ttf";
            }
         }

      else if (!strcmp(family, "courier")) {
         if (IS_FONT_BOLD(flags)) {
            /* Courier-BoldOblique - nimbu29.ttf */
            if (IS_FONT_OBLIQUE(flags) || IS_FONT_ITALIC(flags)) {
               fname = "nimbu29.ttf";
               }
            /* Courier-Bold - nimbu27.ttf */
            else {
               fname = "nimbu27.ttf";
               }
            }
         /* Courier-Oblique - nimbu28.ttf */
         else if (IS_FONT_OBLIQUE(flags) || IS_FONT_ITALIC(flags)) {
            fname = "nimbu28.ttf";
            }
         /* default: Courier - nimbu26.ttf */
         else {
            fname = "nimbu26.ttf";
            }
         }

      else if (!strcmp(family, "helvetica")) {
         if (IS_FONT_NARROW(flags)) {
            if (IS_FONT_BOLD(flags)) {
               /* Helvatica-Narrow-BoldOblique - nimbu21.ttf */
               if (IS_FONT_OBLIQUE(flags) || IS_FONT_ITALIC(flags)) {
                  fname = "nimbu21.ttf";
                  }
               /* Helvatica-Narrow-Bold - nimbu19.ttf */
               else {
                  fname = "nimbu19.ttf";
                  }
               }
            else {
               /* Helvatica-Narrow-Oblique - nimbu20.ttf */
               if (IS_FONT_OBLIQUE(flags) || IS_FONT_ITALIC(flags)) {
                  fname = "nimbu20.ttf";
                  }
               /* Helvatica-Narrow - nimbu18.ttf */
               else {
                  fname = "nimbu18.ttf";
                  }
               }
            }
         else { /* assumed normal width */
             if (IS_FONT_BOLD(flags)) {
               /* Helvatica-BoldOblique - nimbu17.ttf */
               if (IS_FONT_OBLIQUE(flags) || IS_FONT_ITALIC(flags)) {
                  fname = "nimbu17.ttf";
                  }
               /* Helvatica-Bold - nimbu15.ttf */
               else {
                  fname = "nimbu15.ttf";
                  }
               }
            else {
               /* Helvatica-Oblique - nimbu16.ttf */
               if (IS_FONT_OBLIQUE(flags) || IS_FONT_ITALIC(flags)) {
                  fname = "nimbu16.ttf";
                  }
               /* Helvatica - nimbu14.ttf */
               else {
                  fname = "nimbu14.ttf";
                  }
               }
            }
         }

      else if (!strcmp(family, "palatino")) {
         if (IS_FONT_BOLD(flags)) {
            /* Palatino-BoldItalic - urwpa33.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "urwpa33.ttf";
               }
            /* Palatino-Bold - urwpa31.ttf */
            else {
               fname = "urwpa31.ttf";
               }
            }
         else {
            /* Palatino-Italic - urwpa32.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "urwpa32.ttf";
               }
            /* Palatino-Roman - urwpa30.ttf */
            else {
               fname = "urwpa30.ttf";
               }
            }
         }

      else if (!strcmp(family, "new century schoolbook")) {
         if (IS_FONT_BOLD(flags)) {
            /* NewCenturySchlbk-BoldItalic - centu12.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "centu12.ttf";
               }
            /* NewCenturySchlbk-Bold - centu10.ttf */
            else {
               fname = "centu10.ttf";
               }
            }
         else {
            /* NewCenturySchlbk-Italic - centu11.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "centu11.ttf";
               }
            /* NewCenturySchlbk-Roman - centu9.ttf */
            else {
               fname = "centu9.ttf";
               }
            }
         }

      else if (!strcmp(family, "times") || !strcmp(family,"times new roman")) {
          if (IS_FONT_BOLD(flags)) {
            /* Times-BoldItalic - nimbu25.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "nimbu25.ttf";
               }
            /* Times-Bold - nimbu23.ttf */
            else {
               fname = "nimbu23.ttf";
               }
            }
         else {
            /* Times-Italic - nimbu24.ttf */
            if (IS_FONT_ITALIC(flags) || IS_FONT_OBLIQUE(flags)) {
               fname = "nimbu24.ttf";
               }
            /* Times-Roman - nimbu22.ttf */
            else {
               fname = "nimbu22.ttf";
               }
            }
         }

      else if (!strcmp(family, "dingbats")) {
         fname = "dingb13.ttf";
         }
      else if (!strcmp(family, "symbol")) {
         fname = "stand34.ttf";
         }
      else {
         /*
          * How should this be dealt with? For now, just let Font()/Wattrib()
          * fail. This is a TODO item.
          */
         fprintf(stderr,"font '%s' not supported\n", family);
         return NULL;
         }
      }

   /*
    * Pseudo LUT for default Unicon font types. This is only used if
    * a specific font name was not given.
    *
    * For now, it covers basic cases. Should add extra cases to cover
    * extremes of font attributes Unicon users could pass, e.g. "normal",
    * "roman", etc.
    *
    */
   if (!fname) {
      switch (flags & 0x1FFFF) { /* ignore charsets & font attrs */
         /*
          * Unicon "mono" fonts (fixed width sans serif)
          *
          * Testing out SourceCodePro
          */
         case FONTFLAG_MONO | FONTFLAG_SANS:
            fname = "SourceCodePro-Regular.ttf";
            break;

         case FONTFLAG_MONO | FONTFLAG_SANS | FONTFLAG_BOLD:
            fname = "SourceCodePro-Bold.ttf";
            break;

         case FONTFLAG_MONO | FONTFLAG_SANS | FONTFLAG_ITALIC:
            fname = "SourceCodePro-It.ttf";
            break;

         case FONTFLAG_MONO | FONTFLAG_SANS | FONTFLAG_ITALIC | FONTFLAG_BOLD:
            fname = "SourceCodePro-BoldIt.ttf";
            break;

         /*
          * Unicon "typewriter" fonts (fixed width serif)
          */

         /* Courier - nimbu26.ttf */
         case FONTFLAG_MONO | FONTFLAG_SERIF:
            fname = "nimbu26.ttf";
            break;

         /* Courier-Oblique - numbu28.ttf */
         case FONTFLAG_MONO | FONTFLAG_SERIF | FONTFLAG_OBLIQUE:
            fname = "nimbu28.ttf";
            break;

         /* Courier-Bold - numbu27.ttf */
         case FONTFLAG_MONO | FONTFLAG_SERIF | FONTFLAG_BOLD:
            fname = "nimbu27.ttf";
            break;

         /* Courier-BoldOblique - numbu29.ttf */
         case FONTFLAG_MONO | FONTFLAG_SERIF | FONTFLAG_BOLD | FONTFLAG_OBLIQUE:
            fname = "nimbu29.ttf";
            break;


         /*
          * Unicon "sans" fonts (proportional width sans serif)
          */

         /* Helvetica - numbu14.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS:
            fname = "nimbu14.ttf";
            break;

         /* Helvetica-Oblique - numbu16.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS | FONTFLAG_OBLIQUE:
            fname = "nimbu16.ttf";
            break;

         /* Helvetica-Bold - numbu15.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS | FONTFLAG_BOLD:
            fname = "nimbu15.ttf";
            break;

         /* Helvetica-BoldOblique - numbu17.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS | FONTFLAG_BOLD |
              FONTFLAG_OBLIQUE:
            fname = "nimbu17.ttf";
            break;

         /* Helvetica-Narrow - numbu18.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS | FONTFLAG_NARROW:
            fname = "nimbu18.ttf";
            break;

         /* Helvetica-Narrow-Oblique - numbu20.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS | FONTFLAG_NARROW |
              FONTFLAG_OBLIQUE:
            fname = "nimbu20.ttf";
            break;

         /* Helvetica-Narrow-Bold - numbu19.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS | FONTFLAG_NARROW |
              FONTFLAG_BOLD:
            fname = "nimbu19.ttf";
            break;

         /* Helvetica-Narrow-BoldOblique - numbu21.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SANS | FONTFLAG_NARROW |
              FONTFLAG_BOLD | FONTFLAG_OBLIQUE:
            fname = "nimbu21.ttf";
            break;

         /*
          * Unicon "serif" fonts (proportional width serif)
          */

         /* Times-Roman - nimbu22.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SERIF:
            fname = "nimbu22.ttf";
            break;

         /* Times-Italic - nimbu24.ttf */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SERIF | FONTFLAG_ITALIC:
            fname = "nimbu24.ttf";
            break;

         /* Times-Bold - nimbu23.ttf (opt: normal/roman) */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SERIF | FONTFLAG_BOLD:
            fname = "nimbu23.ttf";
            break;

         /* Times-BoldItalic - nimbu25.ttf (opt: normal/roman) */
         case FONTFLAG_PROPORTIONAL | FONTFLAG_SERIF | FONTFLAG_ITALIC |
              FONTFLAG_BOLD:
            fname = "nimbu25.ttf";
            break;

         /* How to do these defaults? Ideally this wouldn't happen */
         case FONTFLAG_MONO: /* go Unicon mono? */
            break;
         case FONTFLAG_PROPORTIONAL: /* go Unicon sans? */
            break;
         default:
            break;
         }
      }

   if (!fname) {
      glprintf("failed to get font filename\n");
      return NULL;
      }

   /*
    * construct absolute file path
    */
   abspath = (char *)malloc(strlen(fontdir)+strlen(fname)+2);
   if (!abspath)
      return NULL;

   if (sprintf(abspath, "%s%c%s", fontdir, PS, fname) <= 0) {
      free(abspath);
      return NULL;
      }

   return abspath;
   }



int gl_setleading(wbp w, int leading)
   {
   wsp ws = w->window;
   wcp wc = w->context, wcr = &(ws->wcrender);
   tended struct descrip f;
   tended struct b_record *rp;
   static struct descrip *constr = NULL;
   const int intcode = GL2D_LEADING;
   int nfields;

   if (!ws->updateRC)
      wc->leading = leading;

   if (ws->initAttrs)
      return Succeeded;

   ws->busy_flag = 1;
   MakeCurrent(w);
   UpdateRenderContext(w, intcode);

   Get2dRecordConstr(constr, intcode);
   nfields = (int)BlkD(*constr,Proc)->nfields;
   Protect(rp = alcrecd(nfields,BlkLoc(*constr)), return RunError);
   f.dword = D_Record;
   BlkLoc(f) = (union block *)rp;

   MakeStr("Leading", 7, &(rp->fields[0]));
   MakeInt(intcode, &(rp->fields[1]));
   MakeInt(leading, &(rp->fields[2]));

   wcr->leading = leading;

   c_put(&(w->window->funclist2d), &f);

   ws->busy_flag = 0;

   return Succeeded;
   }



/**********************************************************
 * (4) Window management functions (platform independent) *
 **********************************************************/



int gl_allowresize(wbp w, int on)
   {
   if (on)
      SETRESIZABLE(w);
   else
      CLRRESIZABLE(w);
   return Succeeded;
   }



wcp gl_clone_context(wbp w)
   {
   wcp wc, rv;

   wc = w->context;
   Protect(rv = gl_alc_context(w), return NULL);

   copy_2dcontext(rv, wc);
   copy_3dcontext(wc, rv);

   return rv;
   }



/*
 * initialize child window w from parent window wp
 */
char gl_child_window_stuff(wbp w, wbp wp, int child_window)
   {
   int is_3d;
   if (child_window_generic(w, wp, child_window) == 0)
      return 0;

   is_3d = (child_window==CHILD_WIN3D)? 1 : 0;
   /*
    * New canvas, so allocate display lists before attribute
    * initialization
    */
   if (is_3d) {
      if (create_display_list(w, 40000) == Failed)
      return 0;
      }
   if (create_display_list2d(w, 40000) == Failed)
      return 0;

   /* preserve certain parent attributes */
#ifdef XWindows
   w->window->iconic = wp->window->iconic;
#endif                                  /* XWindows */
   w->window->buffermode = wp->window->buffermode;

   return 1;
   }



int gl_rebind(wbp w, wbp w2)
   {
   if (w->window->display != w2->context->display) return Failed;
   w->context = w2->context;
   return Succeeded;
   }



/*
 * OpenGL implementation doesn't use Pixmaps
 */
int gl_resizePixmap(wbp w, int width, int height)
   {
   return Succeeded;
   }



int gl_setcursor(wbp w, int on)
   {
   if (on)
      SETCURSORON(w);
   else
      CLRCURSORON(w);
   return Succeeded;
   }



/*
 * Used in macros in fsys.r... what to do?
 */
int gl_wputc(int ci, wbp w)
   {
   int lh, width, height, over;
   char c = (char)ci;
   /* STDLOCALS(w);   replaced by the declarations below*/
   wcp wc = w->context;
   wsp ws = w->window;

   lh = wc->leading;
   width = ws->width;
   height = ws->height;

   switch(c) {
      case '\r': {
         ws->x = wc->dx;
         break;
         }
      case '\n': {
         ws->y += lh;
         ws->x = wc->dx;

         /*
          * Now for the exciting part: do we scroll the window?
          * Copy the pixmap upward, then repaint the window.
          *
          * this needs testing...
          */
         over = ws->y + GL_DESCENT(w) - height;
         if (over > 0) {
            ws->y -= over;
            /*
             * Copy from (0, over) to (0, 0) with dimensions of (width X height)
             */
            gl_copyArea(w, w, 0, over, width, height+over, 0, 0);
            }
         break;
         }
      case '\t': {
         gl_xdis(w, "        ", 8 - ((GL_XTOCOL(w,ws->x))&7));
         break;
         }
      /*
       * Handle backspaces.  This implements cooked mode echo handling.
       */
      case '\177':
      case '\010': {
         int i = 0, pre_x;
         /*
          * Start with the last character queued up.
          */
         i--;
         /*
          * Trot back to the control-H itself.
          */
         while ((i>-EQUEUELEN) && (EVQUESUB(w,i) != c)) i--;
         if (i == -EQUEUELEN) break;
         /*
          * Go past the control-H.
          */
         i--;
         /*
          * Go back through any number of control-H's from prior lifetimes.
          */
         while((i > -EQUEUELEN) && !isprint(EVQUESUB(w,i))) i--;
         if (i == -EQUEUELEN) break;

         /*
          * OK, here's the character we're actually rubbing out.  Back up.
          */
         c = EVQUESUB(w,i);
         pre_x = ws->x;
         ws->x -= GL_TEXTWIDTH(w, &c, 1);
         /*
          * Physically erase the character from the queue.  This results in
          * two control-H's present in the queue.
          */
         *evquesub(w,i) = '\010';
         /*
          * Save the backed-up position, and draw spaces through the erased.
          */
         i = ws->x;
         while(ws->x < pre_x) gl_xdis(w," ",1);
         ws->x = i;
         break;
         }
      default: {
         gl_xdis(w,&c,1);
         }
      }
   return 1;
   }





/*******************************************************
 * (5) Window management functions (platform specific) *
 *******************************************************/




/*
 * allocate a context.  Can't be called until w has a display and window.
 */
wcp gl_alc_context(wbp w)
   {
   wcp wc;

   wc = alc_context(w); /* platform-specific init */
   if (!wc) return NULL;

   /* set defaults here */
   init_2dcontext(wc);
   init_3dcontext(wc);

   return wc;
   }




/*
 * allocate a display on machine s
 */
wdp gl_alc_display(char *s)
   {
   wdp wd;

   wd = alc_display(s); /* platform-specific init */
   if (!wd) return NULL;

   /*
    * Init OpenGL-specific display fields
    */
   if (!wd->texIds) {
      /*
       * Array for non-standard pattern textures. See macros for allocating
       * more as needed
       */
      wd->maxTexIds = 256;
      wd->numTexIds = 0;
      wd->texIds = (unsigned int *)malloc(wd->maxTexIds*sizeof(unsigned int));
      if (!wd->texIds) return NULL;
      }

   if (!wd->glfonts) {
      wd->numFonts = 1;
      wd->glfonts = loadfont(wd,DEFAULTFONTNAME,strlen(DEFAULTFONTNAME));
      if (!wd->glfonts) {
         fprintf(stderr,"Failed to find default font in dat/fonts\n");
         return NULL; /* should this be a runerr? */
         }
      }
   return wd;
   }



/*
 * allocate a window state structure
 */
wsp gl_alc_winstate()
   {
   wsp ws = alc_winstate(); /* platform-specific init */
   if (!ws) return NULL;

#ifdef XWindows
   ws->pix = (Pixmap) NULL; /* OpenGL impl. doesn't use backing store */
   ws->ctx = (GLXContext) NULL;
#endif                                  /* XWindows */

   ws->is_gl = 1;
   ws->buffermode = UGL_IMMEDIATE;
   ws->rendermode = UGL2D;

   /* 2d initialization */
   ws->lastwcserial = -1;
   ws->updateRC = 0;
   ws->initAttrs = 0;
   ws->resize = 0;
   ws->stencil_mask = 0;

   /* 3d initialization */
   ws->type = REAL_WSTATE;
   ws->texindex = -1;

   /* camera initialization */
   ws->eyeupx = ws->eyeupz = 0.0;
   ws->eyeupy = 1.0;
   ws->eyeposx = ws->eyeposy = ws->eyeposz = ws->eyedirx = ws->eyediry = 0.0;
   ws->eyedirz = -100.0;

   /* Set viewing volume defaults */
   ws->projection = UGL_PERSPECTIVE;
   ws->camwidth = DEFAULT_CWIDTH;

   return ws;
   }




void gl_free_context(wcp wc)
   {
   return free_context(wc);
   }



/*
 * free a display
 */
void gl_free_display(wdp wd)
   {
   /* pre-emptively check refcount for deallocation */
   if (wd->refcount == 1) {
      int i;
      wfp wf = wd->glfonts;

      /*
       * Free all 2d facility textures
       */
      for (i = 0; i < 16; i++) {
         if (wd->stdPatTexIds[i])
            glDeleteTextures(1, &(wd->stdPatTexIds[i]));
         wd->stdPatTexIds[i] = 0;
         }
      delete_first_tex(wd, wd->numTexIds);
      free(wd->texIds);
      wd->texIds = NULL;

      /*
       * Free mutable colors
       */
      free_mutables(wd);

#if HAVE_LIBFREETYPE
      /*
       * Free FreeType font fields
       */
      while (wf) { /* free fonts */
         FT_Done_Face(wf->face);
         FT_Done_FreeType(wf->library);
         for (i = 0; i < 256; i++) {
            if (wf->chars[i].pixmap) {
               free(wf->chars[i].pixmap);
               wf->chars[i].pixmap = NULL;
               }
            }
         wf = wf->next;
         }
      wd->glfonts = NULL;
#endif                                  /* HAVE_LIBFREETYPE */
      }
#ifdef XWindows
   /* Why doesn't Windows need to allocate a display? */
   free_display(wd);
#endif                                  /* XWindows */
   }



int gl_free_window(wsp ws)
   {
   return free_window(ws);
   }



/*
 * OpenGL doesn't need to allocate many colors, but this might come in handy
 */
void gl_freecolor(wbp w, char *s)
   {
   return freecolor(w, s);
   }



int gl_do_config(wbp w, int status)
   {
   return do_config(w, status);
   }



/*
 * from rxwin.ri
 */
void gl_getcanvas(wbp w, char *s)
   {
   return getcanvas(w, s);
   }




/*
 * from rxwin.ri...
 */
int gl_getdefault(wbp w, char *prog, char *opt, char *answer)
   {
   return getdefault(w, prog, opt, answer);
   }




void gl_getdisplay(wbp w, char *s)
   {
   return getdisplay(w, s);
   }




void gl_geticonic(wbp w, char *s)
   {
   return geticonic(w, s);
   }



int gl_geticonpos(wbp w, char *s)
   {
   return geticonpos(w, s);
   }




void gl_getpointername(wbp w, char *s)
   {
   return getpointername(w, s);
   }



int gl_getpos(wbp w)
   {
   return getpos(w);
   }



int gl_getvisual(wbp w, char *s)
   {
   return getvisual(w, s);
   }



int gl_nativecolor(wbp w, char *s, long *r, long *g, long *b)
   {
   return nativecolor(w, s, r, g, b);
   }



int gl_lowerWindow(wbp w)
   {
   return lowerWindow(w);
   }



int gl_raiseWindow(wbp w)
   {
   return raiseWindow(w);
   }



int gl_setcanvas(wbp w, char *s)
   {
   return setcanvas(w, s);
   }



int gl_setdisplay(wbp w, char *s)
   {
   return setdisplay(w, s);
   }



int gl_seticonicstate(wbp w, char *s)
   {
   return seticonicstate(w, s);
   }



int gl_seticonimage(wbp w, dptr dp)
   {
   return seticonimage(w, dp);
   }



int gl_seticonlabel(wbp w, char *s)
   {
   return seticonlabel(w, s);
   }



int gl_seticonpos(wbp w, char *s)
   {
   return seticonpos(w, s);
   }



int gl_setimage(wbp w, char *s)
   {
   return setimage(w, s);
   }



int gl_setpointer(wbp w, char *s)
   {
   return setpointer(w, s);
   }



int gl_setwidth(wbp w, SHORT new_width)
   {
   return setwidth(w, new_width);
   }




int gl_setheight(wbp w, SHORT new_height)
   {
   return setheight(w, new_height);
   }



int gl_setgeometry(wbp w, char *s)
   {
   return setgeometry(w, s);
   }




int gl_setwindowlabel(wbp w, char *s)
   {
   return setwindowlabel(w, s);
   }



int gl_query_pointer(wbp w, XPoint *xp)
   {
   return query_pointer(w, xp);
   }



int gl_query_rootpointer(XPoint *xp)
   {
   return query_rootpointer(xp);
   }


int gl_walert(wbp w, int volume)
   {
   return walert(w, volume);
   }



void gl_warpPointer(wbp w, int x, int y)
   {
   return warpPointer(w, x, y);
   }



int gl_wclose(wbp w)
   {
   return wclose(w);
   }



void gl_wflush(wbp w)
   {
   return wflush(w);
   }



#ifdef XWindows
void gl_wflushall()
   {
   return wflushall();
   }
#endif                                  /* XWindows */



int gl_wgetq(wbp w, dptr res, int t)
   {
   wsp ws = w->window;

   /*
    * This is usually called in a Unicon event loop, which stalls pollevent().
    * Go ahead and flush if there are pending rendering operations
    * in immediate mode.
    */
   if (!ws->is_3D && ws->buffermode == UGL_IMMEDIATE && ws->redraw_flag) {
      MakeCurrent(w);
      glFlush();
      ws->redraw_flag = 0;
      }
   return wgetq(w, res, t);
   }



FILE *gl_wopen(char *name, struct b_list *lp, dptr attr, int n, int *err_index, int is_3d)
   {
   return wopen(name, lp, attr,  n, err_index, is_3d, 1);
   }



int gl_wmap(wbp w)
   {
#ifdef XWindows
   return wmap(w);
#else                                   /* XWindows */
   /* placeholder until implemented in MSWin and OSX */
   return my_wmap(w);
#endif                                  /* XWindows */

   }



void gl_wsync(wbp w)
   {
   return wsync(w);
   }

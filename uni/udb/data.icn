#
# data.icn:    handle the print facilities found in debuggers such as GDB
# Author:      Ziad Al-Sharif, zsharif@gmail.com
# Contributor: Gigi Young
#

link exparser
link io
$include "evdefs.icn"
$include "defaults.icn"

#
# This class contains the classical/standard debugging techniqies
#
class Data(
   DState,        # (Alias) object of type State class
   Keywords,      # a set of all Unicon's valid keyword
   GlobalKeywords,# a set of all Unicon's keywords that are Global/General
   GenKeywords,   # a set of all Unicon's keywords that are Generators
   Message        # a string formated with the current message
   )

#
# prints all of Global Variables state in some level
#
method printGlobals(level)
   local x, i, CMonitored := DState.coState.target.val, output := [], globalsTable, variablesList:= [], consoleMsg := ""

   /level := DState.coState.target.curr_frame
   if \DState.mode ~== "--adapter" then
      put (output, "\n")
   put(output,"   Global variables:")

   every x := !DState.srcFile.getCurrGlobals() do {
      i := variable(x, CMonitored, level)
      put(output,"     "||x||" = "||image(i)||" : "|| type(i))
      if \DState.mode == "--adapter" then
         put(variablesList, table("name", x, "value", i, "type", type(i)))
   }

   if /DState.mode | DState.mode ~== "--adapter" then
      more(output)
   else {
      variableTable := table("name", x, "value", i, "type", type(i))
      every consoleMsg ||:= ("\n"||!output)
      globalsTable := [
         "type":"globals";
         "variables": variablesList;
         "consoleMsg": consoleMsg
      ]
      DState.Write(globalsTable)
   }
end

#
# prints all Local Variables for some Level
#
method printLocals(level)
   local x, i, CMonitored := DState.coState.target.val, output := [], localsTable, variablesList := [], consoleMsg := ""

   /level := DState.coState.target.curr_frame
   if \DState.mode ~== "--adapter" then
      put (output, "\n")
   put(output,"   Local variables:")

   every x := !DState.srcFile.getCurrLocals() do {
      i := variable(x, CMonitored, level)
      put(output,"     "||x||" = "||image(i)||" : "|| type(i))
      if \DState.mode == "--adapter" then
         put(variablesList, table("name", x, "value", i, "type", type(i)))
   }

   if /DState.mode | DState.mode ~== "--adapter" then
      more(output)
   else {
      variableTable := table("name", x, "value", i, "type", type(i))
      every consoleMsg ||:= ("\n"||!output)
      localsTable := [
         "type":"locals";
         "variables": variablesList;
         "consoleMsg": consoleMsg
      ]
      DState.Write(localsTable)
   }
end

#
# prints all Local Variables for some Level
#
method printStatics(level)
   local x, i, CMonitored := DState.coState.target.val, output := [], staticsTable, variablesList := [], consoleMsg := ""

   /level := DState.coState.target.curr_frame
   if \DState.mode ~== "--adapter" then
      put (output, "\n")
   put(output,"   Static variables:")

   every x := !DState.srcFile.getCurrStatics() do {
      i := variable(x, CMonitored, level)
      put(output,"     "||x||" = "||image(i)||" : "|| type(i))
      if \DState.mode == "--adapter" then
         put(variablesList, table("name", x, "value", i, "type", type(i)))
   }

   if /DState.mode | DState.mode ~== "--adapter" then
      more(output)
   else {
      variableTable := table("name", x, "value", i, "type", type(i))
      every consoleMsg ||:= ("\n"||!output)
      staticsTable := [
         "type":"statics";
         "variables": variablesList;
         "consoleMsg": consoleMsg
      ]
      DState.Write(staticsTable)
   }
end

#
# prints all Formal Parameters for some Level
#
method printParams(level)
   local x, i, CMonitored := DState.coState.target.val, output := [], paramsTable, variablesList := [], consoleMsg := ""

   /level := DState.coState.target.curr_frame
   if \DState.mode ~== "--adapter" then
      put (output, "\n")
   put(output,"   Parameters:")

   every x := !DState.srcFile.getCurrParams() do {
      i := variable(x, CMonitored, level)
      put(output,"     "||x||" = "||image(i)||" : "|| type(i))
      if \DState.mode == "--adapter" then
         put(variablesList, table("name", x, "value", i, "type", type(i)))
   }

   if /DState.mode | DState.mode ~== "--adapter" then
      more(output)
   else {
      variableTable := table("name", x, "value", i, "type", type(i))
      every consoleMsg ||:= ("\n"||!output)
      paramsTable := [
         "type":"params";
         "variables": variablesList;
         "consoleMsg": consoleMsg
      ]
      DState.Write(paramsTable)
   }
end

#
# returns the expression value or fails
# used by cmdPrint() and assignVar()
#
method getVarValue(Expr, level)
   local Value, x, expr:="", ref, var, Var, index:=[]
   local CMonitored := DState.coState.target.val

   /level := DState.coState.target.curr_frame

   every x := !Expr do expr ||:= x

   # if the string in the expr is not a literal (string value)
   if expr[1] ~== "\"" then {
      index := parsePrintExpression(Expr)
      if *index = 0 then fail
      var := get(index) # variable name
      if Var := variable(var, CMonitored, level) then {
         if (ref := getVarReference(Var, index, level)) & *index = 0 then {
            Value := if integer(ref) = ref then integer(ref)
                     else if real(ref) = ref then real(ref)
                     else ref
            return Value
         }
         else fail
      }
      # var is a primitive or invalid expression
      else {
         if *index = 0 then {
            Value := if integer(expr) = expr then integer(expr)
                     else if real(expr) = expr then real(expr)
                     else string(expr)
            return Value
         }
         # real part still in (index)
         else if index[1][1] == "." then {
            value := var
            while x := get(index) do value ||:= x
            if Value := real(value) then return Value
         }
         else {
            value := var
            while value ||:= " " || get(index)
            Message := "\n   Invalid right-hand expression \""||value||"\"."
            fail
         }
      }
      return Value
   }
   else
      return expr[2:-1]
end

#
# getVarReference is used by printVar and cmdPrint to
# get a reference for an element of a structure
#
method getVarReference(Var, index, level)
   local v, j, i1, i2, x1,x2, x, fld
   local CMonitored := DState.coState.target.val
   /level := DState.coState.target.curr_frame

   if *index = 0 then return Var

   #write("====",ximage(Var),"====",ximage(index))

   case type(Var) of {
      "integer"|"real"|"null"|"cset"|"set"|"file"|"window"|
      "procedure"|"co-expression"|"external":{
            return Var
      }
      "string":{
         x1 := get(index)
         x2 := get(index)
         # normal string subscript
         if \x1 & /x2 then {
            if v := variable(x1, CMonitored, level) | integer(x1) then {
               if abs(v) <= *Var then {
                  Var := Var[v]
                  return Var
               }
               else {
                  Message := "\n   The string subscript \""||x1||
                           "\" is out of range."
               }
            }
            else {
               #write("can't get variable reference ", image(Var),
               #      "[", image(v), "]")
               Message := "\n   The string subscript \""||x1||
                           "\" is invalid."
               fail
            }
         }
         else if \x1 & \x2 then {
            if x2 === "][" then {
               Message := "\n   Strings cannot have double subscripts."
               fail
            }
            # string slice
            else {
               i1 := variable(x1, CMonitored, level) | integer(x1)
               i2 := variable(x2, CMonitored, level) | integer(x2)
               if abs(i1) > *Var then {
                  Message := "\n   The string subscript \""||x1||
                              "\" is out of range."
                  fail
               }
               if abs(i2) > *Var then {
                  Message := "\n   The string subscript \""||x2||
                              "\" is out of range."
                  fail
               }
               Var := Var[i1:i2]
               return Var
            }
         }
         else {
            Message := "\n   Invalid expression."
            fail
         }
      }
      "list":{
         x1 := get(index)
         x2 := get(index)
         # base case
         if \x1 & /x2 then {
            v := variable(x1, CMonitored, level) | integer(x1)
            if abs(v) <= *Var then {
               Var := Var[v]
               return Var #getVarReference(Var, index, level)
            }
            else {
               Message := "\n   The list subscript \""||x1||
                           "\" is out of range."
               fail
            }
         }
         # multiple subscripts
         else if \x1 & \x2 then {
            if x2 == "][" then {
               v := variable(x1, CMonitored, level) | integer(x1)
               if abs(v) <= *Var then {
                  Var := Var[v]
                  return getVarReference(Var, index, level)
               }
               else {
                  Message := "\n   The list subscript \""||x1||
                              "\" is out of range."
                  fail
               }
            }
            else if x1 == "][" then {
               v := variable(x2, CMonitored, level) | integer(x2)
               if abs(v) <= *Var then {
                  Var := Var[v]
                  return getVarReference(Var, index, level)
               }
               else {
                  Message := "\n   The list subscript \""||x2||
                              "\" is out of range."
                  fail
               }
            }
            else {
               i1 := variable(x1, CMonitored, level) | integer(x1)
               i2 := variable(x2, CMonitored, level) | integer(x2)
               if abs(i1) <= *Var & abs(i2) <= *Var then {
                  Var := Var[i1:i2]
                  return getVarReference(Var, index, level)
               }
               else {
                  Message := "\n   The list subscript slice \""||i1||":"||i2||
                              "\" is out of range."
                  fail
               }
            }
         }
         else {
            Message := "\n   Invalid expression."
            fail
         }
      }
      "table":{
         x := get(index)
         if v := variable(x, CMonitored, level, 1) |
                           integer(x) | string(x[2:-2]) then {
            Var := Var[v]
            return getVarReference(Var, index, level)
         }
         fail # shouldn't get here, tables have default init values
      }
      # "record" & "object" do not have the word "record" in their type
      default: {
         if (x := get(index)) == "." then x := get(index) # get name of field

         if \x then {
            every fld := fieldnames(Var) do {
               if x === fld then {
                  Var := Var[string(x)]
                  return getVarReference(Var, index, level)
               }
            }
            Message := "\n   Invalid field name \""||x||"\"."
            fail
         }
         else {
            return getVarReference(Var, index, level)
         }
      }
   }
end

#
# setVarReference is used by assignVar() and cmdPrint()
# to assign a value to any variable or element of a structure
#
method setVarReference(lvar, index, level, value)
   local v, j, i1, i2, x, x1, x2, fld, Var
   local CMonitored := DState.coState.target.val
   /level := DState.coState.target.curr_frame

   if *index = 0 then {
      if variable(lvar, CMonitored, level) then {
         Var := variable(lvar, CMonitored, level, 1) := value
         return Var
      }
      else {
         Message := "\n   Something went wrong."
         fail
      }
   }

   Var := variable(lvar, CMonitored, level, 1)
   if \Var then {
      while *index > 0 do {
         x := get(index)
         case type(Var) of{
           "integer"|"real"|"null"|"cset"|"set"|"file"|"window"|
           "procedure"|"co-expression"|"external":{
              if *index = 0 then {
                 #variable(lvar, Monitored, level, 1) := value
                 Var := value
                 return Var
                 }
              else fail
              }
           "string":{
              x1 := x
              x2 := get(index)
              if \x1 & /x2 then {
                 if v := variable(x1, CMonitored, level) | integer(x1) then {
                    var_ref := variable(lvar, CMonitored, level, 1) :=
                          Var[1:v] || string(value) || Var[v+1:0]
                    return var_ref
                    }
                 else {
                    Message := "\n   The string subscript \""||x1||
                               "\" is invalid."
                    fail
                    }
                 }
              else if \x1 & \x2 then {
                 i1 := variable(x1, CMonitored, level) | integer(x1)
                 i2 := variable(x2, CMonitored, level) | integer(x2)
                 var_ref := variable(lvar, CMonitored, level, 1) :=
                          Var[1:i1]|| string(value) ||Var[i2:0]
                 return var_ref
                 }
              else {
                 Message := "\n   \""|| lvar ||
                      "\" is not a valid expression."
                 fail
                 }
              }
           "list":{
              if x ~== "][" then {
                 if v := variable(x, CMonitored, level, 1) | integer(x) then {
                    if abs(v) <= *Var then {
                       if *index = 0 then {
                          var_ref := Var[v] := value
                          return var_ref
                          }
                       else Var := Var[v]
                       }
                    else { # subscript not in range
                       Message := "\n   The list subscript \""||x||
                                  "\" is out of range."
                       fail
                       }
                    }
                 else { # invalid subscript, x, not a variable or integer
                    Message := "\n   Invalid list subscript \""||x||"\"."
                    fail
                    }
                 }
              }
           "table":{
              if v := \variable(x, CMonitored, level, 1) |
                                         integer(x) | string(x[2:-2]) then {
                 if member(Var, v) then {
                    if *index = 0 then {
                       var_ref := Var[v] := value
                       return var_ref
                       }
                    else Var := Var[v]
                    }
                 else { # not a valid key
                    Message := "\n   \""||x||"\" is not an existing key to table."
                    fail
                    }
                 }
              else { # not a valid subscript
                 Message := "\n   Invalid subscript to table \""||x||"\"."
                 fail
                 }
              }
           # "record" & "object" do not have the word "record" in their type
           default:{
              every fld := fieldnames(Var) do {
                 if x === fld then {
                    if *index = 0 then {
                       var_ref := Var[string(x)]:= value
                       return var_ref
                       }
                    else{
                       Var := Var[string(x)]
                       break
                       }
                    }
                 }#end every
              }#end default
           }#end case
         }#end while
      }# end if \Var
   else {
      Message := "\n   The variable \""|| lvar ||
                   "\" is not within the current frame."
      fail
      }
end

#
# finds the var reference and prints its value acording
# to the action such as */! or the value itself
#
method printVar(Expr, action, level)
   local Var, var, ref, index, x, expr:="", outputTable := table("type", "print"), result := ""
   local CMonitored := DState.coState.target.val
   /level := DState.coState.target.curr_frame

   index := parsePrintExpression(Expr)

   every x := !Expr do expr ||:= x

   if *index = 0 then {
      Message :="\n   \""||expr||"\" is an unknown expression."
      outputTable["success"] := "__false__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
      return
   }

   var := get(index)
   if Var := variable(var, CMonitored, level) then {
      if (ref := getVarReference(Var, index, level)) & *index = 0 then {
         case action of {
            "*" :{ Message := "\n   *"||expr||" = "||*ref
                  outputTable["result"] := *ref
            }
            "!" :{ Message := "\n   !"||expr||" = "
                  result ||:= "{ "
                  every x := !ref do
                     result ||:= image(x)||", "
                  result := result[1:-2] || " }"
                  Message ||:= result
                  outputTable["result"] := result
            }
            #"?" :{ Message := "OOPS: not implemented yet!!!"  }
            default: {
               Message := "\n   "||expr||" = "
               #DState.Write("---type of ",expr," is : ", type(ref))
               if (type(ref) == ("list" | "table" | "set" | "foreign-local" )|
                  match("record"|"object",image(ref))) & *ref >= 1 then {
                  Message ||:= ximage(ref)
               }
               else {
                  Message ||:= image(ref)
               }
               outputTable["result"] := ref
            }
         }
      }
      outputTable["name"] := expr
      outputTable["success"] := "__true__"
   }
   else {
      Message := "\n   The variable \""|| var ||
                   "\" is not within the current frame."
      outputTable["success"] := "__false__"
   }
   outputTable["consoleMsg"] := Message
   DState.Write(outputTable)
end

#
# sets a variable value according to the user input
#
method assignVar(Lexpr, Rexpr, level)
   local lhs, lvar , rvalue, x, lexpr:="", rexpr:="", outputTable := table("type", "assignVar")

   every x := !Lexpr do lexpr ||:= x
   every x := !Rexpr do rexpr ||:= x

   lhs := parsePrintExpression(Lexpr)
   if *lhs = 0 then {
      Message :="\n   The expression \""||lexpr||"\" is unknown."
      outputTable["consoleMsg"] := Message
      outputTable["success"] := "__false__"
      DState.Write(outputTable)
      return
      }

   if rvalue := getVarValue(Rexpr, level) then {
      #write("---lhs------->>",ximage(lhs),"--",image(rvalue))
      lvar := get(lhs)
      if (var_ref := setVarReference(lvar, lhs, level, rvalue)) then {
         Message := "\n   "||lvar||" = "||image(var_ref)
         }
      }
   outputTable["consoleMsg"] := Message
   outputTable["result"] := var_ref
   outputTable["name"] := lvar
   outputTable["success"] := "__true__"
   DState.Write(outputTable)
end

method cmdEval(cmd)
   local resTable, outputTable := table("type", "eval")

   if DState.State ~= PAUSE then {
      DState.State := ERROR
      Message := "\n   The program is not being run._
                  \n   Try \"run\", or Type \"help\" for assistance."
      outputTable["success"] := "__false__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
      return
   }

   cmdStr := ""
   every cmdStr ||:= !cmd||" "
   cmdStr := cmdStr[1:-1]

   resTable := evaluate(cmdStr)

   if /resTable | \resTable["error"] then {
      outputTable["success"] := "__false__"
      if \resTable then {
         outputTable["consoleMsg"] := "\n   An error occurred\n   "||resTable["result"]
         outputTable["result"] := resTable["result"]
      }
      else {
         outputTable["consoleMsg"] := "\n   Invalid expression (probably)"
         outputTable["result"] := "Invalid expression"
      }
         
      DState.Write(outputTable)
      fail
   }
   else {
      outputTable["consoleMsg"] := "\n   "||ximage(resTable["result"])
      outputTable["result"] := resTable["result"]
      outputTable["success"] := "__true__"
      DState.Write(outputTable)
   }
end

method evaluate(expr)
   local sfile, sc, level, CMonitored, vars := table(), idents, links := set(), imports := set()

   CMonitored := DState.coState.target.val
   level := DState.coState.target.curr_frame

   pkgs := DState.srcFile.getPackages()
   idents := getIdentifiers(expr)
   every vars[varName := !idents["vars"]] := variable(varName, CMonitored, level, 1)

   every prc := !idents["procs"] do {
      src := &null
      src := DState.srcFile.findProcMethod(prc)[1]
      if \src then
         if src ~== DState.srcFile.procMainFile then
            insert(links, "\""||DState.srcFile.findDirectory(src)||"/"||src[1:-4]||"\"") #& write(prc||" in "||src)
         else
            vars[prc] := variable(prc, CMonitored, level, 1)
      else
         every pkg := !pkgs do DState.srcFile.findPkgProc(pkg, prc)[1] & insert(imports, pkg)
   }

   sfileName := tempname("ue_")
   sfile := open(sfileName||".icn", "w")

   every write(sfile, "import "||!imports)
   every write(sfile, "link "||!links)
   write(sfile, "global __vars")
   write(sfile, "procedure main()")
   write(sfile, "   &error := 1")
   every varName := key(vars) do {
      write(sfile, varName||" := __vars[\""||varName||"\"]")
   }
   write(sfile, "   return __construct_eval_result_table(("||expr||") | \"failure\")")
   write(sfile, "end")

   write(sfile, "procedure __construct_eval_result_table(evalResult)")
   write(sfile, "   resultTable := table(\"vars\", table())")
   write(sfile, "   if \\&errornumber then {")
   write(sfile, "      evalResult := \"Run-time error \"||&errornumber||\": \"||&errortext")
   write(sfile, "      resultTable[\"error\"] := \"__true__\"")
   write(sfile, "   }")
   write(sfile, "   resultTable[\"result\"] := evalResult")
   write(sfile, "   every varName := key(__vars) do resultTable[\"vars\"][varName]:= variable(varName, &current, 1, 1)")
   write(sfile, "   return resultTable")
   write(sfile, "end")

   close(sfile)

   # write()
   # system("cat "||sfileName||".icn")
   # write()

   sc :=  system("unicon -s "||sfileName||" -o "||sfileName)

   if sc = 0 then {
      coex := load(sfileName)
      variable("__vars", coex) := vars

      resTable := @ coex

      every varName := key(vars) do {
         variable(varName, CMonitored, level, 1) := resTable["vars"][varName]
      }

      evalResult := [
         "result": resTable["result"]
      ]
      evalResult["error"] := \resTable["error"]
   }

   system("rm -f "||sfileName||".icn "||sfileName)

   return \evalResult

end

#
# Prints out a variable and it's current value. Variables from previous
# procedures that are still in the stack can also be viewed.
#
method cmdPrint(cmd)
   local i, j, expr, action, level, cur_level, left, right, outputTable := table("type", "print")
   local CMonitored

   if DState.State ~= PAUSE then {
      DState.State := ERROR
      Message := "\n   The program is not being run._
                  \n   Try \"run\", or Type \"help\" for assistance."
      outputTable["success"] := "__false__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
      return
   }

   CMonitored := DState.coState.target.val
   cur_level := keyword("level", CMonitored)
   level := DState.coState.target.curr_frame

   # this check is probably unnecessary. Frame() ensures that coState frame
   # is valid
   if level > cur_level then {
      Message   :="\n   Frame #"||level||" is not valid."
      Message ||:="\n   The stack currently has "||cur_level||" frame(s)."
      outputTable["success"] := "__false__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
      return
   }

   if \cmd[1] then {
      if cmd[1][1] == ("*"|"!"|"?") then {
         if *(cmd[1]) = 1 then action := pop(cmd[1])
         else {
            action := cmd[1][1]
            cmd[1] := cmd[1][2:0] 
         }
      }
      every j := 1 to *cmd do {
         if cmd[j] == ("="|":=") then {
            left   := cmd[1:j]
            right  := cmd[j+1:0]
            action := ":="
            break
         }
      }
      if \action & action == ":=" then {
         # this allows '& keyword'
         if left[1][1] == "&" then {
            if *left[1] = 1 then left := "&"||left[2]
            else left := left[1]
            assignKeyword(left, right, level)
         }
         else
            assignVar(left, right, level)
      }
      else{
         expr := cmd
         #print -g [level]
         if expr[1] == ("-g"|"-G"|"-globals") then {
            printGlobals(level)
            return
         }
         #print -l [level]
         else if expr[1] == ("-l"|"-L"|"-locals") then {
            printLocals(level)
            return
         }
         #print -p [level]
         else if expr[1] == ("-p"|"-P"|"-params") then {
            printParams(level)
            return
         }
         #print -s [level]
         else if expr[1] == ("-s"|"-S"|"-static") then {
            printStatics(level)
            return
         }
         #print &pos or #print *&subject
         else if expr[1][1] == "&" then {
            # this allows '& keyword'
            if *expr[1] = 1 then expr := "&"||expr[2]
            else expr := expr[1]
            printKeyword(expr, action, level)
         }
         #print x or #print *s
         else
            printVar(expr, action, level)
      }
   }
   else {
      Message :="\n   The command \""||DState.cmdHistory[1]||"\" is incomplete."
      Message ||:="\n   Try \"help\" or \"help print\" for assistance."
      outputTable["success"] := "__false__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
   }
end

#
# It assignes to those keywords that are considered variables
#
method assignKeyword(lexpr, rexpr, level)
   local data, outputTable := table("type", "assignVar")

   #print &pos:=10
   if isValidKeyword(lexpr) then {
      if data := getVarValue(rexpr,level) then {
         var_ref := variable(lexpr, Monitored, 0, 1) := data
         Message := "\n   "||lexpr||" = "||image(var_ref)
         outputTable["result"] := var_ref
         outputTable["name"] := lexpr
         outputTable["success"] := "__true__"
         outputTable["consoleMsg"] := Message
         DState.Write(outputTable)
         return
         }
      else{
         outputTable["success"] := "__false__"
         outputTable["consoleMsg"] := Message
         DState.Write(outputTable)
         fail
      }
   }
   else {
      Message := "\n   "||lexpr ||" is not a valid keyword."
      outputTable["success"] := "__false__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
      fail
   }
end

#
# prints keyword value(s)
#
method printKeyword(expr, action, level)
   local data, outputTable := table("type", "print")

   #print &pos or #print *&subject
   if isValidKeyword(expr) then {
      if data := isGlobalKeyword(expr) then {
         Message :="\n   "|| expr ||" = "|| data
      }
      else if data := isGenKeyword(expr, action) then {
         Message :="\n   "|| expr ||" = "|| data
      }
      else if data := keyword(expr, Monitored) then {
         if \action == "*" then {
            data := *data
         }
         Message :="\n   "|| expr ||" = "|| image(data)
      }
      else{
         Message :="\n   "|| expr || " is not a valid udb operation yet."
         outputTable["success"] := "__false__"
         outputTable["consoleMsg"] := Message
         DState.Write(outputTable)
         fail
      }
      outputTable["result"] := data
      outputTable["name"] := expr
      outputTable["success"] := "__true__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
   }
   else {
      Message :="\n   "|| expr || " : is not a valid keyword."
      outputTable["success"] := "__false__"
      outputTable["consoleMsg"] := Message
      DState.Write(outputTable)
      fail
      }
end

#
# check whether keyword is valid or not
#
method isValidKeyword(expr)

   if member(Keywords, expr) then
      return
   fail
end

#
# check whether a keyword is not suppoted by the keyword() function
# and return its value or list of values
#
method isGlobalKeyword(expr)
   local x, data

   if member(GlobalKeywords, expr) then {
      case expr of{
         "&clock":   { data := &clock       }
         "&date":    { data := &date        }
         "&now":     { data := &now         }
         "&dateline":{ data := &dateline    }
         "&digits":  { data := &digits      }
         "&e":       { data := &e           }
         "&fail":    { data := "&fail"      }
         "&host":    { data := &host        }
         "&lcase":   { data := &lcase       }
         "&letters": { data := &letters     }
         "&null":    { data := image(&null) }
         "&phi":     { data := &phi         }
         "&pi":      { data := &pi          }
         "&dump":    { data := &dump        }
         "&ucase":   { data := &ucase       }
         "&version": { data := &version     }
         "&lpress":  { data := &lpress      }
         "&mpress":  { data := &mpress      }
         "&rpress":  { data := &rpress      }
         "&lrelease":{ data := &lrelease    }
         "&mrelease":{ data := &mrelease    }
         "&rrelease":{ data := &rrelease    }
         "&ldrag":   { data := &ldrag       }
         "&mdrag":   { data := &mdrag       }
         "&rdrag":   { data := &rdrag       }
         "&resize":  { data := &resize      }
         "&ascii":   { data := &ascii       }
         "&cset":    { data := &cset        }
         default:   { fail }
         }
         return image(data)
      }
   fail
end

#
# when a keyword is a generator, it should generate all of the
# possible values, sometimes regardless of the action
#
method isGenKeyword(expr, action)
   local x, L, data

   if member(GenKeywords, expr) then {
      case expr of{
         "&features":{
             if \action == "!" then {
                data:=""
                every x := &features do data ||:="\n      "|| image(x)
                }
             else if /action then
                data := image(&features)
             else
                fail
             return data
             }
         "&regions":{
             L := []
             every x := keyword("&regions", Monitored) do {
                put(L,x)
                }
             data   := "\n   Total memory    = "||(L[1]+L[2]+L[3])||" Byte(s)"
             #data||:= "\n   --Static Region = "||L[1]||" Byte(s)"
             data ||:= "\n   --String Region = "||L[2]||" Byte(s)"
             data ||:= "\n   --Block  Region = "||L[3]||" Byte(s)"
             return data
             }
         "&storage":{
             L := []
             every x := keyword("&storage", Monitored) do {
                put(L,x)
                }
             data   := "\n   Total memory currently in use = "||
                       (L[1]+L[2]+L[3])||" Byte(s)"
             #data||:= "\n   --Static Region     = "||L[1]||" Byte(s)"
             data ||:= "\n   --String Region     = "||L[2]||" Byte(s)"
             data ||:= "\n   --Block  Region     = "||L[3]||" Byte(s)"
             return data
             }
         "&allocated":{
             L := []
             every x := keyword("&allocated", Monitored) do {
                put(L,x)
                }
             data   := "\n   Total Allocations= "||L[1]||" Byte(s)"
             #data||:= "\n   --Static Region  = "||L[2]||" Byte(s)"
             data ||:= "\n   --String Region  = "||L[3]||" Byte(s)"
             data ||:= "\n   --Block  Region  = "||L[4]||" Byte(s)"
             return data
             }
         "&collections":{
             L := []
             every x := keyword("&collections", Monitored) do {
                put(L,x)
                }
             data   := "\n   Total Garbage Collections  = "||L[1]||" Byte(s)"
             #data||:= "\n   --Static Region = "||L[2]||" times(s)"
             data ||:= "\n   --String Region = "||L[3]||" times(s)"
             data ||:= "\n   --Block  Region = "||L[4]||" times(s)"
             return data
             }
         default:     { fail }
         }
      }
   fail
end

#
# parse the expression into a list of tokens, mainVar is tokens[1]
# ie L[2], L[3][4], L[1].x, S[5:-5], L[3][3][3], L[3][3][2:4]
# Input is already semi-tokenized, i.e. a list, but this method
# needs to break it down further.
#
method parsePrintExpression(expr)
   local i := 1, j, x, tokens := []

    while i <= *expr do {
       x := expr[i]

       # first, split multi-token tokens
       x ? {
          if (s := tab(many(&letters++&digits++'_'))) & (*s < *x) then {
             insert(expr,i+1,x[*s+1:0])
             x := expr[i] := s
             }
          else if (c := tab(any('[]'))) & (s := tab(0)) & *s>0 then {
             insert(expr,i+1,s)
             x := expr[i] := c
             }
          else if (c := tab(any(':'))) & (s := tab(0)) & *s>0 &
             (s[1]~=="=") then {
             insert(expr,i+1,s)
             x := expr[i] := c
             }
          }
       i +:= 1
       }

    i := 1
    while i <= *expr do {
       x := expr[i]
       if not (x == ("["|"]"|","|":")) then {
          if not numeric(x) & j:=find(".", x) then {
             if *(s := x[1:j]) > 0 then
                put(tokens, s)
             put(tokens, ".")
             put(tokens, x[j+1:0])
             }
          else {
             if (x === "pos") & (tokens[-1]==="&") &
                 (expr[i-2] == ("[" | ":")) then {
                tokens[-1] ||:= x
                }
             else
                put(tokens, x)
             }
          }
       else if x == "]" & expr[i+1] == "[" then {
          # handle p L[3] [2], "][" is used to indicate new sublist. Otherwise
          # a second index is the back of a slice reference.
          put(tokens,"][")
          }
       else if x == "]" & expr[i+1][1] == "." then {
          # handle p L[3].xxx
          put(tokens,".")
          expr[i+1] := expr[i+1][2:0]
          }
       i +:= 1
       }

   #write("------------ Tokens")
   #every x:=!tokens do
   #   write("-----x=",x)
   return tokens
end

#
# used by cmdList to print a bunch of src lines
#
method printSrcLines(cur_file, cur_line, offset)
   local i, line, max_line

   /offset := 10
   max_line := DState.srcFile.getFileTotalLines(cur_file)

   if cur_line <= 5 then
      line := 1
   else if cur_line <= max_line then
      line := cur_line - 5
   else if cur_line > max_line then {
      Message := "\n   Line number "||cur_line||" out of range; "||
                  cur_file||" has "||max_line||" lines."
      DState.Write(Message)
      fail
      }

   Message :=""
   every i:= 1 to offset do {
      if line = cur_line then
         Message ||:="\n-->"||line ||":"||
                     DState.srcFile.getSrcLine(cur_file, line)
      else if line <= max_line then
         Message ||:="\n   "||line ||":"||
                     DState.srcFile.getSrcLine(cur_file, line)
      else
         break
      line +:= 1
      }
   DState.Write(Message)
end

#
# The list command from gdb, as in gdb defaults are 10 lines from
# the current file are printed centered around the curent line
#
method cmdList(cmd)
   static cur_line, cur_file, max_line
   local name, line

   if DState.RunCode ~= LIST then {
      DState.RunCode := LIST
      if DState.State = LOAD then {
         cur_file := DState.srcFile.procMainFile
         cur_line := DState.srcFile.procMainLine
         max_line := DState.srcFile.getFileTotalLines(cur_file)
         }
      else if DState.State = PAUSE then {
         cur_file := keyword("file", MONITORED)
         cur_line := keyword("line", MONITORED)
         max_line := DState.srcFile.getFileTotalLines(cur_file)
         }
      else{
         DState.RunCode := DState.State := ERROR
         Message := "\n   No Program is Loaded nor Running._
                     \n   Type \"help\" for assistance."
         DState.Write(Message)
         return
         }
      }
   else if *cmd = 1 then {
      if (cur_line + 10) < max_line then  cur_line +:= 10
      else if cur_line < max_line   then  cur_line := max_line
      else if cur_line = max_line   then  cur_line := max_line + 1
      }

   if *cmd >= 2 then {
      # list i
      if line := integer(cmd[2]) then {
         if line > 0 then
            cur_line := line
         else if line < 0 then {
            cur_line := max_line + line
            }
         }
      # list +
      else if cmd[2] == "+" then {
         if (cur_line + 10) < max_line then  cur_line +:= 10
         else if cur_line < max_line   then  cur_line := max_line
         else if cur_line = max_line   then  cur_line := max_line + 1
         }
      # list -
      else if cmd[2] == "-" then {
         if (cur_line - 10) >= 1 then  cur_line -:= 10
         else                          cur_line := 1
         }
      else{
         name := cmd[2]
         # list procName
         if line := DState.srcFile.searchFileProcs(cur_file, name) then {
            cur_line := line
            }
         else{
            # list fileName
            if not find(".icn",name) then  name||:=".icn"
            if DState.srcFile.isSrcFile(name) then {
               cur_file := name
               max_line := DState.srcFile.getFileTotalLines(cur_file)
               if *cmd = 2 then
                  cur_line := 1
               else if line := integer(cmd[3]) then {
                  if line > 0 then
                     cur_line := line
                  else if line < 0 then
                     cur_line := max_line
                  }
               }
            else{
               DState.RunCode := DState.State := ERROR
               Message  := "\n   "||name||" is not a source file in: \""||
                           DState.TP[1]||"\"."
               Message||:= "\n   Try \"src\", or Type \"help\" for assistance."
               DState.Write(Message)
               return
               }
            }
         }
      }

   if DState.srcFile.isLoaded(cur_file) then {
      printSrcLines(cur_file, cur_line)
      }
   else{
      Message := "\n   Source file \""||cur_file||"\" is NOT loaded."
      DState.Write(Message)
      }
end

#
# used to print source code info with a simplified more
#
method printSrcInfo(fnames, ftype)
   local i:=0, cur:=0, ans, total, plural := "s"
   names := []
   total := *fnames

   if total = 1 then plural := ""
   every i := 1 to total do put(names,"   #"||i||"  "||fnames[i])
   msg := "\n   Total of "||total||" "||ftype||plural||":"
   more(names, msg)
end

#
# used to print a summary of all used files
#
method printSrcSummary(detail)
   local found, missing, ftotal, plural
   local packages, classes, records, procs, globals
   local pclasses := [], precords := [], pprocs := [], pglobals := []

   packages := DState.srcFile.getPackages()
   classes := DState.srcFile.getClasses()
   records := DState.srcFile.getRecords()
   procs := DState.srcFile.getProcedures()
   globals := DState.srcFile.getGlobals()

   every pkg := !packages do {
      pclasses |||:= DState.srcFile.getClasses(pkg)
      precords |||:= DState.srcFile.getRecords(pkg)
      pprocs |||:= DState.srcFile.getProcedures(pkg)
      pglobals |||:= DState.srcFile.getGlobals(pkg)
      }

   found   := *DState.srcFile.foundFiles
   missing := *DState.srcFile.missingFiles
   ftotal  := found + missing
   if ftotal ~= 1 then plural := "s are " else plural := " is "
   Message   :="\n   A total of ["||ftotal||"] source file"||plural||"used"
   if found ~= 1 then plural := "s are " else plural := " is "
   Message ||:="\n   "||left(found,5)  ||"source file"||plural||"found"
   if missing ~= 1 then plural := "s are " else plural := " is "
   Message ||:="\n   "||left(missing,5)||"source file"||plural||"missing"
   if \detail then {
      Message ||:="\n   ---------------------------------------"
      if *classes = 1 then plural := "" else plural := "es"
      Message ||:="\n   "||left(*classes,5) ||"class"||plural
      if *records = 1 then plural := "" else plural := "s"
      Message ||:="\n   "||left(*records,5) ||"record"||plural
      if *procs = 1 then plural := "" else plural := "s"
      Message ||:="\n   "||left(*procs,5)||"procedure"||plural
      if *globals = 1 then plural := "" else plural := "s"
      Message ||:="\n   "||left(*globals,5)||"global variable"||plural
      Message ||:="\n   ---------------------------------------"

       if *packages = 1 then plural := "" else plural := "s"
      Message ||:="\n   "||left(*packages,5)||"package"||plural||", with "
      if *pclasses = 1 then plural := "" else plural := "es"
      Message ||:="\n   "||left(*pclasses,5)||"class"||plural
      if *precords = 1 then plural := "" else plural := "s"
      Message ||:="\n   "||left(*precords,5)||"record"||plural
      if *pprocs = 1 then plural := "" else plural := "s"
      Message ||:="\n   "||left(*pprocs,5)||"procedure"||plural
      if *pglobals = 1 then plural := "" else plural := "s"
      Message ||:="\n   "||left(*pglobals,5)||"global variable"||plural
      Message ||:="\n   ---------------------------------------"
      }
   Message ||:="\n   Type \"help src\" for assistance.\n"
   DState.Writes(Message)
end

#
# prints the found/missing source files
#
method cmdSource(cmd)
   static pkg
   local op, names, prefix := "", set_pkg

   if *cmd <= 2 then {

      if (i := find("=",cmd[2])) then {
         set_pkg := cmd[2][i+1:0]
         cmd[2] := cmd[2][1:i]
         }

      op := cmd[2] | ""
      if op[1] ~=="-" then op :="-"||op
      case op of{
         # all loaded source files
         "-f"|"-found":{
            if names := DState.srcFile.getFoundFiles() then
               printSrcInfo(names,"found file")
            else
               DState.Write("\n   No found source files.")
            }
         # all unable to load source files
         "-m"|"-missing":{
            if names := DState.srcFile.getMissingFiles() then
               printSrcInfo(names,"missing file")
            else
               DState.Write("\n   No missing source files.")
            }
         # all files (user+library) used in the binary
         "-file":{
            if names := DState.srcFile.getSourceFiles() then
               printSrcInfo(names,"used file")
            else
               DState.Write("\n   No source files.")
            }
         # all user defined files used in the binary
         "-u"|"user"|"usr":{
            if names := DState.srcFile.getUserFiles() then
               printSrcInfo(names,"user defined file")
            else
               DState.Write("\n   No user defined source files.")
            }
         # all library files used in the binary
         "-l"|"-lib"|"-library":{
            if names := DState.srcFile.getLibFiles() then
               printSrcInfo(names,"used library file")
            else
               DState.Write("\n   No library files.")
            }
         # all packages used in the binary
         "-pkg"|"-pk"|"-package":{
            if \set_pkg then {
               if DState.srcFile.isPackage(set_pkg) then pkg := set_pkg
               else if set_pkg == "" then pkg := &null
               else {
                  write("\n   Package \"",set_pkg,"\" was not found.",
                        "\n   Please try again.")
                  fail
                  }
               #write("\n   Current package: ",(\pkg | "none"))
               }
            else if names := DState.srcFile.getPackages() then {
               printSrcInfo(names,"package")
               }
            else
               DState.Write("\n   No packages used.")
            }
         # all classes used in the binary
         "-c"|"-cls"|"-class":{
            if names := DState.srcFile.getClasses(pkg) then
               printSrcInfo(names,"class")
            else
               DState.Write("\n   No classes used.")
            }
         # all procedures used in the binary
         "-p"|"-proc"|"-procedure":{
            if names := DState.srcFile.getProcedures(pkg) then
               printSrcInfo(names,"procedure")
            else
               DState.Write("\n   No procedures used.")
            }
         # all global variable names used in the binary
         "-g"|"-glb"|"-global":{
            if names := DState.srcFile.getGlobals(pkg) then
               printSrcInfo(names,"global variable")
            else
               DState.Write("\n   No global variables used.")
            }
         # all record names used in the binary
         "-r"|"-rec"|"-record":{
            if names := DState.srcFile.getRecords(pkg) then
               printSrcInfo(names,"record")
            else
               DState.Write("\n   No global records used.")
            }
         # all built-in functions used in the binary
         # is this really necessary?
         "-fun"|"-func"|"-function":{
            if names := DState.srcFile.getFunctions() then
               printSrcInfo(names,"used built-in function")
            else
               DState.Write("\n   No functions used.")
            }
         # a detailed summary with some statistics about the binary
         # is this really necessary?
         "-a"|"-all":{
            printSrcSummary(1)
            }
         # a short summary about the binary
         default:{
            # src
            if *cmd = 1 then {
               write("\n   Current package: ",(\pkg | "none"))
               printSrcSummary(1)
               }
            # src file
            else if *cmd = 2 then {
               if not find(".icn", cmd[2]) then cmd[2] ||:= ".icn"
               if code := DState.srcFile.getSrcCode(cmd[2]) then {
                  more(code)
                  }
               else {
                  msg := "\n   Could not find \"" || cmd[2] || "\"." ||
                         "\n   Please try again."
                  DState.Write(msg)
                  }
               }
            }
         }
      }

   # commands with optional arguments - prints specifics about specified
   # class or package
   else if *cmd = 3 then {
      op := cmd[2] | ""
      arg := cmd[3] | ""
      if op[1] ~=="-" then op :="-"||op
      case op of {
         "-c"|"-cls"|"-class": {
            if names := DState.srcFile.getClasses(pkg,cmd[3]) then {
               output := []
               if \pkg then prefix := pkg||"__"
               if *names = 1 then plural := "" else plural := "s"

               put(output,"\n   Total of "||*names||" field"||plural||
                          " of class "||prefix||cmd[3]||":")
               every i := 1 to *names do put(output,"   #"||i||"  "||names[i])
               more(output)
               }
            else
               DState.Write("\n   No class fields found.")
            }
         "-pkg"|"-pk"|"-package":{
            if names := DState.srcFile.getPackages(cmd[3]) then {
               output := []
               if \pkg then prefix := pkg||"__"
               if *names = 1 then plural := "" else plural := "s"

               put(output,"\n   Total of "||*names||" global name"||plural||
                          " in package "||cmd[3]||":")
               every i := 1 to *names do put(output,"   #"||i||"  "||names[i])
               more(output)
               }
            else
               DState.Write("\n   No global names found in package.")
            }
         default: {
            msg := "\n   Undefined command:"
            while msg ||:= " " || pop(cmd)
            msg ||:= "\n   Type \"help src\" for assistance."
            DState.Write(msg)
            }
         }
      }
   # invalid syntax
   else {
      msg := "\n   Undefined command:"
      while msg ||:= " " || pop(cmd)
      msg ||:= "\n   Type \"help src\" for assistance."
      DState.Write(msg)
      fail
      }

end

#
# Initialization
#
initially()

   Keywords :=
      set("&allocated","&clock","&collections","&column","&current",
          "&date","&now","&dateline","&digits","&e","&error",
          "&errornumber","&errortext","&errorvalue","&errout","&fail",
          "&eventcode","&eventsource","&eventvalue","&features",
          "&file","&host","&input","&lcase","&letters","&level",
          "&line","&main","&null","&output","&phi","&pi","&pos",
          "&progname","&random","&regions","&source","&storage",
          "&subject","&time","&trace","&dump","&ucase","&version",
          "&errno","&window","&col","&row","&x","&y","&interval",
          "&control","&shift","&meta","&lpress","&mpress","&rpress",
          "&lrelease","&mrelease","&rrelease","&ldrag","&mdrag",
          "&rdrag","&resize","&ascii","&cset"
          )
   GlobalKeywords :=
      set("&clock","&date","&now","&dateline","&digits","&e","&fail",
          "&host","&lcase","&letters","&null","&phi","&pi",
          "&dump","&ucase","&version","&lpress","&mpress","&rpress",
          "&lrelease","&mrelease","&rrelease","&ldrag","&mdrag","&rdrag",
          "&resize","&ascii","&cset"
          )
   GenKeywords :=
      set("&features", "&allocated", "&collections", "&storage","&regions")
   Message := ""
end

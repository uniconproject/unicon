#  automatadfa program converts the NFA states, edges, rules
#  and accepted states generated by the main program
#  to a DFA. The algorithm used is from "Compilers, Principles,
#  Techniques and "Tools", (Aho, Sethi, Ullman). This book
#  is also called "The Red Dragon Book")
#
#  For a detailed explanation with examples of how the DFA
#  set of states is constructed, go to the bottom of
#  this program.
#
# This program is called from the automaton.icn  program.
# if \debugdfa (default) states2dfatable procedure creates myautomata.
# if /debugdfa then myautomata is created from the nfa logic
# The createicon procedure in(automaton.icn) is called by flexgram.icn
# and uses the myautomata record that contains the nfa states, edges,
# accepted states and rules generated by the uflex program and the name
# of the program which is the name of the .l file.
#
#
# TODO:
# 1) get rid of @ for epsilon state in NFA could conflict with .l file
# 2) Change dfastatecell values to dfa numbers 1, 2, 3... instead of
# list of nfa states
# 3) Make sure rule number in create_dfa_accepting is lowest one.
#

$include "dfadebug.icn"   # uncomment debug procedures

# print nfa from linked list of states -automaton arg
#_________________________________________________________________

procedure printautomatafdfa(myautomata)
   local state, states, states2, edges, edge, num_states
   local state_table1 := []
   local nfalst := []
   local symbols1 := []

   states := myautomata.states
   write(" NFA automata  from states list ")

   while \states do {
      state := states.current
      write("State :",image(state.label)," Rule #",image(state.rulenum),"dot ",image(state.dot)," semction ",image(semaction))
      if nodemember(state.label, myautomata.accepting) then {
        s1 := "ACCEPTED"
      }
      else s1 := "NOT accepted"
      write("s1",s1)
      printf("State %d Rule %d %s\n",state.label, state.rulenum,
           (if nodemember(state.label, myautomata.accepting) then "acc" else ""))
      edges := state.edges
      every edge := !\edges do {
         if edge.symbol~=="\n" then {
            writes(" edge sym "||image(edge.symbol))

         }
         else writes("\\n")
         put(symbols1,edge.symbol)
         writes(" --> ")
              #writes("   ", if edge.symbol~=="\n"then edge.symbol else "\\n",
         #      " -> ")
         states2 := edge.destinations
              while \states2 do {
                 writes("new state2 ", states2.current.label, " ")
            if \states2.current.rulenum then {
               writes("rule ",states2.current.rulenum)

            }
            if \states2.current.semaction then {
               writes("semaction ",states2.current.semaction)

            }
            states2 := states2._next
              }
              write("...")
           }
      p := state.epsilon
      while \p do {
         write(image(state.label),"-> epsilon --> state  ",p.current.label," rule #:", p.current.rulenum)
         p := p._next
        }
      p := state.semaction
      if \p then {
         write("Semaction: ",image(p) )
      }
      p := state.dot
      #write("dot:",image(state.dot))
      if \p then {
         write("dot: ",image(p) )
         while \p do {
            write(image(state.label),"--> dot --> state  ",p.current.label," rule #:", p.current.rulenum," dot  #:",image(p.current.dot))
            p := p._next
         }
      }
      write("-----------")
      states := states._next
   }

end

#__________________________________________________________
# Build these tables and lists from nfa myautomata:
# nfa_acceptlst  icon list of myautomata.accepted linked list:label,rulenum,nsemaction
# statecol:list of nfa state labels -> put(statecol,state.label) includes state zero
# preserves order
# *statecol used to get number of nfa states for dfa construction
# symbols1 -> put(symbols1,[edge.symbol,startstate.label,destination.label])
# nfastatescell: table with key state:input symbol, value is list of next nfa states
# insert(nfastatescell,state.label||":"||edge.symbol,[states2.current.label])
# NFA transition table will be built from nfastatescell and statecol.
# Call nfa2dfa to build:
# dfastateset: created in nfa2dfa, table key is dfa state (position e.g., 1,2,3,4).
# The value is the list of nfa states making up the dfa state. This is the first column of the dfa table
# dfastatescell: created in  nfa2dfa, table key is dfa state (position) || ":" || input symbol position.
# each value contains set of nfa states reachable from dfa state on symbol in the position.
# For the DFA the list of nfa states in each cell corresponds to one dfa state in the dfastateset
# Call dfa2auto to:
# Convert DFA transition table back to state linked list with NFA accepted states converted
# to new DFA state labels

procedure states2dfatable(myautomata)
   local state, states, states2, edges, edge, num_states
   local lst := []
   local symbols1 := []  # all symbols list of list[edge.symbol,state.label,states2.current.label]
   local nfastatescell := table() # table key" state_label||":"||input symbol value: list of destinations
   local statecol := []  # list of nfa states in order of state.label including zero
   local dfastateset := table() #   key is dfa state postion 1,2,3 ...
   local dfastatescell := table() #  key is dfa state || ":" || input symbol position
   local input_row := []   # list derived from symbols1 for DFA generation contains unique symbols in nfa order


#   write(" NFA AUTO ")
#   printautomatafdfa(myautomata)

   nfa_automata := myautomata



   states := myautomata.states

#   write("BUILDING data structures from NFA for DFA ")
   # Create nfastatescell table with key = state.label : edge.symbol
   # value of nfastatescell[state:input] = list destination states for state:input
   while \states do {
      state := states.current
      put(statecol,state.label)  # states including zero
      edges := state.edges
      every edge := !\edges do {
         states2 := edge.destinations
              while \states2 do {
            put(symbols1,edge.symbol)
            lst := []
            #create list of destinations with more than one destination from ste.label
            if member(nfastatescell,state.label||":"||edge.symbol) then {  # concatenate destination of edge
               lst := nfastatescell[state.label||":"||edge.symbol]
               put(lst,states2.current.label)  # keep adding destinations to list
            }
            else {
               insert(nfastatescell,state.label||":"||edge.symbol,[states2.current.label])
            }
            states2 := states2._next
              }
      }   # every edge
      p := state.epsilon
      while \p do {
         ##write("epsilon --> state  ",p.current.label,"("||p.current.label||") rule #:", p.current.rulenum)
         # use @#$ for epsilon to not be confused with e
         # since input e is used in key for destination
         if member(nfastatescell,state.label||":"||"@#$") then {
            lst := nfastatescell[state.label||":"||"@#$"]
            put(lst,p.current.label)
         }
         else {
              insert(nfastatescell,state.label||":"||"@#$",[p.current.label])
         }
         p := p._next
      }
      states := states._next
   }  # end while
#   write("___________________________________________________________")

   col := 0

   # create unique inputs and positions for display
   input_row := []
   create_input_row(symbols1,input_row)  # create symtab, a sorted symbols table from symbols1

#   write(" input row "||*input_row)
#   every j := 1 to *input_row do {
#      writes(j||" "||image(input_row[j][1])||" : "||image(input_row[j][2])||" ")
#      #write(j||" "||image(input_row[j][1])||" , ")
#   }
#   write()

   nfaaccept := myautomata.accepting
   nfa_acceptlst := []
   # Create icon list from myautomata.accepting
   while nfaaccept ~=== &null do {
      put(nfa_acceptlst,[nfaaccept.current.label,nfaaccept.current.rulenum,nfaaccept.current.semaction])
           nfaaccept := nfaaccept._next
   }



#   print_debug_nfa_acceptlst(nfa_acceptlst)

   nfa2dfa(nfastatescell,statecol,input_row,dfastateset,dfastatescell,statecol)

   # Convert DFA transition table back to state linked list with NFA accepted states converted
   # to new DFA state labels
   dfa2auto(input_row,dfastateset,dfastatescell,nfa_acceptlst,outfile)

   end
#______________________________________________________________________________
# Create input_row from the nfa symbols1 list. Remove duplicate input symbols and
# preseve the order of the symbols in the nfa by putting the position as the
# the second item in input_row. The same order as the nfa is not necessary.
# input_row[1] = input symbol, input_row[2] = postion
#
procedure create_input_row(symbols1,input_row)
local symtab := table()
local lst := []


  k := 1
  # assign  number k to symbol - this will be the order in the col header top row
  # We can sort them by  order to keep the same order as in nfa , but
  # the duplicates have been removed.
  # Putting them in a table removes duplicate symbols
  every j := 1 to *symbols1 do {
      #if not member(symtab,symbols1[j])  then {
         insert(symtab,symbols1[j],k)
             k := k + 1
      #}
   }

   lst  := sort(symtab,2) # create input_row for dfa - default order sorted by input position in nfa
   every j := 1 to *lst do {
      put(input_row,lst[j])
   }
   # will need to make e unique symbol that is not a valid symbol in .l

end
#
# Convert nfa transition table to DFA transition table.
# table. An NFA transition table is illustrated in fig 3.20
# pg 115 of The Red Dragon Book. Use algorithm in fig 3.25 in
# Red Dragon book pg 118 to compute a DFA transition table
# illustrated on pg 120 fig 3.28.
#
# The new dfa transition table will be represented by the
# dfastatecell table and the dfastateset set
# which will be created in this nfa2dfa procedure.
# The key to dfastatecell is row:col which is
# dfa state position ||input symbol position number.
# The value of dfastatecell is list (set) of nfa states for
# that state. only one destination for each start state & input.
# Start at the first DFA state which is the e-closure
# of the first nfa state.
# Go across the input (symbols) columns in the NFA
# transition table for this newstate in
# procedure get_moves(input_col, newstate).
# get_moves() returns the new DFA state resulting from
# moving down a column for each state on a given input.
# This new state will be inserted into the dfastateset
# table which is the new DFA states in first column of the
# DFA transition table.
# dfastateset: table key is dfa number position  1,2,3.....
# The value is the list of nfa states making up the dfa state.
# dfastatescell: table key is dfa number || ":" || input symbol position.
# each value contains list of nfa states reachable from dfa state on symbol in the position.
# For the DFA the list of nfa states in each cell corresponds to one dfa state in dfastateset.
# dfa state number ||":"||input symbol col number.
# value of dfastatescell is he list of nfa states corresponding to dfa state & imput.
# Stop when we can make no more new transitions from
# the NFA states and num_inputs. (see details at the end
# of this file)
# statecol list of nfa state labels -> put(statecol,state.label)
# nfastatescell contains the cell data for the NFA transition
#____________________________________________________________________________
procedure nfa2dfa(nfastatescell,statecol,input_row,dfastateset,dfastatescell)
   local ec_tble := table()
   local newstate := []
   local nextstate := []
   local more := 0
   local numstates := 0
   numstates := *statecol

  # First Compute epsilon closure for all states in statecol
  # ec_closure is a table with key = state and value = set of epsilon closure states
   epsilon_closure(nfastatescell,statecol,ec_tble)

  #print_debug_eclosure(input_row,nfastatescell,statecol)  # prints NFA table used for e-closure
  #print_debug_ec_tble(ec_tble)

  # insert first DFA state from e-closure e.g. of first NFA state this is dfa state 1
   newstate := ec_tble[0]
   insert(dfastateset,1,newstate)
   more := 0

   while more <= *statecol  do {
      more := more + 1
      if member(dfastateset,more)  then {
         newstate := dfastateset[more]
      }
      # just populated dfastateset with new states
      every col := 1 to *input_row do {
         nextstate := []
         nextstate := get_moves(col,nfastatescell,input_row,newstate,ec_tble)
         # For the dfastatecell, we use the dfa state (position) || ":"|| col
         # We use the position in the input_row - not the input
         insert(dfastatescell,more||":"||col,nextstate) # unique state
         mlst := []
         if *nextstate > 0 then {
           if check_membership(dfastateset,nextstate) = 0 then {
              insert(dfastateset,*dfastateset+1,nextstate)
            }
         }
      }  #every col
   }  # while no more dfastateset

#   write(" DFA number of states "||*dfastateset||" number inputs "||*input_row)

   #print_debugdfa_table(dfastatescell,dfastateset,input_row)  # print dfa table

end
#
# Go across the input (symbols) columns in the NFA
# transition table for this newstate.
# get_moves returns the new DFA state resulting from
# moving down a column for each state on a given input.
# See example at end of this program.
#_________________________________________________________
procedure get_moves(col,nfastatescell,input_row,newstate,ec_tble)
local rowlst := []
local dfastate := []
local k := 0
local lst := []

   # GO down input col i for all state labels in statecol in nfa table
   # newstate is list containing nfa states
   input_symbol := input_row[col][1]

   every i := 1 to *newstate do {
      # GO DOWN each state in list and get cell for input i
      row := newstate[i]
      # Check to see if there is a set of states for newstate[i] on input_symbol
      key2 := row||":"||input_symbol

      if member(nfastatescell,key2) then {
         lst := nfastatescell[key2]
         # we have just computed a move for state = row, col
         #  should give us new state
         every m := 1 to *lst do {
           put(rowlst,lst[m])
         }
      }
   }

   # rowlst contains list states for input col and newstate
   # Add the e-closure states to each state in rowlist
   # This is the new DFA state that is a set of all of these nfa states!!!
   elst := []
   dfastate := []
   every k := 1 to *rowlst do {
      put(dfastate,rowlst[k])  # not necessary because this state is in its own eclosure
      elst := ec_tble[rowlst[k]]
      every m := 1 to *elst do {
        put(dfastate,elst[m])
      }
   }

   dfastate := set(dfastate)  # remove duplicates
   dfastate := sort(dfastate) # order states

   return dfastate  # newstate!!!

end
#____________________________________________________________________________
procedure epsilon_closure(nfastatescell,statecol,ec_tble)
local lst := []
local epos := 0
local ecset := set()
local ec := ""
local startnode := ""
local more := ""
local elst := []

   every j := 1 to *statecol do {
      ecset := set()
      eclst := []
      startnode := statecol[j]
      eps_key := startnode||":@#$"
      # Get list of states in last col of nfastatescell state||":@#$"
      if member(nfastatescell,eps_key)  then {
         elst :=  nfastatescell[eps_key]
         every m := 1 to *elst do {
            put(eclst,elst[m])
         }
         put(eclst,startnode)  # add startnode
         get_eclosure(startnode,eclst,ec_tble,nfastatescell)
      }
      else {  # empty last col - just insert startnode
         insert(ec_tble,startnode,[startnode])
      }
   }

end
#
# nfastatescell table cell contains moves on epsilon for each state
# Use the nfastatescell key node||":@#$" to get all the moves for each state
# in the set
#__________________________________________________
procedure get_eclosure(startnode,eclst,ec_tble,nfastatescell)
local  lst := []
local  node := ""
local  more := 1
local  doneset := set()

   eclst := []
   put(eclst,startnode)
   while more = 1 do  { # get and put on eclst to get all states
      if *eclst = 0 then more := 0
      else {
         node := get(eclst)  # pop item off list
         lst := []
         eps_key := node||":@#$"
         if member(nfastatescell,eps_key)  then {
            elst :=  nfastatescell[eps_key]
            every m := 1 to *elst do {
               if not member(doneset,elst[m]) then {
                  put(eclst,elst[m])
                  insert(doneset,elst[m])
               }
            }
         }
         else { # no e move adding
            if not member(doneset,node) then {
               put(eclst,node)
               insert(doneset,node)
            }
         }
      }
   }
   insert(doneset,startnode)
   doneset := sort(doneset)
   insert(ec_tble,startnode,doneset)
end
#______________________________________________________
procedure list2string(lst)
local str := ""
every k:= 1 to *lst do
   str := str || lst[k]

return str
end
#__________________________________________________________
# helper proc for nfa2dfa to determine if this set is
# already a member of dfastateset. The key to dfastateset
# table is the dfa state number or position (1,2,3...) in the first
# column of the DFA transition table. The value is a list of
# nfa states that make up the new dfa state
# Use string comparison on SORTED
# set to prevent distinguishing between 10 and 103.
#_______________________________________________________
procedure check_membership(dfastateset,nextstate)
local nslst := []
local lst := []
local tlst := []
local s1 := ""
local ns := ""

   nslst := sort(nextstate)
   ns := list2string(nslst)

   # This is a table with key = state pos ||":"||input position
   # and value is a lst of nfa states
   # This is the first column states for dfa
   lst := sort(dfastateset)
   every j := 1 to *lst do {
      s1 := list2string(lst[j][2])
      if ns == s1 then
         return 1
   }

return 0
end

#
# Helper procedure for dfa2auto to find the dfa state number
# contains an nfa state (parameter nfastate) in its list of
# nfa states.
# dfastateset is first column of DFA transition table that the nfa set is a member.
# The key to dfastateset table is the dfa state number  1,2,3...
# The value is a list of nfa states that make up the new dfa state
#______________________________________________________________________________________________
procedure is_memberstate(dfa_accept,dfastateset,nfastate,rule)
local nslst := []
local lst := []
local tlst := []
local s1 := ""
local ns := ""
stlst := []
dfa_state := ""

stlst := sort(dfastateset)
# stlst is the sorted dfastate table with key = number (position)
# stlst[key]  is a list of nfa states that make up the dfa number(position)

   every j := 1 to *stlst do {
      dfa_state := stlst[j][1]
      tlst := stlst[j][2]  # return list of nfa states
      every k := 1 to *tlst do {
        if tlst[k] == nfastate then {
           if not member(dfa_accept,dfa_state)  then
              insert(dfa_accept,dfa_state,rule)

        }
      }

   }
   return 1
# Could use set intersection
#intersect := set1 ** set2
#if *intersect > 0 then
#   return 1
#return 0


end
#_________________________________________________________________________________
# helper function for dfa2auto.
# uses dfastateset and nfa_acceptlst
# to create dfa accepting states in myautomata.accepting (linked list)
# and staterule (icon list) and also a ruletble.
# staterule and ruletble used to build dfa states, edges, rules
#
procedure create_dfa_accepting(dfastateset,nfa_acceptlst,ruletble,staterule,myautomata)
local stateaction := table()
local nfast := 0
local newstate := 0
local l := []
local stlst := []
local dfa_accept := table()

   # need list of DFA states
   stlst := sort(dfastateset)  # sorted list with dfa state number, list of nfa states for dfa state
   nfast := ""

# stlst := sort(dfastateset) # sort by position
#NFA ACCEPT LIST   print_debug_nfa_acceptlst

   dfa := []


   # Build simple ruletble from nfa accept to get action from rule while building dfa with new state
   every k := 1 to *nfa_acceptlst do {
      insert(ruletble,nfa_acceptlst[k][2],nfa_acceptlst[k][3])  # rule number,action
   }
   # print_debug_dfa_state_names(dfastateset)
   #  print_debug_nfa_acceptlst(nfa_acceptlst)
   # build stateaction a list of all the dfa states and each state's rule list sorted in rule num order
   # It is possible to have more than one rule for a DFA state for example, we might have
   # NfaSTATE 75 -> DFA newstate 15 rule 15 and NfaSTATE 88 -> DFA newstate 15 rule 18 1
   # Keep lowest rule -
   # todo add check lowest rule
   every k := 1 to *nfa_acceptlst do {
      nfast := nfa_acceptlst[k][1]  # get nfa state label from nfa accept
      rule := nfa_acceptlst[k][2]
      action := nfa_acceptlst[k][3]

      is_memberstate(dfa_accept,dfastateset,nfast,rule)  # There is a dfa state that is a member
      l := []

   }

   # staterule is the table we use to create new accepting linked list
   # It is the same as stateaction except it contains only the first rule
   l := []
   s := []

  l := sort(dfa_accept)
  every j := 1 to *l do {
     insert(staterule,l[j][1],l[j][2])
  }

   nfastate := ""




   # ACCEPTING
   accepting := []
   accnode := []
   lst := []
   if member(staterule,&null) then
      delete(staterule,&null)
   lst := sort(staterule)
   # Construct linked list for accepting states
   # make num states nodes and store in accnode
   every j := 1 to *lst do {
      accept_state := lst[j][1]
      rule := lst[j][2]
      node := anode(accept_state,rule,[],"","",ruletble[rule])
      put(accnode,node)
   }
   accepting := []
   # create last node
   # keep first node in accepting
   alst1 := anodelist(anode,anodelist)
   alst1.current := accnode[1]
   mynode  := accnode[1]
   put(accepting,alst1)

   every j := 2 to *staterule do {
       newnodelst := anodelist(anode,anodelist)
       newnodelst.current := accnode[j]
       alst1._next := newnodelst
       put(accepting,alst1)
       alst1 := newnodelst
   }

   # add end null node
   node0 := anode(0,0,[],"","","")
   j :=  *staterule + 1
   last  := anodelist(anode,anodelist)
   last.current := node0
   alst1._next := last
   last._next := &null
   put(accepting,last)

   alst := accepting[1]  # first node of accepting node
   myautomata.accepting := alst

end
#__________________________________________________________________
procedure dfa2auto(input_row,dfastateset,dfastatescell,nfa_acceptlst,outfile)
local lst := []
local s := ""
local dfa_st := table()
local states := []
local ruletble := table()
local accepting := []
local alst := []
local fd
local staterule := table()

   # nfa_statelst is myautomata.accepting converted from linked list to icon list
   # each row contains state,label, state.rulenum, state.semantic_action_
   # fill ruletble from nfa_acceptlst for easy lookup of action given rulenum
   # stateaction table to create nodes of accepting states

   # create myautomata for DFA
   myautomata := automata(start, states, accepting)

   # Create staterule and ruletble used to build dfa states, edges, rules
   # Create myautomata.accepting for DFA

   create_dfa_accepting(dfastateset,nfa_acceptlst,ruletble,staterule,myautomata)

#   print_debug_dfa_accepting(myautomata.accepting)
#   print_debug_dfa_state_names(dfastateset)



   #
   # We must compare the set of states in the cells to construct statelist
   # Fill dfa_st with a string made up of states and numeric state pos
   # need list of DFA states (col 1)  and
   stlst := []
   stlst := sort(dfastateset)
   #stlst   produces 2 element list of dfa state and its list of nfastates for first col

   # Create dfa_st which gives the nfa states in string form in first col for comparison
   # to build myautomata.states
   dfa_st := table()
   every j := 1 to *stlst do {  # j is the row, dfa state num or position
      s := list2string(stlst[j][2]) # Get destination set of nfa states - only one per input
      # write the nfa states as a string s to build states below
      insert(dfa_st,s,stlst[j][1])  # stlst[j][1]  is dfa state number in first col
   }

   # dfastatecell contains the list of nfastates that match the lists of nfastates
   # in the dfstateset value for state j.
   # e.g., dfastateset[1] has a value of a list containg 1,3,10,12 or 131012
   # and dfastatecell contains 1,3,10,12 or 131012 which means the
   # destination is state 1 because it === 131012
   # Only one destination set per input (cell)
   # rewrite to make dfastatecell contain dfa numbers.
   # BUILD myautomata.states in icon list statelist for createatomata  from:
   # dfastatecell: Each cell contains a destination set  for key j:k
   # in dfastatescell row (state j)  j is the dfa state & k is col number (input k)
   # Each cell destination contains a list of nfa states in dfastatescell[j:k] that
   # match the dfa state which contains the same list of nfa sets
   # When each list is concatenated to a string, it is the value of stlst[j]
   # The name of each dfa state is j (position in first column) and value
   # list of nfa states that can be converted to string value above

   # input_lst
   statelist := []
   states := []

   # Use string for comaparison between (1) dfa_st (list of dfa states (1,2....) and their
   # list of nfa states converted to a string
   # and (2) dfastatescell[row][col] that contains a list of the nfa states making up dfa state
   # Might want to convert dfastatecell to strings
   every j := 1 to *stlst  do {  # going down first col of dfa states
         #lst := stlst[j][2]
         start_node  := stlst[j][1]  # [j] is row position or dfa state
         edgelst := []
         every k := 1 to *input_row do {  # go accross each input for state k
            key2 :=  j || ":" || k
            # NOT ALL of the cells contain states
            # For the dfastatecell, we use the dfa state (position) || ":" input symbol position
            # We use the position of the symbol in the input_row - not the symbol
            if member(dfastatescell,key2) then {  # cell exists get destination
                 lst := dfastatescell[key2]  # get list of destination states
                 # THIS should be safe no conflict between 2,23 and 22, because sorted
                 s := list2string(lst) # Get destination set of nfa states - only one per input
                 # Check new dfa state
                 if member(dfa_st,s)  then  {  # string of nfa states matches string of nfastates in dfa
                    nextstate := dfa_st[s]   # get dfa state number 1,2,3... from nfa state string
                    dfaedge := edge("",[])
                    dfaedge.symbol := input_row[k][1]  # k is column position
                    newnode := anode(nextstate,0,[],"","dot","")
                    if member(staterule,nextstate) then { # ONLY ACCEPTING staterule is accepting dfa states
                        rule1 := staterule[nextstate]
                        if member(ruletble,rule1) then
                           myaction := ruletble[rule1]
                        else
                           myaction := ""
                        newnode.rulenum := rule1
                        newnode.semaction := myaction
                        newnode.dot := "dot"
                    }
                    dfaedge.destinations := newnode
                    put(edgelst,dfaedge)
                }  # member (dfa_st)
            }  # member(dfastatecell)
         } ## every   input row
         if member(staterule,start_node) then { # ONLY ACCEPTING staterule is accepting dfa states
            rule1 := staterule[start_node]
            if member(ruletble,rule1) then
               myaction := ruletble[rule1]
            else
               myaction := ""
         }
         else {
            rule1 := 0
            myaction := ""
         }
         node := anode(start_node,rule1,edgelst,"","dot",myaction)
         if j = 1 then {
            start := node
            myautomata.start := start
         }

         put(states,node)
         anlist := anodelist([],[])
         anlist.current := node
         put(statelist,anlist)
   }  # every stlst state


#   write("Number of DFA States:"||*dfastateset||" Number of inputs:"||*input_row)
   lst := []

#   print_debugdfa_table(dfastatescell,dfastateset,input_row)  # dfa table OBSOLETE BIG
#   print_debugdfa_instatelist(myautomata,statelist,dfastateset) # print dfa in state list

   myautomata.states := statelist
   createicondfa(myautomata,outfile)
end

#__________________________________________________________
# Procedure to create icn program from DFA
procedure createicondfa(myautomata,outfile)
   local state, states, states2, edges, edge, maxrulenum := 0, i, action
   local proclst, proclst_tble
   proclst := []
   proclst_tble := []

   if not (outfile := open(outfilename, "w")) then {
       fprintf(stderr, "Unable to open output file %s\n", outfilename)
       exit(1)
      }

   #
   # write out the standard skeleton automata code
   #
   uflexskel(outfile)

   if \begintext then {
      fprintf(outfile, "%s\n", begintext)
   }


   j1 := 0


   statelist := myautomata.states
   p := 1
   fprintf(outfile,
           "procedure yylexaccepting(myautomata)\n_
       local currstate\n\n")
   while p <= *statelist do {
      states := statelist[p]
      state := states.current

      #while \states do { state := states.current
      fprintf(outfile,
         "   put(myautomata.states, currstate := anode(%d, %d, [], [], []))\n",
              states.current.label, states.current.rulenum)

      if state.label == myautomata.start.label then
        fprintf(outfile, "   myautomata.start := currstate\n")
      if nodemember(state.label, myautomata.accepting) then {
             fprintf(outfile, "   put(myautomata.accepting, currstate)\n")
           if state.rulenum > maxrulenum then
               maxrulenum := state.rulenum
           }
      fprintf(outfile, "\n")
      states := statelist[p]._next
      p := p + 1
      #states := states._next
   }
   fprintf(outfile,
           "end\n\n")

   #states := myautomata.states
   p := 1

   fprintf(outfile,
              "procedure %s(myautomata)\n_
          local currstate, state2, tempedge\n\n",
         "yylex"||p)

   # Add procedure named "yylexm"XXX,end statement
   #### DOES NOT HAPPEN
   #while p < 1 do {
   while p <= *statelist do {

      if p % 5 = 0  then {
         put(proclst,"yylexm"||p)  # store name in proclst to call in yylex
         fprintf(outfile,
         "end\n\n_
              procedure %s(myautomata)\n_
         local currstate, state2, tempedge\n\n",
         "yylexm"||p)

      }
      states := statelist[p]
      state := states.current
      #while \states do { state := states.current
      fprintf(outfile,
              "   currstate := pop(myautomata.states)\n_
              \   put(myautomata.states, currstate)\n\n_
              \   while currstate.label ~= %d do {\n_
              \      currstate := pop(myautomata.states)\n_
              \      put(myautomata.states, currstate)\n      }\n_
              \   state2 := currstate\n\n",
              state.label)

      # NO EPSILON
      states2 := state.epsilon

      # NO DOT
      states2 := state.dot


      edges := state.edges
      every edge := !\edges do {
               fprintf(outfile, "   tempedge := edge()\n")
         if edge.symbol == "\n" then
                 fprintf(outfile, "   tempedge.symbol := \"\\n\"\n")
               else {
              if ((edge.symbol[1] == "[") & (*edge.symbol> 1))  then
                       fprintf(outfile, "   tempedge.symbol := csetfromrecset(\"%s\")\n",
                  escapify(edge.symbol))
                   else fprintf(outfile, "   tempedge.symbol := \"%s\"\n",
                  escapify(edge.symbol))
               }
                 fprintf(outfile, "   tempedge.destinations := []\n")
               states2 := edge.destinations
         #while \states2 do {
          # NO WHILE ONLY ONE DESTINATION per input
               fprintf(outfile, "   currstate := pop(myautomata.states)\n_
                    \   put(myautomata.states, currstate)\n\n_
                    \   while currstate.label ~= %d do {\n_
                    \      currstate := pop(myautomata.states)\n_
                    \      put(myautomata.states, currstate)\n      }\n_
                    \   put(tempedge.destinations, currstate)\n\n_
                    \   put(state2.edges, tempedge)\n",
                    states2.label)
          #states2.current.label)
              #states2 := states2._next
              #}
     }  # every edge
          p := p + 1
   }

   fprintf(outfile,
         "end\n\n")


   fprintf(outfile,
           "global semantic_action\n\n_
           procedure yylex()\n_
           static myautomata\n_
      initial {\n_
           \   myautomata := automata()\n\n_
           \   myautomata.states := []\n_
           \   myautomata.accepting := []\n")


   fprintf(outfile,
          "\   yylexaccepting(myautomata)\n_
      \   yylex1(myautomata)\n")


   every i := 1 to *proclst do {
      fprintf(outfile,
          "\   %s(myautomata)\n\n",proclst[i])
   }

   fprintf(outfile,
          "\   init_semantic_actions()\n\n_
      }\n\n_
           \   return yyulex(myautomata)\n\n_
           end\n\n")

   fprintf(outfile,
           "procedure init_semantic_actions()\n\n_
           \   semantic_action := table()\n")


   action := list(maxrulenum+1, 0)

   every i := 1 to maxrulenum do {
      fprintf(outfile, "   semantic_action[%d] := semantic_action_%d\n", i, i)
   }

   fprintf(outfile, "\nend\n\n")
   # Use new accepting
   states := myautomata.accepting
   while \states do {
      state := states.current
      if action[state.rulenum] == 0 then {
             fprintf(outfile,
                 "procedure semantic_action_%d()\n_
                 \   %s\n_
                 end\n\n",
                 state.rulenum,
                 state.semaction)
         action[state.rulenum] := 1
         }
    states := states._next
   }
end



#__________________________________________________________
# Procedure to create icn program from DFA
procedure createicondfa2(myautomata,outfile)
   local state, states, states2, edges, edge, maxrulenum := 0, i, action

#   write(&errout, "in createicon")

   if not (outfile := open(outfilename, "w")) then {
       fprintf(stderr, "Unable to open output file %s\n", outfilename)
       exit(1)
      }

   #
   # write out the standard skeleton automata code
   #
   uflexskel(outfile)

   if \begintext then {
      fprintf(outfile, "%s\n", begintext)
      }

   fprintf(outfile,
           "global semantic_action\n\n_
           procedure yylex()\n_
           static myautomata\n_
           local currstate, state2, tempedge\n\n_
           \ initial {\n_
           \   myautomata := automata()\n\n_
           \   myautomata.states := []\n_
           \   myautomata.accepting := []\n")

   statelist := myautomata.states
   p := 1
   while p <= *statelist do {
      states := statelist[p]
      state := states.current

      #while \states do { state := states.current
      fprintf(outfile,
         "   put(myautomata.states, currstate := anode(%d, %d, [], [], []))\n",
              states.current.label, states.current.rulenum)

      if state.label == myautomata.start.label then
        fprintf(outfile, "   myautomata.start := currstate\n")
      if nodemember(state.label, myautomata.accepting) then {
             fprintf(outfile, "   put(myautomata.accepting, currstate)\n")
           if state.rulenum > maxrulenum then
               maxrulenum := state.rulenum
           }
      fprintf(outfile, "\n")
      states := statelist[p]._next
      p := p + 1
      #states := states._next
   }

   #states := myautomata.states
   p := 1
   while p <= *statelist do {
      states := statelist[p]
      state := states.current
      #while \states do { state := states.current
      fprintf(outfile,
              "   currstate := pop(myautomata.states)\n_
              \   put(myautomata.states, currstate)\n\n_
              \   while currstate.label ~= %d do {\n_
              \      currstate := pop(myautomata.states)\n_
              \      put(myautomata.states, currstate)\n      }\n_
              \   state2 := currstate\n\n",
              state.label)

      # NO EPSILON
      states2 := state.epsilon
      while 1 = 0 do {
      # while \states2 do {
           fprintf(outfile,
                 "   currstate := pop(myautomata.states)\n_
                 \   put(myautomata.states, currstate)\n\n_
                 \   while currstate.label ~= %d do {\n_
                 \      currstate := pop(myautomata.states)\n_
                 \      put(myautomata.states, currstate)\n      }\n_
                 \   put(state2.epsilon, currstate)\n\n",
                 states2.current.label)
          states2 := states2._next
           }
      # NO DOT
      states2 := state.dot
      while 1 = 0 do {
      #while \states2 do {
           fprintf(outfile,
                 "   currstate := pop(myautomata.states)\n_
                 \   put(myautomata.states, currstate)\n\n_
                 \   while currstate.label ~= %d do {\n_
                 \      currstate := pop(myautomata.states)\n_
                 \      put(myautomata.states, currstate)\n      }\n_
                 \   put(state2.dot, currstate)\n\n",
                 states2.current.label)
            states2 := states2._next
           }

      edges := state.edges
      every edge := !\edges do {
         if edge.symbol == "\n" then
            te_symbol := "\"\\n\"\n"
         else if ((edge.symbol[1] == "[") & (*edge.symbol> 1))  then {
            te_symbol := "csetfromrecset(\"" || escapify(edge.symbol) || "\")"
            }
         else te_symbol := "\"" || escapify(edge.symbol) || "\""

         fprintf(outfile, "   tempedge := edge(%s, [])\n", te_symbol)

         states2 := edge.destinations
         #while \states2 do {
          # NO WHILE ONLY ONE DESTINATION per input
               fprintf(outfile, "   currstate := pop(myautomata.states)\n_
                    \   put(myautomata.states, currstate)\n\n_
                    \   while currstate.label ~= %d do {\n_
                    \      currstate := pop(myautomata.states)\n_
                    \      put(myautomata.states, currstate)\n      }\n_
                    \   put(tempedge.destinations, currstate)\n\n_
                    \   put(state2.edges, tempedge)\n",
                    states2.label)
          #states2.current.label)
              #states2 := states2._next
              #}
     }  # every edge
          p := p + 1
   }


   fprintf(outfile,
           "   init_semantic_actions()\n_
           \   }\n\n_
           \   return yyulex(myautomata)\n\n_
           end\n\n_
           procedure init_semantic_actions()\n\n_
           \   semantic_action := table()\n")


   action := list(maxrulenum+1, 0)

   every i := 1 to maxrulenum do {
      fprintf(outfile, "   semantic_action[%d] := semantic_action_%d\n", i, i)
   }

   fprintf(outfile, "\nend\n\n")
   # Use new accepting
   states := myautomata.accepting
   while \states do {
      state := states.current
      if action[state.rulenum] == 0 then {
             fprintf(outfile,
                 "procedure semantic_action_%d()\n_
                 \   %s\n_
                 end\n\n",
                 state.rulenum,
                 state.semaction)
         action[state.rulenum] := 1
         }
    states := states._next
   }
end
#__________________________________________________________________
# Create new DFA transition table.
# Go down each col of nfa trans table for each member of the
# newstate set in the procedure get_moves(input_col, state set).
# For example, Pg 120 Red Dragon Book:
# moves({0,1,2,4,7},1) will and go down col 1 (input 1) of nfa
# transition table and will compute e-closure
# for the states in cell (1,0), (1,1), (1,2), (1,4), (1,7) .
# Only state 2 dest (3) and state 7 dest (8) are filled.
# It will return a the new computed state for col 1 (input i)
# = e-closure{3,8} = {1,2,3,4,6,7,8}.
# The NFA transition table is nfastatescell and ec_table contains
# the epsilon closure for each state.
#
# NFA trans table for (a|b)*abb
#state a  b  epsilon
#  0   -  -  1,7
#  1   -  -  2,4
#  2   3  -  -
#  3   -  -  6
#  4   -  5  -
#  5   -  -  6
#  6   -  -  1,7
#  7   8  -  -
#  8   -  9  -
#  9   -  10 -
#
# New DFA Transition Table Dtran Pg 120 Red Dragon Book
# for (a|b)*abb
# e-closure(0)->{0,1,2,4,7}   e-closure(1)->{1,2,4}
# e-closure(2)->{2}           e-closure(3)->{1,2,3,4,6,7}
# e-closure(4)->{4}           e-closure(5)->{1,2,4,5,6,7}
# e-closure(6)->{1,2,4,6,7}   e-closure(7)->{7}
# e-closure(8)->{8}           e-closure(9)->{9}
# e-closure(10)->{10}
#
#statelistlst := [{0,1,2,4,7}, {1,2,3,4,6,7,8}, {1,2,4,5,6,7}, {1,2,4,5,6,7,9}, {1,2,4,5,6,7,10} ]
# set STATES            input a      input b
#{0,1,2,4,7}       {1,2,3,4,6,7,8} {1,2,4,5,6,7}
#{1,2,3,4,6,7,8}   {1,2,3,4,6,7,8} {1,2,4,5,6,7,9}
#{1,2,4,5,6,7}     {1,2,3,4,6,7,8} {1,2,4,5,6,7}
#{1,2,4,5,6,7,9}   {1,2,3,4,6,7,8} {1,2,4,5,6,7,10}
#{1,2,4,5,6,7,10}  {1,2,3,4,6,7,8} {1,2,4,5,6,7}

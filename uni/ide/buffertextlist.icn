#
#  buffertextlist.icn - modified editabletextlist
#
#  Author: Nolan Clayton, Hani bani Salameh, Clinton Jeffery
#
#  Adds line numbers, syntax coloring and error highlighting for an
#  IDE to the generic EditableTextlist.
#
#  To do: separate out Unicon language dependency so it is extensible.
#

#
#  A scrollable editable text area.  An {Event} is generated whenever the
#  contents are changed by the user.
#
link graphics

import gui
import undo
import lang
import util

$include "guih.icn"
$include "../unicon/ytab_h.icn"

#
# This subclass of the remappable keybinder handles multi-key prefixes
# and remembers what mode it is in, e.g. emacs-mode, default-mode, etc.
#
class IDEKeybindings : Keybindings(mode, prefix)
   method handle_key(e)
   local m
      if type(e) == "string" then e := prefix || e
      if m := \ (keymap[e]) then {
	 if m == "handle_prefix" then prefix ||:= e
	 else {
	    prefix := ""
	    return m
	    }
	 }
   end
   method current_mode()
      return mode
   end
   method default_mode()
      mode := "default"
      self.Keybindings.default_mode()
   end

   #
   # Emacs-like keybindings.  Probably should rename existing
   # methods whose names are tied to particular keys instead
   # naming them based on what editing function they perform.
   #
   method emacs_mode()
      mode := "emacs"
      set_key("\e",     "handle_prefix",
	      Key_Home, "ide_key_home",
	      Key_End,  "ide_key_end",
	      "\^a",    "handle_start_of_line",
	      "\^b",    "handle_key_left",
	      "\^c",    "handle_prefix",
	      "\^f",    "handle_key_right",
	      "\^n",    "handle_key_down",
	      "\^p",    "handle_key_up",
	      "\^v",    "handle_key_page_down",
	      "\^x",    "handle_prefix",
	      "\^y",    "handle_paste",
	      "\^z",    "handle_scrolldown_one_line",
	      "\^x\^c", "handle_exit",
	      "\^x\^x", "exchange_point_and_mark",
	      "\^x\^f", "find_file",
	      "\^x\^s", "save_buffer",
	      "\^x\^n", "next_error")
   end
initially
   self.Keybindings.initially()
   prefix := ""
end

class BuffEditableTextList : EditableTextList(
   moved,	# to-do: check if we need this and if so, implement it.
   mouse_locked,
   scroll_locked,
   vi,      #virtual line index
   highlightcolor,
   autoindent,
   scroll_y,
   errorLineNumber,
   doReparse,
   paren_match_found
   )

   # HOME goes to beginning of line, ^HOME goes to beginning of file
   method ide_key_home(e)
      if &control then handle_key_home(e)
      else handle_start_of_line()
   end

   # END goes to end of line, ^END goes to end of file
   method ide_key_end(e)
      if &control then handle_key_end(e)
      else handle_end_of_line()
   end

   method fire(type, param)
      self$Connectable.fire(type,param)
      if type === CONTENT_CHANGED_EVENT then {
	 # Optimize this blind any-change==reparse logic to be more
	 # selective.  Pressing return won't change the token sequence,
	 # nor will editing of comments.
	 doReparse := 1
	 }
      if type === CURSOR_MOVED_EVENT & old_cursor_y ~= cursor_y then {
	 ReparseCode()
	 }
   end

   method on_vsb(ev,y_coor,enter_here)
      if /enter_here & \scroll_locked then fail #lock scrollbar
      self.EditableTextList.on_vsb(ev)
      if \enter_here=1 then {
	 if \self.vsb then {
	    self.vsb.set_value(y_coor)
	    enter_here := 0
	    }
	 }
   end

   method on_hsb(ev,x_coor,enter_here)
      if /enter_here & \scroll_locked then fail#lock scrollbar
      self.EditableTextList.on_hsb(ev)
      if \enter_here=1 then {
	 if \self.hsb then {
	    self.hsb.set_value(x_coor)
	    enter_here := 0
	    }
	 }
   end

   method handle_press(e,received)
      if /received & \mouse_locked then fail #lock mouse
      self.EditableTextList.handle_press(e)
   end

   method handle_drag(e,received)
      if /received & \mouse_locked then fail #lock mouse
      self.EditableTextList.handle_drag(e)
   end

   method handle_release(e,received)
      if /received & \mouse_locked then fail #lock mouse
      self.EditableTextList.handle_release(e)
   end

   method handle_return(e)
      local i, str
      self.EditableTextList.handle_return(e)
      if \autoindent then{ 
	 str := contents[cursor_y - 1]
	 i := 1

         while i < *str + 1  do {	    
            case str[i] of { 
               " "     : handle_default(" ")
               #"\t"    : handle_tab_text("\t")
               default : i := *str +2
               }
            i +:= 1
	    }
        }
      # Reparse code when the cursor moves in the Y axis
      ReparseCode( )
   end

   #
   # Overrides default handle_event() re-parsing on line changes, etc.
   #
   method handle_event(e)
      if integer(e) = &mpress then
	 simulate_wheelbutton()
      # turn scroll up/down into a key_up/down in the vsb.
      else if integer(e) = -13 then
         every 1 to 4 do (\vsb).handle_button_up(e)
      else if integer(e) = -14 then
         every 1 to 4 do (\vsb).handle_button_down(e)
      else self.EditableTextList.handle_event(e)
      
      if \self.old_cursor_y ~= self.cursor_y then ReparseCode()
   end

   #
   # The virtual x position of a line in the canvas, except
   # that we have line numbering turned on at the left.
   #
   method get_left_pos()
      local lineno_space := 0
      # if \pegasus.line_no then
      #lineno_space := TextWidth(cwin,*contents) + 3
      lineno_space := 35
      return lineno_space +
         ((self.view.x - (\self.hsb).get_value()) | self.view.x)
   end

   method draw(subject_x, subject_y, vx, vy, vw, vh)
      local rev, first_line, last_line, xp, yp, i

      #
      # Which lines to draw
      #
      first_line := get_first_line()
      last_line := get_last_line()
      last_line >:= get_line_count()

      #
      # Where to draw them
      #
      yp := vy + self.line_height / 2

      #
      # Left offset
      #
      xp := vx - subject_x

      rev := Clone(self.cbwin, "drawop=reverse")

      #
      # Write the lines
      #
      every i := first_line to last_line do {
         draw_line(xp+35, yp, i, rev)
         yp +:= self.line_height
         }

      Uncouple(rev)
      rev := &null
      return
   end


   method draw_line(xp, yp, i, rev)
      local si, s, off, off1, off2, v, r, fh, asc, desc, yp2, cw

      fh := WAttrib(self.cbwin, "fheight")
      asc := WAttrib(self.cbwin, "ascent")
      desc := WAttrib(self.cbwin, "descent")
      v := self.view_list[i]
      s := v.str
      si := self.cursor_x - v.first + 1

      left_string(self.cbwin, xp, yp, detab(s))

      Fg(self.cbwin, "pale greyish white")  #rectangle color
      yp2 :=  yp + ((asc - desc)/2) - asc
      FillRectangle(self.cbwin, xp - 35, yp2, 40, fh) #rectangle pos
      Fg(self.cbwin, "weak greyish blue")   #line_num color
      left_string(self.cbwin, xp - TextWidth(self.cwin, i) - 3 , yp, i)  #line_num pos

      Fg(cbwin, "black")

     # Check if an error line has been set.
      if \errorLineNumber then {
         # Check if this string belong to the error line
         if i = errorLineNumber then {
            # Set error line color (red)
            Fg(self.cbwin, "red")
            }
         }

      left_string_unicon (self.cbwin, xp, yp, detab(s), i)

      if (v.index = \self.cursor_y) & 
         (v.first <= \self.cursor_x <= v.last) then {
         if \self.has_focus then {
            cw := Clone(self.cbwin, "bg=red", "fg=white")
            off := TextWidthEx(self.cbwin, s, 1, si, self.tab_width)
            EraseRectangle(cw, xp + off, yp - self.line_height / 2, 
                           CharWidth(self.cbwin, s[si]), self.line_height)

            if s[si] ~== "\t" then
               left_string(cw, xp + off, yp, s[si])

            Uncouple(cw)
            } 
         else {
            cw := Clone(self.cbwin, "fg=red")
            Rectangle(cw, 
                      xp + TextWidthEx(self.cbwin, s, 1, si, self.tab_width), 
                      1 + yp - self.line_height / 2, 
                      CharWidth(self.cbwin, s[si]), 
                      self.line_height)
            Uncouple(cw)
            }
         }

      if \self.mark_y then {
         if (self.mark_y < v.index < self.cursor_y) | 
            (self.mark_y > v.index > self.cursor_y) then {
            # Whole line selected
            r := [v.first, v.last]
            } 
         else if v.index = self.mark_y = self.cursor_y then {
            # Part of line
            if self.mark_x < self.cursor_x then {
               r := range(v.first, v.last, self.mark_x, self.cursor_x)
               }
            else if self.mark_x > self.cursor_x then {
               r := range(v.first, v.last, self.cursor_x + 1 , self.mark_x)
               }
            } 
         else if v.index = self.mark_y then {
            if self.mark_y < self.cursor_y then {
               r := range(v.first, v.last, self.mark_x, *self.contents[v.index] + 1)
               } 
            else {
               r := range(v.first, v.last, 1, self.mark_x)
               }
            } 
         else if v.index = self.cursor_y then {
            if self.mark_y > self.cursor_y then {
               r := range(v.first, v.last, self.cursor_x + 1, *self.contents[v.index] + 1)
               } 
            else {
               r := range(v.first, v.last, 1, self.cursor_x)
               }
            }
         if \r then {
            off1 := TextWidthEx(self.cbwin, s, 1, r[1] - v.first + 1, self.tab_width)
            off2 := TextWidthEx(self.cbwin, s, 1, r[2] - v.first + 1, self.tab_width)
            FillRectangle(rev, xp + off1, 1 + yp - self.line_height / 2,  off2 - off1, self.line_height)
            }
         }
   end

   method toggle_autoindent()
      if \autoindent then  autoindent:= &null
      else autoindent := 1
   end

   # Simulate a wheelbutton using middle mouse button events.
   # Not a very good simulation! This code is subsumed by the
   # new scrollup/scrolldown (-13, -14) events.
   method simulate_wheelbutton()

      if \self.has_focus then {
         scroll_y := &y

	 # five for each press
	 handle_key_down()
	 handle_key_down()
	 handle_key_down()
	 handle_key_down()
	 handle_key_down()

         while Event() === &mdrag do {
            if &y > scroll_y then {
               handle_key_down()
               handle_key_down()
               handle_key_down()
               }

            if &y < scroll_y  then {
               handle_key_up()
               handle_key_up()
               handle_key_up()
              }
            self.constrain_line()
            self.refresh(1)
            }
         }
   end

   method highlight_line(i)
      start_handle()
      if /i  then i := 1
      if not (*contents >=  i > 1) then i := 1

      mark_x := 1
      mark_y := i
      cursor_y := i
      cursor_x := *contents[i] + 1
      end_handle()
   end

   # New left_string for the UniconTextList
   method left_string_unicon(win, x, y, s, currentLine)
      local i, token, last_s_Position, new_s_Position, off, remainder

      y +:= (WAttrib(win, "ascent") - WAttrib(win, "descent")) / 2
      # Check if an error line has been set.
      if \errorLineNumber then {
         # Check if this string belong to the error line
         if currentLine = errorLineNumber then {
            # Set error line color (red)
            Fg(win, "Red")
            # Print the string
            DrawString(win, x, y, s)
            # Exit this method
            return
            }
         }	

      # Reinitialize error counter in the yyerror function.  This is done in
      # order to avoid the istop() function being called from within the
      # yyerror() function when the merr error counter gets to 10.  This is
      # only helpful within this syntax coloring procedure.
      yyerror( "reinitialize merr errors" )

      # Reinitialize lexical analyzer
      yyin := s
      yylex_reinit()

      # Initialize string s position variables
      off := 0
      new_s_Position  := 1
      last_s_Position := 1

      # Get string s tokens
      while (token := yylex()) ~=== EOFX do {
         # Set token color
         case token of {
            ABSTRACT | BREAK | BY | CASE | CLASS | CREATE |
            DEFAULT | DO | ELSE | END | EVERY | FAIL | 
            GLOBAL | IF | IMPORT | INITIALLY | 
            iconINITIAL | INVOCABLE | LINK | LOCAL | 
            METHOD | NEXT | NOT | OF | PACKAGE | 
            PROCEDURE | RECORD | REPEAT | RETURN | STATIC | 
            SUSPEND | THEN | TO | UNTIL | WHILE | GLOBAL | 
            LOCAL                                         : Fg(win, "Blue")
            STRINGLIT | CSETLIT                           : Fg(win, "Dark Red")
            default                                       : Fg(win, "Black")
            }
            # Get token end position in string s
            new_s_Position := yytoken["column"] + *yytoken["s"] - 1
            # Print the string
            DrawString(win, x, y, s[ last_s_Position : (new_s_Position + 1)])
            # Get the printed text of string s offset
            off := TextWidth(win, s[ last_s_Position : (new_s_Position + 1)])

           # Get the new last string s starting position
           last_s_Position := new_s_Position + 1
           # Add the offset to the x position
           x +:= off
      }
      # Draw the rest of the string s that was not a token
      Fg( win, "very dark green" )
      remainder := s[ last_s_Position : ( *s + 1 ) ]
      if *(trim(\remainder)) > 0 then
         DrawString( win, x, y, s[ last_s_Position : ( *s + 1 ) ] )
      Fg( win, "dark green" )
   end

   method SetErrorLineNumber ( lineNumber )
      if lineNumber > *contents then
         errorLineNumber := *contents
      else
         errorLineNumber := lineNumber
   end

   method ReparseCode ()
      local s, rv, x, errorObject, timeElapsed, lineNumberOffset

      if doReparse === 1 then {
         # Get time spent in reparsing the code
         timeElapsed := &time
         # Clear errors
         SetErrorLineNumber ( 0 )

         # Initialize preprocessor variables
         uni_predefs := predefs()

         # Get the line number offset and the code
         s := []
         x := 1
         s |||:= GetCode()

         # Extract the line number offset		
         lineNumberOffset := s[1]

         # Remove the line number offset from the list
         pop( s )

         # Call the preprocessor but instead of passing a file name, 
         # we will pass a list containing the code
	 preproc_err_count := 0
         yyin := ""
         every yyin ||:= preprocessor(s, uni_predefs) do yyin ||:= "\n"
	 if preproc_err_count = 0 then {
	    # Reinitialize lexical analyzer
	    yylex_reinit()
	    # Initialize variables
	    /yydebug := 0
	    parsingErrors := []
	    # Reparse the code
	    rv := yyparse()
	    }
         # Display errors	
         if errors + (\yynerrs|0) + preproc_err_count > 0 then {
            every errorObject := !parsingErrors do {
               # display the error
               errorObject.lineNumber +:= lineNumberOffset
	       if errorObject.lineNumber <= *contents then {
		  SetErrorLineNumber(errorObject.lineNumber)
		  uidlog.MsgBox.set_contents([errorObject.lineNumber ||": " ||
					      errorObject.errorMessage])
		  }
               }
            }
        else uidlog.MsgBox.set_contents(["(no errors)"])
        doReparse := 0
        }	
   end

   method GetCode()
      local codeSubStringList, originalPositionY, currentPositionY, token,
              startPositionY := 0, endPositionY := 0, endsneeded

      # reset parser
      reinitialize()

      # Search up for the enclosing procedure or class (compilation unit).
      originalPositionY := currentPositionY := cursor_y
      endsneeded := 1
      while currentPositionY > 0 do {
         # Reinitialize lexical analyzer
         yyin := contents[currentPositionY]
         yylex_reinit()
         # Get string s tokens
         while (token := yylex()) ~=== EOFX do {
            # Get tokens
            case token of {
               PROCEDURE : {
                  startPositionY := currentPositionY
                  break
                  }
               CLASS : {
		  endsneeded := 2
                  startPositionY := currentPositionY
                  break
                  }
               default : break
               }
            }
         if startPositionY ~= 0 then break
         # go up
         currentPositionY -:= 1
         }
      if startPositionY = 0 then startPositionY := 1
      # Search down for the enclosing end
      currentPositionY := cursor_y
      while currentPositionY < *contents + 1 do {
         # Reinitialize lexical analyzer
         yyin := contents[ currentPositionY ]
	 while countdoublequotes(yyin)%2=1 & yyin[-1]=="_" do {
	    currentPositionY +:= 1
	    yyin ||:= contents[ currentPositionY ]
	    }
         yylex_reinit()
         # Get string s tokens
         while ( token := yylex() ) ~=== EOFX do {
            # Get tokens
            case token of {
               END: {
		  endsneeded -:= 1
		  if endsneeded = 0 then {
		      endPositionY := currentPositionY
		      break
		      }
                  }
               METHOD: {
                  endsneeded +:= 1
                  }
               CLASS | PROCEDURE: {
                  endPositionY := currentPositionY
                  break
                  }
               default : break
               }
            }
         if endPositionY ~= 0 then break
         # go down
         currentPositionY +:= 1
         }
      # Check if a valid enclosing end was found
      if endPositionY = 0 then {
         # Return all code
         codeSubStringList := [ 0 ] ||| contents 		
         return codeSubStringList
         }
      # Send only the enclosing sub string list
      if startPositionY = 0 then startPositionY := 1
      codeSubStringList := [ startPositionY ] ||| 
                           contents[ startPositionY : endPositionY + 1 ]
      return codeSubStringList
   end

   initially
      self$EditableTextList.initially()
      kmap := IDEKeybindings()
      kmap.emacs_mode()
      highlightcolor := "65535,65535,32428"
      autoindent := &null
      scroll_y := 1

      errorLineNumber := 0
      doReparse := 0

      # This variable comes from the unilex.icn file
      errors := 0
end

# count # of doublequotes, supposedly accounting correctly for escaped quotes
procedure countdoublequotes(s)
local i := 0
   s ? {
      while tab(upto('"\\')) do {
	 if ="\"" then
	    i +:= 1
	 else move(2)
	 }
      }
   return i
end
